### YamlMime:ManagedReference
items:
- uid: System.ServiceProcess.ServiceBase
  id: ServiceBase
  children:
  - System.ServiceProcess.ServiceBase.#ctor
  - System.ServiceProcess.ServiceBase.AutoLog
  - System.ServiceProcess.ServiceBase.CanHandlePowerEvent
  - System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent
  - System.ServiceProcess.ServiceBase.CanPauseAndContinue
  - System.ServiceProcess.ServiceBase.CanShutdown
  - System.ServiceProcess.ServiceBase.CanStop
  - System.ServiceProcess.ServiceBase.Dispose(System.Boolean)
  - System.ServiceProcess.ServiceBase.EventLog
  - System.ServiceProcess.ServiceBase.ExitCode
  - System.ServiceProcess.ServiceBase.MaxNameLength
  - System.ServiceProcess.ServiceBase.OnContinue
  - System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)
  - System.ServiceProcess.ServiceBase.OnPause
  - System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)
  - System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)
  - System.ServiceProcess.ServiceBase.OnShutdown
  - System.ServiceProcess.ServiceBase.OnStart(System.String[])
  - System.ServiceProcess.ServiceBase.OnStop
  - System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)
  - System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)
  - System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])
  - System.ServiceProcess.ServiceBase.ServiceHandle
  - System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)
  - System.ServiceProcess.ServiceBase.ServiceName
  - System.ServiceProcess.ServiceBase.Stop
  langs:
  - csharp
  name: ServiceBase
  nameWithType: ServiceBase
  fullName: System.ServiceProcess.ServiceBase
  type: Class
  summary: "Fornece uma classe base para um serviço que será existe como parte de uma aplicação de serviço. ServiceBase tem de ser derivado ao criar uma nova classe de serviço."
  remarks: "Derive from ServiceBase when defining your service class in a service application. Any useful service overrides the [OnStart(String\\[\\])](assetId:///M:System.ServiceProcess.ServiceBase.OnStart(System.String[])?qualifyHint=False&autoUpgrade=True) and <xref:System.ServiceProcess.ServiceBase.OnStop%2A> methods. For additional functionality, you can override <xref:System.ServiceProcess.ServiceBase.OnPause%2A> and <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> with specific behavior in response to changes in the service state.  \n  \n A service is a long-running executable that does not support a user interface, and which might not run under the logged-on user account. The service can run without any user being logged on to the computer.  \n  \n By default, services run under the System account, which is not the same as the Administrator account. You cannot change the rights of the System account. Alternatively, you can use a <xref:System.ServiceProcess.ServiceProcessInstaller> to specify a user account under which the service will run.  \n  \n An executable can contain more than one service but must contain a separate <xref:System.ServiceProcess.ServiceInstaller> for each service. The <xref:System.ServiceProcess.ServiceInstaller> instance registers the service with the system. The installer also associates each service with an event log that you can use to record service commands. The `main()` function in the executable defines which services should run. The current working directory of the service is the system directory, not the directory in which the executable is located.  \n  \n When you start a service, the system locates the executable and runs the <xref:System.ServiceProcess.ServiceBase.OnStart%2A> method for that service, contained within the executable. However, running the service is not the same as running the executable. The executable only loads the service. The service is accessed (for example, started and stopped) through the Service Control Manager.  \n  \n The executable calls the ServiceBase derived class's constructor the first time you call Start on the service. The <xref:System.ServiceProcess.ServiceBase.OnStart%2A> command-handling method is called immediately after the constructor executes. The constructor is not executed again after the first time the service has been loaded, so it is necessary to separate the processing performed by the constructor from that performed by <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Any resources that can be released by <xref:System.ServiceProcess.ServiceBase.OnStop%2A> should be created in <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Creating resources in the constructor prevents them from being created properly if the service is started again after <xref:System.ServiceProcess.ServiceBase.OnStop%2A> has released the resources.  \n  \n The Service Control Manager (SCM) provides a way to interact with the service. You can use the SCM to pass Start, Stop, Pause, Continue, or custom commands into the service. The SCM uses the values of <xref:System.ServiceProcess.ServiceBase.CanStop%2A> and <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> to determine whether the service accepts Stop, Pause, or Continue commands. Stop, Pause, and Continue are enabled in the SCM's context menus only if the corresponding property <xref:System.ServiceProcess.ServiceBase.CanStop%2A> or <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> is `true` in the service class. If enabled, the command is passed to the service, and <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, or <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> is called. If <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, or <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> is `false`, the corresponding command-handling method (such as <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) will not be processed, even if you have implemented the method.  \n  \n You can use the <xref:System.ServiceProcess.ServiceController> class to do programmatically what the SCM does using a user interface. You can automate the tasks available in the console. If <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, or <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> is `true` but you have not implemented a corresponding command-handling method (such as <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) the system throws an exception and ignores the command.  \n  \n You do not have to implement <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, or any other method in ServiceBase. However, the service's behavior is described in <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, so at minimum, this member should be overridden. The `main()` function of the executable registers the service in the executable with the Service Control Manager by calling the <xref:System.ServiceProcess.ServiceBase.Run%2A> method. The <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> property of the ServiceBase object passed to the <xref:System.ServiceProcess.ServiceBase.Run%2A> method must match the <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A> property of the service installer for that service.  \n  \n You can use `InstallUtil.exe` to install services on your system.  \n  \n> [!NOTE]\n>  You can specify a log other than the Application event log to receive notification of service calls, but neither the <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> nor the <xref:System.ServiceProcess.ServiceBase.EventLog%2A> property can write to a custom log. Set <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> to `false` if you do not want to use automatic logging."
  syntax:
    content: >-
      [System.ComponentModel.InstallerType(typeof(System.ServiceProcess.ServiceProcessInstaller))]

      public class ServiceBase : System.ComponentModel.Component
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements: []
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.Site
  - System.ComponentModel.Component.ToString
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.#ctor
  id: '#ctor'
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: ServiceBase()
  nameWithType: ServiceBase.ServiceBase()
  fullName: System.ServiceProcess.ServiceBase.ServiceBase()
  type: Constructor
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Cria uma nova instância do <xref href=&quot;System.ServiceProcess.ServiceBase&quot;> </xref> classe."
  remarks: "Não crie uma instância de <xref:System.ServiceProcess.ServiceBase>classe.</xref:System.ServiceProcess.ServiceBase> Em vez disso, derivar <xref:System.ServiceProcess.ServiceBase>e instanciar a classe derivada.</xref:System.ServiceProcess.ServiceBase> O mínimo tem de implementar no construtor para uma classe herdada de <xref:System.ServiceProcess.ServiceBase>consiste em definir a <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>no seu componente.</xref:System.ServiceProcess.ServiceBase.ServiceName%2A> </xref:System.ServiceProcess.ServiceBase> Nenhum processamento adicional especificamente é necessário no construtor. Deve processar a maioria das inicialização em <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, em vez de no construtor.</xref:System.ServiceProcess.ServiceBase.OnStart%2A> Caso contrário, não há nenhuma garantia que os objetos serão reinicializados quando reiniciar um serviço depois foi parado.       Se substituir o construtor na sua classe derivada, chame o construtor de classe base no seu código.       O <xref:System.ServiceProcess.ServiceBase>conjuntos de construtor <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>para `true`.</xref:System.ServiceProcess.ServiceBase.AutoLog%2A> </xref:System.ServiceProcess.ServiceBase> Se não pretender registar automaticamente chamadas para o serviço do Gestor de controlo de serviços (SCM), defina <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>para `false`.</xref:System.ServiceProcess.ServiceBase.AutoLog%2A>       Se o executável contém um único serviço, o sistema chama o construtor do serviço quando iniciar é selecionado o SCM e executa o destrutor se denomina-se a parar.       Se o executável contém vários serviços, chamar iniciar um serviço faz com que os construtores ser chamado para todos os serviços no executável, mas apenas o serviço especificado é iniciado. Os processos de destruição para os serviços são executados em conjunto quando todos os serviços foram parados, não individualmente quando cada serviço estiver parado.      > [!NOTE] > Se substituir o construtor de classe base, deve explicitamente chamá-lo no construtor da sua classe derivada."
  syntax:
    content: public ServiceBase ();
    parameters: []
  overload: System.ServiceProcess.ServiceBase.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.AutoLog
  id: AutoLog
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: AutoLog
  nameWithType: ServiceBase.AutoLog
  fullName: System.ServiceProcess.ServiceBase.AutoLog
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Indica se deve iniciar, parar, colocar em pausa e continuar comandos no registo de eventos de relatório."
  remarks: "Definição AutoLog `true` dá instruções ao serviço para utilizar o registo de eventos de aplicações para falhas de comando de relatório, bem como informações de alteração de estado para iniciar, parar, colocar em pausa e continuar eventos no serviço. O nome do serviço é utilizado como o registo <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=fullName>.</xref:System.Diagnostics.EventLog.Source%2A?displayProperty=fullName>       Para relatar informações de um registo de eventos personalizado em vez de registo de aplicações, defina AutoLog `false` e escrever instruções dentro os métodos de processamento de comandos <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, ou <xref:System.ServiceProcess.ServiceBase.OnStop%2A>publicar no registo adequadas</xref:System.ServiceProcess.ServiceBase.OnStop%2A> </xref:System.ServiceProcess.ServiceBase.OnPause%2A> </xref:System.ServiceProcess.ServiceBase.OnContinue%2A>      > [!NOTE] > A <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>fontes de que a cadeia de origem para o registo de eventos, tem de ser definida antes do serviço tenta ao escrever no registo de eventos.</xref:System.ServiceProcess.ServiceBase.ServiceName%2A> A tentar aceder ao registo de eventos antes do nome de origem está definido emite uma exceção."
  syntax:
    content: public bool AutoLog { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Para informações de relatório no registo de eventos; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceProcess.ServiceBase.AutoLog*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.CanHandlePowerEvent
  id: CanHandlePowerEvent
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: CanHandlePowerEvent
  nameWithType: ServiceBase.CanHandlePowerEvent
  fullName: System.ServiceProcess.ServiceBase.CanHandlePowerEvent
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Obtém ou define um valor que indica se o serviço pode processar as notificações de alterações de estado de energia do computador."
  remarks: "Quando as alterações de estado de energia do computador, o Gestor de controlo de serviços (SCM) verifica se o serviço aceita utilizando o valor do CanHandlePowerEvent comandos de eventos de energia.       Se for CanHandlePowerEvent `true`, o comando é passado para o serviço e o <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A>método denomina-se definido.</xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> Se <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A>não está implementado na classe derivada, o SCM processa o evento de energia através da classe base vazio <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A?displayProperty=fullName>método.</xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A?displayProperty=fullName> </xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A>"
  syntax:
    content: public bool CanHandlePowerEvent { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o serviço processa o estado de energia do computador alterações indicadas no <xref href=&quot;System.ServiceProcess.PowerBroadcastStatus&quot;> </xref> classe, caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceProcess.ServiceBase.CanHandlePowerEvent*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Esta propriedade é modificada depois do serviço foi iniciado."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent
  id: CanHandleSessionChangeEvent
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: CanHandleSessionChangeEvent
  nameWithType: ServiceBase.CanHandleSessionChangeEvent
  fullName: System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Obtém ou define um valor que indica se o serviço pode processar eventos de alteração de sessão recebidos a partir de uma sessão de servidor de terminais."
  syntax:
    content: public bool CanHandleSessionChangeEvent { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o serviço pode processar eventos de alteração de sessão do servidor de terminais; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Esta propriedade é modificada depois do serviço foi iniciado."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.CanPauseAndContinue
  id: CanPauseAndContinue
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: CanPauseAndContinue
  nameWithType: ServiceBase.CanPauseAndContinue
  fullName: System.ServiceProcess.ServiceBase.CanPauseAndContinue
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Obtém ou define um valor que indica se o serviço pode ser colocada em pausa e retomado."
  remarks: "Defina o valor da propriedade propriedades CanStop no construtor para o serviço.       Quando um serviço está em pausa, forem que está a fazer. Quando continuar o serviço (a através do Gestor de controlo do serviço ou através de programação), <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>é executado.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A>       Enviar um pedido de colocação em pausa para o serviço pode poupar recursos do sistema. Colocar em pausa não pode de versão todos os recursos do sistema, mas não de paragem. <xref:System.ServiceProcess.ServiceBase.OnPause%2A>e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, muitas vezes, são implementados para efetuar menos processamento que <xref:System.ServiceProcess.ServiceBase.OnStop%2A>e <xref:System.ServiceProcess.ServiceBase.OnStart%2A>.</xref:System.ServiceProcess.ServiceBase.OnStart%2A> </xref:System.ServiceProcess.ServiceBase.OnStop%2A> </xref:System.ServiceProcess.ServiceBase.OnContinue%2A></xref:System.ServiceProcess.ServiceBase.OnPause%2A>       Quando é propriedades CanStop `true`, substituir <xref:System.ServiceProcess.ServiceBase.OnPause%2A>e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>para especificar o processamento que deve ocorrer quando o Gestor de controlo de serviços (SCM) transmite um pedido de colocação em pausa ou continuar para o seu serviço.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A> </xref:System.ServiceProcess.ServiceBase.OnPause%2A> <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>deve ser implementado para anular o processamento em <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.</xref:System.ServiceProcess.ServiceBase.OnPause%2A></xref:System.ServiceProcess.ServiceBase.OnContinue%2A>       Se for propriedades CanStop `false`, o SCM passará não colocar em pausa ou continuar pedidos para o serviço, por isso, o <xref:System.ServiceProcess.ServiceBase.OnPause%2A>e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>métodos não serão chamados, mesmo que estão implementados.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A> </xref:System.ServiceProcess.ServiceBase.OnPause%2A> No SCM, o `Pause` e `Continue` controlos estão desativados quando propriedades CanStop `false`."
  syntax:
    content: public bool CanPauseAndContinue { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o serviço pode ser colocado em pausa; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceProcess.ServiceBase.CanPauseAndContinue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O serviço já foi iniciado. Não é possível alterar a propriedade propriedades CanStop assim que o serviço foi iniciado."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.CanShutdown
  id: CanShutdown
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: CanShutdown
  nameWithType: ServiceBase.CanShutdown
  fullName: System.ServiceProcess.ServiceBase.CanShutdown
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Obtém ou define um valor que indica se o serviço deve ser notificado quando o sistema está a encerrar."
  remarks: "Se for CanShutdown `true`, o serviço é notificado quando o sistema está a encerrar. No encerramento, o <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>método é denominado se tiver sido implementado na sua classe derivada</xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>      > [!NOTE] > Apenas o sistema deve fazer com que o <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>método a executar; o serviço pode chamá-lo, mas isto não é recomendado.</xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>"
  syntax:
    content: public bool CanShutdown { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o serviço deve ser notificado quando o sistema está a encerrar; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.  A predefinição é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceProcess.ServiceBase.CanShutdown*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O serviço já foi iniciado. Não é possível alterar a propriedade CanShutdown assim que o serviço foi iniciado."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.CanStop
  id: CanStop
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: CanStop
  nameWithType: ServiceBase.CanStop
  fullName: System.ServiceProcess.ServiceBase.CanStop
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Obtém ou define um valor que indica se o serviço pode ser parado depois de ser iniciada."
  remarks: "Quando parar denomina-se num serviço, o Gestor de controlo de serviços (SCM) verifica se o serviço aceita os comandos de paragem utilizando o valor dos valores das. Para a maioria dos serviços, o valor dos valores das é `true`, mas alguns serviços do sistema operativo, por exemplo, não permitir que o utilizador impedi-las.       Se os valores das `true`, o comando de paragem foi transmitido para o serviço e o <xref:System.ServiceProcess.ServiceBase.OnStop%2A>método denomina-se de que está definida.</xref:System.ServiceProcess.ServiceBase.OnStop%2A> Se <xref:System.ServiceProcess.ServiceBase.OnStop%2A>não está implementado na classe derivada, os identificadores SCM comando de paragem através da classe base vazio <xref:System.ServiceProcess.ServiceBase.OnStop%2A?displayProperty=fullName>método.</xref:System.ServiceProcess.ServiceBase.OnStop%2A?displayProperty=fullName> </xref:System.ServiceProcess.ServiceBase.OnStop%2A>"
  syntax:
    content: public bool CanStop { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o serviço pode ser parado e a <xref:System.ServiceProcess.ServiceBase.OnStop*>método chamado; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.ServiceProcess.ServiceBase.OnStop*>"
  overload: System.ServiceProcess.ServiceBase.CanStop*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O serviço já foi iniciado. Não é possível alterar a propriedade dos valores das assim que o serviço foi iniciado."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: ServiceBase.Dispose(Boolean)
  fullName: System.ServiceProcess.ServiceBase.Dispose(Boolean)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Disposes dos recursos (que não seja memória) utilizados pelo <xref href=&quot;System.ServiceProcess.ServiceBase&quot;> </xref>."
  remarks: "Chamar Dispose na sua classe derivada (e através de, no <xref:System.ServiceProcess.ServiceBase>classe) quando tiver terminado de utilizar a classe derivada</xref:System.ServiceProcess.ServiceBase> O método de Dispose deixa a classe derivada num Estado não utilizável. Depois de chamar Dispose, tem de libertar todas as referências a classe derivada e <xref:System.ServiceProcess.ServiceBase>para a memória que foram occupying pode ser recuperada através da recolha de lixo.</xref:System.ServiceProcess.ServiceBase>      > [!NOTE] > Sempre chamada Dispose antes de libertar a última referência para a classe derivada de <xref:System.ServiceProcess.ServiceBase>.</xref:System.ServiceProcess.ServiceBase> Caso contrário, os recursos <xref:System.ServiceProcess.ServiceBase>e classe derivada estiver a utilizar será não ser libertado até que a recolha de lixo chama os processos de destruição de objectos.</xref:System.ServiceProcess.ServiceBase>       <xref:System.ServiceProcess.ServiceBase.OnStop%2A>muitas vezes, é implementado para processar o código no <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, combinados com uma chamada para Dispose.</xref:System.ServiceProcess.ServiceBase.OnPause%2A></xref:System.ServiceProcess.ServiceBase.OnStop%2A> Se optar por fazê-lo na sua classe derivada, é customary implementar <xref:System.ServiceProcess.ServiceBase.OnStart%2A>alocar independentemente Dispose lançadas.</xref:System.ServiceProcess.ServiceBase.OnStart%2A>"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Para libertar recursos geridos e; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para libertar recursos apenas não geridos."
  overload: System.ServiceProcess.ServiceBase.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.EventLog
  id: EventLog
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: EventLog
  nameWithType: ServiceBase.EventLog
  fullName: System.ServiceProcess.ServiceBase.EventLog
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Obtém um registo de eventos que pode utilizar para escrever notificação de chamadas de comando de serviço, tais como iniciar e parar, o registo de eventos de aplicações."
  remarks: "O construtor inicializa a propriedade de registo de eventos para uma instância com o <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=fullName>e <xref:System.Diagnostics.EventLog.Log%2A?displayProperty=fullName>conjunto de propriedades.</xref:System.Diagnostics.EventLog.Log%2A?displayProperty=fullName> </xref:System.Diagnostics.EventLog.Source%2A?displayProperty=fullName> A origem é o <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>do serviço, e o registo é o registo da aplicação. o computador</xref:System.ServiceProcess.ServiceBase.ServiceName%2A> Estes valores são definidos automaticamente e não podem ser alterados para o registo automático de comandos de serviço.       Quando <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>é `true`, iniciar, parar, colocar em pausa, continuar e comandos personalizados são automaticamente registadas no ficheiro de registo de eventos da aplicação.</xref:System.ServiceProcess.ServiceBase.AutoLog%2A> Pode utilizar a propriedade de registo de eventos para escrever mensagens adicionais para esse registo bem. As chamadas de componente <xref:System.Diagnostics.EventLog.WriteEntry%2A?displayProperty=fullName>utilizando este membro de registo de eventos.</xref:System.Diagnostics.EventLog.WriteEntry%2A?displayProperty=fullName>       Para relatar informações de um registo de eventos personalizado em vez de registo de aplicações, defina <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>para `false` e escrever instruções dentro os métodos de processamento de comandos <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, ou <xref:System.ServiceProcess.ServiceBase.OnStop%2A>para publicar o registo adequado</xref:System.ServiceProcess.ServiceBase.OnStop%2A> </xref:System.ServiceProcess.ServiceBase.OnPause%2A> </xref:System.ServiceProcess.ServiceBase.OnContinue%2A> </xref:System.ServiceProcess.ServiceBase.AutoLog%2A>"
  syntax:
    content: public virtual System.Diagnostics.EventLog EventLog { get; }
    return:
      type: System.Diagnostics.EventLog
      description: "Um <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> instância cuja origem está registada no registo de aplicação."
  overload: System.ServiceProcess.ServiceBase.EventLog*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.ExitCode
  id: ExitCode
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: ExitCode
  nameWithType: ServiceBase.ExitCode
  fullName: System.ServiceProcess.ServiceBase.ExitCode
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Obtém ou define o código de saída para o serviço."
  remarks: "Defina a propriedade de ExitCode para um valor diferente de zero, antes de parar o serviço para indicar um erro com o Gestor de controlo de serviços."
  syntax:
    content: public int ExitCode { get; set; }
    return:
      type: System.Int32
      description: "O código de saída para o serviço."
  overload: System.ServiceProcess.ServiceBase.ExitCode*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.MaxNameLength
  id: MaxNameLength
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: MaxNameLength
  nameWithType: ServiceBase.MaxNameLength
  fullName: System.ServiceProcess.ServiceBase.MaxNameLength
  type: Field
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Indica o tamanho máximo para um nome de serviço."
  remarks: "ServiceName e DisplayName têm restrições de tamanho que tem de ser observadas ao definir as propriedades na sua classe de serviço."
  syntax:
    content: public const int MaxNameLength = 80;
    return:
      type: System.Int32
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnContinue
  id: OnContinue
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnContinue()
  nameWithType: ServiceBase.OnContinue()
  fullName: System.ServiceProcess.ServiceBase.OnContinue()
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Quando implementada numa classe derivada, OnContinue é executado quando um comando continuar é enviado para o serviço pelo Gestor de controlo de serviços (SCM). Especifica as ações a tomar quando um serviço retoma normal a funcionar após a ser colocada em pausa."
  remarks: "Implementar OnContinue para espelhar a resposta da aplicação para <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.</xref:System.ServiceProcess.ServiceBase.OnPause%2A> Quando continuar o serviço (a através da consola de serviços ou através de programação), OnContinue execuções de processamento e o serviço fica ativo novamente.       OnContinue deve ser substituído quando a <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>propriedade é `true`.</xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>       Se <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>é `false`, o SCM passará não colocar em pausa ou continuar pedidos para o serviço, por isso, o <xref:System.ServiceProcess.ServiceBase.OnPause%2A>e métodos de OnContinue não serão chamados, mesmo que estão implementados.</xref:System.ServiceProcess.ServiceBase.OnPause%2A> </xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> No SCM, o `Pause` e `Continue` controlos estão desativados quando <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>é `false`.</xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>"
  syntax:
    content: protected virtual void OnContinue ();
    parameters: []
  overload: System.ServiceProcess.ServiceBase.OnContinue*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)
  id: OnCustomCommand(System.Int32)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnCustomCommand(Int32)
  nameWithType: ServiceBase.OnCustomCommand(Int32)
  fullName: System.ServiceProcess.ServiceBase.OnCustomCommand(Int32)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Quando implementada numa classe derivada, OnCustomCommand executa quando o Gestor de controlo de serviços (SCM) transmite comandos personalizados para o serviço. Especifica as ações a tomar quando ocorre um comando com o valor do parâmetro especificado."
  remarks: "OnCustomCommand permite-lhe especificar funcionalidades adicionais além iniciar, parar, colocar em pausa e continuar de serviços.       O SCM não examine o comando personalizado para verificar se o serviço suporta o `command` parâmetro transmitido. O comando personalizado estes passam diretamente ao serviço. Se o serviço não reconhece o `command` parâmetro faz nada.       Comandos personalizados são gerados por um <xref:System.ServiceProcess.ServiceController.ExecuteCommand%2A>instrução num <xref:System.ServiceProcess.ServiceController>componente.</xref:System.ServiceProcess.ServiceController> </xref:System.ServiceProcess.ServiceController.ExecuteCommand%2A> Utilizar uma instrução de comutador ou se... em seguida, a condição para processar comandos personalizados que definir do seu serviço.       Os únicos valores de um comando personalizado que pode definir na sua aplicação ou utilizar na OnCustomCommand são as entre 128 e 255. Números inteiros abaixo 128 correspondem aos valores de sistema reservados.       Se o <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>propriedade é `true`, comandos personalizados, como todos os outros comandos, escrevem entradas de registo de eventos para comunicar se a execução do método foi concluída com êxito ou falha.</xref:System.ServiceProcess.ServiceBase.AutoLog%2A>"
  syntax:
    content: protected virtual void OnCustomCommand (int command);
    parameters:
    - id: command
      type: System.Int32
      description: "A mensagem de comandos enviada para o serviço."
  overload: System.ServiceProcess.ServiceBase.OnCustomCommand*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnPause
  id: OnPause
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnPause()
  nameWithType: ServiceBase.OnPause()
  fullName: System.ServiceProcess.ServiceBase.OnPause()
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Quando implementada numa classe derivada, executa quando um comando de pausa é enviado para o serviço pelo Gestor de controlo de serviços (SCM). Especifica as ações a tomar quando interrompe um serviço."
  remarks: "Utilize OnPause para especificar o processamento que ocorre quando o serviço recebe um comando de pausa. OnPause deve ser substituído quando a <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>propriedade é `true`.</xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>       Quando continuar um serviço em pausa (a através da consola de serviços ou através de programação), o <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>processamento é executado e o serviço fica ativo novamente.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A>       O comando de pausa só permite à aplicação de reagir a um evento específico. OnPause faz nada para o serviço que não é possível definir não.       Enviar um pedido de colocação em pausa para o serviço pode poupar recursos do sistema porque a colocar em pausa não precisa de libertar todos os recursos do sistema. Por exemplo, se threads tenham sido abertos pelo processo de colocação em pausa de um serviço em vez de a pará-lo, pode permitir que os threads para permanece aberta, evitando a necessidade de realocá-los quando o serviço continua. Se definir pausa para libertar todos os recursos do sistema, comporta-se como um comando de paragem.       Definir <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>para `true`e substituir OnPause e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>para especificar o processamento que deve ocorrer quando o SCM transmite um pedido de colocação em pausa ou continuar para o seu serviço.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A> </xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>deve ser implementado para anular o processamento em OnPause.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A>       Se <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>é `false`, o SCM passará não colocar em pausa ou continuar pedidos para o serviço, por isso, o OnPause e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>métodos não serão chamados, mesmo que se encontra implementado.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A> </xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> No SCM, o `Pause` e `Continue` controlos estão desativados quando <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>é `false`.</xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>"
  syntax:
    content: protected virtual void OnPause ();
    parameters: []
  overload: System.ServiceProcess.ServiceBase.OnPause*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)
  id: OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnPowerEvent(PowerBroadcastStatus)
  nameWithType: ServiceBase.OnPowerEvent(PowerBroadcastStatus)
  fullName: System.ServiceProcess.ServiceBase.OnPowerEvent(PowerBroadcastStatus)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Quando implementada numa classe derivada, executa quando o estado de energia do computador foi alterada. Isto aplica-se aos computadores portáteis entrar em modo suspenso, o que não é igual um encerramento do sistema."
  remarks: "Utilize OnPowerEvent para especificar o processamento que ocorre quando os eventos do sistema indicaram a <xref:System.ServiceProcess.PowerBroadcastStatus>enumeração ocorre – por exemplo, quando o computador é colocado no modo suspenso ou indica a energia da bateria.</xref:System.ServiceProcess.PowerBroadcastStatus>       OnPowerEvent deve ser substituído quando a <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>propriedade é `true`.</xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>"
  syntax:
    content: protected virtual bool OnPowerEvent (System.ServiceProcess.PowerBroadcastStatus powerStatus);
    parameters:
    - id: powerStatus
      type: System.ServiceProcess.PowerBroadcastStatus
      description: "A <xref href=&quot;System.ServiceProcess.PowerBroadcastStatus&quot;> </xref> indica que uma notificação do sistema sobre o estado de energia."
    return:
      type: System.Boolean
      description: "Quando implementada numa classe derivada, as necessidades da sua aplicação determinam que valor para devolver. Por exemplo, se um <xref uid=&quot;langword_csharp_QuerySuspend&quot; name=&quot;QuerySuspend&quot; href=&quot;&quot;> </xref> Estado difusão é passado, pode fazer com que a aplicação para rejeitar a consulta devolvendo <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceProcess.ServiceBase.OnPowerEvent*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)
  id: OnSessionChange(System.ServiceProcess.SessionChangeDescription)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnSessionChange(SessionChangeDescription)
  nameWithType: ServiceBase.OnSessionChange(SessionChangeDescription)
  fullName: System.ServiceProcess.ServiceBase.OnSessionChange(SessionChangeDescription)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Executa quando é recebido um evento de alteração de uma sessão de servidor de terminais."
  remarks: "Tem de definir o <xref:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent%2A>propriedade `true` para ativar a execução deste método.</xref:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent%2A>"
  syntax:
    content: protected virtual void OnSessionChange (System.ServiceProcess.SessionChangeDescription changeDescription);
    parameters:
    - id: changeDescription
      type: System.ServiceProcess.SessionChangeDescription
      description: "Uma estrutura que identifica o tipo de alteração."
  overload: System.ServiceProcess.ServiceBase.OnSessionChange*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnShutdown
  id: OnShutdown
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnShutdown()
  nameWithType: ServiceBase.OnShutdown()
  fullName: System.ServiceProcess.ServiceBase.OnShutdown()
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Quando implementada numa classe derivada, executa quando o sistema está a encerrar. Especifica que deve ocorrer imediatamente antes do sistema a ser encerrado."
  remarks: "Utilize OnShutdown para especificar o processamento que ocorre quando o sistema será encerrado.       Este evento ocorre apenas quando o sistema operativo é encerrado, não quando o computador está desativado.       OnShutdown deve ser substituído quando a <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>propriedade é `true`.</xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>"
  syntax:
    content: protected virtual void OnShutdown ();
    parameters: []
  overload: System.ServiceProcess.ServiceBase.OnShutdown*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnStart(System.String[])
  id: OnStart(System.String[])
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnStart(String[])
  nameWithType: ServiceBase.OnStart(String[])
  fullName: System.ServiceProcess.ServiceBase.OnStart(String[])
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Quando implementada numa classe derivada, executa quando um comando de início é enviado para o serviço pelo Gestor de controlo de serviços (SCM) ou quando o sistema operativo for iniciada (para um serviço que inicia automaticamente). Especifica as ações a tomar quando o serviço for iniciado."
  remarks: "Use OnStart to specify the processing that occurs when the service receives a Start command. OnStart is the method in which you specify the behavior of the service. OnStart can take arguments as a way to pass data, but this usage is rare.  \n  \n> [!CAUTION]\n>  Do not use the constructor to perform processing that should be in OnStart. Use OnStart to handle all initialization of your service. The constructor is called when the application's executable runs, not when the service runs. The executable runs before OnStart. When you continue, for example, the constructor is not called again because the SCM already holds the object in memory. If <xref:System.ServiceProcess.ServiceBase.OnStop%2A> releases resources allocated in the constructor rather than in OnStart, the needed resources would not be created again the second time the service is called.  \n  \n Services can be set to start automatically when the computer reboots by setting the <xref:System.ServiceProcess.ServiceInstaller.StartType%2A> on the service's installer to <xref:System.ServiceProcess.ServiceStartMode>. In such a situation, OnStart would be called at system startup.  \n  \n OnStart is expected to be overridden in the derived class. For the service to be useful, OnStart and <xref:System.ServiceProcess.ServiceBase.OnStop%2A> should both be implemented in your service class.  \n  \n Process initialization arguments for the service in the OnStart method, not in the Main method. The arguments in the `args` parameter array can be set manually in the properties window for the service in the Services console. The arguments entered in the console are not saved; they are passed to the service on a one-time basis when the service is started from the control panel. Arguments that must be present when the service is automatically started can be placed in the ImagePath string value for the service's registry key (HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\\\*\\<service name>*). You can obtain the arguments from the registry using the <xref:System.Environment.GetCommandLineArgs%2A> method, for example:  `string[] imagePathArgs = Environment.GetCommandLineArgs();`."
  syntax:
    content: protected virtual void OnStart (string[] args);
    parameters:
    - id: args
      type: System.String[]
      description: "Dados transmitidos através do comando de início."
  overload: System.ServiceProcess.ServiceBase.OnStart*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnStop
  id: OnStop
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnStop()
  nameWithType: ServiceBase.OnStop()
  fullName: System.ServiceProcess.ServiceBase.OnStop()
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Quando implementada numa classe derivada, executa quando é enviado um comando de paragem ao serviço pelo Gestor de controlo de serviços (SCM). Especifica as ações a tomar quando um serviço deixa de ser executada."
  remarks: "Utilize OnStop para especificar o processamento que ocorre quando o serviço recebe um comando de paragem.       Quando o SCM recebe um comando de paragem, utiliza o valor de <xref:System.ServiceProcess.ServiceBase.CanStop%2A>para verificar se o serviço aceita os comandos de paragem.</xref:System.ServiceProcess.ServiceBase.CanStop%2A> Se <xref:System.ServiceProcess.ServiceBase.CanStop%2A>é `true`, o comando de paragem foi transmitido para o serviço e o método OnStop denomina-se tiver sido definida.</xref:System.ServiceProcess.ServiceBase.CanStop%2A> Se não se encontra implementado OnStop no serviço, o SCM processa o comando de paragem.       Se <xref:System.ServiceProcess.ServiceBase.CanStop%2A>é `false`, o SCM ignora o comando de paragem.</xref:System.ServiceProcess.ServiceBase.CanStop%2A> Não for passado para o serviço. O comando de paragem devolve e emite uma exceção.       OnStop deverá ser substituídas na classe derivada. Para o serviço ser úteis, <xref:System.ServiceProcess.ServiceBase.OnStart%2A>e OnStop deve ambos ser implementado na sua classe de serviço.</xref:System.ServiceProcess.ServiceBase.OnStart%2A>"
  syntax:
    content: protected virtual void OnStop ();
    parameters: []
  overload: System.ServiceProcess.ServiceBase.OnStop*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)
  id: RequestAdditionalTime(System.Int32)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: RequestAdditionalTime(Int32)
  nameWithType: ServiceBase.RequestAdditionalTime(Int32)
  fullName: System.ServiceProcess.ServiceBase.RequestAdditionalTime(Int32)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Pedidos mais tempo para uma operação pendente."
  remarks: "O método RequestAdditionalTime se destina a ser chamado pelo substituída <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, ou <xref:System.ServiceProcess.ServiceBase.OnStop%2A>métodos para pedir mais tempo para uma operação pendente, para impedir que o Gestor de controlo de serviços (SCM) marcar o serviço como não responde.</xref:System.ServiceProcess.ServiceBase.OnStop%2A> </xref:System.ServiceProcess.ServiceBase.OnStart%2A> </xref:System.ServiceProcess.ServiceBase.OnPause%2A> </xref:System.ServiceProcess.ServiceBase.OnContinue%2A>  Se a operação pendente não é um continuar, colocar em pausa, iniciar ou parar, um <xref:System.InvalidOperationException>é emitida.</xref:System.InvalidOperationException>"
  syntax:
    content: public void RequestAdditionalTime (int milliseconds);
    parameters:
    - id: milliseconds
      type: System.Int32
      description: "O pedido de tempo em milissegundos."
  overload: System.ServiceProcess.ServiceBase.RequestAdditionalTime*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O serviço não está no estado pendente."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)
  id: Run(System.ServiceProcess.ServiceBase)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: Run(ServiceBase)
  nameWithType: ServiceBase.Run(ServiceBase)
  fullName: System.ServiceProcess.ServiceBase.Run(ServiceBase)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Regista o executável para um serviço com o Gestor de controlo de serviços (SCM)."
  remarks: "Chamada esta sobrecarga de `main()` função do serviço executável para registar o serviço com o Gestor de controlo do serviço. Depois de chamar executar, o Gestor de controlo de serviço emite um comando de início, o que resulta numa chamada para o <xref:System.ServiceProcess.ServiceBase.OnStart%2A>método no serviço.</xref:System.ServiceProcess.ServiceBase.OnStart%2A> O serviço não será iniciado até que o comando de início é executado.       O método de execução denomina-se muito da mesma forma como <xref:System.Windows.Forms.Application.Run%2A?displayProperty=fullName>para aplicações do Windows Forms.</xref:System.Windows.Forms.Application.Run%2A?displayProperty=fullName>       Se <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>é `true`, uma entrada é escrita no registo de eventos se o serviço especificado pelo `service` parâmetro falha a iniciação.</xref:System.ServiceProcess.ServiceBase.AutoLog%2A>"
  syntax:
    content: public static void Run (System.ServiceProcess.ServiceBase service);
    parameters:
    - id: service
      type: System.ServiceProcess.ServiceBase
      description: "A <xref href=&quot;System.ServiceProcess.ServiceBase&quot;> </xref> que indica que um serviço para iniciar."
  overload: System.ServiceProcess.ServiceBase.Run*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>service</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])
  id: Run(System.ServiceProcess.ServiceBase[])
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: Run(ServiceBase[])
  nameWithType: ServiceBase.Run(ServiceBase[])
  fullName: System.ServiceProcess.ServiceBase.Run(ServiceBase[])
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Regista o executável para vários serviços com o Gestor de controlo de serviços (SCM)."
  remarks: "Chamada esta sobrecarga de `main()` função do serviço executável para registar os serviços com o Gestor de controlo do serviço. Depois de chamar executar, o Gestor de controlo de serviço emite comandos de início, o que resultam em chamadas para o <xref:System.ServiceProcess.ServiceBase.OnStart%2A>métodos nos serviços.</xref:System.ServiceProcess.ServiceBase.OnStart%2A> Os serviços não estiverem iniciados até que os comandos de início são executados.       O método de execução denomina-se muito da mesma forma como o <xref:System.Windows.Forms.Application.Run%2A?displayProperty=fullName>método para aplicações do Windows Forms.</xref:System.Windows.Forms.Application.Run%2A?displayProperty=fullName>       Se <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>é `true`, uma entrada é escrita no registo de eventos se qualquer serviço na matriz não conseguir iniciar.</xref:System.ServiceProcess.ServiceBase.AutoLog%2A>"
  syntax:
    content: public static void Run (System.ServiceProcess.ServiceBase[] services);
    parameters:
    - id: services
      type: System.ServiceProcess.ServiceBase[]
      description: "Uma matriz de instâncias de ServiceBase, que indicar para iniciar os serviços."
  overload: System.ServiceProcess.ServiceBase.Run*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Não forneceu um serviço para iniciar. A matriz poderá ser <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> ou estar vazio."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.ServiceHandle
  id: ServiceHandle
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: ServiceHandle
  nameWithType: ServiceBase.ServiceHandle
  fullName: System.ServiceProcess.ServiceBase.ServiceHandle
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Obtém o identificador de controlo de serviço para o serviço."
  remarks: "O identificador de controlo de serviço é utilizado para comunicar com o Gestor de controlo de serviços (SCM).  O identificador pode ser utilizado para atualizar informações de estado do Gestor de controlo de serviço para o serviço de chamada utilizando o não gerido `SetServiceStatus` função."
  syntax:
    content: protected IntPtr ServiceHandle { get; }
    return:
      type: System.IntPtr
      description: "Um <xref:System.IntPtr>estrutura que contém o identificador de controlo de serviço para o serviço.</xref:System.IntPtr>"
  overload: System.ServiceProcess.ServiceBase.ServiceHandle*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)
  id: ServiceMainCallback(System.Int32,System.IntPtr)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: ServiceMainCallback(Int32,IntPtr)
  nameWithType: ServiceBase.ServiceMainCallback(Int32,IntPtr)
  fullName: System.ServiceProcess.ServiceBase.ServiceMainCallback(Int32,IntPtr)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Regista o processador de comandos e inicia o serviço."
  syntax:
    content: public void ServiceMainCallback (int argCount, IntPtr argPointer);
    parameters:
    - id: argCount
      type: System.Int32
      description: "O número de argumentos da matriz de argumento."
    - id: argPointer
      type: System.IntPtr
      description: "Um <xref:System.IntPtr>estrutura que aponta para uma matriz de argumentos.</xref:System.IntPtr>"
  overload: System.ServiceProcess.ServiceBase.ServiceMainCallback*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.ServiceName
  id: ServiceName
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: ServiceName
  nameWithType: ServiceBase.ServiceName
  fullName: System.ServiceProcess.ServiceBase.ServiceName
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Obtém ou define o nome abreviado utilizado para identificar o serviço no sistema."
  remarks: "O ServiceName identifica o serviço para o Gestor de controlo do serviço. O valor desta propriedade deve ser idêntico ao nome registado para o serviço na <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A?displayProperty=fullName>propriedade da classe de programa de instalação correspondente.</xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A?displayProperty=fullName> No código, ServiceName do serviço, normalmente, definido no `main()` função do executável.       O ServiceName também é utilizado para especificar o <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=fullName>associados a <xref:System.ServiceProcess.ServiceBase.EventLog%2A>propriedade.</xref:System.ServiceProcess.ServiceBase.EventLog%2A> </xref:System.Diagnostics.EventLog.Source%2A?displayProperty=fullName> Esta <xref:System.ServiceProcess.ServiceBase.EventLog%2A>é uma instância que escreve informações de comando de serviço para o registo da aplicação.</xref:System.ServiceProcess.ServiceBase.EventLog%2A>       ServiceName, que fornece a cadeia de origem para o registo de eventos, tem de ser definida antes do serviço escreve no registo de eventos. A tentar aceder ao registo de eventos antes do nome de origem está definido, faz com que uma exceção ao ser emitida."
  syntax:
    content: public string ServiceName { get; set; }
    return:
      type: System.String
      description: "O nome do serviço."
  overload: System.ServiceProcess.ServiceBase.ServiceName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O serviço já foi iniciado. Não é possível alterar a propriedade ServiceName assim que o serviço foi iniciado."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O nome especificado é uma cadeia de comprimento de zero ou tem mais de <xref href=&quot;System.ServiceProcess.ServiceBase.MaxNameLength&quot;> </xref>, ou o nome especificado contém carateres direta de barra ou barra invertida."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.Stop
  id: Stop
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: Stop()
  nameWithType: ServiceBase.Stop()
  fullName: System.ServiceProcess.ServiceBase.Stop()
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Para o serviço em execução."
  remarks: "O método de paragem define o estado de serviço para indicar um parar está pendente e chamadas a <xref:System.ServiceProcess.ServiceBase.OnStop%2A>método.</xref:System.ServiceProcess.ServiceBase.OnStop%2A>  Depois da aplicação estiver parada, o estado de serviço está definido para parado. Se a aplicação é um serviço alojado, o domínio de aplicação é descarregado."
  syntax:
    content: public void Stop ();
    parameters: []
  overload: System.ServiceProcess.ServiceBase.Stop*
  exceptions: []
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ServiceProcess.ServiceBase.#ctor
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceBase()
  nameWithType: ServiceBase.ServiceBase()
  fullName: System.ServiceProcess.ServiceBase.ServiceBase()
- uid: System.ServiceProcess.ServiceBase.AutoLog
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: AutoLog
  nameWithType: ServiceBase.AutoLog
  fullName: System.ServiceProcess.ServiceBase.AutoLog
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.ServiceProcess.ServiceBase.CanHandlePowerEvent
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanHandlePowerEvent
  nameWithType: ServiceBase.CanHandlePowerEvent
  fullName: System.ServiceProcess.ServiceBase.CanHandlePowerEvent
- uid: System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanHandleSessionChangeEvent
  nameWithType: ServiceBase.CanHandleSessionChangeEvent
  fullName: System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent
- uid: System.ServiceProcess.ServiceBase.CanPauseAndContinue
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanPauseAndContinue
  nameWithType: ServiceBase.CanPauseAndContinue
  fullName: System.ServiceProcess.ServiceBase.CanPauseAndContinue
- uid: System.ServiceProcess.ServiceBase.CanShutdown
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanShutdown
  nameWithType: ServiceBase.CanShutdown
  fullName: System.ServiceProcess.ServiceBase.CanShutdown
- uid: System.ServiceProcess.ServiceBase.CanStop
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanStop
  nameWithType: ServiceBase.CanStop
  fullName: System.ServiceProcess.ServiceBase.CanStop
- uid: System.ServiceProcess.ServiceBase.Dispose(System.Boolean)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: ServiceBase.Dispose(Boolean)
  fullName: System.ServiceProcess.ServiceBase.Dispose(Boolean)
- uid: System.ServiceProcess.ServiceBase.EventLog
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: EventLog
  nameWithType: ServiceBase.EventLog
  fullName: System.ServiceProcess.ServiceBase.EventLog
- uid: System.Diagnostics.EventLog
  parent: System.Diagnostics
  isExternal: false
  name: EventLog
  nameWithType: EventLog
  fullName: System.Diagnostics.EventLog
- uid: System.ServiceProcess.ServiceBase.ExitCode
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ExitCode
  nameWithType: ServiceBase.ExitCode
  fullName: System.ServiceProcess.ServiceBase.ExitCode
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.ServiceProcess.ServiceBase.MaxNameLength
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: MaxNameLength
  nameWithType: ServiceBase.MaxNameLength
  fullName: System.ServiceProcess.ServiceBase.MaxNameLength
- uid: System.ServiceProcess.ServiceBase.OnContinue
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnContinue()
  nameWithType: ServiceBase.OnContinue()
  fullName: System.ServiceProcess.ServiceBase.OnContinue()
- uid: System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnCustomCommand(Int32)
  nameWithType: ServiceBase.OnCustomCommand(Int32)
  fullName: System.ServiceProcess.ServiceBase.OnCustomCommand(Int32)
- uid: System.ServiceProcess.ServiceBase.OnPause
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnPause()
  nameWithType: ServiceBase.OnPause()
  fullName: System.ServiceProcess.ServiceBase.OnPause()
- uid: System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnPowerEvent(PowerBroadcastStatus)
  nameWithType: ServiceBase.OnPowerEvent(PowerBroadcastStatus)
  fullName: System.ServiceProcess.ServiceBase.OnPowerEvent(PowerBroadcastStatus)
- uid: System.ServiceProcess.PowerBroadcastStatus
  parent: System.ServiceProcess
  isExternal: false
  name: PowerBroadcastStatus
  nameWithType: PowerBroadcastStatus
  fullName: System.ServiceProcess.PowerBroadcastStatus
- uid: System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnSessionChange(SessionChangeDescription)
  nameWithType: ServiceBase.OnSessionChange(SessionChangeDescription)
  fullName: System.ServiceProcess.ServiceBase.OnSessionChange(SessionChangeDescription)
- uid: System.ServiceProcess.SessionChangeDescription
  parent: System.ServiceProcess
  isExternal: false
  name: SessionChangeDescription
  nameWithType: SessionChangeDescription
  fullName: System.ServiceProcess.SessionChangeDescription
- uid: System.ServiceProcess.ServiceBase.OnShutdown
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnShutdown()
  nameWithType: ServiceBase.OnShutdown()
  fullName: System.ServiceProcess.ServiceBase.OnShutdown()
- uid: System.ServiceProcess.ServiceBase.OnStart(System.String[])
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnStart(String[])
  nameWithType: ServiceBase.OnStart(String[])
  fullName: System.ServiceProcess.ServiceBase.OnStart(String[])
- uid: System.String[]
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.ServiceProcess.ServiceBase.OnStop
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnStop()
  nameWithType: ServiceBase.OnStop()
  fullName: System.ServiceProcess.ServiceBase.OnStop()
- uid: System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: RequestAdditionalTime(Int32)
  nameWithType: ServiceBase.RequestAdditionalTime(Int32)
  fullName: System.ServiceProcess.ServiceBase.RequestAdditionalTime(Int32)
- uid: System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Run(ServiceBase)
  nameWithType: ServiceBase.Run(ServiceBase)
  fullName: System.ServiceProcess.ServiceBase.Run(ServiceBase)
- uid: System.ServiceProcess.ServiceBase
  parent: System.ServiceProcess
  isExternal: false
  name: ServiceBase
  nameWithType: ServiceBase
  fullName: System.ServiceProcess.ServiceBase
- uid: System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Run(ServiceBase[])
  nameWithType: ServiceBase.Run(ServiceBase[])
  fullName: System.ServiceProcess.ServiceBase.Run(ServiceBase[])
- uid: System.ServiceProcess.ServiceBase[]
  parent: System.ServiceProcess
  isExternal: false
  name: ServiceBase
  nameWithType: ServiceBase
  fullName: System.ServiceProcess.ServiceBase[]
  spec.csharp:
  - uid: System.ServiceProcess.ServiceBase
    name: ServiceBase
    nameWithType: ServiceBase
    fullName: ServiceBase[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.ServiceProcess.ServiceBase.ServiceHandle
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceHandle
  nameWithType: ServiceBase.ServiceHandle
  fullName: System.ServiceProcess.ServiceBase.ServiceHandle
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceMainCallback(Int32,IntPtr)
  nameWithType: ServiceBase.ServiceMainCallback(Int32,IntPtr)
  fullName: System.ServiceProcess.ServiceBase.ServiceMainCallback(Int32,IntPtr)
- uid: System.ServiceProcess.ServiceBase.ServiceName
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceName
  nameWithType: ServiceBase.ServiceName
  fullName: System.ServiceProcess.ServiceBase.ServiceName
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.ServiceProcess.ServiceBase.Stop
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Stop()
  nameWithType: ServiceBase.Stop()
  fullName: System.ServiceProcess.ServiceBase.Stop()
- uid: System.ServiceProcess.ServiceBase.#ctor*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceBase
  nameWithType: ServiceBase.ServiceBase
- uid: System.ServiceProcess.ServiceBase.AutoLog*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: AutoLog
  nameWithType: ServiceBase.AutoLog
- uid: System.ServiceProcess.ServiceBase.CanHandlePowerEvent*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanHandlePowerEvent
  nameWithType: ServiceBase.CanHandlePowerEvent
- uid: System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanHandleSessionChangeEvent
  nameWithType: ServiceBase.CanHandleSessionChangeEvent
- uid: System.ServiceProcess.ServiceBase.CanPauseAndContinue*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanPauseAndContinue
  nameWithType: ServiceBase.CanPauseAndContinue
- uid: System.ServiceProcess.ServiceBase.CanShutdown*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanShutdown
  nameWithType: ServiceBase.CanShutdown
- uid: System.ServiceProcess.ServiceBase.CanStop*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanStop
  nameWithType: ServiceBase.CanStop
- uid: System.ServiceProcess.ServiceBase.Dispose*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Dispose
  nameWithType: ServiceBase.Dispose
- uid: System.ServiceProcess.ServiceBase.EventLog*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: EventLog
  nameWithType: ServiceBase.EventLog
- uid: System.ServiceProcess.ServiceBase.ExitCode*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ExitCode
  nameWithType: ServiceBase.ExitCode
- uid: System.ServiceProcess.ServiceBase.OnContinue*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnContinue
  nameWithType: ServiceBase.OnContinue
- uid: System.ServiceProcess.ServiceBase.OnCustomCommand*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnCustomCommand
  nameWithType: ServiceBase.OnCustomCommand
- uid: System.ServiceProcess.ServiceBase.OnPause*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnPause
  nameWithType: ServiceBase.OnPause
- uid: System.ServiceProcess.ServiceBase.OnPowerEvent*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnPowerEvent
  nameWithType: ServiceBase.OnPowerEvent
- uid: System.ServiceProcess.ServiceBase.OnSessionChange*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnSessionChange
  nameWithType: ServiceBase.OnSessionChange
- uid: System.ServiceProcess.ServiceBase.OnShutdown*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnShutdown
  nameWithType: ServiceBase.OnShutdown
- uid: System.ServiceProcess.ServiceBase.OnStart*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnStart
  nameWithType: ServiceBase.OnStart
- uid: System.ServiceProcess.ServiceBase.OnStop*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnStop
  nameWithType: ServiceBase.OnStop
- uid: System.ServiceProcess.ServiceBase.RequestAdditionalTime*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: RequestAdditionalTime
  nameWithType: ServiceBase.RequestAdditionalTime
- uid: System.ServiceProcess.ServiceBase.Run*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Run
  nameWithType: ServiceBase.Run
- uid: System.ServiceProcess.ServiceBase.ServiceHandle*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceHandle
  nameWithType: ServiceBase.ServiceHandle
- uid: System.ServiceProcess.ServiceBase.ServiceMainCallback*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceMainCallback
  nameWithType: ServiceBase.ServiceMainCallback
- uid: System.ServiceProcess.ServiceBase.ServiceName*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceName
  nameWithType: ServiceBase.ServiceName
- uid: System.ServiceProcess.ServiceBase.Stop*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Stop
  nameWithType: ServiceBase.Stop
