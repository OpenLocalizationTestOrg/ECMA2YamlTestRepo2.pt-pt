### YamlMime:ManagedReference
items:
- uid: System.Net.Sockets.NetworkStream
  id: NetworkStream
  children:
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)
  - System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.Net.Sockets.NetworkStream.CanRead
  - System.Net.Sockets.NetworkStream.CanSeek
  - System.Net.Sockets.NetworkStream.CanTimeout
  - System.Net.Sockets.NetworkStream.CanWrite
  - System.Net.Sockets.NetworkStream.Close(System.Int32)
  - System.Net.Sockets.NetworkStream.DataAvailable
  - System.Net.Sockets.NetworkStream.Dispose(System.Boolean)
  - System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)
  - System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)
  - System.Net.Sockets.NetworkStream.Finalize
  - System.Net.Sockets.NetworkStream.Flush
  - System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)
  - System.Net.Sockets.NetworkStream.Length
  - System.Net.Sockets.NetworkStream.Position
  - System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.Net.Sockets.NetworkStream.Readable
  - System.Net.Sockets.NetworkStream.ReadTimeout
  - System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.Net.Sockets.NetworkStream.SetLength(System.Int64)
  - System.Net.Sockets.NetworkStream.Socket
  - System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.Net.Sockets.NetworkStream.Writeable
  - System.Net.Sockets.NetworkStream.WriteTimeout
  langs:
  - csharp
  name: NetworkStream
  nameWithType: NetworkStream
  fullName: System.Net.Sockets.NetworkStream
  type: Class
  summary: "Fornece o fluxo de dados subjacente para acesso à rede."
  remarks: "A classe de NetworkStream fornece métodos para enviar e receber dados através de <xref:System.Net.Sockets.SocketType>sockets no modo de bloqueio.</xref:System.Net.Sockets.SocketType> Para obter mais informações sobre a bloquear nonblocking <xref:System.Net.Sockets.Socket>s, consulte [utilizando um Socket assíncrono do cliente](~/add/includes/ajax-current-ext-md.md).</xref:System.Net.Sockets.Socket> Pode utilizar a classe de NetworkStream ambas as operações síncronas e assíncronas transferência de dados. Para obter mais informações sobre a comunicação síncrona e assíncrona, consulte [Sockets](~/add/includes/ajax-current-ext-md.md).       Para criar um NetworkStream, tem de fornecer um <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> ligado Também pode especificar que <xref:System.IO.FileAccess>tem permissão de NetworkStream através de <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> fornecido</xref:System.IO.FileAccess> Por predefinição, a fechar o NetworkStream não feche o <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> fornecido Se quiser NetworkStream ter permissão para fechar fornecido <xref:System.Net.Sockets.Socket>, tem de especificar `true` para o valor do `ownsSocket` parâmetro.</xref:System.Net.Sockets.Socket>       Utilize o <xref:System.Net.Sockets.NetworkStream.Write%2A>e <xref:System.Net.Sockets.NetworkStream.Read%2A>métodos para simple único thread e/s de bloqueio síncrona.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream.Write%2A> Se pretender processar a e/s separados threads a utilizar, considere utilizar o <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>e <xref:System.Net.Sockets.NetworkStream.EndWrite%2A>métodos, ou o <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>e <xref:System.Net.Sockets.NetworkStream.EndRead%2A>métodos de comunicação.</xref:System.Net.Sockets.NetworkStream.EndRead%2A> </xref:System.Net.Sockets.NetworkStream.BeginRead%2A> </xref:System.Net.Sockets.NetworkStream.EndWrite%2A> </xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>       O NetworkStream não suporta acesso aleatório para o fluxo de dados de rede. O valor da <xref:System.Net.Sockets.NetworkStream.CanSeek%2A>propriedade, o que indica se o fluxo suporta a pesquisa, é sempre `false`; ao ler a <xref:System.Net.Sockets.NetworkStream.Position%2A>propriedade, ler a <xref:System.Net.Sockets.NetworkStream.Length%2A>propriedade, ou chamar o <xref:System.Net.Sockets.NetworkStream.Seek%2A>método irá gerar um <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.Net.Sockets.NetworkStream.Seek%2A> </xref:System.Net.Sockets.NetworkStream.Length%2A> </xref:System.Net.Sockets.NetworkStream.Position%2A> </xref:System.Net.Sockets.NetworkStream.CanSeek%2A>       Operações de leitura e escrita podem ser executadas em simultâneo numa instância da classe NetworkStream sem a necessidade de sincronização. Desde que não há um único thread para as operações de escrita e um único thread para as operações de leitura, não existirá nenhum interferências entre leitura e escrita threads e sem sincronização é necessária."
  example:
  - "The following code example demonstrates how to create a NetworkStream from a connected <xref:System.Net.Sockets.SocketType><xref:System.Net.Sockets.Socket> and perform basic synchronous blocking I/O.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/visualbasic/t-system.net.sockets.net_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/cpp/t-system.net.sockets.net_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/csharp/t-system.net.sockets.net_1.cs)]"
  syntax:
    content: 'public class NetworkStream : System.IO.Stream'
  inheritance:
  - System.IO.Stream
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)
  id: '#ctor(System.Net.Sockets.Socket)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket)
  nameWithType: NetworkStream.NetworkStream(Socket)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Cria uma nova instância do <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> classe para o <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> especificado"
  remarks: "<xref:System.Net.Sockets.NetworkStream>É criada com acesso de leitura/escrita para o <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> especificado</xref:System.Net.Sockets.NetworkStream> <xref:System.Net.Sockets.NetworkStream>Não é proprietário de subjacente <xref:System.Net.Sockets.Socket>para chamar o <xref:System.Net.Sockets.NetworkStream.Close%2A>método não feche <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example illustrates how to create a <xref:System.Net.Sockets.NetworkStream> with a <xref:System.Net.Sockets.Socket>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/visualbasic/m-system.net.sockets.net_0_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/cpp/m-system.net.sockets.net_0_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/csharp/m-system.net.sockets.net_0_1.cs)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "O <xref:System.Net.Sockets.Socket>que o <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> irá utilizar para enviar e receber dados.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "O <code> socket </code> parâmetro não está ligado.       - ou - <xref:System.Net.Sockets.Socket.SocketType*>propriedade o <code> socket </code> não é o parâmetro &lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;.</xref:System.Net.Sockets.Socket.SocketType*>       - ou - <code> socket </code> parâmetro está num Estado nonblocking."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)
  id: '#ctor(System.Net.Sockets.Socket,System.Boolean)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,Boolean)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> classe especificada para <xref:System.Net.Sockets.Socket>com especificado <xref:System.Net.Sockets.Socket>propriedade.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket>"
  remarks: "<xref:System.Net.Sockets.NetworkStream>É criada com acesso de leitura/escrita para o <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> especificado</xref:System.Net.Sockets.NetworkStream> Se o valor de `ownsSocket` parâmetro é `true`, a <xref:System.Net.Sockets.NetworkStream>são proprietários de subjacentes <xref:System.Net.Sockets.Socket>e chamar o <xref:System.Net.Sockets.NetworkStream.Close%2A>método também fecha subjacente <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example creates a <xref:System.Net.Sockets.NetworkStream> with ownership of the <xref:System.Net.Sockets.Socket>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/visualbasic/59c93a1c-9c9b-46b2-a872-_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/cpp/59c93a1c-9c9b-46b2-a872-_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/csharp/59c93a1c-9c9b-46b2-a872-_1.cs)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket, bool ownsSocket);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "O <xref:System.Net.Sockets.Socket>que o <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> irá utilizar para enviar e receber dados.</xref:System.Net.Sockets.Socket>"
    - id: ownsSocket
      type: System.Boolean
      description: "Definido como <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> para indicar que o <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> irá assumir a propriedade do <xref:System.Net.Sockets.Socket>; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "O <code> socket </code> parâmetro não está ligado.       - ou - o valor da <xref:System.Net.Sockets.Socket.SocketType*>propriedade o <code> socket </code> parâmetro não é &lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;.</xref:System.Net.Sockets.Socket.SocketType*>       - ou - <code> socket </code> parâmetro está num Estado nonblocking."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)
  id: '#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket,FileAccess)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Cria uma nova instância do <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> classe especificada para <xref:System.Net.Sockets.Socket>com os direitos de acesso especificado.</xref:System.Net.Sockets.Socket>"
  remarks: "<xref:System.Net.Sockets.NetworkStream>É criada com o acesso especificado para o <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> especificado</xref:System.Net.Sockets.NetworkStream> Com este construtor, <xref:System.Net.Sockets.NetworkStream>não possui a subjacente <xref:System.Net.Sockets.Socket>por isso, ao chamar o <xref:System.Net.Sockets.NetworkStream.Close%2A>método não feche o <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> subjacente</xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>       O `access` parâmetro define as <xref:System.Net.Sockets.NetworkStream.CanRead%2A> <xref:System.Net.Sockets.NetworkStream.CanWrite%2A>Propriedades de <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.CanWrite%2A> e</xref:System.Net.Sockets.NetworkStream.CanRead%2A> Se especificar <xref:System.IO.FileAccess>, em seguida, a <xref:System.Net.Sockets.NetworkStream>permite chamadas para o <xref:System.Net.Sockets.NetworkStream.Write%2A>método.</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> Se especificar <xref:System.IO.FileAccess>, em seguida, a <xref:System.Net.Sockets.NetworkStream>permite chamadas para o <xref:System.Net.Sockets.NetworkStream.Read%2A>método.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> Se especificar <xref:System.IO.FileAccess>, ambas as chamadas de método são permitidas.</xref:System.IO.FileAccess>"
  example:
  - "The following code example creates a <xref:System.Net.Sockets.NetworkStream> with the ability to read and write to the <xref:System.Net.Sockets.Socket>.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/visualbasic/586c6962-cd9c-4b70-aa3e-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/csharp/586c6962-cd9c-4b70-aa3e-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/cpp/586c6962-cd9c-4b70-aa3e-_1.cpp)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "O <xref:System.Net.Sockets.Socket>que o <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> irá utilizar para enviar e receber dados.</xref:System.Net.Sockets.Socket>"
    - id: access
      type: System.IO.FileAccess
      description: "Uma combinação bit a bit do <xref href=&quot;System.IO.FileAccess&quot;> </xref> valores que especificar o tipo de acesso atribuído a <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> através de <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> fornecido"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "O <code> socket </code> parâmetro não está ligado.       - ou - <xref:System.Net.Sockets.Socket.SocketType*>propriedade o <code> socket </code> não é o parâmetro &lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;.</xref:System.Net.Sockets.Socket.SocketType*>       - ou - <code> socket </code> parâmetro está num Estado nonblocking."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)
  id: '#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket,FileAccess,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Cria uma nova instância do <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> classe para especificada <xref:System.Net.Sockets.Socket>com os direitos de acesso especificado e especificada <xref:System.Net.Sockets.Socket>propriedade.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket>"
  remarks: "<xref:System.Net.Sockets.NetworkStream>É criada com acesso de leitura/escrita para o <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> especificado</xref:System.Net.Sockets.NetworkStream> Se o valor da `ownsSocket` parâmetro é `true`, a <xref:System.Net.Sockets.NetworkStream>são proprietários de subjacentes <xref:System.Net.Sockets.Socket>e chamar o <xref:System.Net.Sockets.NetworkStream.Close%2A>método também fecha subjacente <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>       O `access` parâmetro define as <xref:System.Net.Sockets.NetworkStream.CanRead%2A> <xref:System.Net.Sockets.NetworkStream.CanWrite%2A>Propriedades de <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.CanWrite%2A> e</xref:System.Net.Sockets.NetworkStream.CanRead%2A> Se especificar <xref:System.IO.FileAccess>, em seguida, a <xref:System.Net.Sockets.NetworkStream>permite chamadas para o <xref:System.Net.Sockets.NetworkStream.Write%2A>método.</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> Se especificar <xref:System.IO.FileAccess>, em seguida, a <xref:System.Net.Sockets.NetworkStream>permite chamadas para o <xref:System.Net.Sockets.NetworkStream.Read%2A>método.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> Se especificar <xref:System.IO.FileAccess>, ambas as chamadas de método são permitidas.</xref:System.IO.FileAccess>"
  example:
  - "The following code example creates a <xref:System.Net.Sockets.NetworkStream> with the ability to read and write to the <xref:System.Net.Sockets.Socket>. Ownership of the <xref:System.Net.Sockets.Socket> is given to this <xref:System.Net.Sockets.NetworkStream> by specifying `true` for the `ownsSocket` parameter.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/visualbasic/db34d484-28c0-47ef-b5ca-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/csharp/db34d484-28c0-47ef-b5ca-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/cpp/db34d484-28c0-47ef-b5ca-_1.cpp)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access, bool ownsSocket);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "O <xref:System.Net.Sockets.Socket>que o <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> irá utilizar para enviar e receber dados.</xref:System.Net.Sockets.Socket>"
    - id: access
      type: System.IO.FileAccess
      description: "Uma combinação bit a bit do <xref href=&quot;System.IO.FileAccess&quot;> </xref> valores que especifica o tipo de acesso atribuído a <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> através de <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> fornecido"
    - id: ownsSocket
      type: System.Boolean
      description: "Definido como <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> para indicar que o <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> irá assumir a propriedade do <xref:System.Net.Sockets.Socket>; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "O <code> socket </code> parâmetro não está ligado.       - ou - <xref:System.Net.Sockets.Socket.SocketType*>propriedade o <code> socket </code> não é o parâmetro &lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;.</xref:System.Net.Sockets.Socket.SocketType*>       - ou - <code> socket </code> parâmetro está num Estado nonblocking."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Começa uma leitura assíncrona a <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "O método BeginRead inicia no modo assíncrono ler dados a partir das entrada das memórias intermédias de rede. Chamar o método BeginRead dá-lhe a capacidade de receber dados dentro de um thread de execução separado.       Tem de criar um método de chamada de retorno que implementa o <xref:System.AsyncCallback>delegar e passar o respetivo nome para o método BeginRead.</xref:System.AsyncCallback> Muito mínima, no seu `state` parâmetro tem de conter <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> Porque, irá pretender obter os dados recebidos no seu método de chamada de retorno, deve criar uma classe de pequena ou a estrutura para conter uma memória intermédia de leitura e outras informações úteis. Transmitir a instância de estrutura ou classe para o método de BeginRead através de `state` parâmetro.       Deve chamar o método de chamada de retorno de <xref:System.Net.Sockets.NetworkStream.EndRead%2A>método.</xref:System.Net.Sockets.NetworkStream.EndRead%2A> Quando a aplicação chama BeginRead, o sistema aguardará recebidos dados ou ocorre um erro e, em seguida, o sistema irá utilizar o thread separado para executar o método de chamada de retorno especificado e blocos no <xref:System.Net.Sockets.NetworkStream.EndRead%2A>até fornecido <xref:System.Net.Sockets.NetworkStream>lê os dados ou emite uma exceção.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.EndRead%2A> Se pretender que o thread para bloquear depois de chamar o método BeginRead original, utilize o <xref:System.Threading.WaitHandle.WaitOne%2A>método.</xref:System.Threading.WaitHandle.WaitOne%2A> Chamar <xref:System.Threading.EventWaitHandle.Set%2A>no método de chamada de retorno quando quiser continuar a executar o thread original.</xref:System.Threading.EventWaitHandle.Set%2A> Para obter informações adicionais sobre como escrever métodos de chamada de retorno, consulte [um delegado como um método de chamada de retorno de empacotamento de referências](~/add/includes/ajax-current-ext-md.md).       O método BeginRead lê os dados que estiver disponível, até ao número de bytes especificada pelo `size` parâmetro.      > [!NOTE] > Se receber um <xref:System.IO.IOException>Verifique a <xref:System.Exception.InnerException%2A>propriedade para determinar se este foi causada por um <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> Se assim for, utilize o <xref:System.Net.Sockets.SocketException.ErrorCode%2A>propriedade para obter o código de erro específico e os Sockets do Windows versão 2 erro código documentação da API no MSDN para uma descrição detalhada do erro, consulte.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>       Ler e escrever operações podem ser executadas em simultâneo numa instância do <xref:System.Net.Sockets.NetworkStream>classe sem a necessidade de sincronização.</xref:System.Net.Sockets.NetworkStream> Desde que não há um único thread para as operações de escrita e um único thread para as operações de leitura, não existirá nenhum interferências entre leitura e escrita threads e sem sincronização é necessária."
  example:
  - "The following code example uses BeginRead to read data asynchronously from the network stream. The `myReadCallBack` method implements the <xref:System.AsyncCallback> delegate and is called by the system when BeginRead returns.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#3](~/add/codesnippet/visualbasic/b2716ae9-7520-4d87-8b97-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#3](~/add/codesnippet/csharp/b2716ae9-7520-4d87-8b97-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#3](~/add/codesnippet/cpp/b2716ae9-7520-4d87-8b97-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginRead (byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Uma matriz do tipo <xref:System.Byte>que é a localização na memória para armazenar dados lidos no <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>.</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "A localização na `buffer` para começar a armazenar os dados."
    - id: size
      type: System.Int32
      description: "O número de bytes a ler a partir de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
    - id: callback
      type: System.AsyncCallback
      description: "O <xref:System.AsyncCallback>delegado que é executado quando BeginRead estiver concluída.</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "Um objeto que contém quaisquer dados adicionais definidas pelo utilizador."
    return:
      type: System.IAsyncResult
      description: "Um <xref:System.IAsyncResult>que representa a chamada assíncrona.</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.NetworkStream.BeginRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "O <code> offset </code> parâmetro é inferior a 0.       - ou - <code> offset </code> é superior ao comprimento do parâmetro de <code> buffer </code> parâmetro dos.       - ou - <code> size </code> é inferior a 0.       - ou - <code> size </code> é superior ao comprimento da <code> buffer </code> menos o valor da <code> offset </code> parâmetro."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Subjacentes <xref:System.Net.Sockets.Socket>está fechado.</xref:System.Net.Sockets.Socket>       - ou - Ocorreu uma falha ao ler a partir da rede.       - ou - Ocorreu um erro ao aceder o socket. Consulte a secção observações para obter mais informações."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> está fechado."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Começa uma escrita assíncrona para uma transmissão em fluxo."
  remarks: "O método BeginWrite inicia uma operação de envio assíncrono para o anfitrião remoto. Chamar o método BeginWrite dá-lhe a capacidade de enviar dados dentro de um thread de execução separado.       Tem de criar um método de chamada de retorno que implementa o <xref:System.AsyncCallback>delegar e passar o respetivo nome para o método BeginWrite.</xref:System.AsyncCallback> Muito mínima, no seu `state` parâmetro tem de conter <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> Se a chamada de retorno tem de obter mais informações, pode criar uma classe de pequena ou a estrutura para conter o <xref:System.Net.Sockets.NetworkStream>e outras informações necessárias.</xref:System.Net.Sockets.NetworkStream> Transmitir a instância de estrutura ou classe para o método de BeginWrite através de `state` parâmetro.       O método de chamada de retorno deve implementar o <xref:System.Net.Sockets.NetworkStream.EndWrite%2A>método.</xref:System.Net.Sockets.NetworkStream.EndWrite%2A> Quando a aplicação chama BeginWrite, o sistema utiliza um thread separado para executar o método de chamada de retorno especificado e bloqueia no <xref:System.Net.Sockets.NetworkStream.EndWrite%2A>até o <xref:System.Net.Sockets.NetworkStream>envia o número de bytes pedido ou emite uma exceção.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.EndWrite%2A> Se pretender que o thread para bloquear depois de chamar o método BeginWrite original, utilize o <xref:System.Threading.WaitHandle.WaitOne%2A>método.</xref:System.Threading.WaitHandle.WaitOne%2A> Chamar <xref:System.Threading.EventWaitHandle.Set%2A>no método de chamada de retorno quando quiser continuar a executar o thread original.</xref:System.Threading.EventWaitHandle.Set%2A> Para obter informações adicionais sobre como escrever métodos de chamada de retorno, consulte [um delegado como um método de chamada de retorno de empacotamento de referências](~/add/includes/ajax-current-ext-md.md).      > [!NOTE] > Se receber um <xref:System.IO.IOException>Verifique a <xref:System.Exception.InnerException%2A>propriedade para determinar se este foi causada por um <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> Se assim for, utilize o <xref:System.Net.Sockets.SocketException.ErrorCode%2A>propriedade para obter o código de erro específico e os Sockets do Windows versão 2 erro código documentação da API no MSDN para uma descrição detalhada do erro, consulte.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>       Ler e escrever operações podem ser executadas em simultâneo numa instância do <xref:System.Net.Sockets.NetworkStream>classe sem a necessidade de sincronização.</xref:System.Net.Sockets.NetworkStream> Desde que não há um único thread para as operações de escrita e um único thread para as operações de leitura, não existirá nenhum interferências entre leitura e escrita threads e sem sincronização é necessária."
  example:
  - "The following code example uses BeginWrite to write data asynchronously to a network stream. The `myWriteCallBack` method implements the <xref:System.AsyncCallback> delegate and is called by the system when BeginWrite returns.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#2](~/add/codesnippet/visualbasic/d3b03755-0183-42fc-98c1-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#2](~/add/codesnippet/csharp/d3b03755-0183-42fc-98c1-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#2](~/add/codesnippet/cpp/d3b03755-0183-42fc-98c1-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginWrite (byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Uma matriz do tipo <xref:System.Byte>que contém os dados para escrever o <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>.</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "A localização na `buffer` para começar a enviar os dados."
    - id: size
      type: System.Int32
      description: "O número de bytes a escrever o <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
    - id: callback
      type: System.AsyncCallback
      description: "O <xref:System.AsyncCallback>delegado que é executado quando BeginWrite estiver concluída.</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "Um objeto que contém quaisquer dados adicionais definidas pelo utilizador."
    return:
      type: System.IAsyncResult
      description: "Um <xref:System.IAsyncResult>que representa a chamada assíncrona.</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.NetworkStream.BeginWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "O <code> offset </code> parâmetro é inferior a 0.       - ou - <code> offset </code> é superior ao comprimento do parâmetro <code> buffer </code>.       - ou - <code> size </code> parâmetro é inferior a 0.       - ou - <code> size </code> é superior ao comprimento do parâmetro <code> buffer </code> menos o valor da <code> offset </code> parâmetro."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Subjacentes <xref:System.Net.Sockets.Socket>está fechado.</xref:System.Net.Sockets.Socket>       - ou - Ocorreu uma falha ao escrever para a rede.       - ou - Ocorreu um erro ao aceder o socket. Consulte a secção observações para obter mais informações."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> está fechado."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanRead
  id: CanRead
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanRead
  nameWithType: NetworkStream.CanRead
  fullName: System.Net.Sockets.NetworkStream.CanRead
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Obtém um valor que indica se o <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> suporta leitura."
  remarks: "Se for CanRead `true`, <xref:System.Net.Sockets.NetworkStream>permite chamadas para o <xref:System.Net.Sockets.NetworkStream.Read%2A>método.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> Fornecer adequado <xref:System.IO.FileAccess>enumerar o valor no construtor para definir o facilitar a leitura e writability de <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> A propriedade CanRead é definida quando o <xref:System.Net.Sockets.NetworkStream>está inicializado.</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example checks CanRead to verify that the <xref:System.Net.Sockets.NetworkStream> is readable. It then performs a read operation on the <xref:System.Net.Sockets.NetworkStream>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/visualbasic/p-system.net.sockets.net_6_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/cpp/p-system.net.sockets.net_6_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/csharp/p-system.net.sockets.net_6_1.cs)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se os dados podem ser lidos a partir do fluxo; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. O valor predefinido é <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanSeek
  id: CanSeek
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: NetworkStream.CanSeek
  fullName: System.Net.Sockets.NetworkStream.CanSeek
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Obtém um valor que indica se o fluxo suporta pesquisa. Esta propriedade não é atualmente suportada. Esta propriedade devolve sempre <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>em todos os casos que indica que <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> não é possível procurar uma localização específica no fluxo."
  overload: System.Net.Sockets.NetworkStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanTimeout
  id: CanTimeout
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanTimeout
  nameWithType: NetworkStream.CanTimeout
  fullName: System.Net.Sockets.NetworkStream.CanTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Indica se as propriedades de limite de tempo são utilizáveis para <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "Esta propriedade está presente porque esta é herdada a partir de <xref:System.IO.Stream>.</xref:System.IO.Stream>"
  syntax:
    content: public override bool CanTimeout { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>em todos os casos."
  overload: System.Net.Sockets.NetworkStream.CanTimeout*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanWrite
  id: CanWrite
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: NetworkStream.CanWrite
  fullName: System.Net.Sockets.NetworkStream.CanWrite
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Obtém um valor que indica se o <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> suporta escrita."
  remarks: "Se for CanWrite `true`, <xref:System.Net.Sockets.NetworkStream>permite chamadas para o <xref:System.Net.Sockets.NetworkStream.Write%2A>método.</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> Fornecer adequado <xref:System.IO.FileAccess>enumerar o valor no construtor para definir o facilitar a leitura e writability de <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> A propriedade CanWrite é definida quando o <xref:System.Net.Sockets.NetworkStream>está inicializado.</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example checks CanWrite to verify that the <xref:System.Net.Sockets.NetworkStream> is writable. It then performs a write operation on the <xref:System.Net.Sockets.NetworkStream>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/visualbasic/p-system.net.sockets.net_0_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/cpp/p-system.net.sockets.net_0_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/csharp/p-system.net.sockets.net_0_1.cs)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se os dados podem ser escritos para o <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. O valor predefinido é <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Close(System.Int32)
  id: Close(System.Int32)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Close(Int32)
  nameWithType: NetworkStream.Close(Int32)
  fullName: System.Net.Sockets.NetworkStream.Close(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Fecha o <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> após uma espera de tempo especificado para permitir que os dados a serem enviados."
  remarks: "O método Fechar liberta os recursos de não geridos e geridos associados <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> Se o <xref:System.Net.Sockets.NetworkStream>proprietária subjacentes <xref:System.Net.Sockets.Socket>, está fechado, bem como.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>       Se um <xref:System.Net.Sockets.NetworkStream>foi associado um <xref:System.Net.Sockets.TcpClient>o método Fechar irá fechar a ligação de TCP, mas não elimine o <xref:System.Net.Sockets.TcpClient>.</xref:System.Net.Sockets.TcpClient> associados</xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.NetworkStream>"
  syntax:
    content: public void Close (int timeout);
    parameters:
    - id: timeout
      type: System.Int32
      description: "Um 32 bits com sinal número inteiro que especifica o número de milissegundos a aguardar para enviar quaisquer dados restantes antes de fechar."
  overload: System.Net.Sockets.NetworkStream.Close*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "O <code> timeout </code> parâmetro é inferior a -1."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.DataAvailable
  id: DataAvailable
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: DataAvailable
  nameWithType: NetworkStream.DataAvailable
  fullName: System.Net.Sockets.NetworkStream.DataAvailable
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Obtém um valor que indica se os dados estão disponíveis no <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> a ser lido."
  remarks: "Utilize a propriedade DataAvailable para determinar se os dados estão prontos a ser lido. Se for DataAvailable `true`, uma chamada para <xref:System.Net.Sockets.NetworkStream.Read%2A>devolve imediatamente.</xref:System.Net.Sockets.NetworkStream.Read%2A> Se o anfitrião remoto encerra ou fecha a ligação, DataAvailable pode acionar um <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException>"
  example:
  - "The following code example reads from the <xref:System.Net.Sockets.NetworkStream> as long as data is available.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/visualbasic/p-system.net.sockets.net_2_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/cpp/p-system.net.sockets.net_2_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/csharp/p-system.net.sockets.net_2_1.cs)]"
  syntax:
    content: public virtual bool DataAvailable { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se os dados estão disponíveis no fluxo de leitura; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.DataAvailable*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> está fechado."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Subjacentes <xref:System.Net.Sockets.Socket>está fechado.</xref:System.Net.Sockets.Socket>"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "Utilize o &lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt; propriedade para obter o código de erro específico e os Sockets do Windows versão 2 erro código documentação da API no MSDN para uma descrição detalhada do erro, consulte."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: NetworkStream.Dispose(Boolean)
  fullName: System.Net.Sockets.NetworkStream.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Liberta os recursos não geridos utilizados pelo <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> e opcionalmente liberta os recursos geridos."
  remarks: "Este método é denominado pelo público `Dispose` método e o <xref:System.Object.Finalize%2A>método.</xref:System.Object.Finalize%2A> `Dispose`invoca protegida `Dispose(Boolean)` método com o `disposing` parâmetro definido como `true`. <xref:System.Object.Finalize%2A>invoca `Dispose` com `disposing` definido como `false`.</xref:System.Object.Finalize%2A>       Quando o `disposing` parâmetro é `true`, este método versões retidos por quaisquer objetos geridos de todos os recursos que este <xref:System.Net.Sockets.NetworkStream>referências.</xref:System.Net.Sockets.NetworkStream> Este método invoca o `Dispose` método de cada objeto referenciado."
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Para libertar recursos geridos e; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para libertar recursos apenas não geridos."
  overload: System.Net.Sockets.NetworkStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)
  id: EndRead(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: EndRead(IAsyncResult)
  nameWithType: NetworkStream.EndRead(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndRead(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Processa o fim da leitura assíncrona."
  remarks: "O método EndRead conclui a operação de leitura assíncrona foi iniciada no <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>método.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A>       Antes de chamar <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>, terá de criar um método de chamada de retorno que implementa o <xref:System.AsyncCallback>Delegar.</xref:System.AsyncCallback> </xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Este método de chamada de retorno executa num thread separado e é chamado pelo sistema após <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>devolve.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> O método de chamada de retorno tem de aceitar o <xref:System.IAsyncResult>devolveu o <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>método como parâmetro.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> </xref:System.IAsyncResult>       Dentro do método de chamada de retorno, chame o <xref:System.IAsyncResult.AsyncState%2A>propriedade o <xref:System.IAsyncResult>para obter o objeto de estado transmitido para o <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>método.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> </xref:System.IAsyncResult> </xref:System.IAsyncResult.AsyncState%2A> Extrair a receção <xref:System.Net.Sockets.NetworkStream>deste objeto de estado.</xref:System.Net.Sockets.NetworkStream> Depois de obter o <xref:System.Net.Sockets.NetworkStream>, chame o método EndRead para concluir a operação de leitura e devolver o número de bytes lidos com êxito.</xref:System.Net.Sockets.NetworkStream>       Os blocos de método EndRead, até que os dados estão disponíveis. O método EndRead lê como a quantidade de dados que está disponível até ao número de bytes especificada no `size` parâmetro o <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>método.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Se o anfitrião remoto encerra o <xref:System.Net.Sockets.Socket>foi recebida ligação e todos os dados disponíveis, o método EndRead conclui imediatamente e devolve zero bytes.</xref:System.Net.Sockets.Socket>       Para obter os dados recebidos, chame o <xref:System.IAsyncResult.AsyncState%2A>propriedade o <xref:System.IAsyncResult>e extrair a memória intermédia contida no objeto de estado resultante.</xref:System.IAsyncResult> </xref:System.IAsyncResult.AsyncState%2A>      > [!NOTE] > Se receber um <xref:System.IO.IOException>Verifique a <xref:System.Exception.InnerException%2A>propriedade para determinar se este foi causada por um <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> Se assim for, utilize o <xref:System.Net.Sockets.SocketException.ErrorCode%2A>propriedade para obter o código de erro específico e os Sockets do Windows versão 2 erro código documentação da API no MSDN para uma descrição detalhada do erro, consulte.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>"
  example:
  - "In the following code example, `myReadCallback` is provided to <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> as the callback method. EndRead is implemented in `myReadCallback` to complete the asynchronous read call started by <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#5](~/add/codesnippet/visualbasic/m-system.net.sockets.net_2_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#5](~/add/codesnippet/csharp/m-system.net.sockets.net_2_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#5](~/add/codesnippet/cpp/m-system.net.sockets.net_2_1.cpp)]"
  syntax:
    content: public override int EndRead (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "Um <xref:System.IAsyncResult>que representa uma chamada assíncrona.</xref:System.IAsyncResult>"
    return:
      type: System.Int32
      description: "O número de bytes foi lida a <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.EndRead*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>asyncResult</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Subjacentes <xref:System.Net.Sockets.Socket>está fechado.</xref:System.Net.Sockets.Socket>       - ou - Ocorreu um erro ao aceder o socket. Consulte a secção observações para obter mais informações."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> está fechado."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)
  id: EndWrite(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: EndWrite(IAsyncResult)
  nameWithType: NetworkStream.EndWrite(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndWrite(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Processa o fim de uma escrita assíncrona."
  remarks: "EndWrite conclui a operação de envio assíncrono iniciada no <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>.</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>       Antes de chamar <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>, terá de criar um método de chamada de retorno que implementa o <xref:System.AsyncCallback>Delegar.</xref:System.AsyncCallback> </xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> Este método de chamada de retorno executa num thread separado e é chamado pelo sistema após <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>devolve.</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> O método de chamada de retorno tem de aceitar o <xref:System.IAsyncResult>devolveu o <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>método como parâmetro.</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> </xref:System.IAsyncResult>       Dentro do método de chamada de retorno, chame o <xref:System.IAsyncResult.AsyncState%2A>propriedade o `IAsyncResult` parâmetro obter <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> </xref:System.IAsyncResult.AsyncState%2A> Depois de obter o <xref:System.Net.Sockets.NetworkStream>, pode chamar o método EndWrite para concluir a operação de envio e devolver o número de bytes enviados com êxito.</xref:System.Net.Sockets.NetworkStream>       Os blocos de método EndWrite até que o número pedido de bytes são enviados.      > [!NOTE] > Se receber um <xref:System.IO.IOException>Verifique a <xref:System.Exception.InnerException%2A>propriedade para determinar se este foi causada por um <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> Se assim for, utilize o <xref:System.Net.Sockets.SocketException.ErrorCode%2A>propriedade para obter o código de erro específico e os Sockets do Windows versão 2 erro código documentação da API no MSDN para uma descrição detalhada do erro, consulte.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>"
  example:
  - "In the following code example, `myWriteCallback` is provided to <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> as the callback method. EndWrite is implemented in `myWriteCallback` to complete the asynchronous write call started by <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#4](~/add/codesnippet/visualbasic/m-system.net.sockets.net_3_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#4](~/add/codesnippet/csharp/m-system.net.sockets.net_3_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#4](~/add/codesnippet/cpp/m-system.net.sockets.net_3_1.cpp)]"
  syntax:
    content: public override void EndWrite (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "O <xref:System.IAsyncResult>que representa a chamada assíncrona.</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.NetworkStream.EndWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>asyncResult</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Subjacentes <xref:System.Net.Sockets.Socket>está fechado.</xref:System.Net.Sockets.Socket>       - ou - Ocorreu um erro ao escrever para a rede.       - ou - Ocorreu um erro ao aceder o socket. Consulte a secção observações para obter mais informações."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> está fechado."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Finalize
  id: Finalize
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Finalize()
  nameWithType: NetworkStream.Finalize()
  fullName: System.Net.Sockets.NetworkStream.Finalize()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Versões de todos os recursos utilizados pelo <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "Este método substitui <xref:System.Object.Finalize%2A?displayProperty=fullName>.</xref:System.Object.Finalize%2A?displayProperty=fullName> Código da aplicação não deve chamar este método; um objeto <xref:System.Object.Finalize%2A>método é invocado automaticamente durante a recolha de lixo, a menos que Finalização pelo garbage collector foi desativada por uma chamada para o <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName>método.</xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> </xref:System.Object.Finalize%2A>       Para obter mais informações sobre como utilizar o método Finalize, consulte [finalizar métodos e os processos de destruição](http://msdn.microsoft.com/en-us/fd376774-1643-499b-869e-9546a3aeea70), [recursos não geridos limpeza](~/add/includes/ajax-current-ext-md.md), e [a substituir o método Finalize](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)."
  syntax:
    content: ~NetworkStream ();
    parameters: []
  overload: System.Net.Sockets.NetworkStream.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Flush
  id: Flush
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Flush()
  nameWithType: NetworkStream.Flush()
  fullName: System.Net.Sockets.NetworkStream.Flush()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Esvaziamentos da dados da sequência. Este método está reservado para utilização futura."
  remarks: "O método de esvaziamento implementa o <xref:System.IO.Stream.Flush%2A?displayProperty=fullName>método; no entanto, porque <xref:System.Net.Sockets.NetworkStream>não é colocado na memória intermédia, não terá qualquer efeito em fluxos de rede.</xref:System.Net.Sockets.NetworkStream> </xref:System.IO.Stream.Flush%2A?displayProperty=fullName> Chamar o método de remoção não acionar uma excepção."
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.Net.Sockets.NetworkStream.Flush*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)
  id: FlushAsync(System.Threading.CancellationToken)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: FlushAsync(CancellationToken)
  nameWithType: NetworkStream.FlushAsync(CancellationToken)
  fullName: System.Net.Sockets.NetworkStream.FlushAsync(CancellationToken)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Esvaziamentos da dados da sequência como uma operação assíncrona."
  remarks: "Não irá impedir que esta operação. O devolvido <xref:System.Threading.Tasks.Task>objeto será concluída após tem foram descarregados dados da sequência para o <xref:System.Net.Sockets.NetworkStream>instância.</xref:System.Net.Sockets.NetworkStream> </xref:System.Threading.Tasks.Task>"
  syntax:
    content: public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Um token de cancelamento utilizado para propagar a notificação que esta operação deve ser cancelada."
    return:
      type: System.Threading.Tasks.Task
      description: "Devolve <xref:System.Threading.Tasks.Task>.</xref:System.Threading.Tasks.Task>       O objeto de tarefa que representa a operação assíncrona."
  overload: System.Net.Sockets.NetworkStream.FlushAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Length
  id: Length
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Length
  nameWithType: NetworkStream.Length
  fullName: System.Net.Sockets.NetworkStream.Length
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Obtém o comprimento dos dados disponíveis no fluxo. Esta propriedade não é atualmente suportada e sempre emite <xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "O comprimento dos dados disponíveis no fluxo."
  overload: System.Net.Sockets.NetworkStream.Length*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Qualquer utilização desta propriedade."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Position
  id: Position
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Position
  nameWithType: NetworkStream.Position
  fullName: System.Net.Sockets.NetworkStream.Position
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Obtém ou define a posição atual no fluxo. Esta propriedade não é atualmente suportada e sempre emite <xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "A posição atual no fluxo."
  overload: System.Net.Sockets.NetworkStream.Position*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Qualquer utilização desta propriedade."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Read(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Lê dados do <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "Este método lê os dados para o `buffer` parâmetro e devolve o número de bytes lido com êxito. Se não estão disponíveis dados de leitura, o método de leitura devolve 0. A operação de leitura lê os dados que estiver disponível, até ao número de bytes especificada pelo `size` parâmetro. Se o anfitrião remoto encerra a ligação e foi recebida todos os dados disponíveis, o método Read realiza imediatamente e devolver zero bytes.      > [!NOTE] > Verifique se o <xref:System.Net.Sockets.NetworkStream>é legível ao chamar o <xref:System.Net.Sockets.NetworkStream.CanRead%2A>propriedade.</xref:System.Net.Sockets.NetworkStream.CanRead%2A> </xref:System.Net.Sockets.NetworkStream> Se tentar ler a partir de um <xref:System.Net.Sockets.NetworkStream>que é não legível, obterá um <xref:System.IO.IOException>.</xref:System.IO.IOException> </xref:System.Net.Sockets.NetworkStream>      > [!NOTE] > Se receber um <xref:System.IO.IOException>Verifique a <xref:System.Exception.InnerException%2A>propriedade para determinar se este foi causada por um <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> Se assim for, utilize o <xref:System.Net.Sockets.SocketException.ErrorCode%2A>propriedade para obter o código de erro específico e os Sockets do Windows versão 2 erro código documentação da API no MSDN para uma descrição detalhada do erro, consulte.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>"
  example:
  - "The following code example uses <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> to determine if data is available to be read. If data is available, it reads from the <xref:System.Net.Sockets.NetworkStream>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/visualbasic/m-system.net.sockets.net_1_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/cpp/m-system.net.sockets.net_1_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/csharp/m-system.net.sockets.net_1_1.cs)]"
  syntax:
    content: public override int Read (byte[] buffer, int offset, int size);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Uma matriz do tipo <xref:System.Byte>que é a localização na memória para armazenar dados lidos no <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>.</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "A localização na `buffer` para começar a armazenar os dados."
    - id: size
      type: System.Int32
      description: "O número de bytes a ler a partir de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
    return:
      type: System.Int32
      description: "O número de bytes foi lida a <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.Read*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "O <code> offset </code> parâmetro é inferior a 0.       - ou - <code> offset </code> é superior ao comprimento do parâmetro <code> buffer </code>.       - ou - <code> size </code> parâmetro é inferior a 0.       - ou - <code> size </code> é superior ao comprimento do parâmetro <code> buffer </code> menos o valor da <code> offset </code> parâmetro.       - ou - Ocorreu um erro ao aceder o socket. Consulte a secção observações para obter mais informações."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Subjacentes <xref:System.Net.Sockets.Socket>está fechado.</xref:System.Net.Sockets.Socket>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> está fechado.       - ou - não existe uma falha ao ler a partir da rede."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Readable
  id: Readable
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Readable
  nameWithType: NetworkStream.Readable
  fullName: System.Net.Sockets.NetworkStream.Readable
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Obtém ou define um valor que indica se o <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> podem ser lidos."
  remarks: "Tem de derivar do <xref:System.Net.Sockets.NetworkStream>classe para utilizar a propriedade legível.</xref:System.Net.Sockets.NetworkStream> Se for Readable `true`, <xref:System.Net.Sockets.NetworkStream>permite chamadas para o <xref:System.Net.Sockets.NetworkStream.Read%2A>método.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> Também pode determinar se um <xref:System.Net.Sockets.NetworkStream>é legível verificando acessível publicamente <xref:System.Net.Sockets.NetworkStream.CanRead%2A>propriedade.</xref:System.Net.Sockets.NetworkStream.CanRead%2A> </xref:System.Net.Sockets.NetworkStream>       A propriedade legível é definida quando o <xref:System.Net.Sockets.NetworkStream>está inicializado.</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "In the following code example, the `CanCommunicate` property checks the Readable property to determine if the <xref:System.Net.Sockets.NetworkStream> is readable.  \n  \n [!code-cpp[NetworkStream_Protected_Members#1](~/add/codesnippet/cpp/p-system.net.sockets.net_7_1.cpp)]\n [!code-cs[NetworkStream_Protected_Members#1](~/add/codesnippet/csharp/p-system.net.sockets.net_7_1.cs)]\n [!code-vb[NetworkStream_Protected_Members#1](~/add/codesnippet/visualbasic/p-system.net.sockets.net_7_1.vb)]"
  syntax:
    content: protected bool Readable { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>para indicar que o <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> pode ser de leitura; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. O valor predefinido é <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.Readable*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.ReadTimeout
  id: ReadTimeout
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: ReadTimeout
  nameWithType: NetworkStream.ReadTimeout
  fullName: System.Net.Sockets.NetworkStream.ReadTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Obtém ou define a quantidade de tempo que um blocos de operação de leitura à espera de dados."
  remarks: "Se a operação de leitura não for concluída no tempo especificado por esta propriedade, a operação de leitura, emitir uma <xref:System.IO.IOException>.</xref:System.IO.IOException>      > [!NOTE] > Esta propriedade afeta apenas síncronas leituras realizadas por chamar a <xref:System.Net.Sockets.NetworkStream.Read%2A>método.</xref:System.Net.Sockets.NetworkStream.Read%2A> Esta propriedade não afeta assíncronas leituras realizadas por chamar a <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>método.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A>"
  example:
  - "The following code example sets the read time-out for a network stream to 10 milliseconds.  \n  \n [!code-cs[NCLTcpClientSync#2](~/add/codesnippet/csharp/p-system.net.sockets.net_4_1.cs)]"
  syntax:
    content: public override int ReadTimeout { get; set; }
    return:
      type: System.Int32
      description: "A <xref:System.Int32>que especifica o período de tempo, em milissegundos, que irão decorrer antes de falha de uma operação de leitura.</xref:System.Int32> O valor predefinido, <xref:System.Threading.Timeout.Infinite>, especifica que a operação de leitura faz não o tempo limite.</xref:System.Threading.Timeout.Infinite>"
  overload: System.Net.Sockets.NetworkStream.ReadTimeout*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "O valor especificado é menor ou igual a zero e não é <xref:System.Threading.Timeout.Infinite>.</xref:System.Threading.Timeout.Infinite>"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: NetworkStream.Seek(Int64,SeekOrigin)
  fullName: System.Net.Sockets.NetworkStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Define a posição actual da transmissão em fluxo para o valor indicado. Este método não é atualmente suportado e sempre emite <xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin origin);
    parameters:
    - id: offset
      type: System.Int64
      description: "Este parâmetro não é utilizado."
    - id: origin
      type: System.IO.SeekOrigin
      description: "Este parâmetro não é utilizado."
    return:
      type: System.Int64
      description: "A posição na sequência."
  overload: System.Net.Sockets.NetworkStream.Seek*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Qualquer utilização desta propriedade."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: NetworkStream.SetLength(Int64)
  fullName: System.Net.Sockets.NetworkStream.SetLength(Int64)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Define o comprimento da sequência. Este método sempre emite <xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "Este parâmetro não é utilizado."
  overload: System.Net.Sockets.NetworkStream.SetLength*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Qualquer utilização desta propriedade."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Socket
  id: Socket
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Socket
  nameWithType: NetworkStream.Socket
  fullName: System.Net.Sockets.NetworkStream.Socket
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Obtém o <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> subjacente"
  remarks: "Classes derivadas de <xref:System.Net.Sockets.NetworkStream>pode utilizar esta propriedade para obter o <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> subjacente</xref:System.Net.Sockets.NetworkStream> Utilize o subjacente <xref:System.Net.Sockets.Socket>devolveu a propriedade de Socket se necessitar de acesso para além disso que <xref:System.Net.Sockets.NetworkStream>fornece.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.Socket>      > [!NOTE] > Esta propriedade é acessível apenas através de uma classe derivada ou esta classe."
  example:
  - "The following code example retrieves the underlying <xref:System.Net.Sockets.Socket> to verify an active connection.  \n  \n [!code-cpp[NetworkStream_Protected_Members#1](~/add/codesnippet/cpp/p-system.net.sockets.net_3_1.cpp)]\n [!code-cs[NetworkStream_Protected_Members#1](~/add/codesnippet/csharp/p-system.net.sockets.net_3_1.cs)]\n [!code-vb[NetworkStream_Protected_Members#1](~/add/codesnippet/visualbasic/p-system.net.sockets.net_3_1.vb)]"
  syntax:
    content: protected System.Net.Sockets.Socket Socket { get; }
    return:
      type: System.Net.Sockets.Socket
      description: "A <xref:System.Net.Sockets.Socket>que representa a ligação de rede subjacente.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.Socket*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Write(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Escreve dados para o <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "O método de escrita inicia a determinada `offset` e envia `size` bytes o conteúdo de `buffer` à rede. O método de escrita bloqueia até que o número de bytes pedido é enviado ou uma <xref:System.Net.Sockets.SocketException>é emitida.</xref:System.Net.Sockets.SocketException> Se receber um <xref:System.Net.Sockets.SocketException>, utilize o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>propriedade para obter o código de erro específico e os Sockets do Windows versão 2 erro código documentação da API no MSDN para uma descrição detalhada do erro, consulte.</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException>      > [!NOTE] > Verifique se o <xref:System.Net.Sockets.NetworkStream>é gravável acedendo a <xref:System.Net.Sockets.NetworkStream.CanWrite%2A>propriedade.</xref:System.Net.Sockets.NetworkStream.CanWrite%2A> </xref:System.Net.Sockets.NetworkStream> Se tentar escrever a <xref:System.Net.Sockets.NetworkStream>que é não gravável, obterá um <xref:System.IO.IOException>.</xref:System.IO.IOException> </xref:System.Net.Sockets.NetworkStream> Se receber um <xref:System.IO.IOException>Verifique a <xref:System.Exception.InnerException%2A>propriedade para determinar se este foi causada por um <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException>"
  example:
  - "The following code example checks to see whether the <xref:System.Net.Sockets.NetworkStream> is writable. If it is, then Write is used to write a small message.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/visualbasic/87c395a5-03ea-4324-8b05-_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/cpp/87c395a5-03ea-4324-8b05-_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/csharp/87c395a5-03ea-4324-8b05-_1.cs)]"
  syntax:
    content: public override void Write (byte[] buffer, int offset, int size);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Uma matriz do tipo <xref:System.Byte>que contém os dados para escrever o <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>.</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "A localização na `buffer` do qual pretende iniciar a escrita de dados."
    - id: size
      type: System.Int32
      description: "O número de bytes a escrever o <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.Write*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "O <code> offset </code> parâmetro é inferior a 0.       - ou - <code> offset </code> é superior ao comprimento do parâmetro <code> buffer </code>.       - ou - <code> size </code> parâmetro é inferior a 0.       - ou - <code> size </code> é superior ao comprimento do parâmetro <code> buffer </code> menos o valor da <code> offset </code> parâmetro."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu uma falha ao escrever para a rede.       - ou - Ocorreu um erro ao aceder o socket. Consulte a secção observações para obter mais informações."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> está fechado.       - ou - Ocorreu uma falha ao ler a partir da rede."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Writeable
  id: Writeable
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Writeable
  nameWithType: NetworkStream.Writeable
  fullName: System.Net.Sockets.NetworkStream.Writeable
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Obtém um valor que indica se o <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> é gravável."
  remarks: "Tem de derivar do <xref:System.Net.Sockets.NetworkStream>classe para utilizar a propriedade Writeable.</xref:System.Net.Sockets.NetworkStream> Se for Writeable `true`, <xref:System.Net.Sockets.NetworkStream>permite chamadas para o <xref:System.Net.Sockets.NetworkStream.Write%2A>método.</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> Também pode determinar se um <xref:System.Net.Sockets.NetworkStream>é gravável verificando acessível publicamente <xref:System.Net.Sockets.NetworkStream.CanWrite%2A>propriedade.</xref:System.Net.Sockets.NetworkStream.CanWrite%2A> </xref:System.Net.Sockets.NetworkStream>       A propriedade Writeable é definida quando o <xref:System.Net.Sockets.NetworkStream>está inicializado.</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "In the following code example, the `CanCommunicate` property checks the Writeable property to determine if the <xref:System.Net.Sockets.NetworkStream> is writable.  \n  \n [!code-cpp[NetworkStream_Protected_Members#1](~/add/codesnippet/cpp/p-system.net.sockets.net_5_1.cpp)]\n [!code-cs[NetworkStream_Protected_Members#1](~/add/codesnippet/csharp/p-system.net.sockets.net_5_1.cs)]\n [!code-vb[NetworkStream_Protected_Members#1](~/add/codesnippet/visualbasic/p-system.net.sockets.net_5_1.vb)]"
  syntax:
    content: protected bool Writeable { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se os dados podem ser escritos no fluxo; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. O valor predefinido é <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.Writeable*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.WriteTimeout
  id: WriteTimeout
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: WriteTimeout
  nameWithType: NetworkStream.WriteTimeout
  fullName: System.Net.Sockets.NetworkStream.WriteTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Obtém ou define a quantidade de tempo que um blocos de operação de escrita à espera de dados."
  remarks: "Se a operação de escrita não for concluída no tempo especificado por esta propriedade, a operação de escrita emite <xref:System.IO.IOException>.</xref:System.IO.IOException>      > [!NOTE] > Esta propriedade afeta as operações de escrita síncrona apenas efetuadas ao chamar o <xref:System.Net.Sockets.NetworkStream.Write%2A>método.</xref:System.Net.Sockets.NetworkStream.Write%2A> Esta propriedade não afeta as escritas assíncronas efetuadas ao chamar o <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>método.</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>"
  example:
  - "The following code example sets the write time-out for a network stream to 10 milliseconds.  \n  \n [!code-cpp[NCLTcpServerSync#0](~/add/codesnippet/cpp/p-system.net.sockets.net_1_1.cpp)]\n [!code-cs[NCLTcpServerSync#0](~/add/codesnippet/csharp/p-system.net.sockets.net_1_1.cs)]"
  syntax:
    content: public override int WriteTimeout { get; set; }
    return:
      type: System.Int32
      description: "A <xref:System.Int32>que especifica o período de tempo, em milissegundos, que irão decorrer antes de falha de uma operação de escrita.</xref:System.Int32> O valor predefinido, <xref:System.Threading.Timeout.Infinite>, especifica que a operação de escrita faz não o tempo limite.</xref:System.Threading.Timeout.Infinite>"
  overload: System.Net.Sockets.NetworkStream.WriteTimeout*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "O valor especificado é menor ou igual a zero e não é <xref:System.Threading.Timeout.Infinite>.</xref:System.Threading.Timeout.Infinite>"
  platform:
  - net462
references:
- uid: System.IO.Stream
  isExternal: false
  name: System.IO.Stream
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.Net.Sockets.SocketException
  isExternal: true
  name: System.Net.Sockets.SocketException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket)
  nameWithType: NetworkStream.NetworkStream(Socket)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket)
- uid: System.Net.Sockets.Socket
  parent: System.Net.Sockets
  isExternal: true
  name: Socket
  nameWithType: Socket
  fullName: System.Net.Sockets.Socket
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket,FileAccess)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket,FileAccess,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
- uid: System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.Net.Sockets.NetworkStream.CanRead
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanRead
  nameWithType: NetworkStream.CanRead
  fullName: System.Net.Sockets.NetworkStream.CanRead
- uid: System.Net.Sockets.NetworkStream.CanSeek
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanSeek
  nameWithType: NetworkStream.CanSeek
  fullName: System.Net.Sockets.NetworkStream.CanSeek
- uid: System.Net.Sockets.NetworkStream.CanTimeout
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanTimeout
  nameWithType: NetworkStream.CanTimeout
  fullName: System.Net.Sockets.NetworkStream.CanTimeout
- uid: System.Net.Sockets.NetworkStream.CanWrite
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanWrite
  nameWithType: NetworkStream.CanWrite
  fullName: System.Net.Sockets.NetworkStream.CanWrite
- uid: System.Net.Sockets.NetworkStream.Close(System.Int32)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Close(Int32)
  nameWithType: NetworkStream.Close(Int32)
  fullName: System.Net.Sockets.NetworkStream.Close(Int32)
- uid: System.Net.Sockets.NetworkStream.DataAvailable
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: DataAvailable
  nameWithType: NetworkStream.DataAvailable
  fullName: System.Net.Sockets.NetworkStream.DataAvailable
- uid: System.Net.Sockets.NetworkStream.Dispose(System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: NetworkStream.Dispose(Boolean)
  fullName: System.Net.Sockets.NetworkStream.Dispose(Boolean)
- uid: System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndRead(IAsyncResult)
  nameWithType: NetworkStream.EndRead(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndRead(IAsyncResult)
- uid: System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndWrite(IAsyncResult)
  nameWithType: NetworkStream.EndWrite(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndWrite(IAsyncResult)
- uid: System.Net.Sockets.NetworkStream.Finalize
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Finalize()
  nameWithType: NetworkStream.Finalize()
  fullName: System.Net.Sockets.NetworkStream.Finalize()
- uid: System.Net.Sockets.NetworkStream.Flush
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Flush()
  nameWithType: NetworkStream.Flush()
  fullName: System.Net.Sockets.NetworkStream.Flush()
- uid: System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: FlushAsync(CancellationToken)
  nameWithType: NetworkStream.FlushAsync(CancellationToken)
  fullName: System.Net.Sockets.NetworkStream.FlushAsync(CancellationToken)
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.Net.Sockets.NetworkStream.Length
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Length
  nameWithType: NetworkStream.Length
  fullName: System.Net.Sockets.NetworkStream.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Net.Sockets.NetworkStream.Position
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Position
  nameWithType: NetworkStream.Position
  fullName: System.Net.Sockets.NetworkStream.Position
- uid: System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Read(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Read(Byte[],Int32,Int32)
- uid: System.Net.Sockets.NetworkStream.Readable
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Readable
  nameWithType: NetworkStream.Readable
  fullName: System.Net.Sockets.NetworkStream.Readable
- uid: System.Net.Sockets.NetworkStream.ReadTimeout
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: ReadTimeout
  nameWithType: NetworkStream.ReadTimeout
  fullName: System.Net.Sockets.NetworkStream.ReadTimeout
- uid: System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: NetworkStream.Seek(Int64,SeekOrigin)
  fullName: System.Net.Sockets.NetworkStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.Net.Sockets.NetworkStream.SetLength(System.Int64)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: NetworkStream.SetLength(Int64)
  fullName: System.Net.Sockets.NetworkStream.SetLength(Int64)
- uid: System.Net.Sockets.NetworkStream.Socket
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Socket
  nameWithType: NetworkStream.Socket
  fullName: System.Net.Sockets.NetworkStream.Socket
- uid: System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Write(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Write(Byte[],Int32,Int32)
- uid: System.Net.Sockets.NetworkStream.Writeable
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Writeable
  nameWithType: NetworkStream.Writeable
  fullName: System.Net.Sockets.NetworkStream.Writeable
- uid: System.Net.Sockets.NetworkStream.WriteTimeout
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: WriteTimeout
  nameWithType: NetworkStream.WriteTimeout
  fullName: System.Net.Sockets.NetworkStream.WriteTimeout
- uid: System.Net.Sockets.NetworkStream.#ctor*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream
  nameWithType: NetworkStream.NetworkStream
- uid: System.Net.Sockets.NetworkStream.BeginRead*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginRead
  nameWithType: NetworkStream.BeginRead
- uid: System.Net.Sockets.NetworkStream.BeginWrite*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginWrite
  nameWithType: NetworkStream.BeginWrite
- uid: System.Net.Sockets.NetworkStream.CanRead*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanRead
  nameWithType: NetworkStream.CanRead
- uid: System.Net.Sockets.NetworkStream.CanSeek*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanSeek
  nameWithType: NetworkStream.CanSeek
- uid: System.Net.Sockets.NetworkStream.CanTimeout*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanTimeout
  nameWithType: NetworkStream.CanTimeout
- uid: System.Net.Sockets.NetworkStream.CanWrite*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanWrite
  nameWithType: NetworkStream.CanWrite
- uid: System.Net.Sockets.NetworkStream.Close*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Close
  nameWithType: NetworkStream.Close
- uid: System.Net.Sockets.NetworkStream.DataAvailable*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: DataAvailable
  nameWithType: NetworkStream.DataAvailable
- uid: System.Net.Sockets.NetworkStream.Dispose*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Dispose
  nameWithType: NetworkStream.Dispose
- uid: System.Net.Sockets.NetworkStream.EndRead*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndRead
  nameWithType: NetworkStream.EndRead
- uid: System.Net.Sockets.NetworkStream.EndWrite*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndWrite
  nameWithType: NetworkStream.EndWrite
- uid: System.Net.Sockets.NetworkStream.Finalize*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Finalize
  nameWithType: NetworkStream.Finalize
- uid: System.Net.Sockets.NetworkStream.Flush*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Flush
  nameWithType: NetworkStream.Flush
- uid: System.Net.Sockets.NetworkStream.FlushAsync*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: FlushAsync
  nameWithType: NetworkStream.FlushAsync
- uid: System.Net.Sockets.NetworkStream.Length*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Length
  nameWithType: NetworkStream.Length
- uid: System.Net.Sockets.NetworkStream.Position*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Position
  nameWithType: NetworkStream.Position
- uid: System.Net.Sockets.NetworkStream.Read*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Read
  nameWithType: NetworkStream.Read
- uid: System.Net.Sockets.NetworkStream.Readable*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Readable
  nameWithType: NetworkStream.Readable
- uid: System.Net.Sockets.NetworkStream.ReadTimeout*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: ReadTimeout
  nameWithType: NetworkStream.ReadTimeout
- uid: System.Net.Sockets.NetworkStream.Seek*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Seek
  nameWithType: NetworkStream.Seek
- uid: System.Net.Sockets.NetworkStream.SetLength*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: SetLength
  nameWithType: NetworkStream.SetLength
- uid: System.Net.Sockets.NetworkStream.Socket*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Socket
  nameWithType: NetworkStream.Socket
- uid: System.Net.Sockets.NetworkStream.Write*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Write
  nameWithType: NetworkStream.Write
- uid: System.Net.Sockets.NetworkStream.Writeable*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Writeable
  nameWithType: NetworkStream.Writeable
- uid: System.Net.Sockets.NetworkStream.WriteTimeout*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: WriteTimeout
  nameWithType: NetworkStream.WriteTimeout
