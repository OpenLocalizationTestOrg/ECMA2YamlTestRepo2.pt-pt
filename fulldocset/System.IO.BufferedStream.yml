### YamlMime:ManagedReference
items:
- uid: System.IO.BufferedStream
  id: BufferedStream
  children:
  - System.IO.BufferedStream.#ctor(System.IO.Stream)
  - System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)
  - System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.BufferedStream.CanRead
  - System.IO.BufferedStream.CanSeek
  - System.IO.BufferedStream.CanWrite
  - System.IO.BufferedStream.Dispose(System.Boolean)
  - System.IO.BufferedStream.EndRead(System.IAsyncResult)
  - System.IO.BufferedStream.EndWrite(System.IAsyncResult)
  - System.IO.BufferedStream.Flush
  - System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)
  - System.IO.BufferedStream.Length
  - System.IO.BufferedStream.Position
  - System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.BufferedStream.ReadByte
  - System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.IO.BufferedStream.SetLength(System.Int64)
  - System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.BufferedStream.WriteByte(System.Byte)
  langs:
  - csharp
  name: BufferedStream
  nameWithType: BufferedStream
  fullName: System.IO.BufferedStream
  type: Class
  summary: "Adiciona uma camada buffering para ler e escrever operações no fluxo de outro. Esta classe não pode ser herdada."
  remarks: "A buffer is a block of bytes in memory used to cache data, thereby reducing the number of calls to the operating system. Buffers improve read and write performance. A buffer can be used for either reading or writing, but never both simultaneously. The [Read(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True) and [Write(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True) methods of `BufferedStream` automatically maintain the buffer.  \n  \n> [!IMPORTANT]\n>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  \n  \n `BufferedStream` can be composed around certain types of streams. It provides implementations for reading and writing bytes to an underlying data source or repository. Use <xref:System.IO.BinaryReader> and <xref:System.IO.BinaryWriter> for reading and writing other data types. `BufferedStream` is designed to prevent the buffer from slowing down input and output when the buffer is not needed. If you always read and write for sizes greater than the internal buffer size, then `BufferedStream` might not even allocate the internal buffer. `BufferedStream` also buffers reads and writes in a shared buffer. It is assumed that you will almost always be doing a series of reads or writes, but rarely alternate between the two of them."
  example:
  - "The following code examples show how to use the `BufferedStream` class over the `NetworkStream` class to increase the performance of certain I/O operations. Start the server on a remote computer before starting the client. Specify the remote computer name as a command-line argument when starting the client. Vary the `dataArraySize` and `streamBufferSize` constants to view their effect on performance.  \n  \n The first example shows the code that runs on the client, and the second example shows the code that runs on the server.  \n  \n **Example 1: Code that runs on the client**  \n  \n [!code-cs[System.IO.BufferedStream1#1](~/add/codesnippet/csharp/t-system.io.bufferedstream_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#1](~/add/codesnippet/cpp/t-system.io.bufferedstream_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#1](~/add/codesnippet/visualbasic/t-system.io.bufferedstream_1.vb)]  \n  \n **Example 2: Code that runs on the server**  \n  \n [!code-vb[System.IO.BufferedStream2#1](~/add/codesnippet/visualbasic/t-system.io.bufferedstream_2.vb)]\n [!code-cs[System.IO.BufferedStream2#1](~/add/codesnippet/csharp/t-system.io.bufferedstream_2.cs)]\n [!code-cpp[System.IO.BufferedStream2#1](~/add/codesnippet/cpp/t-system.io.bufferedstream_2.cpp)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class BufferedStream : System.IO.Stream
  inheritance:
  - System.IO.Stream
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.BufferedStream.#ctor(System.IO.Stream)
  id: '#ctor(System.IO.Stream)'
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: BufferedStream(Stream)
  nameWithType: BufferedStream.BufferedStream(Stream)
  fullName: System.IO.BufferedStream.BufferedStream(Stream)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.BufferedStream&quot;> </xref> classe com um tamanho de memória intermédia predefinido de 4096 bytes."
  remarks: "Uma memória intermédia de leitura/escrita partilhado é atribuída pela primeira vez um `BufferedStream` objecto foi inicializado com este construtor. A memória intermédia partilhada não é utilizada se todas as leituras e escritas são maior que ou igual a `bufferSize`."
  syntax:
    content: public BufferedStream (System.IO.Stream stream);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "O fluxo actual."
  overload: System.IO.BufferedStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>stream</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)
  id: '#ctor(System.IO.Stream,System.Int32)'
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: BufferedStream(Stream,Int32)
  nameWithType: BufferedStream.BufferedStream(Stream,Int32)
  fullName: System.IO.BufferedStream.BufferedStream(Stream,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.BufferedStream&quot;> </xref> classe com o tamanho da memória intermédia especificado."
  remarks: "Uma memória intermédia de leitura/escrita partilhado é atribuída pela primeira vez um `BufferedStream` objecto foi inicializado com este construtor. A memória intermédia partilhada não é utilizada se todas as leituras e escritas são maior que ou igual a `bufferSize`."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#2](~/add/codesnippet/csharp/m-system.io.bufferedstre_2_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#2](~/add/codesnippet/cpp/m-system.io.bufferedstre_2_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#2](~/add/codesnippet/visualbasic/m-system.io.bufferedstre_2_1.vb)]"
  syntax:
    content: public BufferedStream (System.IO.Stream stream, int bufferSize);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "O fluxo actual."
    - id: bufferSize
      type: System.Int32
      description: "O tamanho de memória intermédia em bytes."
  overload: System.IO.BufferedStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>stream</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>é negativo."
  platform:
  - net462
- uid: System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: BufferedStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.BufferedStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Começa uma operação de leitura assíncrona. (Considere utilizar <xref:System.IO.BufferedStream.ReadAsync*>em vez disso; consulte a secção observações.)</xref:System.IO.BufferedStream.ReadAsync*>"
  remarks: "O .NET Framework 4 e versões anteriores, é necessário usar métodos tais como <xref:System.IO.Stream.BeginRead%2A>e <xref:System.IO.Stream.EndRead%2A>para implementar as operações de ficheiros assíncronas.</xref:System.IO.Stream.EndRead%2A> </xref:System.IO.Stream.BeginRead%2A> Estes métodos ainda estão disponíveis a [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] para suportar código legado; no entanto, os novos métodos assíncronos, tais como <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, e <xref:System.IO.BufferedStream.FlushAsync%2A>, ajuda a implementar operações assíncronas ficheiros mais facilmente.</xref:System.IO.BufferedStream.FlushAsync%2A> </xref:System.IO.BufferedStream.WriteAsync%2A> </xref:System.IO.BufferedStream.ReadAsync%2A>       <xref:System.IO.BufferedStream.EndWrite%2A>tem de ser chamado exatamente uma vez para cada chamada BeginRead.</xref:System.IO.BufferedStream.EndWrite%2A> Falha ao terminar um processo de leitura antes de iniciar a leitura de outra pode provocar um comportamento indesejável como impasse.      > [!NOTE] > Utilize o <xref:System.IO.BufferedStream.CanRead%2A>propriedade para determinar se a instância atual suporta a leitura.</xref:System.IO.BufferedStream.CanRead%2A>       <xref:System.IO.BufferedStream.EndRead%2A>tem de ser chamado com esta <xref:System.IAsyncResult>para determinar o número de bytes foram lidos.</xref:System.IAsyncResult></xref:System.IO.BufferedStream.EndRead%2A>"
  syntax:
    content: public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "A memória intermédia para ler os dados em."
    - id: offset
      type: System.Int32
      description: "O deslocamento de byte no `buffer` no qual pretende começar a escrever lidos do fluxo de dados."
    - id: count
      type: System.Int32
      description: "O número máximo de bytes a ler."
    - id: callback
      type: System.AsyncCallback
      description: "Uma opcional chamada de retorno assíncrona, ser chamado quando a leitura estiver concluída."
    - id: state
      type: System.Object
      description: "Um objeto de fornecidos pelo utilizador que distingue este pedido de leitura assíncrono específico de outros pedidos."
    return:
      type: System.IAsyncResult
      description: "Um objeto que representa a leitura assíncrona, que foi ainda estar pendente."
  overload: System.IO.BufferedStream.BeginRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>ou <code>count</code> é negativo."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Tentativa de leitura assíncrona ultrapassou o fim do fluxo."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O comprimento da memória intermédia menos <code> offset </code> é inferior a <code> count </code>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O fluxo actual não suporta a operação de leitura."
  platform:
  - net462
- uid: System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: BufferedStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.BufferedStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Começa uma operação de escrita assíncrona. (Considere utilizar <xref:System.IO.BufferedStream.WriteAsync*>em vez disso; consulte a secção observações.)</xref:System.IO.BufferedStream.WriteAsync*>"
  remarks: "O .NET Framework 4 e versões anteriores, é necessário usar métodos tais como <xref:System.IO.Stream.BeginWrite%2A>e <xref:System.IO.Stream.EndWrite%2A>para implementar as operações de ficheiros assíncronas.</xref:System.IO.Stream.EndWrite%2A> </xref:System.IO.Stream.BeginWrite%2A> Estes métodos ainda estão disponíveis a [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] para suportar código legado; no entanto, os novos métodos assíncronos, tais como <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, e <xref:System.IO.BufferedStream.FlushAsync%2A>, ajuda a implementar operações assíncronas ficheiros mais facilmente.</xref:System.IO.BufferedStream.FlushAsync%2A> </xref:System.IO.BufferedStream.WriteAsync%2A> </xref:System.IO.BufferedStream.ReadAsync%2A>       <xref:System.IO.BufferedStream.EndWrite%2A>tem de ser chamado exatamente uma vez em cada <xref:System.IAsyncResult>de BeginWrite.</xref:System.IAsyncResult></xref:System.IO.BufferedStream.EndWrite%2A> <xref:System.IO.BufferedStream.EndWrite%2A>irá bloquear até que a operação de e/s foi concluída.</xref:System.IO.BufferedStream.EndWrite%2A>"
  syntax:
    content: public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "A memória intermédia que contém os dados a escrever o fluxo actual."
    - id: offset
      type: System.Int32
      description: "O deslocamento de byte baseado em zero no `buffer` no qual pretende começar a copiar bytes no fluxo atual."
    - id: count
      type: System.Int32
      description: "O número máximo de bytes para escrita."
    - id: callback
      type: System.AsyncCallback
      description: "O método a ser chamado quando a operação de escrita assíncrona foi concluída."
    - id: state
      type: System.Object
      description: "Um objeto de fornecidos pelo utilizador que distingue este pedido de escrita assíncrona específico de outros pedidos."
    return:
      type: System.IAsyncResult
      description: "Um objeto que faça referência a escrita assíncrona que foi ainda estar pendente."
  overload: System.IO.BufferedStream.BeginWrite*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>buffer</code>comprimento menos <code>offset</code> é inferior a <code>count</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>ou <code>count</code> é negativo."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O fluxo não suporta escrita."
  platform:
  - net462
- uid: System.IO.BufferedStream.CanRead
  id: CanRead
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: CanRead
  nameWithType: BufferedStream.CanRead
  fullName: System.IO.BufferedStream.CanRead
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Obtém um valor que indica se o fluxo actual suporta leitura."
  remarks: "Se uma classe derivada de <xref:System.IO.Stream>não suporta leitura, as chamadas para o <xref:System.IO.BufferedStream.Read%2A>, <xref:System.IO.BufferedStream.ReadByte%2A>, <xref:System.IO.Stream.BeginRead%2A>, <xref:System.IO.Stream.EndRead%2A>e o `Peek` métodos de <xref:System.IO.StreamReader>, <xref:System.IO.StringReader>e <xref:System.IO.TextReader>acionar <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.TextReader> </xref:System.IO.StringReader> </xref:System.IO.StreamReader> </xref:System.IO.Stream.EndRead%2A> </xref:System.IO.Stream.BeginRead%2A> </xref:System.IO.BufferedStream.ReadByte%2A> </xref:System.IO.BufferedStream.Read%2A> </xref:System.IO.Stream>       Se o fluxo está fechado, esta propriedade devolve `false`."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#5](~/add/codesnippet/csharp/p-system.io.bufferedstre_2_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#5](~/add/codesnippet/cpp/p-system.io.bufferedstre_2_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#5](~/add/codesnippet/visualbasic/p-system.io.bufferedstre_2_1.vb)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o fluxo de suportar leitura; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> se o fluxo está fechado ou foi aberto com acesso só de escrita."
  overload: System.IO.BufferedStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.IO.BufferedStream.CanSeek
  id: CanSeek
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: BufferedStream.CanSeek
  fullName: System.IO.BufferedStream.CanSeek
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Obtém um valor que indica se o fluxo actual suporta pesquisa."
  remarks: "Se uma classe derivada de <xref:System.IO.Stream>não suporta procura, as chamadas para <xref:System.IO.BufferedStream.Length%2A>, <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Position%2A>e <xref:System.IO.BufferedStream.Seek%2A>acionar <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.BufferedStream.Seek%2A> </xref:System.IO.BufferedStream.Position%2A> </xref:System.IO.BufferedStream.SetLength%2A> </xref:System.IO.BufferedStream.Length%2A> </xref:System.IO.Stream>       Se o fluxo está fechado, esta propriedade devolve `false`."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#3](~/add/codesnippet/csharp/p-system.io.bufferedstre_0_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#3](~/add/codesnippet/cpp/p-system.io.bufferedstre_0_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#3](~/add/codesnippet/visualbasic/p-system.io.bufferedstre_0_1.vb)]"
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o fluxo de suportar a pesquisa; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> se o fluxo está fechado ou se o fluxo foi construído a partir de um identificador de sistema operativo como um pipe ou saída para a consola."
  overload: System.IO.BufferedStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.IO.BufferedStream.CanWrite
  id: CanWrite
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: BufferedStream.CanWrite
  fullName: System.IO.BufferedStream.CanWrite
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Obtém um valor que indica se o fluxo actual suporta escrita."
  remarks: "Se uma classe derivada de <xref:System.IO.Stream>não suporta a escrita de uma chamada para <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Write%2A>, ou <xref:System.IO.BufferedStream.WriteByte%2A>emitir um <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.BufferedStream.WriteByte%2A> </xref:System.IO.BufferedStream.Write%2A> </xref:System.IO.BufferedStream.SetLength%2A> </xref:System.IO.Stream>       Se o fluxo está fechado, esta propriedade devolve `false`."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#4](~/add/codesnippet/csharp/p-system.io.bufferedstre_1_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#4](~/add/codesnippet/cpp/p-system.io.bufferedstre_1_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#4](~/add/codesnippet/visualbasic/p-system.io.bufferedstre_1_1.vb)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o fluxo de suportar escrita; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> se o fluxo está fechado ou foi aberto com acesso só de leitura."
  overload: System.IO.BufferedStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.IO.BufferedStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: BufferedStream.Dispose(Boolean)
  fullName: System.IO.BufferedStream.Dispose(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "A adicionar."
  overload: System.IO.BufferedStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.IO.BufferedStream.EndRead(System.IAsyncResult)
  id: EndRead(System.IAsyncResult)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: EndRead(IAsyncResult)
  nameWithType: BufferedStream.EndRead(IAsyncResult)
  fullName: System.IO.BufferedStream.EndRead(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Tem de aguardar durante a operação de leitura assíncrona pendente concluir. (Considere utilizar <xref:System.IO.BufferedStream.ReadAsync*>em vez disso; consulte a secção observações.)</xref:System.IO.BufferedStream.ReadAsync*>"
  remarks: "O .NET Framework 4 e versões anteriores, é necessário usar métodos tais como <xref:System.IO.Stream.BeginRead%2A>e <xref:System.IO.Stream.EndRead%2A>para implementar as operações de ficheiros assíncronas.</xref:System.IO.Stream.EndRead%2A> </xref:System.IO.Stream.BeginRead%2A> Estes métodos ainda estão disponíveis a [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] para suportar código legado; no entanto, os novos métodos assíncronos, tais como <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, e <xref:System.IO.BufferedStream.FlushAsync%2A>, ajuda a implementar operações assíncronas ficheiros mais facilmente.</xref:System.IO.BufferedStream.FlushAsync%2A> </xref:System.IO.BufferedStream.WriteAsync%2A> </xref:System.IO.BufferedStream.ReadAsync%2A>       EndRead tem de ser chamado com esta <xref:System.IAsyncResult>para determinar o número de bytes foram lidos.</xref:System.IAsyncResult>"
  syntax:
    content: public override int EndRead (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "A referência ao pedido assíncrona pendente para aguardar."
    return:
      type: System.Int32
      description: "O número de bytes lido do fluxo, entre 0 (zero) e o número de bytes que pediu. Os fluxos de devolvem apenas 0 apenas no final da transmissão em fluxo, caso contrário, deverá bloquear até, pelo menos, de 1 byte está disponível."
  overload: System.IO.BufferedStream.EndRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Este <xref:System.IAsyncResult>objeto não foi criado chamando <xref:System.IO.BufferedStream.BeginRead*>nesta classe.</xref:System.IO.BufferedStream.BeginRead*> </xref:System.IAsyncResult>"
  platform:
  - net462
- uid: System.IO.BufferedStream.EndWrite(System.IAsyncResult)
  id: EndWrite(System.IAsyncResult)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: EndWrite(IAsyncResult)
  nameWithType: BufferedStream.EndWrite(IAsyncResult)
  fullName: System.IO.BufferedStream.EndWrite(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Termina uma operação de escrita assíncrona e blocos até que a operação de e/s foi concluída. (Considere utilizar <xref:System.IO.BufferedStream.WriteAsync*>em vez disso; consulte a secção observações.)</xref:System.IO.BufferedStream.WriteAsync*>"
  remarks: "O .NET Framework 4 e versões anteriores, é necessário usar métodos tais como <xref:System.IO.Stream.BeginWrite%2A>e <xref:System.IO.Stream.EndWrite%2A>para implementar as operações de ficheiros assíncronas.</xref:System.IO.Stream.EndWrite%2A> </xref:System.IO.Stream.BeginWrite%2A> Estes métodos ainda estão disponíveis a [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] para suportar código legado; no entanto, os novos métodos assíncronos, tais como <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, e <xref:System.IO.BufferedStream.FlushAsync%2A>, ajuda a implementar operações assíncronas ficheiros mais facilmente.</xref:System.IO.BufferedStream.FlushAsync%2A> </xref:System.IO.BufferedStream.WriteAsync%2A> </xref:System.IO.BufferedStream.ReadAsync%2A>       EndWrite tem de ser chamado exatamente uma vez para cada chamada <xref:System.IO.BufferedStream.BeginRead%2A>.</xref:System.IO.BufferedStream.BeginRead%2A> Falha ao terminar um processo de leitura antes do início outra operação de leitura pode causar impasse ou outro comportamento indesejável."
  syntax:
    content: public override void EndWrite (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "O pedido assíncrono pendente."
  overload: System.IO.BufferedStream.EndWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Este <xref:System.IAsyncResult>objeto não foi criado chamando <xref:System.IO.BufferedStream.BeginWrite*>nesta classe.</xref:System.IO.BufferedStream.BeginWrite*> </xref:System.IAsyncResult>"
  platform:
  - net462
- uid: System.IO.BufferedStream.Flush
  id: Flush
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Flush()
  nameWithType: BufferedStream.Flush()
  fullName: System.IO.BufferedStream.Flush()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Limpa todas as memórias intermédias para este fluxo e faz com que todos os dados colocados em memória intermédia para serem escritos para o dispositivo subjacente."
  remarks: "Flushing o fluxo não será esvaziar o codificador subjacente, exceto se chamar explicitamente `Flush` ou <xref:System.IO.Stream.Close%2A>.</xref:System.IO.Stream.Close%2A>       Se utilizar o <xref:System.IO.BufferedStream.%23ctor%2A>construtor, deste modo, especificar o tamanho da memória intermédia ao criar o `BufferedStream` objeto, o conteúdo é descarregado quando atinge o tamanho da memória intermédia.</xref:System.IO.BufferedStream.%23ctor%2A> Por exemplo, tais como a código `BufferedStream bs = new BufferedStream(bs, 5)` irá remover da cache o conteúdo quando o tamanho da memória intermédia atinge 5 bytes.       Todos os métodos de leitura e escrita de `BufferedStream` manter automaticamente a memória intermédia de, pelo que não é necessário invocar `Flush` quando mudar novamente e estabelecido entre leitura e escrita."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#6](~/add/codesnippet/csharp/m-system.io.bufferedstre_0_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#6](~/add/codesnippet/cpp/m-system.io.bufferedstre_0_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#6](~/add/codesnippet/visualbasic/m-system.io.bufferedstre_0_1.vb)]"
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.IO.BufferedStream.Flush*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O fluxo foi eliminado."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "A origem de dados ou o repositório não está aberto."
  platform:
  - net462
- uid: System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)
  id: FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: FlushAsync(CancellationToken)
  nameWithType: BufferedStream.FlushAsync(CancellationToken)
  fullName: System.IO.BufferedStream.FlushAsync(CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "No modo assíncrono limpa todas as memórias intermédias para este fluxo, faz com que todos os dados colocados em memória intermédia para serem escritos para o dispositivo subjacente e monitoriza os pedidos de cancelamento."
  syntax:
    content: public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "O token para monitorizar os pedidos de cancelamento."
    return:
      type: System.Threading.Tasks.Task
      description: "Uma tarefa que representa a operação assíncrona."
  overload: System.IO.BufferedStream.FlushAsync*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O fluxo foi eliminado."
  platform:
  - net462
- uid: System.IO.BufferedStream.Length
  id: Length
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Length
  nameWithType: BufferedStream.Length
  fullName: System.IO.BufferedStream.Length
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Obtém o comprimento de sequência em bytes."
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "O comprimento de sequência em bytes."
  overload: System.IO.BufferedStream.Length*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "O fluxo subjacente é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> ou fechado."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O fluxo não suporta pesquisa."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Métodos foram chamados depois do fluxo foi fechado."
  platform:
  - net462
- uid: System.IO.BufferedStream.Position
  id: Position
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Position
  nameWithType: BufferedStream.Position
  fullName: System.IO.BufferedStream.Position
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Obtém a posição dentro do fluxo actual."
  remarks: "O `get` acessor invoca <xref:System.IO.BufferedStream.Seek%2A>para obter a posição atual no fluxo subjacente e, em seguida, ajusta este valor de acordo com a posição actual na memória intermédia.</xref:System.IO.BufferedStream.Seek%2A>       O `set` acessor copia todos os dados escritos anteriormente para a memória intermédia para o fluxo subjacente e, em seguida, invoca <xref:System.IO.BufferedStream.Seek%2A>.</xref:System.IO.BufferedStream.Seek%2A>       Pesquisa para qualquer localização, para além do comprimento do fluxo é suportada."
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "A posição dentro do fluxo actual."
  overload: System.IO.BufferedStream.Position*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "O valor transmitido ao <xref:System.IO.BufferedStream.Seek*>é negativo.</xref:System.IO.BufferedStream.Seek*>"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorre um erro de e/s, tais como o fluxo que está a ser fechado."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O fluxo não suporta pesquisa."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Métodos foram chamados depois do fluxo foi fechado."
  platform:
  - net462
- uid: System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: BufferedStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.BufferedStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Bytes de cópias do fluxo de memória intermédia atual para uma matriz."
  remarks: "O `Read` método irá devolver 0 apenas se for atingido o fim da sequência. Noutros casos, `Read` sempre lê, pelo menos, um bytes da sequência antes de regressar. Por definição, se não estão disponíveis dados do fluxo após uma chamada para `Read`, a `Read` método devolve 0 (atingido o fim do fluxo é automaticamente). Uma implementação é gratuita devolver menos bytes que o pedido mesmo que não foi atingido o fim do fluxo.       Utilize <xref:System.IO.BinaryReader>para ler os tipos de dados primitivos.</xref:System.IO.BinaryReader>"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#7](~/add/codesnippet/csharp/m-system.io.bufferedstre_3_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#7](~/add/codesnippet/cpp/m-system.io.bufferedstre_3_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#7](~/add/codesnippet/visualbasic/m-system.io.bufferedstre_3_1.vb)]"
  syntax:
    content: public override int Read (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "A memória intermédia para que os bytes estão a ser copiado."
    - id: offset
      type: System.Int32
      description: "O desvio de bytes na memória intermédia no qual pretende começar a ler bytes."
    - id: count
      type: System.Int32
      description: "O número de bytes a ser lido."
    return:
      type: System.Int32
      description: "O número total de bytes lido no <code> array </code>. Isto pode ser inferior ao número de bytes pedido se que não estão atualmente disponíveis muitos bytes ou 0 se foi atingido o fim da sequência antes de quaisquer dados pode ser lida."
  overload: System.IO.BufferedStream.Read*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Length of <code>array</code> minus <code>offset</code> is less than <code>count</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>ou <code>count</code> é negativo."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "O fluxo não estiver aberto ou é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O fluxo não suporta leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Métodos foram chamados depois do fluxo foi fechado."
  platform:
  - net462
- uid: System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: BufferedStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.BufferedStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "No modo assíncrono lê uma sequência de bytes do fluxo atual, avança a posição dentro do fluxo de pelo número de bytes lidos e monitoriza os pedidos de cancelamento."
  remarks: "Pode criar um token de cancelamento através da criação de uma instância do <xref:System.Threading.CancellationTokenSource>classe e transmitir o <xref:System.Threading.CancellationTokenSource.Token%2A>propriedade como o `cancellationToken` parâmetro.</xref:System.Threading.CancellationTokenSource.Token%2A> </xref:System.Threading.CancellationTokenSource>"
  syntax:
    content: public override System.Threading.Tasks.Task<int> ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "A memória intermédia para escrever dados no."
    - id: offset
      type: System.Int32
      description: "O deslocamento de byte no `buffer` no qual pretende iniciar a escrita de dados da sequência."
    - id: count
      type: System.Int32
      description: "O número máximo de bytes a ler."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "O token para monitorizar os pedidos de cancelamento."
    return:
      type: System.Threading.Tasks.Task{System.Int32}
      description: "Operação de leitura de uma tarefa que representa o assíncrona. O valor da <code> TResult </code> parâmetro contém o número total de bytes na memória intermédia de leitura. O valor de resultados pode ser inferior ao número de bytes se o número de bytes atualmente disponíveis é inferior ao número pedido ou pode ser 0 (zero) se foi atingido o fim do fluxo de pedido."
  overload: System.IO.BufferedStream.ReadAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>ou <code>count</code> é negativo."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "A soma de <code> offset </code> e <code> count </code> é maior do que o comprimento da memória intermédia."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O fluxo não suporta leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O fluxo foi eliminado."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O fluxo está a ser utilizado por uma operação de leitura anterior."
  platform:
  - net462
- uid: System.IO.BufferedStream.ReadByte
  id: ReadByte
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: ReadByte()
  nameWithType: BufferedStream.ReadByte()
  fullName: System.IO.BufferedStream.ReadByte()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Lê um byte do fluxo subjacente e devolve o byte convertido para um <xref uid=&quot;langword_csharp_int&quot; name=&quot;int&quot; href=&quot;&quot;> </xref>, ou devolve -1 se ao ler a partir do final da transmissão em fluxo."
  syntax:
    content: public override int ReadByte ();
    parameters: []
    return:
      type: System.Int32
      description: "O byte convertido para um <xref uid=&quot;langword_csharp_int&quot; name=&quot;int&quot; href=&quot;&quot;> </xref>, ou -1 se ao ler a partir do final da transmissão em fluxo."
  overload: System.IO.BufferedStream.ReadByte*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorre um erro de e/s, tais como o fluxo que está a ser fechado."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O fluxo não suporta leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Métodos foram chamados depois do fluxo foi fechado."
  platform:
  - net462
- uid: System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: BufferedStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.BufferedStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Define a posição dentro do fluxo de memória intermédia actual."
  remarks: "Se `offset` é negativo, a nova posição será preceder a posição especificada pelo `origin` pelo número de bytes especificada por `offset`. Se `offset` for 0, a nova posição será a posição especificada pelo `origin`. Se `offset` for positivo, a nova posição seguirá a posição especificada pelo `origin` pelo número de bytes especificada por `offset`.       Quando um <xref:System.IO.BufferedStream>objeto é a sequência base para um <xref:System.IO.StreamReader>objeto, chamar o método de procura, pode fazer com a posição do fluxo já não corresponder à posição da memória intermédia interna no leitor.</xref:System.IO.StreamReader> </xref:System.IO.BufferedStream> Para repor a memória intermédia interna, chame o <xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=fullName>método; no entanto, este método abrandar o desempenho e deve ser chamado apenas quando for absolutamente necessário.</xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=fullName>       Pesquisa para qualquer localização, para além do comprimento do fluxo é suportada."
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin origin);
    parameters:
    - id: offset
      type: System.Int64
      description: "Um deslocamento de byte relativa `origin`."
    - id: origin
      type: System.IO.SeekOrigin
      description: "Um valor de tipo <xref:System.IO.SeekOrigin>que indica que o ponto de referência a partir do qual obter a posição de novo.</xref:System.IO.SeekOrigin>"
    return:
      type: System.Int64
      description: "Nova posição dentro do fluxo de memória intermédia actual."
  overload: System.IO.BufferedStream.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "O fluxo não estiver aberto ou é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O fluxo não suporta pesquisa."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Métodos foram chamados depois do fluxo foi fechado."
  platform:
  - net462
- uid: System.IO.BufferedStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: BufferedStream.SetLength(Int64)
  fullName: System.IO.BufferedStream.SetLength(Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Define o comprimento do fluxo de memória intermédia."
  remarks: "A memória intermédia é esvaziada antes de definir o comprimento do repositório ou origem de dados subjacente. Se o valor especificado é inferior ao comprimento atual do fluxo de memória intermédia, a sequência de memória intermédia é truncada. Se o valor especificado é maior do que o comprimento atual do fluxo de memória intermédia, a sequência de memória intermédia é expandida. Se a sequência de memória intermédia é expandida, o conteúdo da memória intermédia transmissão em fluxo entre o antigo e novo durações não está definido.       `SetLength`Esvaziamentos da qualquer escritas colocados em memória intermédia, se necessário.       Tem de suportar uma sequência de escrita e pesquisa para `SetLength` funcione."
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "Um número inteiro que indica que o comprimento pretendido do fluxo de memória intermédia atual em bytes."
  overload: System.IO.BufferedStream.SetLength*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>value</code>é negativo."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "O fluxo não estiver aberto ou é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O fluxo não suporta o escrita e pesquisa."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Métodos foram chamados depois do fluxo foi fechado."
  platform:
  - net462
- uid: System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: BufferedStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.BufferedStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Copia bytes no fluxo de memória intermédia e avança a posição atual no fluxo de memória intermédia pelo número de bytes escritos."
  remarks: ''
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#6](~/add/codesnippet/csharp/m-system.io.bufferedstre_1_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#6](~/add/codesnippet/cpp/m-system.io.bufferedstre_1_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#6](~/add/codesnippet/visualbasic/m-system.io.bufferedstre_1_1.vb)]"
  syntax:
    content: public override void Write (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "A matriz de bytes a partir dos quais pretende copiar `count` bytes no fluxo de memória intermédia atual."
    - id: offset
      type: System.Int32
      description: "O desvio na memória intermédia no qual pretende começar a copiar bytes no fluxo de memória intermédia atual."
    - id: count
      type: System.Int32
      description: "O número de bytes a escrever para o fluxo actual de memória intermédia."
  overload: System.IO.BufferedStream.Write*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Length of <code>array</code> minus <code>offset</code> is less than <code>count</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>ou <code>count</code> é negativo."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "O fluxo está fechado ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O fluxo não suporta escrita."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Métodos foram chamados depois do fluxo foi fechado."
  platform:
  - net462
- uid: System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: BufferedStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.BufferedStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "No modo assíncrono escreve uma sequência de bytes no fluxo atual, avança a posição atual neste fluxo pelo número de bytes escritos e monitoriza os pedidos de cancelamento."
  remarks: "Pode criar um token de cancelamento através da criação de uma instância do <xref:System.Threading.CancellationTokenSource>classe e transmitir o <xref:System.Threading.CancellationTokenSource.Token%2A>propriedade como o `cancellationToken` parâmetro.</xref:System.Threading.CancellationTokenSource.Token%2A> </xref:System.Threading.CancellationTokenSource>"
  syntax:
    content: public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "A memória intermédia para escrever dados a partir de."
    - id: offset
      type: System.Int32
      description: "O deslocamento de byte baseado em zero no `buffer` partir do qual iniciar copiar bytes no fluxo."
    - id: count
      type: System.Int32
      description: "O número máximo de bytes para escrita."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "O token para monitorizar os pedidos de cancelamento."
    return:
      type: System.Threading.Tasks.Task
      description: "Uma tarefa que representa a operação de escrita assíncrona."
  overload: System.IO.BufferedStream.WriteAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>ou <code>count</code> é negativo."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "A soma de <code> offset </code> e <code> count </code> é maior do que o comprimento da memória intermédia."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O fluxo não suporta escrita."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O fluxo foi eliminado."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O fluxo está a ser utilizado por uma operação de escrita anterior."
  platform:
  - net462
- uid: System.IO.BufferedStream.WriteByte(System.Byte)
  id: WriteByte(System.Byte)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: WriteByte(Byte)
  nameWithType: BufferedStream.WriteByte(Byte)
  fullName: System.IO.BufferedStream.WriteByte(Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Escreve um byte a posição atual no fluxo de memória intermédia."
  syntax:
    content: public override void WriteByte (byte value);
    parameters:
    - id: value
      type: System.Byte
      description: "Um byte para escrever no fluxo."
  overload: System.IO.BufferedStream.WriteByte*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O fluxo não suporta escrita."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>value</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Métodos foram chamados depois do fluxo foi fechado."
  platform:
  - net462
references:
- uid: System.IO.Stream
  isExternal: false
  name: System.IO.Stream
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.IO.BufferedStream.#ctor(System.IO.Stream)
  parent: System.IO.BufferedStream
  isExternal: false
  name: BufferedStream(Stream)
  nameWithType: BufferedStream.BufferedStream(Stream)
  fullName: System.IO.BufferedStream.BufferedStream(Stream)
- uid: System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)
  parent: System.IO.BufferedStream
  isExternal: false
  name: BufferedStream(Stream,Int32)
  nameWithType: BufferedStream.BufferedStream(Stream,Int32)
  fullName: System.IO.BufferedStream.BufferedStream(Stream,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.BufferedStream
  isExternal: false
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: BufferedStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.BufferedStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.BufferedStream
  isExternal: false
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: BufferedStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.BufferedStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IO.BufferedStream.CanRead
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanRead
  nameWithType: BufferedStream.CanRead
  fullName: System.IO.BufferedStream.CanRead
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.BufferedStream.CanSeek
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanSeek
  nameWithType: BufferedStream.CanSeek
  fullName: System.IO.BufferedStream.CanSeek
- uid: System.IO.BufferedStream.CanWrite
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanWrite
  nameWithType: BufferedStream.CanWrite
  fullName: System.IO.BufferedStream.CanWrite
- uid: System.IO.BufferedStream.Dispose(System.Boolean)
  parent: System.IO.BufferedStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: BufferedStream.Dispose(Boolean)
  fullName: System.IO.BufferedStream.Dispose(Boolean)
- uid: System.IO.BufferedStream.EndRead(System.IAsyncResult)
  parent: System.IO.BufferedStream
  isExternal: false
  name: EndRead(IAsyncResult)
  nameWithType: BufferedStream.EndRead(IAsyncResult)
  fullName: System.IO.BufferedStream.EndRead(IAsyncResult)
- uid: System.IO.BufferedStream.EndWrite(System.IAsyncResult)
  parent: System.IO.BufferedStream
  isExternal: false
  name: EndWrite(IAsyncResult)
  nameWithType: BufferedStream.EndWrite(IAsyncResult)
  fullName: System.IO.BufferedStream.EndWrite(IAsyncResult)
- uid: System.IO.BufferedStream.Flush
  parent: System.IO.BufferedStream
  isExternal: false
  name: Flush()
  nameWithType: BufferedStream.Flush()
  fullName: System.IO.BufferedStream.Flush()
- uid: System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  isExternal: false
  name: FlushAsync(CancellationToken)
  nameWithType: BufferedStream.FlushAsync(CancellationToken)
  fullName: System.IO.BufferedStream.FlushAsync(CancellationToken)
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.IO.BufferedStream.Length
  parent: System.IO.BufferedStream
  isExternal: false
  name: Length
  nameWithType: BufferedStream.Length
  fullName: System.IO.BufferedStream.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.BufferedStream.Position
  parent: System.IO.BufferedStream
  isExternal: false
  name: Position
  nameWithType: BufferedStream.Position
  fullName: System.IO.BufferedStream.Position
- uid: System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.BufferedStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: BufferedStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.BufferedStream.Read(Byte[],Int32,Int32)
- uid: System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  isExternal: false
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: BufferedStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.BufferedStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.Threading.Tasks.Task{System.Int32}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<Int32>
  nameWithType: Task<Int32>
  fullName: System.Threading.Tasks.Task<System.Int32>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Int32>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.BufferedStream.ReadByte
  parent: System.IO.BufferedStream
  isExternal: false
  name: ReadByte()
  nameWithType: BufferedStream.ReadByte()
  fullName: System.IO.BufferedStream.ReadByte()
- uid: System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.BufferedStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: BufferedStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.BufferedStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.IO.BufferedStream.SetLength(System.Int64)
  parent: System.IO.BufferedStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: BufferedStream.SetLength(Int64)
  fullName: System.IO.BufferedStream.SetLength(Int64)
- uid: System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.BufferedStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: BufferedStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.BufferedStream.Write(Byte[],Int32,Int32)
- uid: System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  isExternal: false
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: BufferedStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.BufferedStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.IO.BufferedStream.WriteByte(System.Byte)
  parent: System.IO.BufferedStream
  isExternal: false
  name: WriteByte(Byte)
  nameWithType: BufferedStream.WriteByte(Byte)
  fullName: System.IO.BufferedStream.WriteByte(Byte)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.IO.BufferedStream.#ctor*
  parent: System.IO.BufferedStream
  isExternal: false
  name: BufferedStream
  nameWithType: BufferedStream.BufferedStream
- uid: System.IO.BufferedStream.BeginRead*
  parent: System.IO.BufferedStream
  isExternal: false
  name: BeginRead
  nameWithType: BufferedStream.BeginRead
- uid: System.IO.BufferedStream.BeginWrite*
  parent: System.IO.BufferedStream
  isExternal: false
  name: BeginWrite
  nameWithType: BufferedStream.BeginWrite
- uid: System.IO.BufferedStream.CanRead*
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanRead
  nameWithType: BufferedStream.CanRead
- uid: System.IO.BufferedStream.CanSeek*
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanSeek
  nameWithType: BufferedStream.CanSeek
- uid: System.IO.BufferedStream.CanWrite*
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanWrite
  nameWithType: BufferedStream.CanWrite
- uid: System.IO.BufferedStream.Dispose*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Dispose
  nameWithType: BufferedStream.Dispose
- uid: System.IO.BufferedStream.EndRead*
  parent: System.IO.BufferedStream
  isExternal: false
  name: EndRead
  nameWithType: BufferedStream.EndRead
- uid: System.IO.BufferedStream.EndWrite*
  parent: System.IO.BufferedStream
  isExternal: false
  name: EndWrite
  nameWithType: BufferedStream.EndWrite
- uid: System.IO.BufferedStream.Flush*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Flush
  nameWithType: BufferedStream.Flush
- uid: System.IO.BufferedStream.FlushAsync*
  parent: System.IO.BufferedStream
  isExternal: false
  name: FlushAsync
  nameWithType: BufferedStream.FlushAsync
- uid: System.IO.BufferedStream.Length*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Length
  nameWithType: BufferedStream.Length
- uid: System.IO.BufferedStream.Position*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Position
  nameWithType: BufferedStream.Position
- uid: System.IO.BufferedStream.Read*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Read
  nameWithType: BufferedStream.Read
- uid: System.IO.BufferedStream.ReadAsync*
  parent: System.IO.BufferedStream
  isExternal: false
  name: ReadAsync
  nameWithType: BufferedStream.ReadAsync
- uid: System.IO.BufferedStream.ReadByte*
  parent: System.IO.BufferedStream
  isExternal: false
  name: ReadByte
  nameWithType: BufferedStream.ReadByte
- uid: System.IO.BufferedStream.Seek*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Seek
  nameWithType: BufferedStream.Seek
- uid: System.IO.BufferedStream.SetLength*
  parent: System.IO.BufferedStream
  isExternal: false
  name: SetLength
  nameWithType: BufferedStream.SetLength
- uid: System.IO.BufferedStream.Write*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Write
  nameWithType: BufferedStream.Write
- uid: System.IO.BufferedStream.WriteAsync*
  parent: System.IO.BufferedStream
  isExternal: false
  name: WriteAsync
  nameWithType: BufferedStream.WriteAsync
- uid: System.IO.BufferedStream.WriteByte*
  parent: System.IO.BufferedStream
  isExternal: false
  name: WriteByte
  nameWithType: BufferedStream.WriteByte
