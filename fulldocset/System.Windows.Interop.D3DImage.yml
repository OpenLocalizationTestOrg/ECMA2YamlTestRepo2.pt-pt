### YamlMime:ManagedReference
items:
- uid: System.Windows.Interop.D3DImage
  id: D3DImage
  children:
  - System.Windows.Interop.D3DImage.#ctor
  - System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)
  - System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)
  - System.Windows.Interop.D3DImage.Clone
  - System.Windows.Interop.D3DImage.CloneCore(System.Windows.Freezable)
  - System.Windows.Interop.D3DImage.CloneCurrentValue
  - System.Windows.Interop.D3DImage.CloneCurrentValueCore(System.Windows.Freezable)
  - System.Windows.Interop.D3DImage.CopyBackBuffer
  - System.Windows.Interop.D3DImage.CreateInstanceCore
  - System.Windows.Interop.D3DImage.Finalize
  - System.Windows.Interop.D3DImage.FreezeCore(System.Boolean)
  - System.Windows.Interop.D3DImage.GetAsFrozenCore(System.Windows.Freezable)
  - System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(System.Windows.Freezable)
  - System.Windows.Interop.D3DImage.Height
  - System.Windows.Interop.D3DImage.IsFrontBufferAvailable
  - System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged
  - System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty
  - System.Windows.Interop.D3DImage.Lock
  - System.Windows.Interop.D3DImage.Metadata
  - System.Windows.Interop.D3DImage.PixelHeight
  - System.Windows.Interop.D3DImage.PixelWidth
  - System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)
  - System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)
  - System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)
  - System.Windows.Interop.D3DImage.Unlock
  - System.Windows.Interop.D3DImage.Width
  langs:
  - csharp
  name: D3DImage
  nameWithType: D3DImage
  fullName: System.Windows.Interop.D3DImage
  type: Class
  summary: "Um <xref href=&quot;System.Windows.Media.ImageSource&quot;> </xref> que apresenta uma superfície de Direct3D criados pelo utilizador."
  remarks: "Utilize a classe de D3DImage para alojar conteúdo Direct3D numa aplicação Windows Presentation Foundation (WPF).       Chamar o <xref:System.Windows.Interop.D3DImage.Lock%2A>método para alterar o conteúdo de Direct3D apresentado pelo D3DImage.</xref:System.Windows.Interop.D3DImage.Lock%2A> Chamar o <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>método para atribuir uma superfície Direct3D para um D3DImage.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Chamar o <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A>método para controlar as atualizações para a superfície de Direct3D.</xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> Chamar o <xref:System.Windows.Interop.D3DImage.Unlock%2A>método para apresentar as áreas foi alteradas.</xref:System.Windows.Interop.D3DImage.Unlock%2A>       A classe de D3DImage gere dois apresentação das memórias intermédias, que são chamadas a *memória intermédia de back-* e *memória intermédia de front-*. A memória intermédia de back-é a superfície de Direct3D.  A memória intermédia de back-é copiada reencaminhar para a memória intermédia de front-quando chamar o <xref:System.Windows.Interop.D3DImage.Unlock%2A>método, onde é apresentada no hardware.</xref:System.Windows.Interop.D3DImage.Unlock%2A> Ocasionalmente, a memória intermédia de front-fica indisponível. Esta falta de disponibilidade pode ser causada pelo bloqueio de ecrã, ecrã inteiro exclusivas Direct3D aplicações, a mudança de utilizador ou outras atividades de sistema. Se isto ocorre, a aplicação WPF é notificada através de processamento de <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>eventos.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>  Como a sua aplicação responde na memória intermédia de front-se tornar indisponível depende se WPF está ativada para reverter a composição de software. O <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>método tem uma sobrecarga que assume um parâmetro que especifica se WPF retrocede para composição de software.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>      ## Responder a uma memória intermédia de frente disponível quando WPF não se encontra novamente para o Software composição quando chamar o <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29>sobrecarga ou chame o <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>sobrecarga com o `enableSoftwareFallback` parâmetro definido como `false`, o sistema de composição disponibiliza a referência da memória intermédia de back-quando a memória intermédia de front-fica indisponível e não será apresentado nada.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> </xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> Quando a memória intermédia de front-estiver novamente disponível, o sistema de composição gera o <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>eventos ao notificar a sua aplicação WPF.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>  Pode criar um processador de eventos para o <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>eventos reiniciar composição novamente com uma superfície de Direct3D válida.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> Para reiniciar composição, tem de chamar <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>      ## Responder a uma memória intermédia de frente disponível quando WPF recai anterior para Software composição quando chamar o <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>sobrecarga com o `enableSoftwareFallback` parâmetro definido como `true`, o sistema de composição mantém a referência da memória intermédia de back-quando a memória intermédia de front-fica indisponível, pelo que não é necessário chamar <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>quando a memória intermédia de front-esteja novamente disponível.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> </xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>  Poderão existir situações em que o dispositivo do utilizador fica indisponível.  Quando isso ocorrer, chamar <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>para libertar a referência do WPF na memória intermédia de back-.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>  Se precisar de repor o seu dispositivo, chamar <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>com o `backBuffer` parâmetro definido como `null`e, em seguida, chame <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>com `backBuffer` definido como uma superfície Direct3D válida.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> </xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>      > [!NOTE] > Desempenho depende significativamente a superfície de Direct3D as definições. Para obter mais informações, consulte [considerações de desempenho para Direct3D9 e interoperabilidade do WPF](~/add/includes/ajax-current-ext-md.md).      > [!NOTE] > D3DImage a classe não mostrar conteúdo Direct3D quando WPF composições no software, tal como através de uma ligação de ambiente de trabalho remoto, a menos que tem de chamar <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>e especifique `true` para o `enableSoftwareFallback` parâmetro.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>"
  example:
  - "The following code example shows how to declare a D3DImage in XAML. You must map the <xref:System.Windows.Interop> namespace, because it is not included in the default XAML namespaces. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-xml[System.Windows.Interop.D3DImage#10](~/add/codesnippet/xaml/d3dhost/window1.xaml#10)]"
  syntax:
    content: 'public class D3DImage : System.Windows.Media.ImageSource'
  inheritance:
  - System.Object
  - System.Windows.Threading.DispatcherObject
  - System.Windows.DependencyObject
  - System.Windows.Freezable
  - System.Windows.Media.Animation.Animatable
  - System.Windows.Media.ImageSource
  implements: []
  inheritedMembers:
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)
  - System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.DependencyObjectType
  - System.Windows.DependencyObject.Equals(System.Object)
  - System.Windows.DependencyObject.GetHashCode
  - System.Windows.DependencyObject.GetLocalValueEnumerator
  - System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.IsSealed
  - System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)
  - System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)
  - System.Windows.Freezable.CanFreeze
  - System.Windows.Freezable.Changed
  - System.Windows.Freezable.CreateInstance
  - System.Windows.Freezable.Freeze
  - System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)
  - System.Windows.Freezable.GetAsFrozen
  - System.Windows.Freezable.GetCurrentValueAsFrozen
  - System.Windows.Freezable.IsFrozen
  - System.Windows.Freezable.OnChanged
  - System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)
  - System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)
  - System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.Freezable.ReadPreamble
  - System.Windows.Freezable.WritePostscript
  - System.Windows.Freezable.WritePreamble
  - System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)
  - System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)
  - System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.Media.Animation.Animatable.GetAnimationBaseValue(System.Windows.DependencyProperty)
  - System.Windows.Media.Animation.Animatable.HasAnimatedProperties
  - System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference(System.Windows.DependencyObject)
  - System.Windows.Media.ImageSource.PixelsToDIPs(System.Double,System.Int32)
  - System.Windows.Media.ImageSource.System#IFormattable#ToString(System.String,System.IFormatProvider)
  - System.Windows.Media.ImageSource.ToString
  - System.Windows.Media.ImageSource.ToString(System.IFormatProvider)
  - System.Windows.Threading.DispatcherObject.CheckAccess
  - System.Windows.Threading.DispatcherObject.Dispatcher
  - System.Windows.Threading.DispatcherObject.VerifyAccess
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.#ctor
  id: '#ctor'
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: D3DImage()
  nameWithType: D3DImage.D3DImage()
  fullName: System.Windows.Interop.D3DImage.D3DImage()
  type: Constructor
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> classe."
  remarks: "A resolução de ecrã de predefinido é 1/96th polegada."
  syntax:
    content: public D3DImage ();
    parameters: []
  overload: System.Windows.Interop.D3DImage.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)
  id: '#ctor(System.Double,System.Double)'
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: D3DImage(Double,Double)
  nameWithType: D3DImage.D3DImage(Double,Double)
  fullName: System.Windows.Interop.D3DImage.D3DImage(Double,Double)
  type: Constructor
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> classe com a resolução de visualização especificado."
  remarks: "A resolução de ecrã de predefinido é 1/96th polegada."
  syntax:
    content: public D3DImage (double dpiX, double dpiY);
    parameters:
    - id: dpiX
      type: System.Double
      description: "A resolução de apresentação no eixo x."
    - id: dpiY
      type: System.Double
      description: "A resolução de apresentação no eixo y."
  overload: System.Windows.Interop.D3DImage.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>dpiX</code>ou <code>dpiY</code> é menor que zero."
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)
  id: AddDirtyRect(System.Windows.Int32Rect)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: AddDirtyRect(Int32Rect)
  nameWithType: D3DImage.AddDirtyRect(Int32Rect)
  fullName: System.Windows.Interop.D3DImage.AddDirtyRect(Int32Rect)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Especifica a área da memória intermédia back que foram alterados."
  remarks: "Chame o método AddDirtyRect para indicar as alterações de código tem a memória intermédia de back. A compor, a área alterada na memória intermédia de back-tem de ter uma área correspondente foi alterada no <xref:System.Windows.Interop.D3DImage>.</xref:System.Windows.Interop.D3DImage>       Chamar o <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>e <xref:System.Windows.Interop.D3DImage.Lock%2A>métodos antes de chamar o método AddDirtyRect.</xref:System.Windows.Interop.D3DImage.Lock%2A> </xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>       Chamar o <xref:System.Windows.Interop.D3DImage.Unlock%2A>método para copiar as áreas alteradas na memória intermédia de front-.</xref:System.Windows.Interop.D3DImage.Unlock%2A>      > [!NOTE] > Após alguns chamadas para o método de AddDirtyRect, áreas de alteração são intercaladas para uma única área. Isto significa que tem de ter dados válidos fora as áreas foi alteradas."
  example:
  - "The following code example shows how to call the AddDirtyRect method to specify the changed region in the back buffer. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#3](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#3)]"
  syntax:
    content: public void AddDirtyRect (System.Windows.Int32Rect dirtyRect);
    parameters:
    - id: dirtyRect
      type: System.Windows.Int32Rect
      description: "Um <xref href=&quot;System.Windows.Int32Rect&quot;> </xref> que representa a área que foram alterados."
  overload: System.Windows.Interop.D3DImage.AddDirtyRect*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O mapa de bits não tiver sido bloqueado por uma chamada para o <> </> *> ou <> </> *> métodos.       - ou - a memória intermédia de back-não foi atribuída por uma chamada para o <xref:System.Windows.Interop.D3DImage.SetBackBuffer*>método.</xref:System.Windows.Interop.D3DImage.SetBackBuffer*>"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Um ou mais das seguintes condições são VERDADEIRO.       <code>dirtyRect.X</code>&lt; 0       <code>dirtyRect.Y</code> &lt; 0       <code>dirtyRect.Width</code> &lt; 0 or <code>dirtyRect.Width</code> &gt; <>*>       <code>dirtyRect.Height</code> &lt; 0 or <code>dirtyRect.Height</code> &gt;<>*>"
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Clone
  id: Clone
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Clone()
  nameWithType: D3DImage.Clone()
  fullName: System.Windows.Interop.D3DImage.Clone()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Cria um clone modificável deste <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> objeto, efetuar cópias profundas de valores deste objeto. Quando copiar propriedades de dependência, este método copia recursos referências e os dados enlaces (que já não pode ser resolvido), mas não animações ou os respetivos valores atuais."
  remarks: "Este método é utilizado para produzir modificável cópias congeladas <xref:System.Windows.Freezable>objetos (ou qualquer <xref:System.Windows.Freezable>objeto).</xref:System.Windows.Freezable> </xref:System.Windows.Freezable> Para sua comodidade, este método funciona como sombra a versão herdada por uma implementação com tipo seguro.       Para obter mais informações, consulte <xref:System.Windows.Freezable.Clone%2A?displayProperty=fullName>.</xref:System.Windows.Freezable.Clone%2A?displayProperty=fullName>"
  syntax:
    content: public System.Windows.Interop.D3DImage Clone ();
    parameters: []
    return:
      type: System.Windows.Interop.D3DImage
      description: "Um clone modificável do objeto atual. O objeto clonado <> </> *> propriedade serão <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> , mesmo se a origem <> </> *> propriedade foi<xref uid=&quot;langword_csharp_true.&quot; name=&quot;true.&quot; href=&quot;&quot;></xref>"
  overload: System.Windows.Interop.D3DImage.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.CloneCore(System.Windows.Freezable)
  id: CloneCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: CloneCore(Freezable)
  nameWithType: D3DImage.CloneCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.CloneCore(Freezable)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Faz com que a instância de um clone (cópia profunda) de especificado <xref href=&quot;System.Windows.Freezable&quot;> </xref> utilizando valores de propriedade base (não animada)."
  syntax:
    content: protected override void CloneCore (System.Windows.Freezable sourceFreezable);
    parameters:
    - id: sourceFreezable
      type: System.Windows.Freezable
      description: "O objeto a clonagem."
  overload: System.Windows.Interop.D3DImage.CloneCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.CloneCurrentValue
  id: CloneCurrentValue
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: CloneCurrentValue()
  nameWithType: D3DImage.CloneCurrentValue()
  fullName: System.Windows.Interop.D3DImage.CloneCurrentValue()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Cria um clone modificável deste <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> objeto, tornando profundas cópias dos valores atuais deste objeto. As referências de recurso, enlaces de dados e animações não são copiadas, mas os respetivos valores atuais são copiados."
  remarks: "Este método é utilizado para produzir modificável cópias congeladas <xref:System.Windows.Freezable>objetos (ou qualquer <xref:System.Windows.Freezable>objeto).</xref:System.Windows.Freezable> </xref:System.Windows.Freezable> Para sua comodidade, este método funciona como sombra a versão herdada por uma implementação com tipo seguro.       Para obter mais informações, consulte <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=fullName>.</xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=fullName>"
  syntax:
    content: public System.Windows.Interop.D3DImage CloneCurrentValue ();
    parameters: []
    return:
      type: System.Windows.Interop.D3DImage
      description: "Um clone modificável do objeto atual. O objeto clonado <> </> *> propriedade serão <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> , mesmo se a origem <> </> *> propriedade foi <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Interop.D3DImage.CloneCurrentValue*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.CloneCurrentValueCore(System.Windows.Freezable)
  id: CloneCurrentValueCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: CloneCurrentValueCore(Freezable)
  nameWithType: D3DImage.CloneCurrentValueCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.CloneCurrentValueCore(Freezable)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Faz com que a instância de um clone modificável (cópia profunda) de especificado <xref href=&quot;System.Windows.Freezable&quot;> </xref> utilizando valores de propriedade atual."
  syntax:
    content: protected override void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);
    parameters:
    - id: sourceFreezable
      type: System.Windows.Freezable
      description: "O <xref href=&quot;System.Windows.Freezable&quot;> </xref> para ser clonado."
  overload: System.Windows.Interop.D3DImage.CloneCurrentValueCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.CopyBackBuffer
  id: CopyBackBuffer
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: CopyBackBuffer()
  nameWithType: D3DImage.CopyBackBuffer()
  fullName: System.Windows.Interop.D3DImage.CopyBackBuffer()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Cria uma cópia de software do <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>."
  remarks: "O método de CopyBackBuffer é chamado por clientes, tais como o sistema de impressão e a <xref:System.Windows.Media.Imaging.RenderTargetBitmap>classe.</xref:System.Windows.Media.Imaging.RenderTargetBitmap>       Opcionalmente, substitua o método de CopyBackBuffer para implementar a lógica personalizada e devolver um <xref:System.Windows.Media.Imaging.BitmapSource>.</xref:System.Windows.Media.Imaging.BitmapSource> diferentes Por exemplo, pode devolver um marcador de posição <xref:System.Windows.Media.Imaging.BitmapSource>se a implementação de CopyBackBuffer predefinida devolve `null`.</xref:System.Windows.Media.Imaging.BitmapSource>"
  syntax:
    content: protected virtual System.Windows.Media.Imaging.BitmapSource CopyBackBuffer ();
    parameters: []
    return:
      type: System.Windows.Media.Imaging.BitmapSource
      description: "A <xref href=&quot;System.Windows.Media.Imaging.BitmapSource&quot;> </xref> que é uma cópia de software do atual estado da memória intermédia anterior; caso contrário, <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se a memória intermédia de back-não é possível ler."
  overload: System.Windows.Interop.D3DImage.CopyBackBuffer*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.CreateInstanceCore
  id: CreateInstanceCore
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: CreateInstanceCore()
  nameWithType: D3DImage.CreateInstanceCore()
  fullName: System.Windows.Interop.D3DImage.CreateInstanceCore()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Quando implementada numa classe derivada, cria uma nova instância do <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> classe derivada."
  remarks: "Se lhe derivar a <xref:System.Windows.Interop.D3DImage>classe, tem de substituir o método de CreateInstanceCore para ativar a clonagem correto.</xref:System.Windows.Interop.D3DImage> A implementação predefinida efetua uma `return new D3DImage()`, que não será correto se a instância é uma classe diferente."
  syntax:
    content: protected override System.Windows.Freezable CreateInstanceCore ();
    parameters: []
    return:
      type: System.Windows.Freezable
      description: "A nova instância."
  overload: System.Windows.Interop.D3DImage.CreateInstanceCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Finalize
  id: Finalize
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Finalize()
  nameWithType: D3DImage.Finalize()
  fullName: System.Windows.Interop.D3DImage.Finalize()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Liberta recursos e efetuar outras operações de limpeza antes do <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> é reclamada a recolha de lixo."
  remarks: "Este método substitui <xref:System.Object.Finalize%2A>.</xref:System.Object.Finalize%2A> Código da aplicação não deve chamar este método; um objeto `Finalize` método é invocado automaticamente durante a recolha de lixo, a menos que Finalização pelo garbage collector foi desativada por uma chamada para o <xref:System.GC.SuppressFinalize%2A>método.</xref:System.GC.SuppressFinalize%2A>       Para obter mais informações, consulte [finalizar métodos e os processos de destruição](http://msdn.microsoft.com/en-us/fd376774-1643-499b-869e-9546a3aeea70), [recursos não geridos limpeza](~/add/includes/ajax-current-ext-md.md), e [a substituir o método Finalize](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)."
  syntax:
    content: ~D3DImage ();
    parameters: []
  overload: System.Windows.Interop.D3DImage.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.FreezeCore(System.Boolean)
  id: FreezeCore(System.Boolean)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: FreezeCore(Boolean)
  nameWithType: D3DImage.FreezeCore(Boolean)
  fullName: System.Windows.Interop.D3DImage.FreezeCore(Boolean)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Faz com que o <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> unmodifiable ou determina se que pode ser efetuado unmodifiable."
  remarks: "O <xref:System.Windows.Interop.D3DImage>classe não permite freezing porque as alterações são sempre possíveis devido a disponibilidade de memória intermédia front.</xref:System.Windows.Interop.D3DImage>"
  syntax:
    content: protected override sealed bool FreezeCore (bool isChecking);
    parameters:
    - id: isChecking
      type: System.Boolean
      description: "Não tem qualquer efeito."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>em todos os casos."
  overload: System.Windows.Interop.D3DImage.FreezeCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.GetAsFrozenCore(System.Windows.Freezable)
  id: GetAsFrozenCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: GetAsFrozenCore(Freezable)
  nameWithType: D3DImage.GetAsFrozenCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.GetAsFrozenCore(Freezable)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Faz com que a instância de um clone congelado de especificado <xref href=&quot;System.Windows.Freezable&quot;> </xref> utilizando valores de propriedade base (não animada)."
  syntax:
    content: protected override void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);
    parameters:
    - id: sourceFreezable
      type: System.Windows.Freezable
      description: "A instância para copiar."
  overload: System.Windows.Interop.D3DImage.GetAsFrozenCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(System.Windows.Freezable)
  id: GetCurrentValueAsFrozenCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: GetCurrentValueAsFrozenCore(Freezable)
  nameWithType: D3DImage.GetCurrentValueAsFrozenCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(Freezable)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Faz com que a instância atual um clone congelado de especificado <xref href=&quot;System.Windows.Freezable&quot;> </xref>. Se o objeto tem propriedades de dependência animado, os respetivos valores animados atuais são copiados."
  syntax:
    content: protected override void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);
    parameters:
    - id: sourceFreezable
      type: System.Windows.Freezable
      description: "O <xref href=&quot;System.Windows.Freezable&quot;> </xref> para copiar e parar."
  overload: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Height
  id: Height
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Height
  nameWithType: D3DImage.Height
  fullName: System.Windows.Interop.D3DImage.Height
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Obtém a altura do <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>."
  remarks: "O valor de altura pode ser alteradas quando é atribuído um novo back buffer por uma chamada para o <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>método.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>"
  syntax:
    content: public override sealed double Height { get; }
    return:
      type: System.Double
      description: "A altura do <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>, em unidades de medida. Uma unidade de medida é 1/96th polegada."
  overload: System.Windows.Interop.D3DImage.Height*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailable
  id: IsFrontBufferAvailable
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: IsFrontBufferAvailable
  nameWithType: D3DImage.IsFrontBufferAvailable
  fullName: System.Windows.Interop.D3DImage.IsFrontBufferAvailable
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Obtém um valor que indica se uma memória intermédia de front-existe."
  remarks: "Ocasionalmente, a memória intermédia de front-fica indisponível. Esta falta de disponibilidade pode ser causada pelo bloqueio de ecrã, ecrã inteiro exclusivas Direct3D aplicações, a mudança de utilizador ou outras atividades de sistema. Se isto ocorre, a aplicação WPF é notificada através de processamento de <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>eventos.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>  Como a sua aplicação responde na memória intermédia de front-se tornar indisponível depende se WPF está ativada para reverter a composição de software. O <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>método tem uma sobrecarga que assume um parâmetro que especifica se WPF retrocede para composição de software.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Para obter mais informações, consulte observações na <xref:System.Windows.Interop.D3DImage>classe.</xref:System.Windows.Interop.D3DImage>      <a name=&quot;dependencyPropertyInfo_IsFrontBufferAvailable&quot;></a># # Informações de propriedade de dependência |||   |-|-|   | Campo Identificador | <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty>|   | Definir propriedades de metadados `true`| Nenhum |</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty>"
  example:
  - "The following code example shows how to check the IsFrontBufferAvailable property when rendering the composition target. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#2](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#2)]"
  syntax:
    content: public bool IsFrontBufferAvailable { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se existir uma memória intermédia de front; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Interop.D3DImage.IsFrontBufferAvailable*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged
  id: IsFrontBufferAvailableChanged
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: IsFrontBufferAvailableChanged
  nameWithType: D3DImage.IsFrontBufferAvailableChanged
  fullName: System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Ocorre quando o <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailable*>alterações de propriedade.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailable*>"
  remarks: "Processe IsFrontBufferAvailableChanged para ser notificado quando o estado da memória intermédia front é alterado. Como a sua aplicação responde na memória intermédia de front-se tornar indisponível depende se WPF está ativada para reverter a composição de software. O <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>método tem uma sobrecarga que assume um parâmetro que especifica se WPF retrocede para composição de software.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Para obter mais informações, consulte observações na <xref:System.Windows.Interop.D3DImage>classe.</xref:System.Windows.Interop.D3DImage>"
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler IsFrontBufferAvailableChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty
  id: IsFrontBufferAvailableProperty
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: IsFrontBufferAvailableProperty
  nameWithType: D3DImage.IsFrontBufferAvailableProperty
  fullName: System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Identifica o <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailable*>propriedade de dependência.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailable*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsFrontBufferAvailableProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Lock
  id: Lock
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Lock()
  nameWithType: D3DImage.Lock()
  fullName: System.Windows.Interop.D3DImage.Lock()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Bloqueia o <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> e permite operações em memória intermédia back."
  remarks: "Chamar o método de bloqueio para alterar a fundo da memória intermédia ao chamar o <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A>e <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>métodos.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> </xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> Enquanto o <xref:System.Windows.Interop.D3DImage>é bloqueada, a aplicação pode também compor para a superfície de Direct3D atribuída na memória intermédia de back-.</xref:System.Windows.Interop.D3DImage>      > [!NOTE] > Bloqueia o método Lock o quando o sistema de composição está a ler a memória intermédia de back-atualizar a memória intermédia de front. Utilize o <xref:System.Windows.Interop.D3DImage.TryLock%2A>método para evitar bloquear indefinidamente.</xref:System.Windows.Interop.D3DImage.TryLock%2A>"
  example:
  - "The following code example shows how to call the Lock method to enable updates to the back buffer. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#3](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#3)]"
  syntax:
    content: public void Lock ();
    parameters: []
  overload: System.Windows.Interop.D3DImage.Lock*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A contagem de bloqueios <xref:System.UInt32.MaxValue>.</xref:System.UInt32.MaxValue> de é igual a"
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Metadata
  id: Metadata
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Metadata
  nameWithType: D3DImage.Metadata
  fullName: System.Windows.Interop.D3DImage.Metadata
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Obtém os metadados associados a origem da imagem."
  syntax:
    content: public override sealed System.Windows.Media.ImageMetadata Metadata { get; }
    return:
      type: System.Windows.Media.ImageMetadata
      description: "<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>em todos os casos."
  overload: System.Windows.Interop.D3DImage.Metadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.PixelHeight
  id: PixelHeight
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: PixelHeight
  nameWithType: D3DImage.PixelHeight
  fullName: System.Windows.Interop.D3DImage.PixelHeight
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Obtém a altura do <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>, em pixels."
  remarks: "O valor de PixelHeight pode ser alteradas quando é atribuído um novo back buffer por uma chamada para o <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>método.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>"
  example:
  - "The following code example shows how to use the PixelHeight property to specify the changed region in the back buffer. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#3](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#3)]"
  syntax:
    content: public int PixelHeight { get; }
    return:
      type: System.Int32
      description: "A altura do <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>, em pixels."
  overload: System.Windows.Interop.D3DImage.PixelHeight*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.PixelWidth
  id: PixelWidth
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: PixelWidth
  nameWithType: D3DImage.PixelWidth
  fullName: System.Windows.Interop.D3DImage.PixelWidth
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Obtém a largura do <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>, em pixels."
  remarks: "O valor de PixelWidth pode ser alteradas quando é atribuído um novo back buffer por uma chamada para o <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>método.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>"
  example:
  - "The following code example shows how to use the PixelWidth property to specify the changed region in the back buffer. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#3](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#3)]"
  syntax:
    content: public int PixelWidth { get; }
    return:
      type: System.Int32
      description: "A largura do <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>, em pixels."
  overload: System.Windows.Interop.D3DImage.PixelWidth*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)
  id: SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: SetBackBuffer(D3DResourceType,IntPtr)
  nameWithType: D3DImage.SetBackBuffer(D3DResourceType,IntPtr)
  fullName: System.Windows.Interop.D3DImage.SetBackBuffer(D3DResourceType,IntPtr)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Atribui uma superfície Direct3D como origem da memória intermédia anterior."
  remarks: "Chame o método SetBackBuffer para atribuir uma superfície Direct3D na memória intermédia de fundo.      > [!NOTE] > Desempenho depende significativamente a superfície de Direct3D as definições. Para obter mais informações, consulte [considerações de desempenho para Direct3D9 e interoperabilidade do WPF](~/add/includes/ajax-current-ext-md.md).       Chamar a sobrecarga de SetBackBuffer é idêntico ao chamar o <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>sobrecarga com o `enableSoftwareFallback` parâmetro definido como `false`.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> Quando chamar SetBackBuffer ou chamada <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>com o `enableSoftwareFallback` parâmetro definido como `false`, o sistema de composição a referência da memória intermédia de back-de versões, quando a memória intermédia de front-fica indisponível e não será apresentado nada.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> Quando a memória intermédia de front-estiver novamente disponível, o sistema de composição gera o <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>eventos ao notificar a sua aplicação WPF.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>  Pode criar um processador de eventos para o <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>eventos reiniciar composição novamente com uma superfície de Direct3D válida.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> Para reiniciar composição, tem de chamar SetBackBuffer.       A lista seguinte mostra as definições de memória intermédia de back-necessário para o `IDirect3DSurface9` tipo.      - `D3DFMT_A8R8G8B8` ou `D3DFMT_X8R8G8B8`       -    `D3DUSAGE_RENDERTARGET`       -    `D3DPOOL_DEFAULT` Multisampling é permitido em `IDirect3DSurface9Ex` analisa apenas."
  example:
  - "The following code example shows how to call the SetBackBuffer method to assign a Direct3D surface. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#3](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#3)]"
  syntax:
    content: public void SetBackBuffer (System.Windows.Interop.D3DResourceType backBufferType, IntPtr backBuffer);
    parameters:
    - id: backBufferType
      type: System.Windows.Interop.D3DResourceType
      description: "O tipo de Direct3D superfície. Tem de ser um válido <xref href=&quot;System.Windows.Interop.D3DResourceType&quot;> </xref>."
    - id: backBuffer
      type: System.IntPtr
      description: "A superfície de Direct3D atribuir como a fundo da memória intermédia."
  overload: System.Windows.Interop.D3DImage.SetBackBuffer*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> não tiver sido bloqueado por uma chamada para o <> </> *> ou <> </> *> métodos."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>backBufferType</code>Não é um <xref href=&quot;System.Windows.Interop.D3DResourceType&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Os parâmetros de criação para <code> backBuffer </code> não cumprem os requisitos para o <code> backBufferType </code>- ou -o <code> backBuffer </code> não é válido."
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)
  id: SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: SetBackBuffer(D3DResourceType,IntPtr,Boolean)
  nameWithType: D3DImage.SetBackBuffer(D3DResourceType,IntPtr,Boolean)
  fullName: System.Windows.Interop.D3DImage.SetBackBuffer(D3DResourceType,IntPtr,Boolean)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Atribui uma superfície Direct3D como origem da memória intermédia anterior."
  remarks: "Quando chamar o <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29>sobrecarga ou chame a sobrecarga de SetBackBuffer com o `enableSoftwareFallback` parâmetro definido como `false`, o sistema de composição disponibiliza a referência da memória intermédia de back-quando a memória intermédia de front-fica indisponível e não será apresentado nada.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> Quando a memória intermédia de front-estiver novamente disponível, o sistema de composição gera o <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>eventos ao notificar a sua aplicação WPF.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>  Pode criar um processador de eventos para o <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>eventos reiniciar composição novamente com uma superfície de Direct3D válida.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> Para reiniciar composição, tem de chamar <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>       Quando chamar SetBackBuffer com o `enableSoftwareFallback` parâmetro definido como `true`, o sistema de composição mantém a referência da memória intermédia de back-quando a memória intermédia de front-fica indisponível, pelo que não é necessário chamar <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>quando a memória intermédia de front-esteja novamente disponível.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>  Poderão existir situações em que o dispositivo do utilizador fica indisponível.  Quando isso ocorrer, chamar <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>para libertar a referência do WPF na memória intermédia de back-.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>  Se precisar de repor o seu dispositivo, chamar <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>com `backBuffer` definido como `null`e, em seguida, chame <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>com `backBuffer` definido como uma superfície Direct3D válida.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> </xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>       A lista seguinte mostra as definições de memória intermédia de back-necessário para o `IDirect3DSurface9` tipo.      - `D3DFMT_A8R8G8B8` ou `D3DFMT_X8R8G8B8`       -    `D3DUSAGE_RENDERTARGET`       -    `D3DPOOL_DEFAULT` Multisampling é permitido em `IDirect3DSurface9Ex` analisa apenas."
  syntax:
    content: public void SetBackBuffer (System.Windows.Interop.D3DResourceType backBufferType, IntPtr backBuffer, bool enableSoftwareFallback);
    parameters:
    - id: backBufferType
      type: System.Windows.Interop.D3DResourceType
      description: "O tipo de Direct3D superfície. Tem de ser um válido <xref href=&quot;System.Windows.Interop.D3DResourceType&quot;> </xref>."
    - id: backBuffer
      type: System.IntPtr
      description: "A superfície de Direct3D atribuir como a fundo da memória intermédia."
    - id: enableSoftwareFallback
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Para reverter na composição do software; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Interop.D3DImage.SetBackBuffer*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)
  id: TryLock(System.Windows.Duration)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: TryLock(Duration)
  nameWithType: D3DImage.TryLock(Duration)
  fullName: System.Windows.Interop.D3DImage.TryLock(Duration)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Tenta bloquear o <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> e aguarda que a duração especificada."
  syntax:
    content: public bool TryLock (System.Windows.Duration timeout);
    parameters:
    - id: timeout
      type: System.Windows.Duration
      description: "A duração para aguardar a aquisição do bloqueio."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o bloqueio foi adquirido; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Interop.D3DImage.TryLock*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>timeout</code>está definido como <xref:System.Windows.Duration.Automatic*>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A contagem de bloqueios <xref:System.UInt32.MaxValue>.</xref:System.UInt32.MaxValue> de é igual a"
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Unlock
  id: Unlock
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Unlock()
  nameWithType: D3DImage.Unlock()
  fullName: System.Windows.Interop.D3DImage.Unlock()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "É decrementada o bloqueio de contagem do <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>."
  remarks: "Quando o bloqueio de contagem do <xref:System.Windows.Interop.D3DImage>atingir zero, o <xref:System.Windows.Interop.D3DImage>é totalmente desbloqueada.</xref:System.Windows.Interop.D3DImage> </xref:System.Windows.Interop.D3DImage> O <xref:System.Windows.Interop.D3DImage>está marcado para compor se a imagem foi alterada áreas que foram especificadas anterior chamadas para o <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A>método.</xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> </xref:System.Windows.Interop.D3DImage>       Quando as alterações forem consolidadas e ocorre de composição, chamadas adicionais para o <xref:System.Windows.Interop.D3DImage.Lock%2A>blocos de método até que o thread de composição tem de copiar o conteúdo da memória intermédia back-na memória intermédia de front-.</xref:System.Windows.Interop.D3DImage.Lock%2A> Esta sincronização evita a apresentação artefactos, tais como, é necessário remover.      > [!NOTE] > Não atualizar a superfície de Direct3D enquanto o <xref:System.Windows.Interop.D3DImage>está desbloqueado.</xref:System.Windows.Interop.D3DImage>"
  example:
  - "The following code example shows how to call the Unlock method to copy the updated back buffer to the front buffer. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#3](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#3)]"
  syntax:
    content: public void Unlock ();
    parameters: []
  overload: System.Windows.Interop.D3DImage.Unlock*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Width
  id: Width
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Width
  nameWithType: D3DImage.Width
  fullName: System.Windows.Interop.D3DImage.Width
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Obtém a largura do <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>."
  remarks: "O valor da largura pode ser alteradas quando é atribuído um novo back buffer por uma chamada para o <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>método.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>"
  syntax:
    content: public override sealed double Width { get; }
    return:
      type: System.Double
      description: "A largura do <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>, em unidades de medida. Uma unidade de medida é 1/96th polegada."
  overload: System.Windows.Interop.D3DImage.Width*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.Media.ImageSource
  isExternal: false
  name: System.Windows.Media.ImageSource
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Windows.Interop.D3DImage.#ctor
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: D3DImage()
  nameWithType: D3DImage.D3DImage()
  fullName: System.Windows.Interop.D3DImage.D3DImage()
- uid: System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: D3DImage(Double,Double)
  nameWithType: D3DImage.D3DImage(Double,Double)
  fullName: System.Windows.Interop.D3DImage.D3DImage(Double,Double)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: AddDirtyRect(Int32Rect)
  nameWithType: D3DImage.AddDirtyRect(Int32Rect)
  fullName: System.Windows.Interop.D3DImage.AddDirtyRect(Int32Rect)
- uid: System.Windows.Int32Rect
  parent: System.Windows
  isExternal: false
  name: Int32Rect
  nameWithType: Int32Rect
  fullName: System.Windows.Int32Rect
- uid: System.Windows.Interop.D3DImage.Clone
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Clone()
  nameWithType: D3DImage.Clone()
  fullName: System.Windows.Interop.D3DImage.Clone()
- uid: System.Windows.Interop.D3DImage
  parent: System.Windows.Interop
  isExternal: false
  name: D3DImage
  nameWithType: D3DImage
  fullName: System.Windows.Interop.D3DImage
- uid: System.Windows.Interop.D3DImage.CloneCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CloneCore(Freezable)
  nameWithType: D3DImage.CloneCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.CloneCore(Freezable)
- uid: System.Windows.Freezable
  parent: System.Windows
  isExternal: false
  name: Freezable
  nameWithType: Freezable
  fullName: System.Windows.Freezable
- uid: System.Windows.Interop.D3DImage.CloneCurrentValue
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CloneCurrentValue()
  nameWithType: D3DImage.CloneCurrentValue()
  fullName: System.Windows.Interop.D3DImage.CloneCurrentValue()
- uid: System.Windows.Interop.D3DImage.CloneCurrentValueCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CloneCurrentValueCore(Freezable)
  nameWithType: D3DImage.CloneCurrentValueCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.CloneCurrentValueCore(Freezable)
- uid: System.Windows.Interop.D3DImage.CopyBackBuffer
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CopyBackBuffer()
  nameWithType: D3DImage.CopyBackBuffer()
  fullName: System.Windows.Interop.D3DImage.CopyBackBuffer()
- uid: System.Windows.Media.Imaging.BitmapSource
  parent: System.Windows.Media.Imaging
  isExternal: false
  name: BitmapSource
  nameWithType: BitmapSource
  fullName: System.Windows.Media.Imaging.BitmapSource
- uid: System.Windows.Interop.D3DImage.CreateInstanceCore
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CreateInstanceCore()
  nameWithType: D3DImage.CreateInstanceCore()
  fullName: System.Windows.Interop.D3DImage.CreateInstanceCore()
- uid: System.Windows.Interop.D3DImage.Finalize
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Finalize()
  nameWithType: D3DImage.Finalize()
  fullName: System.Windows.Interop.D3DImage.Finalize()
- uid: System.Windows.Interop.D3DImage.FreezeCore(System.Boolean)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: FreezeCore(Boolean)
  nameWithType: D3DImage.FreezeCore(Boolean)
  fullName: System.Windows.Interop.D3DImage.FreezeCore(Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.Interop.D3DImage.GetAsFrozenCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: GetAsFrozenCore(Freezable)
  nameWithType: D3DImage.GetAsFrozenCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.GetAsFrozenCore(Freezable)
- uid: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: GetCurrentValueAsFrozenCore(Freezable)
  nameWithType: D3DImage.GetCurrentValueAsFrozenCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(Freezable)
- uid: System.Windows.Interop.D3DImage.Height
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Height
  nameWithType: D3DImage.Height
  fullName: System.Windows.Interop.D3DImage.Height
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailable
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: IsFrontBufferAvailable
  nameWithType: D3DImage.IsFrontBufferAvailable
  fullName: System.Windows.Interop.D3DImage.IsFrontBufferAvailable
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: IsFrontBufferAvailableChanged
  nameWithType: D3DImage.IsFrontBufferAvailableChanged
  fullName: System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged
- uid: System.Windows.DependencyPropertyChangedEventHandler
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyChangedEventHandler
  nameWithType: DependencyPropertyChangedEventHandler
  fullName: System.Windows.DependencyPropertyChangedEventHandler
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: IsFrontBufferAvailableProperty
  nameWithType: D3DImage.IsFrontBufferAvailableProperty
  fullName: System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Windows.Interop.D3DImage.Lock
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Lock()
  nameWithType: D3DImage.Lock()
  fullName: System.Windows.Interop.D3DImage.Lock()
- uid: System.Windows.Interop.D3DImage.Metadata
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Metadata
  nameWithType: D3DImage.Metadata
  fullName: System.Windows.Interop.D3DImage.Metadata
- uid: System.Windows.Media.ImageMetadata
  parent: System.Windows.Media
  isExternal: false
  name: ImageMetadata
  nameWithType: ImageMetadata
  fullName: System.Windows.Media.ImageMetadata
- uid: System.Windows.Interop.D3DImage.PixelHeight
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: PixelHeight
  nameWithType: D3DImage.PixelHeight
  fullName: System.Windows.Interop.D3DImage.PixelHeight
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.Interop.D3DImage.PixelWidth
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: PixelWidth
  nameWithType: D3DImage.PixelWidth
  fullName: System.Windows.Interop.D3DImage.PixelWidth
- uid: System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: SetBackBuffer(D3DResourceType,IntPtr)
  nameWithType: D3DImage.SetBackBuffer(D3DResourceType,IntPtr)
  fullName: System.Windows.Interop.D3DImage.SetBackBuffer(D3DResourceType,IntPtr)
- uid: System.Windows.Interop.D3DResourceType
  parent: System.Windows.Interop
  isExternal: false
  name: D3DResourceType
  nameWithType: D3DResourceType
  fullName: System.Windows.Interop.D3DResourceType
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: SetBackBuffer(D3DResourceType,IntPtr,Boolean)
  nameWithType: D3DImage.SetBackBuffer(D3DResourceType,IntPtr,Boolean)
  fullName: System.Windows.Interop.D3DImage.SetBackBuffer(D3DResourceType,IntPtr,Boolean)
- uid: System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: TryLock(Duration)
  nameWithType: D3DImage.TryLock(Duration)
  fullName: System.Windows.Interop.D3DImage.TryLock(Duration)
- uid: System.Windows.Duration
  parent: System.Windows
  isExternal: false
  name: Duration
  nameWithType: Duration
  fullName: System.Windows.Duration
- uid: System.Windows.Interop.D3DImage.Unlock
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Unlock()
  nameWithType: D3DImage.Unlock()
  fullName: System.Windows.Interop.D3DImage.Unlock()
- uid: System.Windows.Interop.D3DImage.Width
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Width
  nameWithType: D3DImage.Width
  fullName: System.Windows.Interop.D3DImage.Width
- uid: System.Windows.Interop.D3DImage.#ctor*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: D3DImage
  nameWithType: D3DImage.D3DImage
- uid: System.Windows.Interop.D3DImage.AddDirtyRect*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: AddDirtyRect
  nameWithType: D3DImage.AddDirtyRect
- uid: System.Windows.Interop.D3DImage.Clone*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Clone
  nameWithType: D3DImage.Clone
- uid: System.Windows.Interop.D3DImage.CloneCore*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CloneCore
  nameWithType: D3DImage.CloneCore
- uid: System.Windows.Interop.D3DImage.CloneCurrentValue*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CloneCurrentValue
  nameWithType: D3DImage.CloneCurrentValue
- uid: System.Windows.Interop.D3DImage.CloneCurrentValueCore*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CloneCurrentValueCore
  nameWithType: D3DImage.CloneCurrentValueCore
- uid: System.Windows.Interop.D3DImage.CopyBackBuffer*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CopyBackBuffer
  nameWithType: D3DImage.CopyBackBuffer
- uid: System.Windows.Interop.D3DImage.CreateInstanceCore*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CreateInstanceCore
  nameWithType: D3DImage.CreateInstanceCore
- uid: System.Windows.Interop.D3DImage.Finalize*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Finalize
  nameWithType: D3DImage.Finalize
- uid: System.Windows.Interop.D3DImage.FreezeCore*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: FreezeCore
  nameWithType: D3DImage.FreezeCore
- uid: System.Windows.Interop.D3DImage.GetAsFrozenCore*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: GetAsFrozenCore
  nameWithType: D3DImage.GetAsFrozenCore
- uid: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: GetCurrentValueAsFrozenCore
  nameWithType: D3DImage.GetCurrentValueAsFrozenCore
- uid: System.Windows.Interop.D3DImage.Height*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Height
  nameWithType: D3DImage.Height
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailable*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: IsFrontBufferAvailable
  nameWithType: D3DImage.IsFrontBufferAvailable
- uid: System.Windows.Interop.D3DImage.Lock*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Lock
  nameWithType: D3DImage.Lock
- uid: System.Windows.Interop.D3DImage.Metadata*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Metadata
  nameWithType: D3DImage.Metadata
- uid: System.Windows.Interop.D3DImage.PixelHeight*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: PixelHeight
  nameWithType: D3DImage.PixelHeight
- uid: System.Windows.Interop.D3DImage.PixelWidth*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: PixelWidth
  nameWithType: D3DImage.PixelWidth
- uid: System.Windows.Interop.D3DImage.SetBackBuffer*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: SetBackBuffer
  nameWithType: D3DImage.SetBackBuffer
- uid: System.Windows.Interop.D3DImage.TryLock*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: TryLock
  nameWithType: D3DImage.TryLock
- uid: System.Windows.Interop.D3DImage.Unlock*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Unlock
  nameWithType: D3DImage.Unlock
- uid: System.Windows.Interop.D3DImage.Width*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Width
  nameWithType: D3DImage.Width
