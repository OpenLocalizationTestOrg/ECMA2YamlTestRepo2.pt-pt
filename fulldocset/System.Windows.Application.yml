### YamlMime:ManagedReference
items:
- uid: System.Windows.Application
  id: Application
  children:
  - System.Windows.Application.#ctor
  - System.Windows.Application.Activated
  - System.Windows.Application.Current
  - System.Windows.Application.Deactivated
  - System.Windows.Application.DispatcherUnhandledException
  - System.Windows.Application.Exit
  - System.Windows.Application.FindResource(System.Object)
  - System.Windows.Application.FragmentNavigation
  - System.Windows.Application.GetContentStream(System.Uri)
  - System.Windows.Application.GetCookie(System.Uri)
  - System.Windows.Application.GetRemoteStream(System.Uri)
  - System.Windows.Application.GetResourceStream(System.Uri)
  - System.Windows.Application.LoadCompleted
  - System.Windows.Application.LoadComponent(System.Uri)
  - System.Windows.Application.LoadComponent(System.Object,System.Uri)
  - System.Windows.Application.MainWindow
  - System.Windows.Application.Navigated
  - System.Windows.Application.Navigating
  - System.Windows.Application.NavigationFailed
  - System.Windows.Application.NavigationProgress
  - System.Windows.Application.NavigationStopped
  - System.Windows.Application.OnActivated(System.EventArgs)
  - System.Windows.Application.OnDeactivated(System.EventArgs)
  - System.Windows.Application.OnExit(System.Windows.ExitEventArgs)
  - System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)
  - System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)
  - System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)
  - System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)
  - System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)
  - System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)
  - System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)
  - System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)
  - System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)
  - System.Windows.Application.Properties
  - System.Windows.Application.ResourceAssembly
  - System.Windows.Application.Resources
  - System.Windows.Application.Run
  - System.Windows.Application.Run(System.Windows.Window)
  - System.Windows.Application.SessionEnding
  - System.Windows.Application.SetCookie(System.Uri,System.String)
  - System.Windows.Application.Shutdown
  - System.Windows.Application.Shutdown(System.Int32)
  - System.Windows.Application.ShutdownMode
  - System.Windows.Application.Startup
  - System.Windows.Application.StartupUri
  - System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  - System.Windows.Application.TryFindResource(System.Object)
  - System.Windows.Application.Windows
  langs:
  - csharp
  name: Application
  nameWithType: Application
  fullName: System.Windows.Application
  type: Class
  summary: "Encapsula uma [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] aplicação."
  remarks: "Aplicação é uma classe que encapsula [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] funcionalidades específicas da aplicação, incluindo o seguinte:- **aplicação duração**: <xref:System.Windows.Application.Activated>, <xref:System.Windows.Application.Current%2A> <xref:System.Windows.Application.Deactivated>, <xref:System.Windows.Application.DispatcherUnhandledException> <xref:System.Windows.Application.Exit>, <xref:System.Windows.Application.Run%2A> <xref:System.Windows.Application.SessionEnding>, <xref:System.Windows.Application.Shutdown%2A> <xref:System.Windows.Application.ShutdownMode%2A>, <xref:System.Windows.Application.Startup>.</xref:System.Windows.Application.Startup> </xref:System.Windows.Application.ShutdownMode%2A> </xref:System.Windows.Application.Shutdown%2A> </xref:System.Windows.Application.SessionEnding> </xref:System.Windows.Application.Run%2A> </xref:System.Windows.Application.Exit> </xref:System.Windows.Application.DispatcherUnhandledException> </xref:System.Windows.Application.Deactivated> </xref:System.Windows.Application.Current%2A> </xref:System.Windows.Application.Activated>      - **Janela de âmbito de aplicação, propriedades e gestão de recursos**: <xref:System.Windows.Application.FindResource%2A>, <xref:System.Windows.Application.GetContentStream%2A> <xref:System.Windows.Application.GetResourceStream%2A>, <xref:System.Windows.Application.LoadComponent%2A> <xref:System.Windows.Application.MainWindow%2A>, <xref:System.Windows.Application.Properties%2A> <xref:System.Windows.Application.Resources%2A>, <xref:System.Windows.Application.StartupUri%2A> <xref:System.Windows.Application.Windows%2A>.</xref:System.Windows.Application.Windows%2A> </xref:System.Windows.Application.StartupUri%2A> </xref:System.Windows.Application.Resources%2A> </xref:System.Windows.Application.Properties%2A> </xref:System.Windows.Application.MainWindow%2A> </xref:System.Windows.Application.LoadComponent%2A> </xref:System.Windows.Application.GetResourceStream%2A> </xref:System.Windows.Application.GetContentStream%2A> </xref:System.Windows.Application.FindResource%2A>      - **Parâmetro da linha de comandos e saída código processamento**: <xref:System.Windows.Application.Startup?displayProperty=fullName>, <xref:System.Windows.Application.Exit?displayProperty=fullName> <xref:System.Windows.Application.Shutdown%2A?displayProperty=fullName>.</xref:System.Windows.Application.Shutdown%2A?displayProperty=fullName> </xref:System.Windows.Application.Exit?displayProperty=fullName> </xref:System.Windows.Application.Startup?displayProperty=fullName>      -   **Navigation**: <xref:System.Windows.Application.FragmentNavigation>, <xref:System.Windows.Application.LoadCompleted>, <xref:System.Windows.Application.Navigated>, <xref:System.Windows.Application.Navigating>, <xref:System.Windows.Application.NavigationProgress>, <xref:System.Windows.Application.NavigationStopped>, <xref:System.Windows.Application.NavigationFailed>, <xref:System.Windows.Application.SetCookie%2A>, <xref:System.Windows.Application.GetCookie%2A>.</xref:System.Windows.Application.GetCookie%2A></xref:System.Windows.Application.SetCookie%2A></xref:System.Windows.Application.NavigationFailed></xref:System.Windows.Application.NavigationStopped></xref:System.Windows.Application.NavigationProgress></xref:System.Windows.Application.Navigating></xref:System.Windows.Application.Navigated></xref:System.Windows.Application.LoadCompleted></xref:System.Windows.Application.FragmentNavigation>       Aplicação implementa o padrão de singleton para fornecer acesso partilhado a respetiva janela, propriedades e os serviços de âmbito de recursos. Por conseguinte, apenas uma instância da classe de aplicação pode ser criada por <xref:System.AppDomain>.</xref:System.AppDomain>       Pode implementar uma aplicação utilizando o markup, marcação e code-behind ou código. Se a aplicação estiver implementada com markup, se markup ou a marcação e por detrás do código, o ficheiro de marcação tem de ser configurado como um [!INCLUDE[TLA#tla_msbuild](~/add/includes/tlasharptla-msbuild-md.md)] `ApplicationDefinition` item.      > [!NOTE] > Uma aplicação autónoma não necessita de um objeto de aplicação; é possível implementar um personalizado `static` o método de ponto de entrada (`Main`) que se abre uma janela sem criar uma instância da aplicação. No entanto, [!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)] necessitam de um objeto de aplicação."
  example:
  - "The following example shows how a standard application is defined using only markup:  \n  \n [!code-xml[ApplicationSnippets#ApplicationMARKUP](~/add/codesnippet/xaml/ApplicationSnippets.CSharp/AppMarkup.xaml#applicationmarkup)]  \n  \n The following example shows how a standard application is defined using only code:  \n  \n [!code-cs[ApplicationSnippets#ApplicationCODE](~/add/codesnippet/csharp/ApplicationSnippets.CSharp/AppCode.cs#applicationcode)]\n [!code-vb[ApplicationSnippets#ApplicationCODE](~/add/codesnippet/visualbasic/applicationsnippets/appcode.vb#applicationcode)]  \n  \n The following example shows how a standard application is defined using a combination of markup and code-behind.  \n  \n [!code-xml[ApplicationSnippets#ApplicationXAML](~/add/codesnippet/xaml/ApplicationSnippets.CSharp/App.xaml#applicationxaml)]  \n  \n [!code-cs[ApplicationSnippets#ApplicationCODEBEHIND](~/add/codesnippet/csharp/ApplicationSnippets.CSharp/App.xaml.cs#applicationcodebehind)]\n [!code-vb[ApplicationSnippets#ApplicationCODEBEHIND](~/add/codesnippet/visualbasic/applicationsnippets/application.xaml.vb#applicationcodebehind)]"
  syntax:
    content: 'public class Application : System.Windows.Threading.DispatcherObject, System.Windows.Markup.IQueryAmbient'
  inheritance:
  - System.Object
  - System.Windows.Threading.DispatcherObject
  implements:
  - System.Windows.Markup.IQueryAmbient
  inheritedMembers:
  - System.Windows.Threading.DispatcherObject.CheckAccess
  - System.Windows.Threading.DispatcherObject.Dispatcher
  - System.Windows.Threading.DispatcherObject.VerifyAccess
  platform:
  - net462
- uid: System.Windows.Application.#ctor
  id: '#ctor'
  parent: System.Windows.Application
  langs:
  - csharp
  name: Application()
  nameWithType: Application.Application()
  fullName: System.Windows.Application.Application()
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Windows.Application&quot;> </xref> classe."
  remarks: "Apenas uma instância de <xref:System.Windows.Application>classe pode ser criada por <xref:System.AppDomain>, para garantir acesso partilhado para um único conjunto de dados de janela, propriedades e recursos de âmbito de aplicação.</xref:System.AppDomain> </xref:System.Windows.Application> Por conseguinte, o construtor predefinido da <xref:System.Windows.Application>classe Deteta se a instância a ser inicializada é a primeira instância num <xref:System.AppDomain>; se não, é um <xref:System.InvalidOperationException>é emitida.</xref:System.InvalidOperationException> </xref:System.AppDomain> </xref:System.Windows.Application>       O <xref:System.Windows.Application>objeto para o atual <xref:System.AppDomain>está exposta a partir de estática <xref:System.Windows.Application.Current%2A>propriedade.</xref:System.Windows.Application.Current%2A> </xref:System.AppDomain> </xref:System.Windows.Application>"
  syntax:
    content: public Application ();
    parameters: []
  overload: System.Windows.Application.#ctor*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Mais do que uma instância do <xref href=&quot;System.Windows.Application&quot;> </xref> classe é criada por <xref href=&quot;System.AppDomain&quot;> </xref>."
  platform:
  - net462
- uid: System.Windows.Application.Activated
  id: Activated
  parent: System.Windows.Application
  langs:
  - csharp
  name: Activated
  nameWithType: Application.Activated
  fullName: System.Windows.Application.Activated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando uma aplicação torna-se a aplicação de primeiro plano."
  remarks: "A [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] aplicação que tem um ou mais windows abertas está ativada (torna-se a aplicação de primeiro plano) quando uma das janelas da é ativada pela primeira vez, uma vez que a aplicação foi lançada, ou quando um do windows está ativado enquanto a aplicação está inativa: especificamente, ocorre a ativação quando:-uma aplicação abre-se a primeira janela.      -Um utilizador muda para a aplicação utilizando ALT + TAB ou utilizando o Gestor de tarefas.      -Um utilizador clica no botão de barra de tarefas para uma das janelas numa aplicação.       Aplicações que precisem de detetar quando que ativam podem processar o evento de ativado.       Depois de uma aplicação é ativada pela primeira vez, podem ser desativado e reativado demasiadas vezes durante o período de vida. Se o comportamento de uma aplicação ou estado depende do Estado de ativação, pode processar ativado e <xref:System.Windows.Application.Deactivated>eventos para determinar que a ativação do suplemento de estado</xref:System.Windows.Application.Deactivated>       Depois de uma aplicação fica ativa, ativado não será gerado novamente até que a aplicação ter sido desativada, independentemente de quantas windows numa aplicação são ativados enquanto a aplicação está ativa.       Ativado não é gerado para [!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)]."
  example:
  - "The following example shows how to detect when a standalone application activates and deactivates.  \n  \n [!code-xml[ApplicationActivationSnippets#DetectActivationStateXAML](~/add/codesnippet/xaml/ApplicationActivationSnippets.CSharp/App.xaml#detectactivationstatexaml)]  \n  \n [!code-cs[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/add/codesnippet/csharp/ApplicationActivationSnippets.CSharp/App.xaml.cs#detectactivationstatecodebehind)]\n [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/add/codesnippet/visualbasic/applicationactivationsnippets/application.xaml.vb#detectactivationstatecodebehind)]"
  syntax:
    content: public event EventHandler Activated;
    return:
      type: System.EventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Current
  id: Current
  parent: System.Windows.Application
  langs:
  - csharp
  name: Current
  nameWithType: Application.Current
  fullName: System.Windows.Application.Current
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém o <xref href=&quot;System.Windows.Application&quot;> </xref> objeto para o atual <xref href=&quot;System.AppDomain&quot;> </xref>."
  remarks: "<xref:System.Windows.Application>é um por-<xref:System.AppDomain> tipo singleton que implementa a propriedade atual estática para fornecer acesso partilhado para a <xref:System.Windows.Application>instância para o atual <xref:System.AppDomain>.</xref:System.AppDomain> </xref:System.Windows.Application> </xref:System.AppDomain></xref:System.Windows.Application> Esta estrutura garante que esse estado gerido pelo <xref:System.Windows.Application>, incluindo o estado e de recursos partilhados, está disponível a partir de uma localização única e partilhada.</xref:System.Windows.Application>       Esta propriedade é seguros para threads e está disponível a partir de qualquer thread."
  syntax:
    content: public static System.Windows.Application Current { get; }
    return:
      type: System.Windows.Application
      description: "O <xref href=&quot;System.Windows.Application&quot;> </xref> objeto para o atual <xref href=&quot;System.AppDomain&quot;> </xref>."
  overload: System.Windows.Application.Current*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Deactivated
  id: Deactivated
  parent: System.Windows.Application
  langs:
  - csharp
  name: Deactivated
  nameWithType: Application.Deactivated
  fullName: System.Windows.Application.Deactivated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando uma aplicação deixa de ser a aplicação de primeiro plano."
  remarks: "A [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] aplicação que tem um ou mais windows abertas desativa (deixa de ser a aplicação de primeiro plano) quando um utilizador faz o seguinte:-muda para outra aplicação utilizando ALT + TAB ou utilizando o Gestor de tarefas.      -Clica no botão de barra de tarefas para uma janela de outra aplicação.       Aplicações que precisem de desativação de detetar podem processar o evento de desativado.       Depois de uma aplicação é ativada pela primeira vez, podem ser desativado e reativado demasiadas vezes durante o período de vida. Se o comportamento de uma aplicação ou estado depende do Estado de ativação, pode processar ambas desativado e <xref:System.Windows.Application.Activated>eventos para determinar quais estipulam é suplemento</xref:System.Windows.Application.Activated>       Desativado não é gerado para [!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)]."
  example:
  - "The following example shows how to detect when a standalone application deactivates and activates.  \n  \n [!code-xml[ApplicationActivationSnippets#DetectActivationStateXAML](~/add/codesnippet/xaml/ApplicationActivationSnippets.CSharp/App.xaml#detectactivationstatexaml)]  \n  \n [!code-cs[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/add/codesnippet/csharp/ApplicationActivationSnippets.CSharp/App.xaml.cs#detectactivationstatecodebehind)]\n [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/add/codesnippet/visualbasic/applicationactivationsnippets/application.xaml.vb#detectactivationstatecodebehind)]"
  syntax:
    content: public event EventHandler Deactivated;
    return:
      type: System.EventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.DispatcherUnhandledException
  id: DispatcherUnhandledException
  parent: System.Windows.Application
  langs:
  - csharp
  name: DispatcherUnhandledException
  nameWithType: Application.DispatcherUnhandledException
  fullName: System.Windows.Application.DispatcherUnhandledException
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando uma exceção é emitida por uma aplicação, mas não processada."
  remarks: "Por predefinição, [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] intercete exceções não processadas, notifica os utilizadores da exceção de uma caixa de diálogo (partir do qual se podem reportar a exceção) e uma aplicação será automaticamente encerrado.       No entanto, se uma aplicação precisa de realizar uma excepção não processada personalizada de processamento de uma localização centralizada, deve processar DispatcherUnhandledException.       DispatcherUnhandledException é gerado por um <xref:System.Windows.Application>para cada exceção que não é tratada pelo código em execução no thread de IU principal.</xref:System.Windows.Application>       Se uma exceção não é tratada num fundo [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] thread (um thread com a sua própria <xref:System.Windows.Threading.Dispatcher>) ou um thread de trabalho em segundo plano (um thread sem um <xref:System.Windows.Threading.Dispatcher>), a exceção não seja reencaminhada para o principal [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] thread.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher> Por conseguinte, DispatcherUnhandledException não é gerado. Nestas circunstâncias, terá de escrever código para fazer o seguinte: 1.  Lidar com exceções no thread em segundo plano.      2.  Emitir essas exceções para o principal [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] thread.      3.  Rethrow-los no principal [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] thread sem processamento-las para permitir DispatcherUnhandledException ser gerado.       Para obter mais informações, consulte o [modelo de thread](~/add/includes/ajax-current-ext-md.md) descrição geral.       O processador de eventos DispatcherUnhandledException foi transmitido um <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs>argumento que contém a nível contextual das informações sobre a exceção, incluindo:-a exceção (<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Exception%2A>).</xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Exception%2A> </xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs>      -O <xref:System.Windows.Threading.Dispatcher>do que teve origem (<xref:System.Windows.Threading.DispatcherEventArgs.Dispatcher%2A>).</xref:System.Windows.Threading.DispatcherEventArgs.Dispatcher%2A> </xref:System.Windows.Threading.Dispatcher>       Pode utilizar estas informações para determinar se uma exceção recuperável ou não. Uma exceção recuperável poderá ser um <xref:System.IO.FileNotFoundException>, por exemplo, durante a uma exceção irrecuperável poderá ser um <xref:System.StackOverflowException>, por exemplo.</xref:System.StackOverflowException> </xref:System.IO.FileNotFoundException>       Ao processar uma exceção não processada de DispatcherUnhandledException e não quiser [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] para continuar a processá-lo, tem de definir o <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled%2A>propriedade `true`.</xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled%2A>       Ao contrário de outros eventos que <xref:System.Windows.Application>gera, DispatcherUnhandledException não tem uma implementação de virtual protegida (OnDispatcherUnhandledException) correspondente.</xref:System.Windows.Application> Por conseguinte, as classes que derivar <xref:System.Windows.Application>tem sempre de registar um processador de eventos DispatcherUnhandledException processar exceções não processadas.</xref:System.Windows.Application>"
  example:
  - "The following example shows how to process unhandled exceptions by handling the DispatcherUnhandledException event.  \n  \n [!code-cs[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND1](~/add/codesnippet/csharp/ApplicationDispatcherUnhandledExceptionSnippets.CSharp/App.xaml.cs#handledispatcherunhandledexceptioncodebehind1)]\n [!code-vb[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND1](~/add/codesnippet/visualbasic/applicationdispatcherunhandledexceptionsnippets/application.xaml.vb#handledispatcherunhandledexceptioncodebehind1)]  \n[!code-cs[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND2](~/add/codesnippet/csharp/ApplicationDispatcherUnhandledExceptionSnippets.CSharp/App.xaml.cs#handledispatcherunhandledexceptioncodebehind2)]\n[!code-vb[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND2](~/add/codesnippet/visualbasic/applicationdispatcherunhandledexceptionsnippets/application.xaml.vb#handledispatcherunhandledexceptioncodebehind2)]"
  syntax:
    content: public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException;
    return:
      type: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Exit
  id: Exit
  parent: System.Windows.Application
  langs:
  - csharp
  name: Exit
  nameWithType: Application.Exit
  fullName: System.Windows.Application.Exit
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre imediatamente antes de uma aplicação será encerrado e não pode ser cancelada."
  remarks: "Uma aplicação pode encerrar para qualquer uma das seguintes razões: - <xref:System.Windows.Application.Shutdown%2A>método do <xref:System.Windows.Application>objeto é denominado, explicitamente ou conforme determinado pelo <xref:System.Windows.Application.ShutdownMode%2A>propriedade.</xref:System.Windows.Application.ShutdownMode%2A> </xref:System.Windows.Application> </xref:System.Windows.Application.Shutdown%2A>      -O utilizador termina a sessão por terminar sessão ou encerrar.       Pode detetar encerramento da aplicação caso ao processar o evento de saída e efetuar qualquer processamento adicional conforme necessário.       Também pode processar saída inspecionar ou alterar o código de saída da aplicação quando não precisa de chamar <xref:System.Windows.Application.Shutdown%2A>explicitamente.</xref:System.Windows.Application.Shutdown%2A> O código de saída está exposto a partir de <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A>propriedade do <xref:System.Windows.ExitEventArgs>argumento que é transferido para o processador de eventos de saída.</xref:System.Windows.ExitEventArgs> </xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> Quando a aplicação deixa de ser executada, o código de saída é passado para o sistema operativo para o processamento subsequente.       Se a aplicação processa a <xref:System.Windows.Application.SessionEnding>eventos e subsequentemente cancela-lo, saída não é gerado e a aplicação continua em execução no accordance com o modo de encerramento.</xref:System.Windows.Application.SessionEnding>       O código de saída pode ser definido um [!INCLUDE[TLA#tla_xbap](~/add/includes/tlasharptla-xbap-md.md)], embora o valor é ignorado.       Para [!INCLUDE[TLA2#tla_xbap#plural](~/add/includes/tla2sharptla-xbapsharpplural-md.md)], saída é gerada nas seguintes circunstâncias: - um [!INCLUDE[TLA2#tla_xbap](~/add/includes/ajax-current-ext-md.md)] é direcionado away do.      -No [!INCLUDE[TLA2#tla_ie7](~/add/includes/tla2sharptla-ie7-md.md)], quando o separador que está a alojar o [!INCLUDE[TLA2#tla_xbap](~/add/includes/ajax-current-ext-md.md)] está fechado.      -Quando o browser é fechado.       Em todos os casos, o valor da <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A>propriedade é ignorada.</xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A>"
  example:
  - "The following example demonstrates how to:  \n  \n-   Handle the Exit event.  \n  \n-   Inspect and update the <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> property of the <xref:System.Windows.ExitEventArgs>.  \n  \n-   Write an entry to an application log in isolated storage.  \n  \n-   Persist the application state to isolated storage.  \n  \n [!code-xml[ApplicationExitSnippets#HandleExitXAML](~/add/codesnippet/xaml/ApplicationExitSnippets.CSharp/App.xaml#handleexitxaml)]  \n  \n [!code-cs[ApplicationExitSnippets#HandleExitCODEBEHIND](~/add/codesnippet/csharp/ApplicationExitSnippets.CSharp/App.xaml.cs#handleexitcodebehind)]\n [!code-vb[ApplicationExitSnippets#HandleExitCODEBEHIND](~/add/codesnippet/visualbasic/applicationexitsnippets/application.xaml.vb#handleexitcodebehind)]"
  syntax:
    content: public event System.Windows.ExitEventHandler Exit;
    return:
      type: System.Windows.ExitEventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.FindResource(System.Object)
  id: FindResource(System.Object)
  parent: System.Windows.Application
  langs:
  - csharp
  name: FindResource(Object)
  nameWithType: Application.FindResource(Object)
  fullName: System.Windows.Application.FindResource(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Procura um [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] recursos, tais como um <xref href=&quot;System.Windows.Style&quot;> </xref> ou <xref href=&quot;System.Windows.Media.Brush&quot;> </xref>, com o nome da chave e gera uma exceção se o recurso pedido não foi encontrado (consulte [XAML recursos](~/add/includes/ajax-current-ext-md.md))."
  remarks: "Primeiro terá um aspeto FindResource em recursos de âmbito de aplicação para o recurso especificado. Recursos de âmbito de aplicação são geridos pelo <xref:System.Windows.Application>e exposta a partir de <xref:System.Windows.Application.Resources%2A>propriedade.</xref:System.Windows.Application.Resources%2A> </xref:System.Windows.Application> Se o recurso especificado não foi encontrado no conjunto de recursos de âmbito de aplicação, FindResource, em seguida, em seguida procura recursos do sistema. Recursos do sistema são shell definido pelo utilizador e incluem as cores, tipos de letra e configurações de shell. Estes são expostas a partir de <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, e <xref:System.Windows.SystemParameters>tipos, respetivamente, como as propriedades estáticas.</xref:System.Windows.SystemParameters> </xref:System.Windows.SystemFonts> </xref:System.Windows.SystemColors> Para utilizar FindResource para adquiri-los, estes tipos também expõem as propriedades de chave de recurso que foram concebidas para transmitir ao FindResource; Por exemplo, <xref:System.Windows.SystemParameters.IconWidthKey%2A>.</xref:System.Windows.SystemParameters.IconWidthKey%2A>       Porque FindResource devolve um objeto, tem de converter o valor devolvido para o tipo apropriado se não for encontrado o recurso.      > [!IMPORTANT] > Se chamar este método para uma chave que não é possível encontrar, é emitida uma exceção. Se não pretender lidar com exceções que resultam da chamada FindResource, chamar <xref:System.Windows.Application.TryFindResource%2A>em vez disso; <xref:System.Windows.Application.TryFindResource%2A>devolve um `null` quando um recurso pedido não é possível localizar e não acionar uma excepção de referência.</xref:System.Windows.Application.TryFindResource%2A> </xref:System.Windows.Application.TryFindResource%2A>       Este método é seguros para threads e pode ser chamado a partir de qualquer thread."
  example:
  - "The following example shows how to use FindResource to find a resource, and to handle <xref:System.Windows.ResourceReferenceKeyNotFoundException> if the resource is not found.  \n  \n [!code-cs[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/add/codesnippet/csharp/ApplicationFindResourceSnippets/MainWindow.xaml.cs#applicationcallfindresourcecodebehind)]\n [!code-vb[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/add/codesnippet/visualbasic/applicationfindresourcesnippets/mainwindow.xaml.vb#applicationcallfindresourcecodebehind)]"
  syntax:
    content: public object FindResource (object resourceKey);
    parameters:
    - id: resourceKey
      type: System.Object
      description: "O nome do recurso para localizar."
    return:
      type: System.Object
      description: "O objeto de recurso pedido. Se o recurso pedido não for encontrado, um <xref href=&quot;System.Windows.ResourceReferenceKeyNotFoundException&quot;> </xref> é emitida."
  overload: System.Windows.Application.FindResource*
  exceptions:
  - type: System.Windows.ResourceReferenceKeyNotFoundException
    commentId: T:System.Windows.ResourceReferenceKeyNotFoundException
    description: "Não é possível localizar o recurso."
  platform:
  - net462
- uid: System.Windows.Application.FragmentNavigation
  id: FragmentNavigation
  parent: System.Windows.Application
  langs:
  - csharp
  name: FragmentNavigation
  nameWithType: Application.FragmentNavigation
  fullName: System.Windows.Application.FragmentNavigation
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando um navegador na aplicação começa navegação a um fragmento do conteúdo, navegação imediatamente ocorre se o fragmento pretendido é o conteúdo atual, ou após a origem [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)] conteúdo foi carregado o fragmento pretendido esteja no conteúdo diferente."
  remarks: "Um navegador é um um <xref:System.Windows.Navigation.NavigationWindow>ou um <xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       Consulte <xref:System.Windows.Navigation.NavigationService.FragmentNavigation?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.FragmentNavigation?displayProperty=fullName>"
  syntax:
    content: public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;
    return:
      type: System.Windows.Navigation.FragmentNavigationEventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.GetContentStream(System.Uri)
  id: GetContentStream(System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: GetContentStream(Uri)
  nameWithType: Application.GetContentStream(Uri)
  fullName: System.Windows.Application.GetContentStream(Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Devolve uma sequência de recursos para um ficheiro de dados de conteúdo que está localizado em especificado <xref:System.Uri>(consulte [WPF recurso de aplicação, o conteúdo e os ficheiros de dados](~/add/includes/ajax-current-ext-md.md)).</xref:System.Uri>"
  remarks: "Este método não é seguros para threads."
  syntax:
    content: public static System.Windows.Resources.StreamResourceInfo GetContentStream (Uri uriContent);
    parameters:
    - id: uriContent
      type: System.Uri
      description: "O caminho relativo <xref:System.Uri>que mapeia para um recurso soltas.</xref:System.Uri>"
    return:
      type: System.Windows.Resources.StreamResourceInfo
      description: "A <xref href=&quot;System.Windows.Resources.StreamResourceInfo&quot;> </xref> que contém um ficheiro de dados de conteúdo que está localizado em <xref:System.Uri>.</xref:System.Uri> especificado Se um recurso soltas não for encontrado, é devolvido um valor nulo."
  overload: System.Windows.Application.GetContentStream*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "O <xref:System.Uri>é passado para GetContentStream é nulo.</xref:System.Uri>"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O <xref:System.Uri>que é transmitido a GetContentStream é absoluto <xref:System.Uri>.</xref:System.Uri> </xref:System.Uri>"
  platform:
  - net462
- uid: System.Windows.Application.GetCookie(System.Uri)
  id: GetCookie(System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: GetCookie(Uri)
  nameWithType: Application.GetCookie(Uri)
  fullName: System.Windows.Application.GetCookie(Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém um cookie para a localização especificada pela <xref:System.Uri>.</xref:System.Uri>"
  remarks: "GetCookie obtém um cookie para o <xref:System.Uri>.</xref:System.Uri> especificado Se não é possível obter o cookie, um <xref:System.ComponentModel.Win32Exception>é emitida.</xref:System.ComponentModel.Win32Exception> Terá de escrever o código para analisar a cadeia de cookie numa lista de pares nome/valor.       Para obter uma descrição geral de cookies [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)], consulte [descrição geral de navegação](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static string GetCookie (Uri uri);
    parameters:
    - id: uri
      type: System.Uri
      description: "O <xref:System.Uri>que especifica a localização para a qual foi criado um cookie.</xref:System.Uri>"
    return:
      type: System.String
      description: "A <xref:System.String>valor, se existir o cookie; caso contrário, um <xref href=&quot;System.ComponentModel.Win32Exception&quot;> </xref> é emitida.</xref:System.String>"
  overload: System.Windows.Application.GetCookie*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "A [!INCLUDE[TLA#tla_win32](~/add/includes/tlasharptla-win32-md.md)] erro ser gerado pelo <xref uid=&quot;langword_csharp_InternetGetCookie&quot; name=&quot;InternetGetCookie&quot; href=&quot;&quot;> </xref> função (chamada pelo GetCookie) se ocorrer um problema ao tentar obter o cookie especificado."
  platform:
  - net462
- uid: System.Windows.Application.GetRemoteStream(System.Uri)
  id: GetRemoteStream(System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: GetRemoteStream(Uri)
  nameWithType: Application.GetRemoteStream(Uri)
  fullName: System.Windows.Application.GetRemoteStream(Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Devolve uma sequência de recursos para um ficheiro de dados do site de origem que está localizado em especificado <xref:System.Uri>(consulte [recurso de aplicações do WPF, conteúdo e os ficheiros de dados](~/add/includes/ajax-current-ext-md.md)).</xref:System.Uri>"
  remarks: "Este método não é seguros para threads."
  syntax:
    content: public static System.Windows.Resources.StreamResourceInfo GetRemoteStream (Uri uriRemote);
    parameters:
    - id: uriRemote
      type: System.Uri
      description: "O <xref:System.Uri>que mapeia para um recurso soltas no site de origem.</xref:System.Uri>"
    return:
      type: System.Windows.Resources.StreamResourceInfo
      description: "A <xref href=&quot;System.Windows.Resources.StreamResourceInfo&quot;> </xref> que contenha uma sequência de recursos para um ficheiro de dados do site de origem que está localizado em <xref:System.Uri>.</xref:System.Uri> especificado Se o recurso soltas não for encontrado, <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> é devolvido."
  overload: System.Windows.Application.GetRemoteStream*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "O <xref:System.Uri>é passado para GetRemoteStream é nulo.</xref:System.Uri>"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O <xref:System.Uri>é passado para GetRemoteStream é não relativo, ou absoluto, mas não o `pack://siteoforigin:,,,/` formulário.</xref:System.Uri>"
  platform:
  - net462
- uid: System.Windows.Application.GetResourceStream(System.Uri)
  id: GetResourceStream(System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: GetResourceStream(Uri)
  nameWithType: Application.GetResourceStream(Uri)
  fullName: System.Windows.Application.GetResourceStream(Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Devolve uma sequência de recursos para um ficheiro de dados de recursos está localizado em especificado <xref:System.Uri>(consulte [WPF recurso de aplicação, o conteúdo e os ficheiros de dados](~/add/includes/ajax-current-ext-md.md)).</xref:System.Uri>"
  remarks: "Este método não é seguros para threads."
  syntax:
    content: public static System.Windows.Resources.StreamResourceInfo GetResourceStream (Uri uriResource);
    parameters:
    - id: uriResource
      type: System.Uri
      description: "O <xref:System.Uri>que mapeia para um recurso incorporado.</xref:System.Uri>"
    return:
      type: System.Windows.Resources.StreamResourceInfo
      description: "A <xref href=&quot;System.Windows.Resources.StreamResourceInfo&quot;> </xref> que contenha uma sequência de recursos para o ficheiro de dados de recursos está localizado em <xref:System.Uri>.</xref:System.Uri> especificado"
  overload: System.Windows.Application.GetResourceStream*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "O <xref:System.Uri>é passado para GetResourceStream é nulo.</xref:System.Uri>"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O <xref:System.Uri>é passado para GetResourceStream é não relativo, ou absoluto, mas não o `pack://application:,,,/` formulário.</xref:System.Uri>"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "O <xref:System.Uri>é passado para GetResourceStream não é possível localizar.</xref:System.Uri>"
  platform:
  - net462
- uid: System.Windows.Application.LoadCompleted
  id: LoadCompleted
  parent: System.Windows.Application
  langs:
  - csharp
  name: LoadCompleted
  nameWithType: Application.LoadCompleted
  fullName: System.Windows.Application.LoadCompleted
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando o conteúdo que foi utilizado por um navegador na aplicação foi carregado, analisar e começou a composição."
  remarks: "Um navegador é um um <xref:System.Windows.Navigation.NavigationWindow>ou um <xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       Consulte <xref:System.Windows.Navigation.NavigationService.LoadCompleted?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.LoadCompleted?displayProperty=fullName>      > [!NOTE] > Escutar eventos no conteúdo navigated, tais como o <xref:System.Windows.FrameworkElement.Loaded>evento <xref:System.Windows.Controls.Page>antes de aceder às propriedades do conteúdo navigated.</xref:System.Windows.Controls.Page> </xref:System.Windows.FrameworkElement.Loaded>"
  syntax:
    content: public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;
    return:
      type: System.Windows.Navigation.LoadCompletedEventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.LoadComponent(System.Uri)
  id: LoadComponent(System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: LoadComponent(Uri)
  nameWithType: Application.LoadComponent(Uri)
  fullName: System.Windows.Application.LoadComponent(Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Carrega um [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] ficheiro que está localizado em especificado [!INCLUDE[TLA#tla_uri](~/add/includes/tlasharptla-uri-md.md)]e converte-o a uma instância do objeto que é especificado pelo elemento raiz do [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] ficheiro."
  remarks: "Explicitamente tem de converter o valor devolvido para o mesmo tipo que o elemento raiz do [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] ficheiro.       O [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)] ficheiro pode ser um ficheiro de código da aplicação (configurado como um [!INCLUDE[TLA#tla_msbuild](~/add/includes/tlasharptla-msbuild-md.md)] item da página) ou um ficheiro de dados de aplicação (um ficheiro de recursos, o ficheiro de conteúdo ou o site de origem do ficheiro; consulte [WPF recurso de aplicação, o conteúdo e os ficheiros de dados](~/add/includes/ajax-current-ext-md.md)).      > [!NOTE] > Este método não é seguro para thread."
  syntax:
    content: public static object LoadComponent (Uri resourceLocator);
    parameters:
    - id: resourceLocator
      type: System.Uri
      description: "A <xref:System.Uri>que mapeia para um caminho relativo [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] ficheiro.</xref:System.Uri>"
    return:
      type: System.Object
      description: "Carregar uma instância do elemento de raiz especificado pelo ficheiro XAML."
  overload: System.Windows.Application.LoadComponent*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>resourceLocator</code>é nulo."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>resourceLocator</code> is an absolute [!INCLUDE[TLA2#tla_uri](~/add/includes/tla2sharptla-uri-md.md)]."
  - type: System.Exception
    commentId: T:System.Exception
    description: "O ficheiro não é um [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)] ficheiro."
  platform:
  - net462
- uid: System.Windows.Application.LoadComponent(System.Object,System.Uri)
  id: LoadComponent(System.Object,System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: LoadComponent(Object,Uri)
  nameWithType: Application.LoadComponent(Object,Uri)
  fullName: System.Windows.Application.LoadComponent(Object,Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Carrega um [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] ficheiro que está localizado em especificado [!INCLUDE[TLA#tla_uri](~/add/includes/tlasharptla-uri-md.md)] e converte-o a uma instância do objeto que é especificado pelo elemento raiz do [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] ficheiro."
  remarks: "O [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)] ficheiro pode ser um ficheiro de código da aplicação (configurado como um [!INCLUDE[TLA#tla_msbuild](~/add/includes/tlasharptla-msbuild-md.md)] item da página) ou um ficheiro de dados de aplicação (um ficheiro de recursos, o ficheiro de conteúdo ou o site de origem do ficheiro; consulte [WPF recurso de aplicação, o conteúdo e os ficheiros de dados](~/add/includes/ajax-current-ext-md.md)).      > [!NOTE] > Este método não é seguro para thread."
  syntax:
    content: public static void LoadComponent (object component, Uri resourceLocator);
    parameters:
    - id: component
      type: System.Object
      description: "Um objeto do mesmo tipo que o elemento raiz do [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] ficheiro."
    - id: resourceLocator
      type: System.Uri
      description: "A <xref:System.Uri>que mapeia para um caminho relativo [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] ficheiro.</xref:System.Uri>"
  overload: System.Windows.Application.LoadComponent*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>resourceLocator</code>é nulo."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>resourceLocator</code> is an absolute [!INCLUDE[TLA2#tla_uri](~/add/includes/tla2sharptla-uri-md.md)]."
  - type: System.Exception
    commentId: T:System.Exception
    description: "<code>component</code>é um tipo que não coincide com o elemento raiz do [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] ficheiro."
  platform:
  - net462
- uid: System.Windows.Application.MainWindow
  id: MainWindow
  parent: System.Windows.Application
  langs:
  - csharp
  name: MainWindow
  nameWithType: Application.MainWindow
  fullName: System.Windows.Application.MainWindow
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define a janela principal da aplicação."
  remarks: "MainWindow é automaticamente definido com uma referência ao <xref:System.Windows.Window>objeto a ser instanciado no <xref:System.AppDomain>.</xref:System.AppDomain> </xref:System.Windows.Window> primeiro       Pode especificar uma janela principal diferente, definindo MainWindow atribuir outro <xref:System.Windows.Application.Windows%2A>objeto para a propriedade MainWindow.</xref:System.Windows.Application.Windows%2A>       Se o <xref:System.Windows.Application.ShutdownMode%2A>propriedade o <xref:System.Windows.Application>objeto está definido como <xref:System.Windows.ShutdownMode>, fechar a janela principal faz com que a aplicação encerrar.</xref:System.Windows.ShutdownMode> </xref:System.Windows.Application> </xref:System.Windows.Application.ShutdownMode%2A>       É possível definir a propriedade MainWindow de [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)], se a janela principal de uma aplicação não é a janela de que é produzida por definir a <xref:System.Windows.Application.StartupUri%2A>propriedade no [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)].</xref:System.Windows.Application.StartupUri%2A> As limitações de duas a [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)] abordagem são:-pode especificar um um [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)]-apenas <xref:System.Windows.Window>ou um [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)]-apenas <xref:System.Windows.Navigation.NavigationWindow>como a janela principal.</xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Window>      -Tem de definir o <xref:System.Windows.UIElement.Visibility%2A>propriedade da janela tem de especificar, caso contrário, não será apresentado.</xref:System.Windows.UIElement.Visibility%2A>       A referência do primeiro <xref:System.Windows.Window>o objeto a ser instanciado também é adicionado como o primeiro item para o <xref:System.Windows.Application.Windows%2A>coleção.</xref:System.Windows.Application.Windows%2A> </xref:System.Windows.Window> Se MainWindow subsequentemente está definida com uma referência a outro <xref:System.Windows.Window>, irá alterar a posição do item com a referência para a janela principal, enquanto a ordem dos itens no <xref:System.Windows.Application.Windows%2A>permanece igual.</xref:System.Windows.Application.Windows%2A> </xref:System.Windows.Window> Por conseguinte, utilize sempre MainWindow referir-se a janela principal em vez do primeiro item na <xref:System.Windows.Application.Windows%2A>.</xref:System.Windows.Application.Windows%2A>      > [!NOTE] > Se a janela principal é uma <xref:System.Windows.Navigation.NavigationWindow>, e terá acesso específico aos <xref:System.Windows.Navigation.NavigationWindow>Membros, terá de converter o valor de MainWindow para <xref:System.Windows.Navigation.NavigationWindow>.</xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Navigation.NavigationWindow>   >> Esta propriedade está disponível apenas a partir do thread que criou o <xref:System.Windows.Application>objeto.</xref:System.Windows.Application>"
  example:
  - "The following example shows how to find the main application window.  \n  \n [!code-cs[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/add/codesnippet/csharp/ApplicationMainWindowSnippets.CSharp/App.xaml.cs#getapplicationmainwindowcode)]\n [!code-vb[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/add/codesnippet/visualbasic/applicationmainwindowsnippets/application.xaml.vb#getapplicationmainwindowcode)]  \n  \n The following example shows how to set MainWindow using [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)].  \n  \n [!code-xml[ApplicationMainWindowSnippets#SetApplicationMainWindowXAML](~/add/codesnippet/xaml/ApplicationMainWindowSnippets.XAML/App.xaml#setapplicationmainwindowxaml)]  \n  \n The following example shows how to instantiate the MainWindow in code during application startup.  \n  \n [!code-cs[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/add/codesnippet/csharp/HOWTOWindowManagementSnippets/App.xaml.cs#firstwindowusingcodecodebehind)]\n [!code-vb[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/add/codesnippet/visualbasic/howtowindowmanagementsnippets/application.xaml.vb#firstwindowusingcodecodebehind)]"
  syntax:
    content: public System.Windows.Window MainWindow { get; set; }
    return:
      type: System.Windows.Window
      description: "A <xref href=&quot;System.Windows.Window&quot;> </xref> que está designado como a janela principal da aplicação."
  overload: System.Windows.Application.MainWindow*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "MainWindow está definida a partir de uma aplicação que está alojada num browser, tais como um [!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)]."
  platform:
  - net462
- uid: System.Windows.Application.Navigated
  id: Navigated
  parent: System.Windows.Application
  langs:
  - csharp
  name: Navigated
  nameWithType: Application.Navigated
  fullName: System.Windows.Application.Navigated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando o conteúdo que está a ser utilizado por um navegador na aplicação foi encontrado, apesar do poderá não ter sido concluída a carregar."
  remarks: "Um navegador é um um <xref:System.Windows.Navigation.NavigationWindow>ou um <xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       Consulte <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=fullName>"
  syntax:
    content: public event System.Windows.Navigation.NavigatedEventHandler Navigated;
    return:
      type: System.Windows.Navigation.NavigatedEventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Navigating
  id: Navigating
  parent: System.Windows.Application
  langs:
  - csharp
  name: Navigating
  nameWithType: Application.Navigating
  fullName: System.Windows.Application.Navigating
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando uma nova navegação solicitada por um navegador na aplicação."
  remarks: "Um navegador é um um <xref:System.Windows.Navigation.NavigationWindow>ou um <xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       Consulte <xref:System.Windows.Navigation.NavigationService.Navigating?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.Navigating?displayProperty=fullName>"
  syntax:
    content: public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;
    return:
      type: System.Windows.Navigation.NavigatingCancelEventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.NavigationFailed
  id: NavigationFailed
  parent: System.Windows.Application
  langs:
  - csharp
  name: NavigationFailed
  nameWithType: Application.NavigationFailed
  fullName: System.Windows.Application.NavigationFailed
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando ocorre um erro enquanto um navegador na aplicação está a navegar para o conteúdo pedido."
  remarks: "Um navegador é um um <xref:System.Windows.Navigation.NavigationWindow>ou um <xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       Consulte <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=fullName>"
  syntax:
    content: public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;
    return:
      type: System.Windows.Navigation.NavigationFailedEventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.NavigationProgress
  id: NavigationProgress
  parent: System.Windows.Application
  langs:
  - csharp
  name: NavigationProgress
  nameWithType: Application.NavigationProgress
  fullName: System.Windows.Application.NavigationProgress
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre periodicamente durante uma transferência que está a ser gerida por um navegador na aplicação para fornecer informações de progresso de navegação."
  remarks: "Um navegador é um um <xref:System.Windows.Navigation.NavigationWindow>ou um <xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       Consulte <xref:System.Windows.Navigation.NavigationService.NavigationProgress?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.NavigationProgress?displayProperty=fullName>"
  syntax:
    content: public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;
    return:
      type: System.Windows.Navigation.NavigationProgressEventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.NavigationStopped
  id: NavigationStopped
  parent: System.Windows.Application
  langs:
  - csharp
  name: NavigationStopped
  nameWithType: Application.NavigationStopped
  fullName: System.Windows.Application.NavigationStopped
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando o <xref uid=&quot;langword_csharp_StopLoading&quot; name=&quot;StopLoading&quot; href=&quot;&quot;> </xref> é chamado o método de um navegador na aplicação, ou quando uma nova navegação solicitada por um navegador enquanto uma navegação atual está em curso."
  remarks: "Um navegador é um um <xref:System.Windows.Navigation.NavigationWindow>ou um <xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       Consulte <xref:System.Windows.Navigation.NavigationService.NavigationStopped?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.NavigationStopped?displayProperty=fullName>"
  syntax:
    content: public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;
    return:
      type: System.Windows.Navigation.NavigationStoppedEventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnActivated(System.EventArgs)
  id: OnActivated(System.EventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnActivated(EventArgs)
  nameWithType: Application.OnActivated(EventArgs)
  fullName: System.Windows.Application.OnActivated(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Gera o <xref href=&quot;System.Windows.Application.Activated&quot;> </xref> eventos."
  remarks: "OnActivated gera o <xref:System.Windows.Application.Activated>eventos.</xref:System.Windows.Application.Activated>       Um tipo que deriva de <xref:System.Windows.Application>pode substituir OnActivated.</xref:System.Windows.Application> O método substituído tem de chamar OnActivated na classe base se <xref:System.Windows.Application.Activated>tem de ser gerado.</xref:System.Windows.Application.Activated>"
  syntax:
    content: protected virtual void OnActivated (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "Um <xref:System.EventArgs>que contém os dados do evento.</xref:System.EventArgs>"
  overload: System.Windows.Application.OnActivated*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnDeactivated(System.EventArgs)
  id: OnDeactivated(System.EventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnDeactivated(EventArgs)
  nameWithType: Application.OnDeactivated(EventArgs)
  fullName: System.Windows.Application.OnDeactivated(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Gera o <xref href=&quot;System.Windows.Application.Deactivated&quot;> </xref> eventos."
  remarks: "OnDeactivated gera o <xref:System.Windows.Application.Deactivated>eventos.</xref:System.Windows.Application.Deactivated>       Um tipo que deriva de <xref:System.Windows.Application>pode substituir OnDeactivated.</xref:System.Windows.Application> O método substituído tem de chamar OnDeactivated na classe base se <xref:System.Windows.Application.Deactivated>tem de ser gerado.</xref:System.Windows.Application.Deactivated>"
  syntax:
    content: protected virtual void OnDeactivated (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "Um <xref:System.EventArgs>que contém os dados do evento.</xref:System.EventArgs>"
  overload: System.Windows.Application.OnDeactivated*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnExit(System.Windows.ExitEventArgs)
  id: OnExit(System.Windows.ExitEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnExit(ExitEventArgs)
  nameWithType: Application.OnExit(ExitEventArgs)
  fullName: System.Windows.Application.OnExit(ExitEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Gera o <xref href=&quot;System.Windows.Application.Exit&quot;> </xref> eventos."
  remarks: "OnExit gera o <xref:System.Windows.Application.Exit>eventos.</xref:System.Windows.Application.Exit>       Um tipo que deriva de <xref:System.Windows.Application>pode substituir o método OnExit.</xref:System.Windows.Application> O método substituído tem de chamar OnExit na classe base se <xref:System.Windows.Application.Exit>tem de ser gerado.</xref:System.Windows.Application.Exit>"
  syntax:
    content: protected virtual void OnExit (System.Windows.ExitEventArgs e);
    parameters:
    - id: e
      type: System.Windows.ExitEventArgs
      description: "Um <xref href=&quot;System.Windows.ExitEventArgs&quot;> </xref> que contém os dados do evento."
  overload: System.Windows.Application.OnExit*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)
  id: OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnFragmentNavigation(FragmentNavigationEventArgs)
  nameWithType: Application.OnFragmentNavigation(FragmentNavigationEventArgs)
  fullName: System.Windows.Application.OnFragmentNavigation(FragmentNavigationEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Gera o <xref href=&quot;System.Windows.Application.FragmentNavigation&quot;> </xref> eventos."
  remarks: "OnFragmentNavigation gera o <xref:System.Windows.Application.FragmentNavigation>eventos.</xref:System.Windows.Application.FragmentNavigation>       Um tipo que deriva de <xref:System.Windows.Application>pode substituir OnFragmentNavigation.</xref:System.Windows.Application> O método substituído tem de chamar OnFragmentNavigation na classe base se <xref:System.Windows.Application.FragmentNavigation>tem de ser gerado.</xref:System.Windows.Application.FragmentNavigation>"
  syntax:
    content: protected virtual void OnFragmentNavigation (System.Windows.Navigation.FragmentNavigationEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.FragmentNavigationEventArgs
      description: "A <xref href=&quot;System.Windows.Navigation.FragmentNavigationEventArgs&quot;> </xref> que contém os dados do evento."
  overload: System.Windows.Application.OnFragmentNavigation*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)
  id: OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnLoadCompleted(NavigationEventArgs)
  nameWithType: Application.OnLoadCompleted(NavigationEventArgs)
  fullName: System.Windows.Application.OnLoadCompleted(NavigationEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Gera o <xref href=&quot;System.Windows.Application.LoadCompleted&quot;> </xref> eventos."
  remarks: "OnLoadCompleted gera o <xref:System.Windows.Application.LoadCompleted>eventos.</xref:System.Windows.Application.LoadCompleted>       Um tipo que deriva de <xref:System.Windows.Application>pode substituir OnLoadCompleted.</xref:System.Windows.Application> O método substituído tem de chamar OnLoadCompleted na classe base se <xref:System.Windows.Application.LoadCompleted>tem de ser gerado.</xref:System.Windows.Application.LoadCompleted>"
  syntax:
    content: protected virtual void OnLoadCompleted (System.Windows.Navigation.NavigationEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigationEventArgs
      description: "A <xref href=&quot;System.Windows.Navigation.NavigationEventArgs&quot;> </xref> que contém os dados do evento."
  overload: System.Windows.Application.OnLoadCompleted*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)
  id: OnNavigated(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnNavigated(NavigationEventArgs)
  nameWithType: Application.OnNavigated(NavigationEventArgs)
  fullName: System.Windows.Application.OnNavigated(NavigationEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Gera o <xref href=&quot;System.Windows.Application.Navigated&quot;> </xref> eventos."
  remarks: "OnNavigated gera o <xref:System.Windows.Application.Navigated>eventos.</xref:System.Windows.Application.Navigated>       Um tipo que deriva de <xref:System.Windows.Application>pode substituir OnNavigated.</xref:System.Windows.Application> O método substituído tem de chamar OnNavigated na classe base se <xref:System.Windows.Application.Navigated>tem de ser gerado.</xref:System.Windows.Application.Navigated>"
  syntax:
    content: protected virtual void OnNavigated (System.Windows.Navigation.NavigationEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigationEventArgs
      description: "A <xref href=&quot;System.Windows.Navigation.NavigationEventArgs&quot;> </xref> que contém os dados do evento."
  overload: System.Windows.Application.OnNavigated*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)
  id: OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnNavigating(NavigatingCancelEventArgs)
  nameWithType: Application.OnNavigating(NavigatingCancelEventArgs)
  fullName: System.Windows.Application.OnNavigating(NavigatingCancelEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Gera o <xref href=&quot;System.Windows.Application.Navigating&quot;> </xref> eventos."
  remarks: "OnNavigating gera o <xref:System.Windows.Application.Navigating>eventos.</xref:System.Windows.Application.Navigating>       Um tipo que deriva de <xref:System.Windows.Application>pode substituir OnNavigating.</xref:System.Windows.Application> O método substituído tem de chamar OnNavigating na classe base se <xref:System.Windows.Application.Navigating>tem de ser gerado.</xref:System.Windows.Application.Navigating>"
  syntax:
    content: protected virtual void OnNavigating (System.Windows.Navigation.NavigatingCancelEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigatingCancelEventArgs
      description: "A <xref href=&quot;System.Windows.Navigation.NavigatingCancelEventArgs&quot;> </xref> que contém os dados do evento."
  overload: System.Windows.Application.OnNavigating*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)
  id: OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnNavigationFailed(NavigationFailedEventArgs)
  nameWithType: Application.OnNavigationFailed(NavigationFailedEventArgs)
  fullName: System.Windows.Application.OnNavigationFailed(NavigationFailedEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Gera o <xref href=&quot;System.Windows.Application.NavigationFailed&quot;> </xref> eventos."
  remarks: "OnNavigationFailed gera o <xref:System.Windows.Application.NavigationFailed>eventos.</xref:System.Windows.Application.NavigationFailed>       Um tipo que deriva de <xref:System.Windows.Application>pode substituir OnNavigationFailed.</xref:System.Windows.Application> O método substituído tem de chamar OnNavigationFailed na classe base se <xref:System.Windows.Application.NavigationFailed>tem de ser gerado.</xref:System.Windows.Application.NavigationFailed>"
  example:
  - "<xref:System.Windows.Application.OnFragmentNavigation%2A>  \n  \n <xref:System.Windows.Application.OnLoadCompleted%2A>  \n  \n <xref:System.Windows.Application.OnNavigating%2A>  \n  \n <xref:System.Windows.Application.OnNavigated%2A>  \n  \n <xref:System.Windows.Application.OnNavigationProgress%2A>  \n  \n <xref:System.Windows.Application.OnNavigationStopped%2A>"
  syntax:
    content: protected virtual void OnNavigationFailed (System.Windows.Navigation.NavigationFailedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigationFailedEventArgs
      description: "A <xref href=&quot;System.Windows.Navigation.NavigationFailedEventArgs&quot;> </xref> que contém os dados do evento."
  overload: System.Windows.Application.OnNavigationFailed*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)
  id: OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnNavigationProgress(NavigationProgressEventArgs)
  nameWithType: Application.OnNavigationProgress(NavigationProgressEventArgs)
  fullName: System.Windows.Application.OnNavigationProgress(NavigationProgressEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Gera o <xref href=&quot;System.Windows.Application.NavigationProgress&quot;> </xref> eventos."
  remarks: "OnNavigationProgress gera o <xref:System.Windows.Application.NavigationProgress>eventos.</xref:System.Windows.Application.NavigationProgress>       Um tipo que deriva de <xref:System.Windows.Application>pode substituir OnNavigationProgress.</xref:System.Windows.Application> O método substituído deve chamar explicitamente OnNavigationProgress na classe base se <xref:System.Windows.Application.NavigationProgress>tem de ser gerado.</xref:System.Windows.Application.NavigationProgress>"
  syntax:
    content: protected virtual void OnNavigationProgress (System.Windows.Navigation.NavigationProgressEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigationProgressEventArgs
      description: "A <xref href=&quot;System.Windows.Navigation.NavigationProgressEventArgs&quot;> </xref> que contém os dados do evento."
  overload: System.Windows.Application.OnNavigationProgress*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)
  id: OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnNavigationStopped(NavigationEventArgs)
  nameWithType: Application.OnNavigationStopped(NavigationEventArgs)
  fullName: System.Windows.Application.OnNavigationStopped(NavigationEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Gera o <xref href=&quot;System.Windows.Application.NavigationStopped&quot;> </xref> eventos."
  remarks: "OnNavigationStopped gera o <xref:System.Windows.Application.NavigationStopped>eventos.</xref:System.Windows.Application.NavigationStopped>       Um tipo que deriva de <xref:System.Windows.Application>pode substituir OnNavigationStopped.</xref:System.Windows.Application> O método substituído tem de chamar OnNavigationStopped na classe base se <xref:System.Windows.Application.NavigationStopped>tem de ser gerado.</xref:System.Windows.Application.NavigationStopped>"
  syntax:
    content: protected virtual void OnNavigationStopped (System.Windows.Navigation.NavigationEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigationEventArgs
      description: "A <xref href=&quot;System.Windows.Navigation.NavigationEventArgs&quot;> </xref> que contém os dados do evento."
  overload: System.Windows.Application.OnNavigationStopped*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)
  id: OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnSessionEnding(SessionEndingCancelEventArgs)
  nameWithType: Application.OnSessionEnding(SessionEndingCancelEventArgs)
  fullName: System.Windows.Application.OnSessionEnding(SessionEndingCancelEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Gera o <xref href=&quot;System.Windows.Application.SessionEnding&quot;> </xref> eventos."
  remarks: "OnSessionEnding gera o <xref:System.Windows.Application.SessionEnding>eventos.</xref:System.Windows.Application.SessionEnding>       Um tipo que deriva de <xref:System.Windows.Application>pode substituir OnSessionEnding.</xref:System.Windows.Application> O método substituído tem de chamar OnSessionEnding na classe base se <xref:System.Windows.Application.SessionEnding>tem de ser gerado.</xref:System.Windows.Application.SessionEnding>"
  syntax:
    content: protected virtual void OnSessionEnding (System.Windows.SessionEndingCancelEventArgs e);
    parameters:
    - id: e
      type: System.Windows.SessionEndingCancelEventArgs
      description: "A <xref href=&quot;System.Windows.SessionEndingCancelEventArgs&quot;> </xref> que contém os dados do evento."
  overload: System.Windows.Application.OnSessionEnding*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)
  id: OnStartup(System.Windows.StartupEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnStartup(StartupEventArgs)
  nameWithType: Application.OnStartup(StartupEventArgs)
  fullName: System.Windows.Application.OnStartup(StartupEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Gera o <xref href=&quot;System.Windows.Application.Startup&quot;> </xref> eventos."
  remarks: "OnStartup gera o <xref:System.Windows.Application.Startup>eventos.</xref:System.Windows.Application.Startup>       Um tipo que deriva de <xref:System.Windows.Application>pode substituir OnStartup.</xref:System.Windows.Application> O método substituído tem de chamar OnStartup na classe base se a <xref:System.Windows.Application.Startup>evento tem de ser gerado.</xref:System.Windows.Application.Startup>"
  syntax:
    content: protected virtual void OnStartup (System.Windows.StartupEventArgs e);
    parameters:
    - id: e
      type: System.Windows.StartupEventArgs
      description: "A <xref href=&quot;System.Windows.StartupEventArgs&quot;> </xref> que contém os dados do evento."
  overload: System.Windows.Application.OnStartup*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Properties
  id: Properties
  parent: System.Windows.Application
  langs:
  - csharp
  name: Properties
  nameWithType: Application.Properties
  fullName: System.Windows.Application.Properties
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém uma coleção de propriedades de âmbito de aplicação."
  remarks: "<xref:System.Windows.Application>expõe um dicionário através de propriedades que pode utilizar para armazenar propriedades de âmbito de aplicação.</xref:System.Windows.Application> Isto permite-lhe partilhar estado entre todo o código num <xref:System.AppDomain>de forma segura para os threads, sem a necessidade de escrever o seu próprio código de estado.</xref:System.AppDomain>       Propriedades armazenadas nas propriedades tem de ser convertidas para o tipo apropriado devolvido.       Propriedade de TheProperties é seguros para threads e está disponível a partir de qualquer thread."
  example:
  - "The following example shows how create and use an application-scope property using Properties.  \n  \n [!code-xml[ApplicationPropertiesSnippets#HandleStartupXAML](~/add/codesnippet/xaml/ApplicationPropertiesSnippets.CSharp/App.xaml#handlestartupxaml)]  \n  \n [!code-cs[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/add/codesnippet/csharp/ApplicationPropertiesSnippets.CSharp/App.xaml.cs#handlestartupcodebehind)]\n [!code-vb[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/add/codesnippet/visualbasic/applicationpropertiessnippets/application.xaml.vb#handlestartupcodebehind)]  \n  \n [!code-xml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML1](~/add/codesnippet/xaml/ApplicationPropertiesSnippets.CSharp/MainWindow.xaml#mainwindowgetpropertyxaml1)]  \n[!code-xml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML2](~/add/codesnippet/xaml/ApplicationPropertiesSnippets.CSharp/MainWindow.xaml#mainwindowgetpropertyxaml2)]  \n  \n [!code-cs[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/add/codesnippet/csharp/ApplicationPropertiesSnippets.CSharp/MainWindow.xaml.cs#mainwindowgetpropertycodebehind)]\n [!code-vb[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/add/codesnippet/visualbasic/applicationpropertiessnippets/mainwindow.xaml.vb#mainwindowgetpropertycodebehind)]"
  syntax:
    content: public System.Collections.IDictionary Properties { get; }
    return:
      type: System.Collections.IDictionary
      description: "Um <xref:System.Collections.IDictionary>que contém as propriedades de âmbito de aplicação.</xref:System.Collections.IDictionary>"
  overload: System.Windows.Application.Properties*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.ResourceAssembly
  id: ResourceAssembly
  parent: System.Windows.Application
  langs:
  - csharp
  name: ResourceAssembly
  nameWithType: Application.ResourceAssembly
  fullName: System.Windows.Application.ResourceAssembly
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define o <xref:System.Reflection.Assembly>que fornece o pacote [!INCLUDE[TLA#tla_uri#plural](~/add/includes/tlasharptla-urisharpplural-md.md)] para os recursos num [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] aplicação.</xref:System.Reflection.Assembly>"
  remarks: "Por predefinição, [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] recursos são resolvidos no tempo de execução relativamente a assemblagem de entrada, o que é identificado por valor devolvido pelo <xref:System.Reflection.Assembly.GetEntryAssembly%2A>método.</xref:System.Reflection.Assembly.GetEntryAssembly%2A>       A assemblagem de entrada é a assemblagem que é devolvida pelo <xref:System.Reflection.Assembly.GetEntryAssembly%2A>e pode ser o seguinte:-a assemblagem executável no domínio de aplicação predefinido.</xref:System.Reflection.Assembly.GetEntryAssembly%2A>      -A assemblagem primeiro para ser executada chamando <xref:System.AppDomain.ExecuteAssembly%2A>.</xref:System.AppDomain.ExecuteAssembly%2A>       Nos seguintes casos, no entanto, um [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] assemblagem não é possível obter uma referência à assemblagem de entrada: - um não gerido anfitriões de aplicação (nativo) de [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] assemblagem.      -A anfitriões de aplicações geridas do [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] assemblagem ao carregá-lo para um novo domínio aplicacional utilizando um método diferente de <xref:System.AppDomain.ExecuteAssembly%2A>.</xref:System.AppDomain.ExecuteAssembly%2A>       Em ambos os nestes casos, <xref:System.Reflection.Assembly.GetEntryAssembly%2A>devolve `null`e o [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] recursos da assemblagem não não possível resolver.</xref:System.Reflection.Assembly.GetEntryAssembly%2A> Nestes casos, ResourceAssembly pode ser definida, uma vez apenas, com uma referência à assemblagem que deve ser utilizada para resolver os recursos.       ResourceAssembly só pode ser definida uma vez porque não é provável que a assemblagem de recursos será alterado após a [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] é carregada a assemblagem.      > [!NOTE] > ResourceAssembly não pode ser definida quando um [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] assemblagem pode detetar a assemblagem de entrada — ou seja, quando <xref:System.Reflection.Assembly.GetEntryAssembly%2A>devolve uma referência a uma assemblagem vez `null`.</xref:System.Reflection.Assembly.GetEntryAssembly%2A>       Esta propriedade é seguros para threads e está disponível a partir de qualquer thread.       ResourceAssembly é apresentado no .NET Framework versão 3.5.  Para obter mais informações, consulte [versões e dependências](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static System.Reflection.Assembly ResourceAssembly { get; set; }
    return:
      type: System.Reflection.Assembly
      description: "Uma referência para o <xref:System.Reflection.Assembly>que fornece o pacote [!INCLUDE[TLA#tla_uri#plural](~/add/includes/tlasharptla-urisharpplural-md.md)] para os recursos num [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] aplicação.</xref:System.Reflection.Assembly>"
  overload: System.Windows.Application.ResourceAssembly*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] aplicação tem uma assemblagem de entrada ou ResourceAssembly já foi definido."
  platform:
  - net462
- uid: System.Windows.Application.Resources
  id: Resources
  parent: System.Windows.Application
  langs:
  - csharp
  name: Resources
  nameWithType: Application.Resources
  fullName: System.Windows.Application.Resources
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define uma coleção de recursos de âmbito de aplicação, tais como estilos e brushes."
  remarks: "A propriedade de recursos pode ser utilizada para partilhar recursos entre o windows e os elementos de uma aplicação. Além disso, a propriedade de recursos está incluída no caminho de pesquisa de recursos, que é atravessado pela seguinte ordem: 1.  Elementos de 2.  3 do Windows.  4 recursos.  Sistema consequentemente, [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] elementos podem vincular a recursos de âmbito de aplicação. Além disso, se alterar a recursos, o sistema de recurso assegura que o elemento propriedades que estão vinculadas a esses recursos são automaticamente atualizadas para refletir a alteração.       Recursos de âmbito de aplicação fornecem uma forma simples para suportar um tema consistente em toda a aplicação. Pode criar facilmente um tema no [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] utilizando o `Application.Resources` etiquetas. No entanto, se a aplicação suportar vários temas, que podem conter um grande número de elementos de tema, poderá ser mais fácil para geri-los utilizando um <xref:System.Windows.ResourceDictionary>instância para cada tema.</xref:System.Windows.ResourceDictionary> Desta forma, um novo tema pode ser aplicado ao definir a propriedade de recursos para o <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary> adequado       Existem duas considerações a tomar quando utilizar recursos. Primeiro, o dicionário *chave* é um objeto, por isso terá de utilizar exatamente a mesma instância de objeto quando a definição tanto ao obter um valor de propriedade (tenha em atenção que a chave é sensível ao utilizar uma cadeia). Segundo, o dicionário *valor* é um objeto, por isso terá de converter o valor para o tipo pretendido obter um valor de propriedade.       Recursos é seguros para threads e está disponíveis a partir de qualquer thread."
  example:
  - "This example illustrates how to use [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] together with application-scope resources to create a consistent visual appearance.  \n  \n [!code-xml[ApplicationResourcesSnippets#ResourcesPropertyXAML](~/add/codesnippet/xaml/ApplicationResourcesSnippets.XAML/App.xaml#resourcespropertyxaml)]  \n  \n [!code-xml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML1](~/add/codesnippet/xaml/ApplicationResourcesSnippets.XAML/MainWindow.xaml#windowbackgroundpropertyxaml1)]  \n[!code-xml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML2](~/add/codesnippet/xaml/ApplicationResourcesSnippets.XAML/MainWindow.xaml#windowbackgroundpropertyxaml2)]  \n  \n The following example shows how to set an application resource in code and XAML.  \n  \n [!code-vb[HOWTOApplicationModelSnippets#SetApplicationScopeResourceCODE](~/add/codesnippet/visualbasic/howtoapplicationmodelsnippets/applicationpropertiessnippet.xaml.vb#setapplicationscoperesourcecode)]\n [!code-cs[HOWTOApplicationModelSnippets#SetApplicationScopeResourceCODE](~/add/codesnippet/csharp/HOWTOApplicationModelSnippets/ApplicationPropertiesSnippet.xaml.cs#setapplicationscoperesourcecode)]  \n  \n [!code-xml[HOWTOApplicationModelSnippets#SetApplicationScopeResourceXAML](~/add/codesnippet/xaml/HOWTOApplicationModelSnippets/App.xaml#setapplicationscoperesourcexaml)]  \n  \n The following example shows how to get an application resource in code.  \n  \n [!code-vb[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/add/codesnippet/visualbasic/howtoapplicationmodelsnippets/applicationpropertiessnippet.xaml.vb#getapplicationscoperesourcecode)]\n [!code-cs[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/add/codesnippet/csharp/HOWTOApplicationModelSnippets/ApplicationPropertiesSnippet.xaml.cs#getapplicationscoperesourcecode)]"
  syntax:
    content: public System.Windows.ResourceDictionary Resources { get; set; }
    return:
      type: System.Windows.ResourceDictionary
      description: "A <xref href=&quot;System.Windows.ResourceDictionary&quot;> </xref> objeto que contenha zero ou mais recursos de âmbito de aplicação."
  overload: System.Windows.Application.Resources*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Run
  id: Run
  parent: System.Windows.Application
  langs:
  - csharp
  name: Run()
  nameWithType: Application.Run()
  fullName: System.Windows.Application.Run()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicia um [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] aplicação."
  remarks: "<xref:System.Windows.Application.Run%2A>é chamado para iniciar um [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] aplicação.</xref:System.Windows.Application.Run%2A> Se definir o <xref:System.Windows.Application>utilizando marcação, ou a marcação e code-behind, <xref:System.Windows.Application.Run%2A>será chamado implicitamente.</xref:System.Windows.Application.Run%2A> </xref:System.Windows.Application> No entanto, se definir a sua <xref:System.Windows.Application>utilização do código, terá de chamar explicitamente <xref:System.Windows.Application.Run%2A>.</xref:System.Windows.Application.Run%2A> </xref:System.Windows.Application>       Quando <xref:System.Windows.Application.Run%2A>denomina-se, <xref:System.Windows.Application>anexa um novo <xref:System.Windows.Threading.Dispatcher>instância para o [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] thread.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Application> </xref:System.Windows.Application.Run%2A> Em seguida, o <xref:System.Windows.Threading.Dispatcher>do objeto <xref:System.Windows.Threading.Dispatcher.Run%2A>método é denominado, que inicia uma bomba de mensagem para processar mensagens do windows.</xref:System.Windows.Threading.Dispatcher.Run%2A> </xref:System.Windows.Threading.Dispatcher> Por fim, o <xref:System.Windows.Threading.Dispatcher>chamadas de objeto a <xref:System.Windows.Application>do objeto a <xref:System.Windows.Application.OnStartup%2A>método para aumentar o <xref:System.Windows.Application.Startup>eventos.</xref:System.Windows.Application.Startup> </xref:System.Windows.Application.OnStartup%2A> </xref:System.Windows.Application> </xref:System.Windows.Threading.Dispatcher> Por conseguinte, o modelo de execução da aplicação tiver sido estabelecido dentro do tempo para processar <xref:System.Windows.Application.Startup>, altura em que a aplicação é considerada estar em execução.</xref:System.Windows.Application.Startup>       Uma aplicação deixa de ser executada quando <xref:System.Windows.Application.Shutdown%2A>é chamado; o valor do <xref:System.Windows.Application.ShutdownMode%2A>propriedade determina quando <xref:System.Windows.Application.Shutdown%2A>se chama e se ocorre automaticamente ou terá de explicitamente chamar mesmo.</xref:System.Windows.Application.Shutdown%2A> </xref:System.Windows.Application.ShutdownMode%2A> </xref:System.Windows.Application.Shutdown%2A>       <xref:System.Windows.Application.Run%2A>pode ser chamado apenas a partir do thread que cria o <xref:System.Windows.Application>objeto.</xref:System.Windows.Application></xref:System.Windows.Application.Run%2A> Além disso, <xref:System.Windows.Application.Run%2A>não pode ser chamado a partir de um [!INCLUDE[TLA2#tla_xbap](~/add/includes/ajax-current-ext-md.md)].</xref:System.Windows.Application.Run%2A>"
  example:
  - "The following example shows an application that uses a custom <xref:System.Windows.Application> and must therefore explicitly call <xref:System.Windows.Application.Run%2A>.  \n  \n [!code-vb[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/add/codesnippet/visualbasic/applicationrunsnippets/app.vb#customentrypointandruncode)]\n [!code-cs[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/add/codesnippet/csharp/ApplicationRunSnippets.CSharp/App.cs#customentrypointandruncode)]"
  syntax:
    content: public int Run ();
    parameters: []
    return:
      type: System.Int32
      description: "O <xref:System.Int32>código de saída da aplicação que é devolvido para o sistema operativo quando a aplicação será encerrado.</xref:System.Int32> Por predefinição, o valor do código de saída é 0."
  overload: System.Windows.Application.Run*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Executar é chamado a partir de uma aplicação alojada no browser (por exemplo, um [!INCLUDE[TLA#tla_xbap](~/add/includes/tlasharptla-xbap-md.md)])."
  platform:
  - net462
- uid: System.Windows.Application.Run(System.Windows.Window)
  id: Run(System.Windows.Window)
  parent: System.Windows.Application
  langs:
  - csharp
  name: Run(Window)
  nameWithType: Application.Run(Window)
  fullName: System.Windows.Application.Run(Window)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicia um [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] aplicação e abre-se a janela especificada."
  remarks: "Esta sobrecarga de expande o <xref:System.Windows.Application.Run%2A>método para abrir a janela especificada depois de uma aplicação entra em execução.</xref:System.Windows.Application.Run%2A>       Se definir um código <xref:System.Windows.Application>que é aberta uma janela quando entra em execução, pode chama explicitamente o executar.</xref:System.Windows.Application>       Se criar o <xref:System.Windows.Application>utilizar markup, ou a marcação e por detrás do código, pode automaticamente abrir uma janela durante utilizando as seguintes técnicas: - forma declarativa, definindo <xref:System.Windows.Application.StartupUri%2A>.</xref:System.Windows.Application.StartupUri%2A> </xref:System.Windows.Application>      -Através de programação, ao processamento <xref:System.Windows.Application.Startup>.</xref:System.Windows.Application.Startup>"
  example:
  - "The following example shows an application with a manually-created static entry point method that instantiates <xref:System.Windows.Application>, before calling <xref:System.Windows.Application.Run%2A>.  \n  \n [!code-cs[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/add/codesnippet/csharp/ApplicationRunOL1Snippets.CSharp/App.cs#customentrypointandrunol1code)]\n [!code-vb[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/add/codesnippet/visualbasic/applicationrunol1snippets/app.vb#customentrypointandrunol1code)]"
  syntax:
    content: public int Run (System.Windows.Window window);
    parameters:
    - id: window
      type: System.Windows.Window
      description: "A <xref href=&quot;System.Windows.Window&quot;> </xref> que se abre automaticamente quando uma aplicação é iniciada."
    return:
      type: System.Int32
      description: "O <xref:System.Int32>código de saída da aplicação que é devolvido para o sistema operativo quando a aplicação será encerrado.</xref:System.Int32> Por predefinição, o valor do código de saída é 0."
  overload: System.Windows.Application.Run*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref:System.Windows.Application.Run*>é chamado a partir de uma aplicação alojada no browser (por exemplo, um [!INCLUDE[TLA#tla_xbap](~/add/includes/tlasharptla-xbap-md.md)]).</xref:System.Windows.Application.Run*>"
  platform:
  - net462
- uid: System.Windows.Application.SessionEnding
  id: SessionEnding
  parent: System.Windows.Application
  langs:
  - csharp
  name: SessionEnding
  nameWithType: Application.SessionEnding
  fullName: System.Windows.Application.SessionEnding
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando o utilizador termina a [!INCLUDE[TLA#tla_mswin](~/add/includes/tlasharptla-mswin-md.md)] sessão ao terminar sessão ou encerrar o sistema operativo."
  remarks: "Por predefinição, uma aplicação encerra quando o [!INCLUDE[TLA#tla_mswin](~/add/includes/tlasharptla-mswin-md.md)] terminar sessão, que ocorre quando um utilizador termina a sessão ou encerrado. Quando isto acontecer, [!INCLUDE[TLA2#tla_mswin](~/add/includes/tla2sharptla-mswin-md.md)] pede-lhe cada aplicação abra a encerrar. No entanto, é possível que uma aplicação poderá não estar pronta para encerrar quando isto ocorre. Por exemplo, uma aplicação poderá ter dados que está num estado inconsistente, ou no meio de uma operação de execução longa. Nestas situações, pode ser preferível para impedir que terminar a sessão e pode ser mais preferível para permitir que os utilizadores a opção para decidir se deve ou não permitem a sessão para terminar.       Pode detetar quando termina uma sessão ao processar o evento SessionEnding. Se precisar de uma aplicação impedir que a sessão de terminar, o <xref:System.Windows.SessionEndingCancelEventArgs>argumento que é transferido para o processador de eventos expõe o <xref:System.ComponentModel.CancelEventArgs.Cancel%2A>que definiu `true` (o valor predefinido é `false`).</xref:System.ComponentModel.CancelEventArgs.Cancel%2A> </xref:System.Windows.SessionEndingCancelEventArgs>       Se SessionEnding é processado ou é processado sem a ser cancelado, <xref:System.Windows.Application.Shutdown%2A>denomina-se e o <xref:System.Windows.Application.Exit>o evento é gerado.</xref:System.Windows.Application.Exit> </xref:System.Windows.Application.Shutdown%2A>       Para obter mais informações sobre a razão pela qual está a terminar a sessão, uma aplicação pode inspecionar <xref:System.Windows.SessionEndingCancelEventArgs.ReasonSessionEnding%2A>, que é um do <xref:System.Windows.ReasonSessionEnding>valores (<xref:System.Windows.ReasonSessionEnding> e <xref:System.Windows.ReasonSessionEnding>).</xref:System.Windows.ReasonSessionEnding> </xref:System.Windows.ReasonSessionEnding> </xref:System.Windows.ReasonSessionEnding> </xref:System.Windows.SessionEndingCancelEventArgs.ReasonSessionEnding%2A>       SessionEnding não é gerado por aplicações de consola.       É desencadeado SessionEnding apenas no thread que cria o <xref:System.Windows.Application>objeto.</xref:System.Windows.Application>       SessionEnding não é gerado para [!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)]."
  example:
  - "The following example demonstrates how to handle the SessionEnding event and allow the user to cancel it.  \n  \n [!code-xml[ApplicationSessionEndingSnippets#HandlingSessionEndingXAML](~/add/codesnippet/xaml/ApplicationSessionEndingSnippets.CSharp/App.xaml#handlingsessionendingxaml)]  \n  \n [!code-vb[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/add/codesnippet/visualbasic/applicationsessionendingsnippets/application.xaml.vb#handlingsessionendingcodebehind)]\n [!code-cs[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/add/codesnippet/csharp/ApplicationSessionEndingSnippets.CSharp/App.xaml.cs#handlingsessionendingcodebehind)]"
  syntax:
    content: public event System.Windows.SessionEndingCancelEventHandler SessionEnding;
    return:
      type: System.Windows.SessionEndingCancelEventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.SetCookie(System.Uri,System.String)
  id: SetCookie(System.Uri,System.String)
  parent: System.Windows.Application
  langs:
  - csharp
  name: SetCookie(Uri,String)
  nameWithType: Application.SetCookie(Uri,String)
  fullName: System.Windows.Application.SetCookie(Uri,String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Cria um cookie para a localização especificada pela <xref:System.Uri>.</xref:System.Uri>"
  remarks: "Um cookie é uma informação arbitrária dos dados que podem ser armazenados por uma aplicação no computador cliente durante a sessões de aplicação (cookies de sessão) ou entre sessões de aplicação (cookies persistentes). Pode criar os dois tipos de cookies chamando SetCookie.       Dados de cookie demoram, normalmente, a forma de um par nome/valor no seguinte formato: `Name=Value` passar uma cadeia de formato para SetCookie, juntamente com o <xref:System.Uri>da localização para o qual o cookie deve ser definido (normalmente, o domínio de aplicação).</xref:System.Uri>       Se um cookie é um cookie de sessão ou um cookie persistente depende se a cadeia de cookie que passa ao SetCookie inclua uma data de expiração. A cadeia para um cookie de sessão não inclui uma data de expiração. A cadeia para um cookie persistente e tem de estar no seguinte formato: `NAME=VALUE; expires=DAY, DD-MMM-YYYY HH:MM:SS GMT` cookies persistentes são armazenados na atual [!INCLUDE[TLA#tla_mswin](~/add/includes/tlasharptla-mswin-md.md)] pasta Temporary Internet Files da instalação até expirarem, caso em que estes sejam eliminados. Pode eliminar um cookie persistente da sua aplicação, definindo a respetiva data de expiração para um valor de data/hora no passado.       Para obter uma descrição geral de cookies [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)], consulte [descrição geral de navegação](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static void SetCookie (Uri uri, string value);
    parameters:
    - id: uri
      type: System.Uri
      description: "O <xref:System.Uri>que especifica a localização para o qual o cookie deve ser criado.</xref:System.Uri>"
    - id: value
      type: System.String
      description: "O <xref:System.String>que contém os dados de cookie.</xref:System.String>"
  overload: System.Windows.Application.SetCookie*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "A [!INCLUDE[TLA#tla_win32](~/add/includes/tlasharptla-win32-md.md)] erro ser gerado pelo <xref uid=&quot;langword_csharp_InternetSetCookie&quot; name=&quot;InternetSetCookie&quot; href=&quot;&quot;> </xref> função (chamada pelo SetCookie) se ocorrer um problema ao tentar criar o cookie especificado."
  platform:
  - net462
- uid: System.Windows.Application.Shutdown
  id: Shutdown
  parent: System.Windows.Application
  langs:
  - csharp
  name: Shutdown()
  nameWithType: Application.Shutdown()
  fullName: System.Windows.Application.Shutdown()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Será encerrado a uma aplicação."
  remarks: "Quando é chamado encerramento, uma aplicação deixa de ser executada. Pode processar o <xref:System.Windows.Application.Exit>eventos para detetar quando uma aplicação está prestes a parar de executar, para efetuar qualquer processamento adequado.</xref:System.Windows.Application.Exit>       Encerramento implicitamente é chamado pelo [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] nas seguintes situações: - quando <xref:System.Windows.Application.ShutdownMode%2A>está definida como <xref:System.Windows.ShutdownMode>.</xref:System.Windows.ShutdownMode> </xref:System.Windows.Application.ShutdownMode%2A>      -Quando <xref:System.Windows.Application.ShutdownMode%2A>está definida como <xref:System.Windows.ShutdownMode>.</xref:System.Windows.ShutdownMode> </xref:System.Windows.Application.ShutdownMode%2A>      -Quando um utilizador termina a sessão e a <xref:System.Windows.Application.SessionEnding>evento é não processado, ou processado sem cancelamento.</xref:System.Windows.Application.SessionEnding>       Chamar explicitamente o encerramento faz com que uma aplicação encerrar, independentemente do <xref:System.Windows.Application.ShutdownMode%2A>definição.</xref:System.Windows.Application.ShutdownMode%2A> No entanto, se <xref:System.Windows.Application.ShutdownMode%2A>está definido como <xref:System.Windows.ShutdownMode>, tem de chamar o encerramento de encerrar uma aplicação.</xref:System.Windows.ShutdownMode> </xref:System.Windows.Application.ShutdownMode%2A>      > [!IMPORTANT] > Encerramento quando é chamado, a aplicação será encerrado independentemente se o <xref:System.Windows.Window.Closing>eventos de quaisquer janelas abertas foi cancelado.</xref:System.Windows.Window.Closing>       Este método pode ser chamado apenas a partir do thread que criou o <xref:System.Windows.Application>objeto.</xref:System.Windows.Application>"
  syntax:
    content: public void Shutdown ();
    parameters: []
  overload: System.Windows.Application.Shutdown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Shutdown(System.Int32)
  id: Shutdown(System.Int32)
  parent: System.Windows.Application
  langs:
  - csharp
  name: Shutdown(Int32)
  nameWithType: Application.Shutdown(Int32)
  fullName: System.Windows.Application.Shutdown(Int32)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Uma aplicação que devolve o código de saída especificado para o sistema operativo será encerrado."
  remarks: "Pode processar o <xref:System.Windows.Application.Exit>eventos para definir um código de saída.</xref:System.Windows.Application.Exit> No entanto, se chamar explicitamente <xref:System.Windows.Application.Shutdown%2A>, e para processar <xref:System.Windows.Application.Exit>só para definir um código de saída, pode chamar encerramento em vez disso.</xref:System.Windows.Application.Exit> </xref:System.Windows.Application.Shutdown%2A>       Este método pode ser chamado apenas a partir do thread que criou o <xref:System.Windows.Application>objeto.</xref:System.Windows.Application>"
  syntax:
    content: public void Shutdown (int exitCode);
    parameters:
    - id: exitCode
      type: System.Int32
      description: "Um código de saída de número inteiro de uma aplicação. O código de saída predefinido é 0."
  overload: System.Windows.Application.Shutdown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.ShutdownMode
  id: ShutdownMode
  parent: System.Windows.Application
  langs:
  - csharp
  name: ShutdownMode
  nameWithType: Application.ShutdownMode
  fullName: System.Windows.Application.ShutdownMode
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define a condição que faz com que o <xref:System.Windows.Application.Shutdown*>método a chamar.</xref:System.Windows.Application.Shutdown*>"
  remarks: "Parar de aplicações em execução apenas quando o <xref:System.Windows.Application.Shutdown%2A>método da aplicação é chamado.</xref:System.Windows.Application.Shutdown%2A> Encerramento pode ocorrer implícita ou explicitamente, tal como especificado pelo valor da propriedade ShutdownMode.       Se definir ShutdownMode para <xref:System.Windows.ShutdownMode>, [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] implicitamente chama <xref:System.Windows.Application.Shutdown%2A>quando a janela último numa aplicação fecha-se, mesmo se qualquer atualmente instanciadas windows estão definidas como a janela principal (consulte <xref:System.Windows.Application.MainWindow%2A>).</xref:System.Windows.Application.MainWindow%2A> </xref:System.Windows.Application.Shutdown%2A> </xref:System.Windows.ShutdownMode>       Um ShutdownMode de <xref:System.Windows.ShutdownMode>faz com que [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)]implicitamente chamar <xref:System.Windows.Application.Shutdown%2A>quando o <xref:System.Windows.Application.MainWindow%2A>fecha-se, mesmo se outras janelas estão atualmente abertas.</xref:System.Windows.Application.MainWindow%2A> </xref:System.Windows.Application.Shutdown%2A> </xref:System.Windows.ShutdownMode>       A duração de algumas aplicações não pode ser quando a janela principal janela última está fechada ou poderá não estar dependente do windows em todos os dependente. Nestes cenários tem de definir a propriedade ShutdownMode <xref:System.Windows.ShutdownMode>, que requer explícita <xref:System.Windows.Application.Shutdown%2A>chamada de método para parar a aplicação.</xref:System.Windows.Application.Shutdown%2A> </xref:System.Windows.ShutdownMode> Caso contrário, a aplicação continua em execução em segundo plano.       ShutdownMode pode ser configurado de forma declarativa de [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] ou programaticamente a partir do código.       Esta propriedade está disponível apenas a partir do thread que criou o <xref:System.Windows.Application>objeto.</xref:System.Windows.Application>"
  example:
  - "The following example shows how to configure ShutdownMode to specify that an application must be closed explicitly.  \n  \n [!code-xml[ApplicationShutdownModeSnippets#SetShutdownModeXAML](~/add/codesnippet/xaml/ApplicationShutdownModeSnippets.XAML/App.xaml#setshutdownmodexaml)]"
  syntax:
    content: public System.Windows.ShutdownMode ShutdownMode { get; set; }
    return:
      type: System.Windows.ShutdownMode
      description: "A <xref href=&quot;System.Windows.ShutdownMode&quot;> </xref> valor de enumeração. O valor predefinido é <xref href=&quot;System.Windows.ShutdownMode&quot;> </xref>."
  overload: System.Windows.Application.ShutdownMode*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Startup
  id: Startup
  parent: System.Windows.Application
  langs:
  - csharp
  name: Startup
  nameWithType: Application.Startup
  fullName: System.Windows.Application.Startup
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando o <xref:System.Windows.Application.Run*>método o <xref href=&quot;System.Windows.Application&quot;> </xref> objeto é chamado.</xref:System.Windows.Application.Run*>"
  remarks: "Típica [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] aplicação pode efetuar uma variedade de tarefas de inicialização de arranque, incluindo:-processar parâmetros da linha de comandos.      -Ao abrir a janela principal.      -A inicializar a recursos de âmbito de aplicação.      -A inicializar a propriedades de âmbito de aplicação.       Pode especificar forma declarativa a janela principal e os recursos de âmbito de aplicação utilizando [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] (<xref:System.Windows.Application.StartupUri%2A> e <xref:System.Windows.Application.Resources%2A>, respetivamente).</xref:System.Windows.Application.Resources%2A> </xref:System.Windows.Application.StartupUri%2A> Por vezes, no entanto, os recursos ou a janela principal da sua aplicação pode apenas ser determinada programaticamente em tempo de execução. Além disso, os parâmetros da linha de comandos e propriedades de âmbito de aplicação só podem ser utilizados através de programação. Inicialização programática pode ser efetuada por processar o evento de arranque, incluindo o seguinte: - adquirir e processar parâmetros da linha de comandos, que estão disponíveis no <xref:System.Windows.StartupEventArgs.Args%2A>propriedade o <xref:System.Windows.StartupEventArgs>classe que é transferida para o processador de eventos de arranque.</xref:System.Windows.StartupEventArgs> </xref:System.Windows.StartupEventArgs.Args%2A>      -Inicializar o âmbito de aplicação recursos utilizando o <xref:System.Windows.Application.Resources%2A>propriedade.</xref:System.Windows.Application.Resources%2A>      -Inicializar propriedades de âmbito de aplicação utilizando o <xref:System.Windows.Application.Properties%2A>propriedade.</xref:System.Windows.Application.Properties%2A>      -Instanciar e Mostrar windows um (ou mais).      > [!NOTE] > Parâmetros da linha de comandos é também possível adquirir ao chamar a estática <xref:System.Environment.GetCommandLineArgs%2A>método o <xref:System.Environment>objeto.</xref:System.Environment> </xref:System.Environment.GetCommandLineArgs%2A> No entanto, <xref:System.Environment.GetCommandLineArgs%2A>requer uma fidedignidade total para executar.</xref:System.Environment.GetCommandLineArgs%2A>       Se definir <xref:System.Windows.Application.StartupUri%2A>utilizando [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)], a janela principal, que é criada não está disponível a partir de <xref:System.Windows.Application.MainWindow%2A>propriedade ou o <xref:System.Windows.Application.Windows%2A>propriedade do <xref:System.Windows.Application>objeto até depois do evento de arranque é processado.</xref:System.Windows.Application> </xref:System.Windows.Application.Windows%2A> </xref:System.Windows.Application.MainWindow%2A> </xref:System.Windows.Application.StartupUri%2A> Se precisar de acesso para a janela principal durante o arranque, terá de criar manualmente um novo objeto de janela do processador de eventos de arranque.      > [!NOTE] > Se a sua aplicação utiliza <xref:System.Net.AuthenticationManager.CredentialPolicy%2A>para especificar uma política de credencial, tem de definir <xref:System.Net.AuthenticationManager.CredentialPolicy%2A>depois de arranque é gerado; caso contrário, [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] define-o como uma política de acesso predefinida interno diretamente depois do evento de arranque foi gerado.</xref:System.Net.AuthenticationManager.CredentialPolicy%2A> </xref:System.Net.AuthenticationManager.CredentialPolicy%2A>       Os argumentos da linha de comandos que são transmitidos para o processador de eventos de arranque não são os mesmos que o [!INCLUDE[TLA#tla_url](~/add/includes/tlasharptla-url-md.md)] consultar parâmetros de cadeia que são transferidos para um [!INCLUDE[TLA#tla_xbap](~/add/includes/tlasharptla-xbap-md.md)]."
  example:
  - "The following example shows how to acquire and process command-line options from a standalone application. If the **/StartMinimized** command-line parameter was provided, the application opens the main window in a minimized state.  \n  \n [!code-xml[ApplicationStartupSnippets#HandleStartupXAML](~/add/codesnippet/xaml/ApplicationStartupSnippets.CSharp/App.xaml#handlestartupxaml)]  \n  \n [!code-cs[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/add/codesnippet/csharp/ApplicationStartupSnippets.CSharp/App.xaml.cs#handlestartupcodebehind)]\n [!code-vb[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/add/codesnippet/visualbasic/applicationstartupsnippets/application.xaml.vb#handlestartupcodebehind)]  \n  \n [!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)] cannot retrieve and process command-line arguments because they are launched with [!INCLUDE[TLA#tla_clickonce](~/add/includes/tlasharptla-clickonce-md.md)] deployment (see [Deploying a WPF Application (WPF)](~/add/includes/ajax-current-ext-md.md)). However, they can retrieve and process query string parameters from the URLs that are used to launch them."
  syntax:
    content: public event System.Windows.StartupEventHandler Startup;
    return:
      type: System.Windows.StartupEventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.StartupUri
  id: StartupUri
  parent: System.Windows.Application
  langs:
  - csharp
  name: StartupUri
  nameWithType: Application.StartupUri
  fullName: System.Windows.Application.StartupUri
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define um [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] que é automaticamente apresentado quando uma aplicação for iniciada."
  remarks: "Pode utilizar StartupUri para carregar automaticamente um [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] recurso quando uma aplicação for iniciada.       A tabela seguinte mostra os tipos de [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] recursos que podem ser carregados, o tipo de janela abertos para e o tipo de aplicação que esses recursos podem ser definidos como o StartupUri.      | Tipo | Janela | Tipo de aplicação |   |----------|------------|----------------------|   | <xref:System.Windows.Window>| <xref:System.Windows.Window>| Apenas autónomo |   | <xref:System.Windows.Navigation.NavigationWindow>| <xref:System.Windows.Navigation.NavigationWindow>| Apenas autónomo |   | <xref:System.Windows.Controls.Page>| <xref:System.Windows.Navigation.NavigationWindow>| Alojada no browser/autónomo |   | <xref:System.Windows.Controls.UserControl>| <xref:System.Windows.Navigation.NavigationWindow>| Alojada no browser/autónomo |   | <xref:System.Windows.Documents.FlowDocument>| <xref:System.Windows.Navigation.NavigationWindow>| Alojada no browser/autónomo |   | <xref:System.Windows.Navigation.PageFunction%601>| <xref:System.Windows.Navigation.NavigationWindow>| Alojada no browser/autónomo |       Normalmente, definir a propriedade StartupUri forma declarativa na [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)].</xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Navigation.PageFunction%601> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Documents.FlowDocument> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Controls.UserControl> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Controls.Page> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Window> </xref:System.Windows.Window> No entanto, pode definir StartupUri programaticamente, tais como de um <xref:System.Windows.Application.Startup>processador de eventos, que é útil se para as aplicações que só podem carregar o necessário [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] recursos em tempo de execução.</xref:System.Windows.Application.Startup> Por exemplo, uma aplicação pode aguardar até o tempo de execução para carregar os respetivos recursos se o nome do [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] recurso é armazenado num ficheiro de configuração.       Se definir forma declarativa StartupUri ou através de programação, correspondente [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] recurso não está carregado até depois do <xref:System.Windows.Application.Startup>evento é processado.</xref:System.Windows.Application.Startup> Por conseguinte, não terá acesso a janela resultante de um a <xref:System.Windows.Application.Windows%2A>propriedade ou a <xref:System.Windows.Application.MainWindow%2A>propriedade quando o processamento <xref:System.Windows.Application.Startup>.</xref:System.Windows.Application.Startup> </xref:System.Windows.Application.MainWindow%2A> </xref:System.Windows.Application.Windows%2A>"
  syntax:
    content: public Uri StartupUri { get; set; }
    return:
      type: System.Uri
      description: "A <xref:System.Uri>que referencia o [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] que abre automaticamente quando uma aplicação for iniciada.</xref:System.Uri>"
  overload: System.Windows.Application.StartupUri*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "StartupUri está definida com um valor nulo."
  platform:
  - net462
- uid: System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  id: System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  isEii: true
  parent: System.Windows.Application
  langs:
  - csharp
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: Application.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.Application.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Consultas para uma propriedade de ambiente especificada está disponível no âmbito atual."
  remarks: "Este membro é uma implementação de membro de interface explícita. Pode ser utilizado apenas quando o <xref:System.Windows.Application>instância é convertida para um <xref:System.Windows.Markup.IQueryAmbient>interface.</xref:System.Windows.Markup.IQueryAmbient> </xref:System.Windows.Application>"
  syntax:
    content: bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);
    parameters:
    - id: propertyName
      type: System.String
      description: "O nome da propriedade ambiente pedida."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a propriedade de ambiente pedida está disponível; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.TryFindResource(System.Object)
  id: TryFindResource(System.Object)
  parent: System.Windows.Application
  langs:
  - csharp
  name: TryFindResource(Object)
  nameWithType: Application.TryFindResource(Object)
  fullName: System.Windows.Application.TryFindResource(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Procura o recurso especificado."
  remarks: "Primeiro terá um aspeto TryFindResource em recursos de âmbito de aplicação para o recurso especificado. Recursos de âmbito de aplicação são geridos pelo <xref:System.Windows.Application>e exposta a partir de <xref:System.Windows.Application.Resources%2A>propriedade.</xref:System.Windows.Application.Resources%2A> </xref:System.Windows.Application> Se o recurso especificado não foi encontrado no conjunto de recursos de âmbito de aplicação, TryFindResource, em seguida, em seguida procura recursos do sistema. Recursos do sistema são shell definido pelo utilizador e incluem as cores, tipos de letra e configurações de shell. Estes são expostas a partir de <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, e <xref:System.Windows.SystemParameters>tipos, respetivamente, como as propriedades estáticas.</xref:System.Windows.SystemParameters> </xref:System.Windows.SystemFonts> </xref:System.Windows.SystemColors> Para utilizar TryFindResource para adquiri-los, estes tipos também expõem as propriedades de chave de recurso que foram concebidas para transmitir ao TryFindResource; Por exemplo, <xref:System.Windows.SystemParameters.IconWidthKey%2A>.</xref:System.Windows.SystemParameters.IconWidthKey%2A>       Porque TryFindResource devolve um objeto, tem de converter o valor devolvido para o tipo apropriado se não for encontrado o recurso.       Este método é seguros para threads e pode ser chamado a partir de qualquer thread."
  example:
  - "The following example shows how to use TryFindResource to acquire a resource.  \n  \n [!code-xml[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceXAML](~/add/codesnippet/xaml/ApplicationTryFindResourceSnippets/App.xaml#applicationcalltryfindresourcexaml)]  \n  \n [!code-cs[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/add/codesnippet/csharp/ApplicationTryFindResourceSnippets/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind1)]\n [!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/add/codesnippet/visualbasic/applicationtryfindresourcesnippets/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind1)]  \n[!code-cs[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/add/codesnippet/csharp/ApplicationTryFindResourceSnippets/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind2)]\n[!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/add/codesnippet/visualbasic/applicationtryfindresourcesnippets/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind2)]"
  syntax:
    content: public object TryFindResource (object resourceKey);
    parameters:
    - id: resourceKey
      type: System.Object
      description: "O nome do recurso para localizar."
    return:
      type: System.Object
      description: "O objeto de recurso pedido. Se o recurso pedido não for encontrado, é devolvida uma referência nula."
  overload: System.Windows.Application.TryFindResource*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Windows
  id: Windows
  parent: System.Windows.Application
  langs:
  - csharp
  name: Windows
  nameWithType: Application.Windows
  fullName: System.Windows.Application.Windows
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém o windows com instâncias criadas numa aplicação."
  remarks: "A <xref:System.Windows.Window>referência é automaticamente adicionada ao Windows, assim como uma janela é instanciada no [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] thread; do windows que são criadas pelo trabalho threads não são adicionados.</xref:System.Windows.Window> A <xref:System.Windows.Window>referência é automaticamente removida após a respetiva <xref:System.Windows.Window.Closing>evento tenha sido processado e antes do respetivo <xref:System.Windows.Window.Closed>o evento é gerado.</xref:System.Windows.Window.Closed> </xref:System.Windows.Window.Closing> </xref:System.Windows.Window>       Por predefinição, o primeiro item adicionado à propriedade Windows torna-se <xref:System.Windows.Application.MainWindow%2A>.</xref:System.Windows.Application.MainWindow%2A>       Esta propriedade está disponível apenas a partir do thread que criou o <xref:System.Windows.Application>objeto.</xref:System.Windows.Application>"
  example:
  - "The following example demonstrates how to enumerate the Windows property to build a top-level Windows menu, which is common to [!INCLUDE[TLA#tla_mdi](~/add/includes/tlasharptla-mdi-md.md)] applications like [!INCLUDE[TLA#tla_xl](~/add/includes/tlasharptla-xl-md.md)], or multiple-instance Single Document Interface (SDI) applications like [!INCLUDE[TLA#tla_word](~/add/includes/tlasharptla-word-md.md)].  \n  \n [!code-vb[ApplicationWindowsSnippets#WindowMenuItemCODE](~/add/codesnippet/visualbasic/applicationwindowssnippets/windowmenuitem.vb#windowmenuitemcode)]\n [!code-cs[ApplicationWindowsSnippets#WindowMenuItemCODE](~/add/codesnippet/csharp/ApplicationWindowsSnippets.CSharp/WindowMenuItem.cs#windowmenuitemcode)]  \n  \n [!code-xml[ApplicationWindowsSnippets#MainWindowSetWindowsXAML](~/add/codesnippet/xaml/ApplicationWindowsSnippets.CSharp/MainWindow.xaml#mainwindowsetwindowsxaml)]  \n  \n [!code-cs[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/add/codesnippet/csharp/ApplicationWindowsSnippets.CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind1)]\n [!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/add/codesnippet/visualbasic/applicationwindowssnippets/mainwindow.xaml.vb#mainwindowsetwindowscodebehind1)]  \n[!code-cs[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/add/codesnippet/csharp/ApplicationWindowsSnippets.CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind2)]\n[!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/add/codesnippet/visualbasic/applicationwindowssnippets/mainwindow.xaml.vb#mainwindowsetwindowscodebehind2)]"
  syntax:
    content: public System.Windows.WindowCollection Windows { get; }
    return:
      type: System.Windows.WindowCollection
      description: "A <xref href=&quot;System.Windows.WindowCollection&quot;> </xref> que contém referências a todos os objetos de janela atual <xref href=&quot;System.AppDomain&quot;> </xref>."
  overload: System.Windows.Application.Windows*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.Threading.DispatcherObject
  isExternal: false
  name: System.Windows.Threading.DispatcherObject
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Windows.ResourceReferenceKeyNotFoundException
  parent: System.Windows
  isExternal: false
  name: ResourceReferenceKeyNotFoundException
  nameWithType: ResourceReferenceKeyNotFoundException
  fullName: System.Windows.ResourceReferenceKeyNotFoundException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ComponentModel.Win32Exception
  parent: System.ComponentModel
  isExternal: false
  name: Win32Exception
  nameWithType: Win32Exception
  fullName: System.ComponentModel.Win32Exception
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.Exception
  isExternal: true
  name: System.Exception
- uid: System.Windows.Application.#ctor
  parent: System.Windows.Application
  isExternal: false
  name: Application()
  nameWithType: Application.Application()
  fullName: System.Windows.Application.Application()
- uid: System.Windows.Application.Activated
  parent: System.Windows.Application
  isExternal: false
  name: Activated
  nameWithType: Application.Activated
  fullName: System.Windows.Application.Activated
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Windows.Application.Current
  parent: System.Windows.Application
  isExternal: false
  name: Current
  nameWithType: Application.Current
  fullName: System.Windows.Application.Current
- uid: System.Windows.Application
  parent: System.Windows
  isExternal: false
  name: Application
  nameWithType: Application
  fullName: System.Windows.Application
- uid: System.Windows.Application.Deactivated
  parent: System.Windows.Application
  isExternal: false
  name: Deactivated
  nameWithType: Application.Deactivated
  fullName: System.Windows.Application.Deactivated
- uid: System.Windows.Application.DispatcherUnhandledException
  parent: System.Windows.Application
  isExternal: false
  name: DispatcherUnhandledException
  nameWithType: Application.DispatcherUnhandledException
  fullName: System.Windows.Application.DispatcherUnhandledException
- uid: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherUnhandledExceptionEventHandler
  nameWithType: DispatcherUnhandledExceptionEventHandler
  fullName: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
- uid: System.Windows.Application.Exit
  parent: System.Windows.Application
  isExternal: false
  name: Exit
  nameWithType: Application.Exit
  fullName: System.Windows.Application.Exit
- uid: System.Windows.ExitEventHandler
  parent: System.Windows
  isExternal: false
  name: ExitEventHandler
  nameWithType: ExitEventHandler
  fullName: System.Windows.ExitEventHandler
- uid: System.Windows.Application.FindResource(System.Object)
  parent: System.Windows.Application
  isExternal: false
  name: FindResource(Object)
  nameWithType: Application.FindResource(Object)
  fullName: System.Windows.Application.FindResource(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.Application.FragmentNavigation
  parent: System.Windows.Application
  isExternal: false
  name: FragmentNavigation
  nameWithType: Application.FragmentNavigation
  fullName: System.Windows.Application.FragmentNavigation
- uid: System.Windows.Navigation.FragmentNavigationEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: FragmentNavigationEventHandler
  nameWithType: FragmentNavigationEventHandler
  fullName: System.Windows.Navigation.FragmentNavigationEventHandler
- uid: System.Windows.Application.GetContentStream(System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: GetContentStream(Uri)
  nameWithType: Application.GetContentStream(Uri)
  fullName: System.Windows.Application.GetContentStream(Uri)
- uid: System.Windows.Resources.StreamResourceInfo
  parent: System.Windows.Resources
  isExternal: false
  name: StreamResourceInfo
  nameWithType: StreamResourceInfo
  fullName: System.Windows.Resources.StreamResourceInfo
- uid: System.Uri
  parent: System
  isExternal: true
  name: Uri
  nameWithType: Uri
  fullName: System.Uri
- uid: System.Windows.Application.GetCookie(System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: GetCookie(Uri)
  nameWithType: Application.GetCookie(Uri)
  fullName: System.Windows.Application.GetCookie(Uri)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.Application.GetRemoteStream(System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: GetRemoteStream(Uri)
  nameWithType: Application.GetRemoteStream(Uri)
  fullName: System.Windows.Application.GetRemoteStream(Uri)
- uid: System.Windows.Application.GetResourceStream(System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: GetResourceStream(Uri)
  nameWithType: Application.GetResourceStream(Uri)
  fullName: System.Windows.Application.GetResourceStream(Uri)
- uid: System.Windows.Application.LoadCompleted
  parent: System.Windows.Application
  isExternal: false
  name: LoadCompleted
  nameWithType: Application.LoadCompleted
  fullName: System.Windows.Application.LoadCompleted
- uid: System.Windows.Navigation.LoadCompletedEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: LoadCompletedEventHandler
  nameWithType: LoadCompletedEventHandler
  fullName: System.Windows.Navigation.LoadCompletedEventHandler
- uid: System.Windows.Application.LoadComponent(System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: LoadComponent(Uri)
  nameWithType: Application.LoadComponent(Uri)
  fullName: System.Windows.Application.LoadComponent(Uri)
- uid: System.Windows.Application.LoadComponent(System.Object,System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: LoadComponent(Object,Uri)
  nameWithType: Application.LoadComponent(Object,Uri)
  fullName: System.Windows.Application.LoadComponent(Object,Uri)
- uid: System.Windows.Application.MainWindow
  parent: System.Windows.Application
  isExternal: false
  name: MainWindow
  nameWithType: Application.MainWindow
  fullName: System.Windows.Application.MainWindow
- uid: System.Windows.Window
  parent: System.Windows
  isExternal: false
  name: Window
  nameWithType: Window
  fullName: System.Windows.Window
- uid: System.Windows.Application.Navigated
  parent: System.Windows.Application
  isExternal: false
  name: Navigated
  nameWithType: Application.Navigated
  fullName: System.Windows.Application.Navigated
- uid: System.Windows.Navigation.NavigatedEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigatedEventHandler
  nameWithType: NavigatedEventHandler
  fullName: System.Windows.Navigation.NavigatedEventHandler
- uid: System.Windows.Application.Navigating
  parent: System.Windows.Application
  isExternal: false
  name: Navigating
  nameWithType: Application.Navigating
  fullName: System.Windows.Application.Navigating
- uid: System.Windows.Navigation.NavigatingCancelEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigatingCancelEventHandler
  nameWithType: NavigatingCancelEventHandler
  fullName: System.Windows.Navigation.NavigatingCancelEventHandler
- uid: System.Windows.Application.NavigationFailed
  parent: System.Windows.Application
  isExternal: false
  name: NavigationFailed
  nameWithType: Application.NavigationFailed
  fullName: System.Windows.Application.NavigationFailed
- uid: System.Windows.Navigation.NavigationFailedEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationFailedEventHandler
  nameWithType: NavigationFailedEventHandler
  fullName: System.Windows.Navigation.NavigationFailedEventHandler
- uid: System.Windows.Application.NavigationProgress
  parent: System.Windows.Application
  isExternal: false
  name: NavigationProgress
  nameWithType: Application.NavigationProgress
  fullName: System.Windows.Application.NavigationProgress
- uid: System.Windows.Navigation.NavigationProgressEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationProgressEventHandler
  nameWithType: NavigationProgressEventHandler
  fullName: System.Windows.Navigation.NavigationProgressEventHandler
- uid: System.Windows.Application.NavigationStopped
  parent: System.Windows.Application
  isExternal: false
  name: NavigationStopped
  nameWithType: Application.NavigationStopped
  fullName: System.Windows.Application.NavigationStopped
- uid: System.Windows.Navigation.NavigationStoppedEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationStoppedEventHandler
  nameWithType: NavigationStoppedEventHandler
  fullName: System.Windows.Navigation.NavigationStoppedEventHandler
- uid: System.Windows.Application.OnActivated(System.EventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnActivated(EventArgs)
  nameWithType: Application.OnActivated(EventArgs)
  fullName: System.Windows.Application.OnActivated(EventArgs)
- uid: System.EventArgs
  parent: System
  isExternal: true
  name: EventArgs
  nameWithType: EventArgs
  fullName: System.EventArgs
- uid: System.Windows.Application.OnDeactivated(System.EventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnDeactivated(EventArgs)
  nameWithType: Application.OnDeactivated(EventArgs)
  fullName: System.Windows.Application.OnDeactivated(EventArgs)
- uid: System.Windows.Application.OnExit(System.Windows.ExitEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnExit(ExitEventArgs)
  nameWithType: Application.OnExit(ExitEventArgs)
  fullName: System.Windows.Application.OnExit(ExitEventArgs)
- uid: System.Windows.ExitEventArgs
  parent: System.Windows
  isExternal: false
  name: ExitEventArgs
  nameWithType: ExitEventArgs
  fullName: System.Windows.ExitEventArgs
- uid: System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnFragmentNavigation(FragmentNavigationEventArgs)
  nameWithType: Application.OnFragmentNavigation(FragmentNavigationEventArgs)
  fullName: System.Windows.Application.OnFragmentNavigation(FragmentNavigationEventArgs)
- uid: System.Windows.Navigation.FragmentNavigationEventArgs
  parent: System.Windows.Navigation
  isExternal: false
  name: FragmentNavigationEventArgs
  nameWithType: FragmentNavigationEventArgs
  fullName: System.Windows.Navigation.FragmentNavigationEventArgs
- uid: System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnLoadCompleted(NavigationEventArgs)
  nameWithType: Application.OnLoadCompleted(NavigationEventArgs)
  fullName: System.Windows.Application.OnLoadCompleted(NavigationEventArgs)
- uid: System.Windows.Navigation.NavigationEventArgs
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationEventArgs
  nameWithType: NavigationEventArgs
  fullName: System.Windows.Navigation.NavigationEventArgs
- uid: System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigated(NavigationEventArgs)
  nameWithType: Application.OnNavigated(NavigationEventArgs)
  fullName: System.Windows.Application.OnNavigated(NavigationEventArgs)
- uid: System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigating(NavigatingCancelEventArgs)
  nameWithType: Application.OnNavigating(NavigatingCancelEventArgs)
  fullName: System.Windows.Application.OnNavigating(NavigatingCancelEventArgs)
- uid: System.Windows.Navigation.NavigatingCancelEventArgs
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigatingCancelEventArgs
  nameWithType: NavigatingCancelEventArgs
  fullName: System.Windows.Navigation.NavigatingCancelEventArgs
- uid: System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationFailed(NavigationFailedEventArgs)
  nameWithType: Application.OnNavigationFailed(NavigationFailedEventArgs)
  fullName: System.Windows.Application.OnNavigationFailed(NavigationFailedEventArgs)
- uid: System.Windows.Navigation.NavigationFailedEventArgs
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationFailedEventArgs
  nameWithType: NavigationFailedEventArgs
  fullName: System.Windows.Navigation.NavigationFailedEventArgs
- uid: System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationProgress(NavigationProgressEventArgs)
  nameWithType: Application.OnNavigationProgress(NavigationProgressEventArgs)
  fullName: System.Windows.Application.OnNavigationProgress(NavigationProgressEventArgs)
- uid: System.Windows.Navigation.NavigationProgressEventArgs
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationProgressEventArgs
  nameWithType: NavigationProgressEventArgs
  fullName: System.Windows.Navigation.NavigationProgressEventArgs
- uid: System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationStopped(NavigationEventArgs)
  nameWithType: Application.OnNavigationStopped(NavigationEventArgs)
  fullName: System.Windows.Application.OnNavigationStopped(NavigationEventArgs)
- uid: System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnSessionEnding(SessionEndingCancelEventArgs)
  nameWithType: Application.OnSessionEnding(SessionEndingCancelEventArgs)
  fullName: System.Windows.Application.OnSessionEnding(SessionEndingCancelEventArgs)
- uid: System.Windows.SessionEndingCancelEventArgs
  parent: System.Windows
  isExternal: false
  name: SessionEndingCancelEventArgs
  nameWithType: SessionEndingCancelEventArgs
  fullName: System.Windows.SessionEndingCancelEventArgs
- uid: System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnStartup(StartupEventArgs)
  nameWithType: Application.OnStartup(StartupEventArgs)
  fullName: System.Windows.Application.OnStartup(StartupEventArgs)
- uid: System.Windows.StartupEventArgs
  parent: System.Windows
  isExternal: false
  name: StartupEventArgs
  nameWithType: StartupEventArgs
  fullName: System.Windows.StartupEventArgs
- uid: System.Windows.Application.Properties
  parent: System.Windows.Application
  isExternal: false
  name: Properties
  nameWithType: Application.Properties
  fullName: System.Windows.Application.Properties
- uid: System.Collections.IDictionary
  parent: System.Collections
  isExternal: true
  name: IDictionary
  nameWithType: IDictionary
  fullName: System.Collections.IDictionary
- uid: System.Windows.Application.ResourceAssembly
  parent: System.Windows.Application
  isExternal: false
  name: ResourceAssembly
  nameWithType: Application.ResourceAssembly
  fullName: System.Windows.Application.ResourceAssembly
- uid: System.Reflection.Assembly
  parent: System.Reflection
  isExternal: true
  name: Assembly
  nameWithType: Assembly
  fullName: System.Reflection.Assembly
- uid: System.Windows.Application.Resources
  parent: System.Windows.Application
  isExternal: false
  name: Resources
  nameWithType: Application.Resources
  fullName: System.Windows.Application.Resources
- uid: System.Windows.ResourceDictionary
  parent: System.Windows
  isExternal: false
  name: ResourceDictionary
  nameWithType: ResourceDictionary
  fullName: System.Windows.ResourceDictionary
- uid: System.Windows.Application.Run
  parent: System.Windows.Application
  isExternal: false
  name: Run()
  nameWithType: Application.Run()
  fullName: System.Windows.Application.Run()
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.Application.Run(System.Windows.Window)
  parent: System.Windows.Application
  isExternal: false
  name: Run(Window)
  nameWithType: Application.Run(Window)
  fullName: System.Windows.Application.Run(Window)
- uid: System.Windows.Application.SessionEnding
  parent: System.Windows.Application
  isExternal: false
  name: SessionEnding
  nameWithType: Application.SessionEnding
  fullName: System.Windows.Application.SessionEnding
- uid: System.Windows.SessionEndingCancelEventHandler
  parent: System.Windows
  isExternal: false
  name: SessionEndingCancelEventHandler
  nameWithType: SessionEndingCancelEventHandler
  fullName: System.Windows.SessionEndingCancelEventHandler
- uid: System.Windows.Application.SetCookie(System.Uri,System.String)
  parent: System.Windows.Application
  isExternal: false
  name: SetCookie(Uri,String)
  nameWithType: Application.SetCookie(Uri,String)
  fullName: System.Windows.Application.SetCookie(Uri,String)
- uid: System.Windows.Application.Shutdown
  parent: System.Windows.Application
  isExternal: false
  name: Shutdown()
  nameWithType: Application.Shutdown()
  fullName: System.Windows.Application.Shutdown()
- uid: System.Windows.Application.Shutdown(System.Int32)
  parent: System.Windows.Application
  isExternal: false
  name: Shutdown(Int32)
  nameWithType: Application.Shutdown(Int32)
  fullName: System.Windows.Application.Shutdown(Int32)
- uid: System.Windows.Application.ShutdownMode
  parent: System.Windows.Application
  isExternal: false
  name: ShutdownMode
  nameWithType: Application.ShutdownMode
  fullName: System.Windows.Application.ShutdownMode
- uid: System.Windows.ShutdownMode
  parent: System.Windows
  isExternal: false
  name: ShutdownMode
  nameWithType: ShutdownMode
  fullName: System.Windows.ShutdownMode
- uid: System.Windows.Application.Startup
  parent: System.Windows.Application
  isExternal: false
  name: Startup
  nameWithType: Application.Startup
  fullName: System.Windows.Application.Startup
- uid: System.Windows.StartupEventHandler
  parent: System.Windows
  isExternal: false
  name: StartupEventHandler
  nameWithType: StartupEventHandler
  fullName: System.Windows.StartupEventHandler
- uid: System.Windows.Application.StartupUri
  parent: System.Windows.Application
  isExternal: false
  name: StartupUri
  nameWithType: Application.StartupUri
  fullName: System.Windows.Application.StartupUri
- uid: System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  parent: System.Windows.Application
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: Application.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.Application.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.Application.TryFindResource(System.Object)
  parent: System.Windows.Application
  isExternal: false
  name: TryFindResource(Object)
  nameWithType: Application.TryFindResource(Object)
  fullName: System.Windows.Application.TryFindResource(Object)
- uid: System.Windows.Application.Windows
  parent: System.Windows.Application
  isExternal: false
  name: Windows
  nameWithType: Application.Windows
  fullName: System.Windows.Application.Windows
- uid: System.Windows.WindowCollection
  parent: System.Windows
  isExternal: false
  name: WindowCollection
  nameWithType: WindowCollection
  fullName: System.Windows.WindowCollection
- uid: System.Windows.Application.#ctor*
  parent: System.Windows.Application
  isExternal: false
  name: Application
  nameWithType: Application.Application
- uid: System.Windows.Application.Current*
  parent: System.Windows.Application
  isExternal: false
  name: Current
  nameWithType: Application.Current
- uid: System.Windows.Application.FindResource*
  parent: System.Windows.Application
  isExternal: false
  name: FindResource
  nameWithType: Application.FindResource
- uid: System.Windows.Application.GetContentStream*
  parent: System.Windows.Application
  isExternal: false
  name: GetContentStream
  nameWithType: Application.GetContentStream
- uid: System.Windows.Application.GetCookie*
  parent: System.Windows.Application
  isExternal: false
  name: GetCookie
  nameWithType: Application.GetCookie
- uid: System.Windows.Application.GetRemoteStream*
  parent: System.Windows.Application
  isExternal: false
  name: GetRemoteStream
  nameWithType: Application.GetRemoteStream
- uid: System.Windows.Application.GetResourceStream*
  parent: System.Windows.Application
  isExternal: false
  name: GetResourceStream
  nameWithType: Application.GetResourceStream
- uid: System.Windows.Application.LoadComponent*
  parent: System.Windows.Application
  isExternal: false
  name: LoadComponent
  nameWithType: Application.LoadComponent
- uid: System.Windows.Application.MainWindow*
  parent: System.Windows.Application
  isExternal: false
  name: MainWindow
  nameWithType: Application.MainWindow
- uid: System.Windows.Application.OnActivated*
  parent: System.Windows.Application
  isExternal: false
  name: OnActivated
  nameWithType: Application.OnActivated
- uid: System.Windows.Application.OnDeactivated*
  parent: System.Windows.Application
  isExternal: false
  name: OnDeactivated
  nameWithType: Application.OnDeactivated
- uid: System.Windows.Application.OnExit*
  parent: System.Windows.Application
  isExternal: false
  name: OnExit
  nameWithType: Application.OnExit
- uid: System.Windows.Application.OnFragmentNavigation*
  parent: System.Windows.Application
  isExternal: false
  name: OnFragmentNavigation
  nameWithType: Application.OnFragmentNavigation
- uid: System.Windows.Application.OnLoadCompleted*
  parent: System.Windows.Application
  isExternal: false
  name: OnLoadCompleted
  nameWithType: Application.OnLoadCompleted
- uid: System.Windows.Application.OnNavigated*
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigated
  nameWithType: Application.OnNavigated
- uid: System.Windows.Application.OnNavigating*
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigating
  nameWithType: Application.OnNavigating
- uid: System.Windows.Application.OnNavigationFailed*
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationFailed
  nameWithType: Application.OnNavigationFailed
- uid: System.Windows.Application.OnNavigationProgress*
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationProgress
  nameWithType: Application.OnNavigationProgress
- uid: System.Windows.Application.OnNavigationStopped*
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationStopped
  nameWithType: Application.OnNavigationStopped
- uid: System.Windows.Application.OnSessionEnding*
  parent: System.Windows.Application
  isExternal: false
  name: OnSessionEnding
  nameWithType: Application.OnSessionEnding
- uid: System.Windows.Application.OnStartup*
  parent: System.Windows.Application
  isExternal: false
  name: OnStartup
  nameWithType: Application.OnStartup
- uid: System.Windows.Application.Properties*
  parent: System.Windows.Application
  isExternal: false
  name: Properties
  nameWithType: Application.Properties
- uid: System.Windows.Application.ResourceAssembly*
  parent: System.Windows.Application
  isExternal: false
  name: ResourceAssembly
  nameWithType: Application.ResourceAssembly
- uid: System.Windows.Application.Resources*
  parent: System.Windows.Application
  isExternal: false
  name: Resources
  nameWithType: Application.Resources
- uid: System.Windows.Application.Run*
  parent: System.Windows.Application
  isExternal: false
  name: Run
  nameWithType: Application.Run
- uid: System.Windows.Application.SetCookie*
  parent: System.Windows.Application
  isExternal: false
  name: SetCookie
  nameWithType: Application.SetCookie
- uid: System.Windows.Application.Shutdown*
  parent: System.Windows.Application
  isExternal: false
  name: Shutdown
  nameWithType: Application.Shutdown
- uid: System.Windows.Application.ShutdownMode*
  parent: System.Windows.Application
  isExternal: false
  name: ShutdownMode
  nameWithType: Application.ShutdownMode
- uid: System.Windows.Application.StartupUri*
  parent: System.Windows.Application
  isExternal: false
  name: StartupUri
  nameWithType: Application.StartupUri
- uid: System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  parent: System.Windows.Application
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
  nameWithType: Application.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
- uid: System.Windows.Application.TryFindResource*
  parent: System.Windows.Application
  isExternal: false
  name: TryFindResource
  nameWithType: Application.TryFindResource
- uid: System.Windows.Application.Windows*
  parent: System.Windows.Application
  isExternal: false
  name: Windows
  nameWithType: Application.Windows
