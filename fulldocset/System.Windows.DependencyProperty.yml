### YamlMime:ManagedReference
items:
- uid: System.Windows.DependencyProperty
  id: DependencyProperty
  children:
  - System.Windows.DependencyProperty.AddOwner(System.Type)
  - System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.DefaultMetadata
  - System.Windows.DependencyProperty.GetHashCode
  - System.Windows.DependencyProperty.GetMetadata(System.Type)
  - System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)
  - System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)
  - System.Windows.DependencyProperty.GlobalIndex
  - System.Windows.DependencyProperty.IsValidType(System.Object)
  - System.Windows.DependencyProperty.IsValidValue(System.Object)
  - System.Windows.DependencyProperty.Name
  - System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  - System.Windows.DependencyProperty.OwnerType
  - System.Windows.DependencyProperty.PropertyType
  - System.Windows.DependencyProperty.ReadOnly
  - System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)
  - System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)
  - System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.ToString
  - System.Windows.DependencyProperty.UnsetValue
  - System.Windows.DependencyProperty.ValidateValueCallback
  langs:
  - csharp
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
  type: Class
  summary: "Representa uma propriedade que pode ser definida como através de métodos, estilo, enlace de dados, animação e herança."
  remarks: "Um DependencyProperty suporta as seguintes capacidades no [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)]:-a propriedade pode ser definida num style. Para obter mais informações, consulte [estilos e Templating](~/add/includes/ajax-current-ext-md.md).      -A propriedade pode ser definida através do enlace de dados. Para obter mais informações sobre as propriedades de dependência de enlace de dados, consulte [como: vincular as propriedades de controlos dois](~/add/includes/ajax-current-ext-md.md).      -A propriedade pode ser definida com uma referência de recursos dinâmicos. Para obter mais informações, consulte [XAML recursos](~/add/includes/ajax-current-ext-md.md).      -A propriedade pode herdam o valor automaticamente um elemento principal na árvore de elemento. Para obter mais informações, consulte [herança de valor de propriedade](~/add/includes/ajax-current-ext-md.md).      -Pode ser animada a propriedade. Para obter mais informações, consulte [descrição geral de animação](~/add/includes/ajax-current-ext-md.md).      -A propriedade pode reportar quando o valor da propriedade anterior foi alterado e o valor da propriedade pode ser forçado. Para obter mais informações, consulte [chamadas de retorno de propriedade de dependência e validação](~/add/includes/ajax-current-ext-md.md).      -A propriedade relatórios de informações para [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], tal como se alterar um valor de propriedade deve exigir que o esquema sistema recompose visuais para um elemento.      -A propriedade recebe suporte no [!INCLUDE[wpfdesigner_current_long](~/add/includes/wpfdesigner-current-long-md.md)].  Por exemplo, a propriedade pode ser editada no **propriedades** janela.       Para saber mais sobre as propriedades de dependência, consulte [descrição geral de propriedades de dependência](~/add/includes/ajax-current-ext-md.md). Se pretender que as propriedades no seu tipos personalizados para suportar as capacidades na lista anterior, deve criar uma propriedade de dependência.  Para saber como criar propriedades de dependência personalizada, consulte [propriedades de dependência personalizadas](~/add/includes/ajax-current-ext-md.md).       Uma propriedade anexada é uma propriedade que permite que qualquer objeto para as informações de relatório para o tipo que define a propriedade anexada. No [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], qualquer tipo que herda de <xref:System.Windows.DependencyObject>pode utilizar uma propriedade anexada independentemente se o tipo herda a partir do tipo que define a propriedade.</xref:System.Windows.DependencyObject> Uma propriedade anexada é uma funcionalidade do [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] idioma.  Para definir uma propriedade anexada em [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], utilize o *ownerType*.* propertyName* sintaxe. É um exemplo de uma propriedade anexada a <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName>propriedade.</xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName> Se pretender criar uma propriedade que pode ser utilizada em todos os <xref:System.Windows.DependencyObject>tipos, em seguida, deve criar uma propriedade anexada.</xref:System.Windows.DependencyObject> Para obter mais informações sobre propriedades anexadas, incluindo como criá-los, consulte o artigo [ligado descrição geral de propriedades](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;xamlAttributeUsage_DependencyProperty&quot;></a># # Utilização do atributo de XAML ```   <object property=&quot;dependencyPropertyName&quot;/>   - or -   <object property=&quot;ownerType.dependencyPropertyName&quot;/>   - or -   <object property=&quot;attachedPropertyOwnerType.attachedPropertyName&quot;/>   ``` <a name=&quot;xamlValues_DependencyProperty&quot;> </a> # # XAML valores `dependencyPropertyName` uma cadeia que especifica o <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName>da propriedade de dependência pretendido.</xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName>       Isto pode ser precedido por um prefixo de espaço de nomes XML se a propriedade não se encontra no espaço de nomes XML predefinido (para obter mais informações, consulte [XAML espaços de nomes e o espaço de nomes de mapeamento para WPF XAML](~/add/includes/ajax-current-ext-md.md).)       `ownerType`.`dependencyPropertyName`    Uma cadeia que especifica um tipo de proprietário de uma propriedade de dependência, um ponto (.), em seguida, <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName>.</xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName> `ownerType`Também pode ser precedido por um prefixo de espaço de nomes XML. Esta utilização é específica para tardio estilos e modelos, onde o proprietário da propriedade de dependência tem de ser especificado para o contexto de análise porque o `TargetType` ainda não é conhecido. Para obter mais informações, consulte [estilos e Templating](../Topic/Styling%20and%20Templating.md).       `attachedPropertyOwnerType` *.* `attachedPropertyName`Uma cadeia que especifica o proprietário de uma propriedade anexada, um ponto (.), em seguida, o nome da propriedade anexada. `attachedPropertyOwnerType`Também pode ser precedido por um prefixo de espaço de nomes XML."
  syntax:
    content: >-
      [System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]

      [System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))]

      public sealed class DependencyProperty
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.AddOwner(System.Type)
  id: AddOwner(System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: AddOwner(Type)
  nameWithType: DependencyProperty.AddOwner(Type)
  fullName: System.Windows.DependencyProperty.AddOwner(Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Adiciona o tipo de outro como um proprietário de uma propriedade de dependência que já foi registado."
  remarks: "Este método permite que o sistema de propriedade reconhecer uma propriedade de dependência num tipo que não se registou essa propriedade de dependência específico inicialmente.       Normalmente, AddOwner é utilizada para adicionar propriedades de dependência para classes que expõe já essa propriedade de dependência através de herança de classe gerida (herança de classe faria com que as propriedades de wrapper para herdado por classe derivada e, por conseguinte, iria fornecer acesso de tabela de membros gerais para a propriedade de dependência já). AddOwner permite que o sistema de propriedade reconhecer uma propriedade de dependência num tipo que não se registou essa propriedade de dependência inicialmente.       Esta assinatura não permite a especificação de metadados.  Quando utiliza este método, os metadados é gerado automaticamente para a nova <xref:System.Windows.DependencyProperty>e o respetivo tipo de proprietário.</xref:System.Windows.DependencyProperty> Os metadados de geração automática são o resultado dos metadados intercalado de todos os tipos base com esta propriedade definida. Se não existem metadados intercalado estiver disponível, os metadados predefinidos para a propriedade é utilizado. Se a propriedade está registada utilizando o <xref:System.Windows.DependencyProperty.RegisterAttached%2A>método, em seguida, os metadados de predefinição é o mesmo que os metadados que é criado quando <xref:System.Windows.DependencyProperty.RegisterAttached%2A>foi chamado.</xref:System.Windows.DependencyProperty.RegisterAttached%2A> </xref:System.Windows.DependencyProperty.RegisterAttached%2A> Caso contrário, o <xref:System.Windows.PropertyMetadata>objeto é criado com o <xref:System.Windows.PropertyMetadata.DefaultValue%2A>propriedade definida para predefinido o tipo de propriedade e todas as outras propriedades do <xref:System.Windows.PropertyMetadata>está definido como `null`.</xref:System.Windows.PropertyMetadata> </xref:System.Windows.PropertyMetadata.DefaultValue%2A> </xref:System.Windows.PropertyMetadata> Utilize o <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>assinatura se pretender fornecer metadados para a versão a propriedade de dependência para adicionar ao tipo fornecido.</xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>       O valor de retorno deste método é normalmente utilizado para declarar e expor a propriedade de dependência armazenando um identificador de propriedade de dependência. O identificador fornece acesso para a propriedade de dependência para chamar o sistema de propriedade [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)] contra a propriedade de dependência, particularmente dado que existe na classe de proprietário de adição. O mesmo nome de propriedade para o proprietário original e o proprietário adicionado deve ser utilizado para indicar uma funcionalidade semelhante. Deve utilizar o <xref:System.Windows.DependencyProperty>devolve o valor do método AddOwner para definir o identificador de propriedade de dependência bem como para declarar [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] wrappers de propriedade, as propriedades de dependência que são adicionados aos tipos utilizando AddOwner.</xref:System.Windows.DependencyProperty>       A metodologia de AddOwner recomendada acima é utilizada ao criar as propriedades de dependência que são declaradas dentro [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]. Por exemplo, ambos <xref:System.Windows.Controls.Border>e <xref:System.Windows.Controls.Control>definir um `BorderBrush` propriedade de dependência, o que tem uma funcionalidade semelhante.</xref:System.Windows.Controls.Control> </xref:System.Windows.Controls.Border> <xref:System.Windows.Controls.Control>Define o `BorderBrush` propriedade para o sistema de propriedade ao chamar AddOwner baseado no proprietário original <xref:System.Windows.Controls.Border>e respetivos registado <xref:System.Windows.Controls.Border.BorderBrushProperty>identificador de propriedade de dependência.</xref:System.Windows.Controls.Border.BorderBrushProperty> </xref:System.Windows.Controls.Border></xref:System.Windows.Controls.Control> O AddOwner devolver o valor, em seguida, é utilizado para estabelecer uma novo estática <xref:System.Windows.DependencyProperty>campo (<xref:System.Windows.Controls.Control.BorderBrushProperty>) para essa propriedade no proprietário adicionado e um `BorderBrush` wrapper propriedade também está declarado.</xref:System.Windows.Controls.Control.BorderBrushProperty> </xref:System.Windows.DependencyProperty>"
  syntax:
    content: public System.Windows.DependencyProperty AddOwner (Type ownerType);
    parameters:
    - id: ownerType
      type: System.Type
      description: "O tipo a adicionar como um proprietário desta propriedade de dependência."
    return:
      type: System.Windows.DependencyProperty
      description: "Uma referência ao original <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> identificador que identifica a propriedade de dependência. Este identificador deve ser exposto pela classe adicionar como um <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> campo."
  overload: System.Windows.DependencyProperty.AddOwner*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)
  id: AddOwner(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: AddOwner(Type,PropertyMetadata)
  nameWithType: DependencyProperty.AddOwner(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.AddOwner(Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Adiciona o tipo de outro como um proprietário de uma propriedade de dependência que já foi registada, fornecendo os metadados da propriedade de dependência para a propriedade de dependência, dado que será existe no tipo de proprietário fornecidos."
  remarks: "Este método permite que o sistema de propriedade reconhecer uma propriedade de dependência num tipo que não se registou essa propriedade de dependência específico inicialmente.       O valor de retorno deste método é utilizado para declarar e expor a propriedade de dependência, particularmente tal como existe na classe de proprietário de adição. Geralmente, o mesmo nome de propriedade para o proprietário original e o proprietário adicionado deve ser utilizado para indicar uma funcionalidade semelhante. É recomendável para expor os identificadores, bem como novos [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] wrappers de propriedade, as propriedades de dependência que são adicionados aos tipos utilizando <xref:System.Windows.DependencyProperty.AddOwner%2A>.</xref:System.Windows.DependencyProperty.AddOwner%2A>       O <xref:System.Windows.DependencyProperty.AddOwner%2A>metodologia recomendada acima é utilizada ao criar [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)] declarado no [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)].</xref:System.Windows.DependencyProperty.AddOwner%2A> Por exemplo, ambos <xref:System.Windows.Controls.Border>e <xref:System.Windows.Controls.Control>definir um `BorderBrush` propriedade de dependência, o que tem uma funcionalidade semelhante.</xref:System.Windows.Controls.Control> </xref:System.Windows.Controls.Border> <xref:System.Windows.Controls.Control>Define o `BorderBrush` propriedade para o sistema de propriedade ao chamar <xref:System.Windows.DependencyProperty.AddOwner%2A>no proprietário original <xref:System.Windows.Controls.Border>e respetivos registado <xref:System.Windows.Controls.Border.BorderBrushProperty>identificador de propriedade de dependência.</xref:System.Windows.Controls.Border.BorderBrushProperty> </xref:System.Windows.Controls.Border> </xref:System.Windows.DependencyProperty.AddOwner%2A></xref:System.Windows.Controls.Control> O <xref:System.Windows.DependencyProperty.AddOwner%2A>devolver o valor é utilizado para estabelecer uma estática <xref:System.Windows.DependencyProperty>campo (<xref:System.Windows.Controls.Control.BorderBrushProperty>) para essa propriedade no proprietário adicionado e um `BorderBrush` wrapper propriedade também está declarado.</xref:System.Windows.Controls.Control.BorderBrushProperty> </xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty.AddOwner%2A>       Identificador de propriedade de dependência do proprietário adicionado deve ser utilizada para operações como <xref:System.Windows.DependencyObject.GetValue%2A>.</xref:System.Windows.DependencyObject.GetValue%2A> No entanto, as operações de tipo específicas que envolvem tipos ou instâncias da classe que foi adicionado como proprietário com metadados diferentes continuará devolvem o mesmo quando de resultados esperado original (não o adicionado do proprietário) identificador de propriedade de dependência é especificado em chamadas para métodos como <xref:System.Windows.DependencyObject.GetValue%2A>ou <xref:System.Windows.DependencyProperty.GetMetadata%2A>.</xref:System.Windows.DependencyProperty.GetMetadata%2A> </xref:System.Windows.DependencyObject.GetValue%2A> Os metadados para o proprietário adicionado é perpetuated pelo AddOwner chamar autónomo, não necessariamente referenciado exclusivamente para o campo de identificador de classe de proprietário adicionar. Contudo, é boa prática para expor o identificador, bem como novo [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] wrappers de propriedade, as propriedades de dependência que são adicionados aos tipos utilizando AddOwner, porque a conseguir fazê-lo cria disparidade entre o [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] e [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] representações das suas propriedades.       Os metadados fornecido intercalado com os metadados de propriedade para a propriedade de dependência tal como existe no proprietário de base. Qualquer características que foram especificadas nos metadados base originais serão mantidas. Apenas as características que foram alteradas especificamente nos metadados da nova substituirão as características dos metadados base. Alguns características, tais como <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, são substituídos se forem especificadas em novos metadados.</xref:System.Windows.PropertyMetadata.DefaultValue%2A> Outros recursos, tais como <xref:System.Windows.PropertyChangedCallback>, são combinados.</xref:System.Windows.PropertyChangedCallback> Em última análise, o comportamento de intercalação depende o tipo de metadados da propriedade que está a ser utilizado para a substituição, pelo que é o comportamento descrito aqui para as classes de metadados de propriedade existentes utilizadas pelo [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] propriedades de dependência. Para obter mais informações, consulte [os metadados da propriedade de dependência](~/add/includes/ajax-current-ext-md.md) e [os metadados da propriedade Framework](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: ownerType
      type: System.Type
      description: "O tipo a adicionar como proprietário desta propriedade de dependência."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "Os metadados que qualificam a propriedade de dependência, tal como existe no tipo fornecido."
    return:
      type: System.Windows.DependencyProperty
      description: "Uma referência ao original <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> identificador que identifica a propriedade de dependência. Este identificador deve ser exposto pela classe adicionar como um <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> campo."
  overload: System.Windows.DependencyProperty.AddOwner*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.DefaultMetadata
  id: DefaultMetadata
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: DefaultMetadata
  nameWithType: DependencyProperty.DefaultMetadata
  fullName: System.Windows.DependencyProperty.DefaultMetadata
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Obtém os metadados de predefinido da propriedade de dependência."
  remarks: "Os metadados de predefinição são os metadados de propriedade que está disponível para esse objeto específico ou um objeto de um tipo derivado onde não existem metadados alternativo foi fornecido pelo explícita <xref:System.Windows.DependencyProperty.Register%2A>ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>chamar.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.Register%2A>       Se o proprietário original aplicada metadados para o primeiro <xref:System.Windows.DependencyProperty.Register%2A>chamada estabelecer a propriedade de dependência, em seguida, esses metadados é devolvido como DefaultMetadata.</xref:System.Windows.DependencyProperty.Register%2A>       Se não existem metadados tenha sido aplicado original <xref:System.Windows.DependencyProperty.Register%2A>chamada, em seguida, os metadados de predefinido é gerado a partir do <xref:System.Windows.DependencyProperty.Register%2A>chamada e este valor é devolvido como o DefaultMetadata.</xref:System.Windows.DependencyProperty.Register%2A> </xref:System.Windows.DependencyProperty.Register%2A>       O objetivo principal de metadados predefinidos associados a ter um <xref:System.Windows.DependencyProperty>consiste em fornecer um valor predefinido para esta propriedade em qualquer <xref:System.Windows.DependencyObject>ou um tipo derivado.</xref:System.Windows.DependencyObject> </xref:System.Windows.DependencyProperty>       As propriedades de nonattached, o tipo de metadados devolvido por esta propriedade não pode ser convertido para tipos derivados de <xref:System.Windows.PropertyMetadata>escreva, mesmo se a propriedade originalmente foi registada com um tipo derivado de metadados.</xref:System.Windows.PropertyMetadata> Se pretender que os metadados originalmente registado, incluindo o respetivo tipo de metadados possivelmente derivada original, chamar <xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29>transmitir registar original em vez disso, escreva como parâmetro.</xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29>       Para propriedades anexadas, o tipo dos metadados devolvidos por esta propriedade irá corresponde ao tipo especificado no original <xref:System.Windows.DependencyProperty.RegisterAttached%2A>método de registo.</xref:System.Windows.DependencyProperty.RegisterAttached%2A>"
  example:
  - "[!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  \n[!code-cs[PropertySystemEsoterics#DPDefaultValue](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]\n[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]"
  syntax:
    content: public System.Windows.PropertyMetadata DefaultMetadata { get; }
    return:
      type: System.Windows.PropertyMetadata
      description: "Os metadados de predefinido da propriedade de dependência."
  overload: System.Windows.DependencyProperty.DefaultMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetHashCode
  id: GetHashCode
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetHashCode()
  nameWithType: DependencyProperty.GetHashCode()
  fullName: System.Windows.DependencyProperty.GetHashCode()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Devolve um código hash para este <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref>."
  remarks: "O sistema de propriedade utiliza o seu próprio identificador exclusivo <xref:System.Windows.DependencyProperty.GlobalIndex%2A>, e o valor da propriedade é devolvido pelo GetHashCode.</xref:System.Windows.DependencyProperty.GlobalIndex%2A>"
  syntax:
    content: public override int GetHashCode ();
    parameters: []
    return:
      type: System.Int32
      description: "O código hash <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref>."
  overload: System.Windows.DependencyProperty.GetHashCode*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetMetadata(System.Type)
  id: GetMetadata(System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetMetadata(Type)
  nameWithType: DependencyProperty.GetMetadata(Type)
  fullName: System.Windows.DependencyProperty.GetMetadata(Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Devolve os metadados para esta propriedade de dependência, tal como existe um tipo existente especificado."
  remarks: "Especificar o tipo ou uma referência de objeto para utilizar como tipo é necessário porque os metadados podem diferir do registo original devido a <xref:System.Windows.DependencyProperty.AddOwner%2A>ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>chamadas alterar os metadados da propriedade de dependência, tal como existe num tipo.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A>"
  example:
  - "The following example gets metadata for a dependency property based on its type. The type is obtained by using a `typeof` operator.  \n  \n [!code-cs[PropertySystemEsoterics#GetMetadataType](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/default.xaml.cs#getmetadatatype)]\n [!code-vb[PropertySystemEsoterics#GetMetadataType](~/add/codesnippet/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]"
  syntax:
    content: public System.Windows.PropertyMetadata GetMetadata (Type forType);
    parameters:
    - id: forType
      type: System.Type
      description: "O tipo específico para obter os metadados da propriedade de dependência."
    return:
      type: System.Windows.PropertyMetadata
      description: "Um objeto de metadados da propriedade."
  overload: System.Windows.DependencyProperty.GetMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)
  id: GetMetadata(System.Windows.DependencyObject)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetMetadata(DependencyObject)
  nameWithType: DependencyProperty.GetMetadata(DependencyObject)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObject)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Devolve os metadados para esta propriedade de dependência, tal como existe na instância do objeto especificado."
  remarks: "Especificar o tipo ou uma referência de objeto é necessária porque os metadados de uma propriedade de dependência fornecida podem variar entre o registo original devido a <xref:System.Windows.DependencyProperty.AddOwner%2A>ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>chamadas podem refinar os metadados de propriedade visto que existe um tipo.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A>       Quando solicita os metadados da propriedade com base numa instância, está realmente apenas a transmitir a instância para que o respetivo tipo pode ser avaliado internamente. Os metadados da propriedade de dependência não variam por instância; é sempre consistente para qualquer combinação de propriedade de tipo indicado."
  example:
  - "The following example gets metadata for a dependency property based on a specific <xref:System.Windows.DependencyObject> instance.  \n  \n [!code-cs[PropertySystemEsoterics#GetMetadataDOInstance](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]\n [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/add/codesnippet/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]"
  syntax:
    content: public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);
    parameters:
    - id: dependencyObject
      type: System.Windows.DependencyObject
      description: "Um objeto de dependência que está marcado para o tipo, para determinar que versão específicos do tipo da propriedade de dependência os metadados deverá ser proveniente."
    return:
      type: System.Windows.PropertyMetadata
      description: "Um objeto de metadados da propriedade."
  overload: System.Windows.DependencyProperty.GetMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)
  id: GetMetadata(System.Windows.DependencyObjectType)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetMetadata(DependencyObjectType)
  nameWithType: DependencyProperty.GetMetadata(DependencyObjectType)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObjectType)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Devolve os metadados para esta propriedade de dependência, tal como existe num tipo especificado."
  remarks: "Especificar o tipo ou uma referência de objeto é necessária porque os metadados de uma propriedade de dependência fornecida podem variar entre o registo original devido a <xref:System.Windows.DependencyProperty.AddOwner%2A>ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>chamadas podem refinar os metadados de propriedade visto que existe um tipo.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A>"
  example:
  - "The following example gets metadata for a dependency property based on its <xref:System.Windows.DependencyObjectType>.  \n  \n [!code-cs[PropertySystemEsoterics#GetMetadataDOType](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/default.xaml.cs#getmetadatadotype)]\n [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/add/codesnippet/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]"
  syntax:
    content: public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);
    parameters:
    - id: dependencyObjectType
      type: System.Windows.DependencyObjectType
      description: "Um objeto específico que regista o tipo de objeto de dependência do qual os metadados da propriedade de dependência for pretendido."
    return:
      type: System.Windows.PropertyMetadata
      description: "Um objeto de metadados da propriedade."
  overload: System.Windows.DependencyProperty.GetMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GlobalIndex
  id: GlobalIndex
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GlobalIndex
  nameWithType: DependencyProperty.GlobalIndex
  fullName: System.Windows.DependencyProperty.GlobalIndex
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Obtém um valor gerado internamente que identifica exclusivamente a propriedade de dependência."
  remarks: "Este valor é um número inteiro, não um [!INCLUDE[TLA#tla_guid](~/add/includes/ajax-current-ext-md.md)]. Geralmente, não é necessário utilizar este valor de índice e há sem acesso de índice para tabelas de todas as propriedades de dependência. Propriedades de dependência em vez disso, devem ser referenciadas pelos campos de identificador.       GlobalIndex é utilizada internamente para um acesso mais rápido para estruturas de dados que utilizam o GlobalIndex como um índice de matriz baseada em zero. A utilização de um semelhante poderá ter aplicações para os estruturadores ou ferramentas."
  syntax:
    content: public int GlobalIndex { get; }
    return:
      type: System.Int32
      description: "Um identificador numérico exclusivo."
  overload: System.Windows.DependencyProperty.GlobalIndex*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.IsValidType(System.Object)
  id: IsValidType(System.Object)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: IsValidType(Object)
  nameWithType: DependencyProperty.IsValidType(Object)
  fullName: System.Windows.DependencyProperty.IsValidType(Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Determina se um valor especificado é aceitável para o tipo da propriedade de dependência, conforme verificado contra o tipo de propriedade fornecido no registo de propriedade de dependência original."
  remarks: "Um valor de `null` é um tipo válido para propriedades de dependência do tipo de referência ou para um <xref:System.Nullable%601>propriedade de dependência e devolvam `true` para estes casos.</xref:System.Nullable%601> Nos casos em que a propriedade de dependência é uma referência de nenhuma delas nem um <xref:System.Nullable%601>tipo, IsValidType irá devolver `false` para um valor nulo em vez de emitir uma exceção.</xref:System.Nullable%601>"
  example:
  - "The following example uses IsValidType as a check before calling <xref:System.Windows.DependencyObject.SetValue%2A> on the dependency property.  \n  \n [!code-cs[PropertySystemEsoterics#TrySetValue](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#trysetvalue)]\n [!code-vb[PropertySystemEsoterics#TrySetValue](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]"
  syntax:
    content: public bool IsValidType (object value);
    parameters:
    - id: value
      type: System.Object
      description: "O valor para verificar."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o valor especificado é o tipo de propriedade registada ou um tipo derivado aceitável; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.DependencyProperty.IsValidType*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.IsValidValue(System.Object)
  id: IsValidValue(System.Object)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: IsValidValue(Object)
  nameWithType: DependencyProperty.IsValidValue(Object)
  fullName: System.Windows.DependencyProperty.IsValidValue(Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Determina se o valor fornecido é aceite para o tipo de propriedade através da verificação do tipo básico e também potencialmente se estiver dentro do intervalo permitido de valores para esse tipo."
  remarks: "Para uma propriedade de dependência, um intervalo permitido de valores para esse tipo pode ser especificado através de um <xref:System.Windows.ValidateValueCallback>que é fornecido no registo de propriedade de dependência.</xref:System.Windows.ValidateValueCallback>       Este método chama <xref:System.Windows.DependencyProperty.IsValidType%2A>internamente.</xref:System.Windows.DependencyProperty.IsValidType%2A> Se a propriedade de dependência em questão não tiver nenhum <xref:System.Windows.ValidateValueCallback>em seguida, chamar este método é efetivamente equivalente a chamar <xref:System.Windows.DependencyProperty.IsValidType%2A>.</xref:System.Windows.DependencyProperty.IsValidType%2A> </xref:System.Windows.ValidateValueCallback> Se a propriedade de dependência tem um <xref:System.Windows.ValidateValueCallback>e se <xref:System.Windows.DependencyProperty.IsValidType%2A>seria ter devolvido `true`, em seguida, o valor devolvido será conforme implementado na chamada de retorno.</xref:System.Windows.DependencyProperty.IsValidType%2A> </xref:System.Windows.ValidateValueCallback>       Um valor nulo é um valor válido para propriedades de dependência do tipo de referência ou para um <xref:System.Nullable%601>propriedade de dependência e devolvam `true` para estes casos.</xref:System.Nullable%601> Nos casos em que a propriedade de dependência é uma referência de nenhuma delas nem um <xref:System.Nullable%601>tipo, <xref:System.Windows.DependencyProperty.IsValidType%2A>irá devolver `false` para um valor nulo em vez de emitir uma exceção.</xref:System.Windows.DependencyProperty.IsValidType%2A> </xref:System.Nullable%601>"
  example:
  - "The following example uses IsValidValue as a check before calling <xref:System.Windows.DependencyObject.SetValue%2A> on the dependency property.  \n  \n [!code-cs[PropertySystemEsoterics#TrySetValueWithValidate](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]\n [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]"
  syntax:
    content: public bool IsValidValue (object value);
    parameters:
    - id: value
      type: System.Object
      description: "O valor para verificar."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o valor é aceitável e é do tipo correto ou um tipo derivado; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.DependencyProperty.IsValidValue*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Name
  id: Name
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Name
  nameWithType: DependencyProperty.Name
  fullName: System.Windows.DependencyProperty.Name
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Obtém o nome da propriedade de dependência."
  remarks: "Esta propriedade obtém o nome fornecido como o `name` parâmetro durante o registo de propriedade de dependência. Este nome é imutável e não pode ser `null` ou uma cadeia vazia. Nome duplicado de registos do mesmo tipo de proprietário não são permitidos e irão gerar uma exceção ao tentar registar o duplicado.      > [!IMPORTANT] > O nome de uma propriedade de dependência tem de seguir a Convenção de correspondente ao nome do respetivo identificador de propriedade de dependência menos o sufixo &quot;Property&quot;. Para obter mais informações, consulte [propriedades de dependência personalizadas](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example queries various characteristics of a dependency property identifier, including the Name.  \n  \n [!code-cs[PropertySystemEsoterics#DPProps](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpprops)]\n [!code-vb[PropertySystemEsoterics#DPProps](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpprops)]"
  syntax:
    content: public string Name { get; }
    return:
      type: System.String
      description: "O nome da propriedade."
  overload: System.Windows.DependencyProperty.Name*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  id: OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: OverrideMetadata(Type,PropertyMetadata)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Especifica os metadados alternativo para esta propriedade de dependência quando está presente em instâncias de um tipo especificado, substituir os metadados que existiam para a propriedade de dependência conforme foi herdada a partir de tipos base."
  remarks: "Os metadados da propriedade de dependência devem ser substituído antes do sistema de propriedade utilize a propriedade de dependência. Isto equivale à hora que instâncias específicas são criadas utilizando a classe que regista a propriedade de dependência. Chamadas para OverrideMetadata só devem ser efetuadas dentro de construtores estáticos do tipo que fornece si próprio como o `forType` parâmetro deste método, ou através da instanciação semelhante. Tentativa de alterar os metadados depois existem instâncias do tipo de proprietário não irá emitir exceções, mas irá resultar no comportamentos inconsistentes no sistema de propriedade.       Depois dos metadados para uma determinada classe derivada de substituição é estabelecido com este método, as tentativas subsequentes para substituir metadados desta classe derivada mesmo irão gerar uma exceção.       Os metadados fornecido intercalado com os metadados de propriedade para a propriedade de dependência tal como existe no proprietário de base. Irão manter quaisquer características que foram especificadas nos metadados da base original; apenas as características que foram alteradas especificamente nos metadados da nova substituirão as características dos metadados base. Alguns características como <xref:System.Windows.PropertyMetadata.DefaultValue%2A>são substituídos se for especificado em novos metadados.</xref:System.Windows.PropertyMetadata.DefaultValue%2A> Outros recursos, tais como <xref:System.Windows.PropertyChangedCallback>, são combinados.</xref:System.Windows.PropertyChangedCallback> Em última análise, o comportamento de intercalação depende o tipo de metadados da propriedade que está a ser utilizado para a substituição, pelo que é o comportamento descrito aqui para as classes de metadados de propriedade existentes utilizadas pelo [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] propriedades de dependência. Para obter mais informações, consulte [os metadados da propriedade de dependência](~/add/includes/ajax-current-ext-md.md) e [os metadados da propriedade Framework](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: forType
      type: System.Type
      description: "O tipo em que esta propriedade de dependência é herdada e onde os metadados alternativo fornecido serão aplicados."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "Os metadados para aplicar a propriedade de dependência no tipo de substituição."
  overload: System.Windows.DependencyProperty.OverrideMetadata*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Foi efetuada uma tentativa para substituir metadados uma propriedade de dependência só de leitura (não é possível efetuar a operação utilizando esta assinatura)."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Os metadados já foi estabelecido para a propriedade de dependência, tal como existe no tipo fornecido."
  platform:
  - net462
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  id: OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Fontes alternativa metadados para uma propriedade de dependência só de leitura quando está presente em instâncias de um tipo especificado, substituir os metadados que foi fornecido o registo de propriedade de dependência inicial. Tem de transmitir o <xref href=&quot;System.Windows.DependencyPropertyKey&quot;> </xref> para a propriedade de dependência só de leitura evitar que gera uma exceção."
  remarks: "Esta assinatura fornece implementação subjacente para um identificador de propriedade de dependência só de leitura (<xref:System.Windows.DependencyPropertyKey>) método.</xref:System.Windows.DependencyPropertyKey> Se substituir metadados para uma propriedade de dependência de leitura e escrita, utilize <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>.</xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>       Os metadados da propriedade de dependência devem ser substituído antes do sistema de propriedade utilize a propriedade de dependência. Isto equivale a hora em que são criados objetos específicos para a classe que regista a propriedade de dependência. Chamadas para <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>só deve ser efetuada dentro de construtores estáticos do tipo que fornece si próprio como o `forType` parâmetro deste método, ou através da instanciação semelhante.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> Tentativa de alterar os metadados depois existem instâncias do tipo de proprietário não irá emitir exceções, mas irá resultar no comportamentos inconsistentes no sistema de propriedade.       Depois dos metadados para uma determinada classe derivada de substituição é estabelecido com este método, as tentativas subsequentes para substituir metadados desta classe derivada mesmo irão gerar uma exceção.       Os metadados fornecido intercalado com os metadados de propriedade para a propriedade de dependência tal como existe no proprietário de base. Irão manter quaisquer características que foram especificadas nos metadados da base original; apenas as características que foram alteradas especificamente nos metadados da nova substituirão as características dos metadados base. Alguns características como <xref:System.Windows.PropertyMetadata.DefaultValue%2A>são substituídos se for especificado em novos metadados.</xref:System.Windows.PropertyMetadata.DefaultValue%2A> Outros recursos, tais como <xref:System.Windows.PropertyChangedCallback>, são combinados.</xref:System.Windows.PropertyChangedCallback> O comportamento de intercalação depende o tipo de metadados da propriedade que está a ser utilizado para a substituição. Para obter mais informações, consulte [os metadados da propriedade de dependência](~/add/includes/ajax-current-ext-md.md) e [os metadados da propriedade Framework](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);
    parameters:
    - id: forType
      type: System.Type
      description: "O tipo em que esta propriedade de dependência é herdada e onde os metadados alternativo fornecido serão aplicados."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "Os metadados para aplicar a propriedade de dependência no tipo de substituição."
    - id: key
      type: System.Windows.DependencyPropertyKey
      description: "A chave de acesso para uma propriedade de dependência só de leitura."
  overload: System.Windows.DependencyProperty.OverrideMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.OwnerType
  id: OwnerType
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: OwnerType
  nameWithType: DependencyProperty.OwnerType
  fullName: System.Windows.DependencyProperty.OwnerType
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Obtém o tipo de objeto que registado a propriedade de dependência com o sistema de propriedade ou adicionado si próprio como proprietário da propriedade."
  remarks: "Este valor foi fornecido durante o registo de propriedade. O proprietário será o original ao registar tipo na case de um <xref:System.Windows.DependencyProperty>identificador gerado a partir de um <xref:System.Windows.DependencyProperty.Register%2A>chamada ou o tipo que adicionou si próprio como proprietário da case de um <xref:System.Windows.DependencyProperty>identificador gerado a partir de um <xref:System.Windows.DependencyProperty.AddOwner%2A>chamar.</xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty.Register%2A> </xref:System.Windows.DependencyProperty>       OwnerType em qualquer dado <xref:System.Windows.DependencyProperty>é imutável e não pode ser `null` num <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty> válido</xref:System.Windows.DependencyProperty>"
  example:
  - "The following example gets the owner type based on a dependency property identifier `dp`, and then gets metadata on the owner type for that same identifier. This operation is actually equivalent to getting <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> on `dp`.  \n  \n [!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]"
  syntax:
    content: public Type OwnerType { get; }
    return:
      type: System.Type
      description: "O tipo do objeto que registado a propriedade ou adicionado si próprio como proprietário da propriedade."
  overload: System.Windows.DependencyProperty.OwnerType*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.PropertyType
  id: PropertyType
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: PropertyType
  nameWithType: DependencyProperty.PropertyType
  fullName: System.Windows.DependencyProperty.PropertyType
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Obtém o tipo que utiliza a propriedade de dependência para o respetivo valor."
  remarks: "Esta propriedade indica o tipo do valor da propriedade conforme declarado pelo registo de propriedade original, através de `propertyType` parâmetro. Semelhante para o <xref:System.Windows.DependencyProperty.Name%2A>, o tipo de propriedade de uma propriedade de dependência é imutável após o registo.</xref:System.Windows.DependencyProperty.Name%2A>"
  example:
  - "The following example queries various characteristics of a dependency property identifier, including the PropertyType. The type name string of the PropertyType is obtained from the returned <xref:System.Type>.  \n  \n [!code-cs[PropertySystemEsoterics#DPProps](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpprops)]\n [!code-vb[PropertySystemEsoterics#DPProps](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpprops)]"
  syntax:
    content: public Type PropertyType { get; }
    return:
      type: System.Type
      description: "O <xref:System.Type>do valor de propriedade.</xref:System.Type>"
  overload: System.Windows.DependencyProperty.PropertyType*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.ReadOnly
  id: ReadOnly
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: ReadOnly
  nameWithType: DependencyProperty.ReadOnly
  fullName: System.Windows.DependencyProperty.ReadOnly
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Obtém um valor que indica se a propriedade de dependência identificado por este <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> instância é uma propriedade de dependência só de leitura."
  remarks: "Propriedades de dependência só de leitura estão registadas no sistema de propriedade ao chamar o <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>método opposed para o <xref:System.Windows.DependencyProperty.Register%2A>método.</xref:System.Windows.DependencyProperty.Register%2A> </xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> Propriedades anexadas também podem ser registadas como só de leitura; consulte <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.</xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>       Propriedades de dependência só de leitura requerem um <xref:System.Windows.DependencyPropertyKey>identificador em vez de um <xref:System.Windows.DependencyProperty>identificador para efetuar operações de metadados, tais como substituir os metadados ou a definição do valor.</xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyPropertyKey> Se tiver adquirido uma coleção de <xref:System.Windows.DependencyProperty>identificadores através de uma chamada para <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A>ou outro [!INCLUDE[TLA2#tla_api](~/add/includes/tla2sharptla-api-md.md)] que expõe identificadores, verifique o valor só de leitura antes de tentar chamar <xref:System.Windows.DependencyObject.SetValue%2A>ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>com esse identificador de propriedade de dependência como um parâmetro de entrada, para verificar se a propriedade de dependência que representa o identificador não é só de leitura.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyObject.SetValue%2A> </xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> </xref:System.Windows.DependencyProperty> Se o valor só de leitura é `true` na propriedade de dependência, não é possível programática para obter uma referência ao <xref:System.Windows.DependencyPropertyKey>identificador dessa propriedade de dependência de metadados ou do <xref:System.Windows.DependencyProperty>identificador; o identificador tem de estar disponível como um campo estático para chamar <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>em relação a uma propriedade de dependência só de leitura.</xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> </xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyPropertyKey>       Quando criar uma propriedade de dependência personalizado e registá-lo como só de leitura, deve definir apenas um acessor get para o [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] propriedade wrapper. Caso contrário, a sua classe terão um modelo de objeto confuso para o wrapper de propriedade em comparação com o acesso para a propriedade de dependência de cópia de segurança. Para obter mais informações, consulte [propriedades de dependência personalizadas](~/add/includes/ajax-current-ext-md.md) ou [propriedades de dependência só de leitura](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example obtains the default metadata and the dependency property identifier properties from various dependency property fields, and uses the information to populate a table to implement a \"metadata browser\".  \n  \n [!code-cs[PropertySystemEsoterics#DPProps](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpprops)]\n [!code-vb[PropertySystemEsoterics#DPProps](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpprops)]"
  syntax:
    content: public bool ReadOnly { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a propriedade de dependência é só de leitura; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.DependencyProperty.ReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)
  id: Register(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Register(String,Type,Type)
  nameWithType: DependencyProperty.Register(String,Type,Type)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Regista uma propriedade de dependência com o nome de propriedade especificado, o tipo de propriedade e o tipo de proprietário."
  remarks: "Para obter mais informações sobre o registo de propriedade de dependência, consulte <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>"
  example:
  - >-
    [!code-cs[WPFAquariumSln#Register3Param](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#register3param)]
     [!code-vb[WPFAquariumSln#Register3Param](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#register3param)]
  syntax:
    content: public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);
    parameters:
    - id: name
      type: System.String
      description: "O nome da propriedade de dependência para registar. O nome tem de ser exclusivo dentro do espaço de nomes de registo do tipo de proprietário."
    - id: propertyType
      type: System.Type
      description: "O tipo da propriedade."
    - id: ownerType
      type: System.Type
      description: "O tipo de proprietário que está a registar a propriedade de dependência."
    return:
      type: System.Windows.DependencyProperty
      description: "Um identificador de propriedade de dependência que deve ser utilizado para definir o valor de um <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> campo na sua classe. Esse identificador, em seguida, é utilizado para referenciar a propriedade de dependência mais tarde, para operações como definir o respetivo valor através de programação ou obtenção de metadados."
  overload: System.Windows.DependencyProperty.Register*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Register(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Regista uma propriedade de dependência com o nome de propriedade especificado, o tipo de propriedade, o tipo de proprietário e os metadados da propriedade."
  remarks: "Para obter mais informações sobre o registo de propriedade de dependência, consulte <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>"
  syntax:
    content: public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: name
      type: System.String
      description: "O nome da propriedade de dependência para registar."
    - id: propertyType
      type: System.Type
      description: "O tipo da propriedade."
    - id: ownerType
      type: System.Type
      description: "O tipo de proprietário que está a registar a propriedade de dependência."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "Metadados da propriedade para a propriedade de dependência."
    return:
      type: System.Windows.DependencyProperty
      description: "Um identificador de propriedade de dependência que deve ser utilizado para definir o valor de um <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> campo na sua classe. Esse identificador, em seguida, é utilizado para referenciar a propriedade de dependência mais tarde, para operações como definir o respetivo valor através de programação ou obtenção de metadados."
  overload: System.Windows.DependencyProperty.Register*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Regista uma propriedade de dependência com o nome de propriedade especificado, o tipo de propriedade, o tipo de proprietário, os metadados da propriedade e uma chamada de retorno de validação de valor da propriedade."
  remarks: "Para obter mais informações sobre o registo de propriedade de dependência, consulte <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>"
  example:
  - "The following example registers a dependency property, including a validation callback (the callback definition is not shown; for details on the callback definition, see <xref:System.Windows.ValidateValueCallback>).  \n  \n [!code-cs[DPCallbackOverride#CurrentDefinitionWithWrapper](~/add/codesnippet/csharp/DPCallbackOverride/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]\n [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/add/codesnippet/visualbasic/DPCallbackOverride.sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]"
  syntax:
    content: public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "O nome da propriedade de dependência para registar."
    - id: propertyType
      type: System.Type
      description: "O tipo da propriedade."
    - id: ownerType
      type: System.Type
      description: "O tipo de proprietário que está a registar a propriedade de dependência."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "Metadados da propriedade para a propriedade de dependência."
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "Uma referência a uma chamada de retorno que deverá efetuar qualquer uma validação personalizada do valor de propriedade de dependência para além da validação do tipo típica."
    return:
      type: System.Windows.DependencyProperty
      description: "Um identificador de propriedade de dependência que deve ser utilizado para definir o valor de um <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> campo na sua classe. Esse identificador, em seguida, é utilizado para referenciar a propriedade de dependência mais tarde, para operações como definir o respetivo valor através de programação ou obtenção de metadados."
  overload: System.Windows.DependencyProperty.Register*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)
  id: RegisterAttached(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttached(String,Type,Type)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Regista uma propriedade anexada com o nome de propriedade especificado, o tipo de propriedade e o tipo de proprietário."
  remarks: "Uma propriedade anexada é um conceito de propriedade definido pelo [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]implementa propriedades anexadas como propriedades de dependência. Porque o [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] propriedades anexadas são propriedades de dependência, podem ter metadados aplicados que podem ser utilizados pelo sistema propriedade geral para operações como relatórios características de esquema. Para obter mais informações, consulte [ligado descrição geral de propriedades](~/add/includes/ajax-current-ext-md.md).       Para obter mais informações sobre o registo de propriedade de dependência, consulte <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>"
  example:
  - "The following example registers an attached property on an abstract class using this RegisterAttached signature.  \n  \n [!code-cs[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]\n [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]"
  syntax:
    content: public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);
    parameters:
    - id: name
      type: System.String
      description: "O nome da propriedade de dependência para registar."
    - id: propertyType
      type: System.Type
      description: "O tipo da propriedade."
    - id: ownerType
      type: System.Type
      description: "O tipo de proprietário que está a registar a propriedade de dependência."
    return:
      type: System.Windows.DependencyProperty
      description: "Um identificador de propriedade de dependência que deve ser utilizado para definir o valor de um <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> campo na sua classe. Esse identificador, em seguida, é utilizado para referenciar a propriedade de dependência mais tarde, para operações como definir o respetivo valor através de programação ou obtenção de metadados."
  overload: System.Windows.DependencyProperty.RegisterAttached*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttached(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Regista uma propriedade anexada com o nome de propriedade especificado, o tipo de propriedade, o tipo de proprietário e os metadados da propriedade."
  remarks: "An attached property is a property concept defined by [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] implements attached properties as dependency properties. Because the [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics. For more information, see [Attached Properties Overview](~/add/includes/ajax-current-ext-md.md).  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property with RegisterAttached instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance. You should register value-inheriting dependency properties with RegisterAttached even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use RegisterAttached to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);
    parameters:
    - id: name
      type: System.String
      description: "O nome da propriedade de dependência para registar."
    - id: propertyType
      type: System.Type
      description: "O tipo da propriedade."
    - id: ownerType
      type: System.Type
      description: "O tipo de proprietário que está a registar a propriedade de dependência."
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "Metadados da propriedade para a propriedade de dependência. Isto pode incluir o valor predefinido, bem como outras características."
    return:
      type: System.Windows.DependencyProperty
      description: "Um identificador de propriedade de dependência que deve ser utilizado para definir o valor de um <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> campo na sua classe. Esse identificador, em seguida, é utilizado para referenciar a propriedade de dependência mais tarde, para operações como definir o respetivo valor através de programação ou obtenção de metadados."
  overload: System.Windows.DependencyProperty.RegisterAttached*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Regista uma propriedade anexada com o tipo de propriedade especificado, o tipo de proprietário, os metadados da propriedade e chamada de retorno de validação de valor da propriedade."
  remarks: "An attached property is a property concept defined by [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] implements attached properties as dependency properties. Because the [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics. For more information, see [Attached Properties Overview](~/add/includes/ajax-current-ext-md.md).  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance. You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example registers an attached property on an abstract class using this RegisterAttached signature. This attached property is an enumeration type property, and the registration adds a validation callback to verify that the provided value is a value of the enumeration.  \n  \n [!code-cs[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]\n [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]"
  syntax:
    content: public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "O nome da propriedade de dependência para registar."
    - id: propertyType
      type: System.Type
      description: "O tipo da propriedade."
    - id: ownerType
      type: System.Type
      description: "O tipo de proprietário que está a registar a propriedade de dependência."
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "Metadados da propriedade para a propriedade de dependência. Isto pode incluir o valor predefinido, bem como outras características."
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "Uma referência a uma chamada de retorno que deverá efetuar qualquer uma validação personalizada do valor de propriedade de dependência para além da validação do tipo típica."
    return:
      type: System.Windows.DependencyProperty
      description: "Um identificador de propriedade de dependência que deve ser utilizado para definir o valor de um <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> campo na sua classe. Esse identificador, em seguida, é utilizado para referenciar a propriedade de dependência mais tarde, para operações como definir o respetivo valor através de programação ou obtenção de metadados."
  overload: System.Windows.DependencyProperty.RegisterAttached*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Regista uma propriedade anexada só de leitura, com o tipo de propriedade especificado, o tipo de proprietário e os metadados da propriedade."
  remarks: "This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>. Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic. It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName> as a `public static readonly` field on your class.  \n  \n Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]. Without a public setter, an attached property cannot be set in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] syntax.  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property as attached is to support property value inheritance. You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);
    parameters:
    - id: name
      type: System.String
      description: "O nome da propriedade de dependência para registar."
    - id: propertyType
      type: System.Type
      description: "O tipo da propriedade."
    - id: ownerType
      type: System.Type
      description: "O tipo de proprietário que está a registar a propriedade de dependência."
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "Metadados da propriedade para a propriedade de dependência."
    return:
      type: System.Windows.DependencyPropertyKey
      description: "Uma chave de propriedade de dependência que deve ser utilizada para definir o valor de um campo estático de só de leitura na sua classe, que, em seguida, é utilizado para referenciar a propriedade de dependência mais tarde."
  overload: System.Windows.DependencyProperty.RegisterAttachedReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Regista uma propriedade anexada só de leitura, com o tipo de propriedade especificado, o tipo de proprietário, os metadados da propriedade e uma chamada de retorno de validação."
  remarks: "This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>. Typically, the keys that represent the type <xref:System.Windows.DependencyProperty>. Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic. It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName> as a `public static readonly` field on your class.  \n  \n Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]. Without a public setter, an attached property cannot be set in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] syntax.  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property as attached instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance. You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "O nome da propriedade de dependência para registar."
    - id: propertyType
      type: System.Type
      description: "O tipo da propriedade."
    - id: ownerType
      type: System.Type
      description: "O tipo de proprietário que está a registar a propriedade de dependência."
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "Metadados da propriedade para a propriedade de dependência."
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "Uma referência a uma chamada de retorno criados pelo utilizador, que deverá efetuar qualquer uma validação personalizada do valor de propriedade de dependência para além da validação do tipo típica."
    return:
      type: System.Windows.DependencyPropertyKey
      description: "Uma chave de propriedade de dependência que deve ser utilizada para definir o valor de um campo estático de só de leitura na sua classe, que, em seguida, é utilizado para referenciar a propriedade de dependência."
  overload: System.Windows.DependencyProperty.RegisterAttachedReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Regista uma propriedade de dependência só de leitura, com o tipo de propriedade especificado, o tipo de proprietário e os metadados da propriedade."
  remarks: "Este método devolve o tipo <xref:System.Windows.DependencyPropertyKey>, enquanto que <xref:System.Windows.DependencyProperty.RegisterAttached%2A>devolve o tipo <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty.RegisterAttached%2A> </xref:System.Windows.DependencyPropertyKey> Normalmente, as chaves que representam propriedades só de leitura não sejam feitas públicas, porque as chaves podem ser utilizadas para definir o valor de propriedade de dependência chamando <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> O design da sua classe irá afetar os seus requisitos, mas é, geralmente, recomendado para limitar o acesso e visibilidade de qualquer <xref:System.Windows.DependencyPropertyKey>apenas as partes do seu código que são necessárias para definir essa propriedade de dependência como parte da classe ou aplicação lógica.</xref:System.Windows.DependencyPropertyKey> Também é recomendável que expõem um identificador de propriedade de dependência para a propriedade de dependência só de leitura, por expor o valor de <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>como um `public static readonly` campo na sua classe.</xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>       Propriedades de dependência só de leitura são razoavelmente normal cenário ambas em existente [!INCLUDE[TLA2#tla_api](~/add/includes/tla2sharptla-api-md.md)] e para cenários de personalização, porque outras [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] funcionalidades poderão requerer uma propriedade de dependência, mesmo se essa propriedade não se destina a ser definível pelos chamadores. Pode utilizar o valor de uma propriedade de dependência só de leitura como base para outras operações do sistema de propriedade que ter uma propriedade de dependência, tais como basing um <xref:System.Windows.Trigger>na propriedade de dependência num style.</xref:System.Windows.Trigger>       Para obter mais informações sobre o registo de propriedade de dependência, consulte <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>"
  example:
  - "The following example registers an `AquariumSize` dependency property as read-only. The example defines `AquariumSizeKey` as an internal key (so that other classes in the assembly could override metadata) and exposes the dependency property identifier based on that key as `AquariumSizeProperty`. Also, a wrapper is created for `AquariumSize`, with only a get accessor.  \n  \n [!code-cs[WPFAquariumSln#RODP](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#rodp)]\n [!code-vb[WPFAquariumSln#RODP](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#rodp)]"
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: name
      type: System.String
      description: "O nome da propriedade de dependência para registar."
    - id: propertyType
      type: System.Type
      description: "O tipo da propriedade."
    - id: ownerType
      type: System.Type
      description: "O tipo de proprietário que está a registar a propriedade de dependência."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "Metadados da propriedade para a propriedade de dependência."
    return:
      type: System.Windows.DependencyPropertyKey
      description: "Uma chave de propriedade de dependência que deve ser utilizada para definir o valor de um campo estático de só de leitura na sua classe, que, em seguida, é utilizado para referenciar a propriedade de dependência."
  overload: System.Windows.DependencyProperty.RegisterReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Regista uma propriedade de dependência só de leitura, com o tipo de propriedade especificado, o tipo de proprietário, os metadados da propriedade e uma chamada de retorno de validação."
  remarks: "Este método devolve o tipo <xref:System.Windows.DependencyPropertyKey>, enquanto que <xref:System.Windows.DependencyProperty.RegisterAttached%2A>devolve o tipo <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty.RegisterAttached%2A> </xref:System.Windows.DependencyPropertyKey> Normalmente, as chaves que representam propriedades só de leitura não sejam feitas públicas, porque as chaves podem ser utilizadas para definir o valor de propriedade de dependência chamando <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> O design da sua classe irá afetar os seus requisitos, mas é, geralmente, recomendado para limitar o acesso e visibilidade de qualquer <xref:System.Windows.DependencyPropertyKey>apenas as partes do seu código que são necessárias para definir essa propriedade de dependência como parte da classe ou aplicação lógica.</xref:System.Windows.DependencyPropertyKey> Também é recomendável que expõem um identificador de propriedade de dependência para a propriedade de dependência só de leitura, por expor o valor de <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>como um `public static readonly` campo na sua classe.</xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>       Propriedades de dependência só de leitura são um cenário razoavelmente normal. Pode utilizar o valor de uma propriedade de dependência só de leitura como base para outras operações do sistema de propriedade que ter uma propriedade de dependência, tais como basing um <xref:System.Windows.Trigger>na propriedade de dependência num style.</xref:System.Windows.Trigger>       Para obter mais informações sobre o registo de propriedade de dependência, consulte <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>       Validação com uma propriedade de dependência só de leitura poderá ser menos importante. O nível de acesso nonpublic que especificar para a chave reduz a probabilidade de entrada inválida arbitrária."
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "O nome da propriedade de dependência para registar."
    - id: propertyType
      type: System.Type
      description: "O tipo da propriedade."
    - id: ownerType
      type: System.Type
      description: "O tipo de proprietário que está a registar a propriedade de dependência."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "Metadados da propriedade para a propriedade de dependência."
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "Uma referência a uma chamada de retorno criados pelo utilizador, que deverá efetuar qualquer uma validação personalizada do valor de propriedade de dependência para além da validação do tipo típica."
    return:
      type: System.Windows.DependencyPropertyKey
      description: "Uma chave de propriedade de dependência que deve ser utilizada para definir o valor de um campo estático de só de leitura na sua classe, que, em seguida, é utilizado para referenciar a propriedade de dependência mais tarde."
  overload: System.Windows.DependencyProperty.RegisterReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.ToString
  id: ToString
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: ToString()
  nameWithType: DependencyProperty.ToString()
  fullName: System.Windows.DependencyProperty.ToString()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Devolve a representação de cadeia da propriedade de dependência."
  remarks: "Esta implementação devolve o <xref:System.Windows.DependencyProperty.Name%2A>valor da propriedade.</xref:System.Windows.DependencyProperty.Name%2A>"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "A representação de cadeia da propriedade de dependência."
  overload: System.Windows.DependencyProperty.ToString*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.UnsetValue
  id: UnsetValue
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: UnsetValue
  nameWithType: DependencyProperty.UnsetValue
  fullName: System.Windows.DependencyProperty.UnsetValue
  type: Field
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Especifica um valor estático que é utilizado pelo [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] sistema propriedade vez <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> para indicar que a propriedade existe, mas não tem o respetivo valor definido pelo sistema de propriedade."
  remarks: "UnsetValue é um valor de sentinel que é utilizado para cenários em que o [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] sistema de propriedade não é possível determinar um pedido <xref:System.Windows.DependencyProperty>valor.</xref:System.Windows.DependencyProperty> É utilizado UnsetValue vez `null`porque `null` pode ser um valor de propriedade válido, bem como uma válido (e utilizadas frequentemente) <xref:System.Windows.PropertyMetadata.DefaultValue%2A>.</xref:System.Windows.PropertyMetadata.DefaultValue%2A>       UnsetValue nunca é devolvido fora <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName>.</xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName> Quando chamar <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName>uma propriedade de dependência num <xref:System.Windows.DependencyObject>instância, um dos seguintes aplica-se: - uma propriedade de dependência tem um valor predefinido estabelecido nos metadados e que o valor é devolvido.</xref:System.Windows.DependencyObject> </xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName> Este valor pode ser proveniente de <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.</xref:System.Windows.DependencyProperty.DefaultMetadata%2A>      -Foi estabelecido outro valor pelo sistema propriedade e o valor predefinido já não é relevante. Para obter mais informações, consulte [precedência de valor de propriedade de dependência](~/add/includes/ajax-current-ext-md.md).       Definir um <xref:System.Windows.PropertyMetadata.DefaultValue%2A>de UnsetValue não é especificamente permitido.</xref:System.Windows.PropertyMetadata.DefaultValue%2A>       <xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=fullName>Devolve UnsetValue quando a propriedade pedida não tiver sido definida localmente.</xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=fullName>       UnsetValue tem um significado especial quando utilizado como o valor de retorno de <xref:System.Windows.CoerceValueCallback>.</xref:System.Windows.CoerceValueCallback> Para obter mais informações, consulte [chamadas de retorno de propriedade de dependência e validação](~/add/includes/ajax-current-ext-md.md).       Se estiver a vincular a uma base de dados, tenha em atenção que UnsetValue não é equivalente ao <xref:System.DBNull.Value>, de forma semelhante ao procedimento <xref:System.DBNull.Value>não é equivalente a um valor nulo true.</xref:System.DBNull.Value> </xref:System.DBNull.Value>"
  syntax:
    content: public static readonly object UnsetValue;
    return:
      type: System.Object
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.ValidateValueCallback
  id: ValidateValueCallback
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: ValidateValueCallback
  nameWithType: DependencyProperty.ValidateValueCallback
  fullName: System.Windows.DependencyProperty.ValidateValueCallback
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Obtém a chamada de retorno de validação de valor para a propriedade de dependência."
  remarks: "Esta propriedade irá conter `null` para qualquer propriedade de dependência com chamada de retorno não registada validação.       Validar o valor de chamadas de retorno tem de funcionar numa noção estática: validação aplicada através da <xref:System.Windows.ValidateValueCallback>não é possível determinar se o valor fornecido é válido para qualquer instância específica.</xref:System.Windows.ValidateValueCallback> A chamada de retorno só pode determinar se todos os objetos que tenha a propriedade de dependência devem ou não devem aceitar o valor fornecido como válido. Se precisar de efetuar a validação que depende de saber os valores de outras propriedades de dependência numa determinada instância, utilize um <xref:System.Windows.CoerceValueCallback>em vez disso.</xref:System.Windows.CoerceValueCallback> O <xref:System.Windows.CoerceValueCallback>está registado como parte dos metadados da propriedade de dependência, em vez de diretamente no identificador de propriedade de dependência.</xref:System.Windows.CoerceValueCallback> Para obter mais informações, consulte [chamadas de retorno de propriedade de dependência e validação](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public System.Windows.ValidateValueCallback ValidateValueCallback { get; }
    return:
      type: System.Windows.ValidateValueCallback
      description: "A chamada de retorno de validação de valor para esta propriedade de dependência, conforme fornecida para o <code> validateValueCallback </code> parâmetro no registo de propriedade de dependência original."
  overload: System.Windows.DependencyProperty.ValidateValueCallback*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Windows.DependencyProperty.AddOwner(System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: AddOwner(Type)
  nameWithType: DependencyProperty.AddOwner(Type)
  fullName: System.Windows.DependencyProperty.AddOwner(Type)
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: AddOwner(Type,PropertyMetadata)
  nameWithType: DependencyProperty.AddOwner(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.AddOwner(Type,PropertyMetadata)
- uid: System.Windows.PropertyMetadata
  parent: System.Windows
  isExternal: false
  name: PropertyMetadata
  nameWithType: PropertyMetadata
  fullName: System.Windows.PropertyMetadata
- uid: System.Windows.DependencyProperty.DefaultMetadata
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: DefaultMetadata
  nameWithType: DependencyProperty.DefaultMetadata
  fullName: System.Windows.DependencyProperty.DefaultMetadata
- uid: System.Windows.DependencyProperty.GetHashCode
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetHashCode()
  nameWithType: DependencyProperty.GetHashCode()
  fullName: System.Windows.DependencyProperty.GetHashCode()
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.DependencyProperty.GetMetadata(System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata(Type)
  nameWithType: DependencyProperty.GetMetadata(Type)
  fullName: System.Windows.DependencyProperty.GetMetadata(Type)
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata(DependencyObject)
  nameWithType: DependencyProperty.GetMetadata(DependencyObject)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObject)
- uid: System.Windows.DependencyObject
  parent: System.Windows
  isExternal: false
  name: DependencyObject
  nameWithType: DependencyObject
  fullName: System.Windows.DependencyObject
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata(DependencyObjectType)
  nameWithType: DependencyProperty.GetMetadata(DependencyObjectType)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObjectType)
- uid: System.Windows.DependencyObjectType
  parent: System.Windows
  isExternal: false
  name: DependencyObjectType
  nameWithType: DependencyObjectType
  fullName: System.Windows.DependencyObjectType
- uid: System.Windows.DependencyProperty.GlobalIndex
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GlobalIndex
  nameWithType: DependencyProperty.GlobalIndex
  fullName: System.Windows.DependencyProperty.GlobalIndex
- uid: System.Windows.DependencyProperty.IsValidType(System.Object)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidType(Object)
  nameWithType: DependencyProperty.IsValidType(Object)
  fullName: System.Windows.DependencyProperty.IsValidType(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.DependencyProperty.IsValidValue(System.Object)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidValue(Object)
  nameWithType: DependencyProperty.IsValidValue(Object)
  fullName: System.Windows.DependencyProperty.IsValidValue(Object)
- uid: System.Windows.DependencyProperty.Name
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Name
  nameWithType: DependencyProperty.Name
  fullName: System.Windows.DependencyProperty.Name
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OverrideMetadata(Type,PropertyMetadata)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
- uid: System.Windows.DependencyPropertyKey
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyKey
  nameWithType: DependencyPropertyKey
  fullName: System.Windows.DependencyPropertyKey
- uid: System.Windows.DependencyProperty.OwnerType
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OwnerType
  nameWithType: DependencyProperty.OwnerType
  fullName: System.Windows.DependencyProperty.OwnerType
- uid: System.Windows.DependencyProperty.PropertyType
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: PropertyType
  nameWithType: DependencyProperty.PropertyType
  fullName: System.Windows.DependencyProperty.PropertyType
- uid: System.Windows.DependencyProperty.ReadOnly
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ReadOnly
  nameWithType: DependencyProperty.ReadOnly
  fullName: System.Windows.DependencyProperty.ReadOnly
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register(String,Type,Type)
  nameWithType: DependencyProperty.Register(String,Type,Type)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type)
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.ValidateValueCallback
  parent: System.Windows
  isExternal: false
  name: ValidateValueCallback
  nameWithType: ValidateValueCallback
  fullName: System.Windows.ValidateValueCallback
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached(String,Type,Type)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type)
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.DependencyProperty.ToString
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ToString()
  nameWithType: DependencyProperty.ToString()
  fullName: System.Windows.DependencyProperty.ToString()
- uid: System.Windows.DependencyProperty.UnsetValue
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: UnsetValue
  nameWithType: DependencyProperty.UnsetValue
  fullName: System.Windows.DependencyProperty.UnsetValue
- uid: System.Windows.DependencyProperty.ValidateValueCallback
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ValidateValueCallback
  nameWithType: DependencyProperty.ValidateValueCallback
  fullName: System.Windows.DependencyProperty.ValidateValueCallback
- uid: System.Windows.DependencyProperty.AddOwner*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: AddOwner
  nameWithType: DependencyProperty.AddOwner
- uid: System.Windows.DependencyProperty.DefaultMetadata*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: DefaultMetadata
  nameWithType: DependencyProperty.DefaultMetadata
- uid: System.Windows.DependencyProperty.GetHashCode*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetHashCode
  nameWithType: DependencyProperty.GetHashCode
- uid: System.Windows.DependencyProperty.GetMetadata*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata
  nameWithType: DependencyProperty.GetMetadata
- uid: System.Windows.DependencyProperty.GlobalIndex*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GlobalIndex
  nameWithType: DependencyProperty.GlobalIndex
- uid: System.Windows.DependencyProperty.IsValidType*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidType
  nameWithType: DependencyProperty.IsValidType
- uid: System.Windows.DependencyProperty.IsValidValue*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidValue
  nameWithType: DependencyProperty.IsValidValue
- uid: System.Windows.DependencyProperty.Name*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Name
  nameWithType: DependencyProperty.Name
- uid: System.Windows.DependencyProperty.OverrideMetadata*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OverrideMetadata
  nameWithType: DependencyProperty.OverrideMetadata
- uid: System.Windows.DependencyProperty.OwnerType*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OwnerType
  nameWithType: DependencyProperty.OwnerType
- uid: System.Windows.DependencyProperty.PropertyType*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: PropertyType
  nameWithType: DependencyProperty.PropertyType
- uid: System.Windows.DependencyProperty.ReadOnly*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ReadOnly
  nameWithType: DependencyProperty.ReadOnly
- uid: System.Windows.DependencyProperty.Register*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register
  nameWithType: DependencyProperty.Register
- uid: System.Windows.DependencyProperty.RegisterAttached*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached
  nameWithType: DependencyProperty.RegisterAttached
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttachedReadOnly
  nameWithType: DependencyProperty.RegisterAttachedReadOnly
- uid: System.Windows.DependencyProperty.RegisterReadOnly*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterReadOnly
  nameWithType: DependencyProperty.RegisterReadOnly
- uid: System.Windows.DependencyProperty.ToString*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ToString
  nameWithType: DependencyProperty.ToString
- uid: System.Windows.DependencyProperty.ValidateValueCallback*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ValidateValueCallback
  nameWithType: DependencyProperty.ValidateValueCallback
