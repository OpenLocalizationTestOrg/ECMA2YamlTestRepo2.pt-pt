### YamlMime:ManagedReference
items:
- uid: System.Security.AccessControl.SemaphoreSecurity
  id: SemaphoreSecurity
  children:
  - System.Security.AccessControl.SemaphoreSecurity.#ctor
  - System.Security.AccessControl.SemaphoreSecurity.#ctor(System.String,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.SemaphoreSecurity.AccessRightType
  - System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  - System.Security.AccessControl.SemaphoreSecurity.AccessRuleType
  - System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  - System.Security.AccessControl.SemaphoreSecurity.AddAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  - System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  - System.Security.AccessControl.SemaphoreSecurity.AuditRuleType
  - System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  - System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(System.Security.AccessControl.SemaphoreAccessRule)
  - System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule)
  - System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  - System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll(System.Security.AccessControl.SemaphoreAuditRule)
  - System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.SemaphoreAuditRule)
  - System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  - System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  - System.Security.AccessControl.SemaphoreSecurity.SetAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  langs:
  - csharp
  name: SemaphoreSecurity
  nameWithType: SemaphoreSecurity
  fullName: System.Security.AccessControl.SemaphoreSecurity
  type: Class
  summary: "Representa a segurança de controlo de acesso do Windows para um semáforo com nome. Esta classe não pode ser herdada."
  remarks: "Um objeto de SemaphoreSecurity especifica direitos de acesso para o semáforo um sistema com nome e também especifica como são auditadas tentativas de acesso. Direitos de acesso para o semáforo são expressos em regras, com cada regra de acesso representado por um <xref:System.Security.AccessControl.SemaphoreAccessRule>objeto.</xref:System.Security.AccessControl.SemaphoreAccessRule> Cada regra de auditoria é representada por um <xref:System.Security.AccessControl.SemaphoreAuditRule>objeto.</xref:System.Security.AccessControl.SemaphoreAuditRule>       Isto reflete o sistema de segurança de Windows subjacente, no qual cada objeto com capacidade de segurança tem no máximo um controlo lista de acesso discricionário (DACL) que controla o acesso ao objeto segurado e no máximo um sistema acesso lista de controlo (SACL) que especifica as tentativas de acesso são auditadas. O DACL e SACL ordenadas apresenta uma lista de entradas de controlo de acesso (ACE) que especificam o acesso e auditoria para utilizadores e grupos. A <xref:System.Security.AccessControl.SemaphoreAccessRule>ou <xref:System.Security.AccessControl.SemaphoreAuditRule>objeto poderão representar mais de uma ACE.</xref:System.Security.AccessControl.SemaphoreAuditRule> </xref:System.Security.AccessControl.SemaphoreAccessRule>      > [!NOTE] > A <xref:System.Threading.Semaphore>objeto pode representar um semáforo local ou um semáforo sistema nomeado.</xref:System.Threading.Semaphore> Segurança de controlo de acesso do Windows é significativa apenas para semaphores de sistema com nome.       O SemaphoreSecurity <xref:System.Security.AccessControl.SemaphoreAccessRule>, e <xref:System.Security.AccessControl.SemaphoreAuditRule>classes ocultar os detalhes de implementação de ACLs e ACEs.</xref:System.Security.AccessControl.SemaphoreAuditRule> </xref:System.Security.AccessControl.SemaphoreAccessRule> Estas permitem-lhe ignorar os diferentes tipos ACE seventeen e a complexidade de manter corretamente herança e propagação de direitos de acesso. Estes objetos são também foi concebidos para impedir que os seguintes erros de controlo de acesso comuns:-criar um descritor de segurança com um DACL nulo. Uma referência nula para um DACL permite que qualquer utilizador adicionar regras de acesso a um objeto, potencialmente, criar um ataque denial-of-service. Um novo objeto de SemaphoreSecurity sempre começa com um DACL vazio, que nega todos os acessos para todos os utilizadores.      -A ordenação canónico ACEs violação. Se a lista de ACE o DACL não é mantida pela ordem canónica, os utilizadores podem inadvertidamente ser dado acesso ao objeto segurado. Por exemplo, direitos de acesso negado sempre têm de aparecer antes de direitos de acesso permitido. Objetos de SemaphoreSecurity mantêm internamente ordem correta.      -Manipulação de sinalizadores de descritor de segurança, devem ser sob o controlo do Gestor de recursos apenas.      -Criar inválidas combinações de ACE sinalizadores.      -Manipular ACEs herdados. Herança e propagação são processadas pelo Gestor de recursos em resposta a alterações efetuadas às regras de acesso e auditoria.      -Inserir ACEs sem significado ACLs.       As capacidades apenas não suportadas pelos objetos de segurança do .NET estão perigosos atividades que devem ser evitadas pela maioria dos programadores de aplicações, tais como o seguinte:-tarefas de baixo nível que normalmente são executadas pelo Gestor de recursos.      -Adicionar ou remover entradas de controlo de acesso de formas que não mantêm a ordenação canónico.       Para modificar a segurança de controlo de acesso do Windows para um semáforo com nome, utilize o <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=fullName>método para obter o objeto de SemaphoreSecurity.</xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=fullName> Modificar o objecto de segurança ao adicionar e remover regras e, em seguida, utilize o <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>método para reattach mesmo.</xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>      > [!IMPORTANT] > Alterações efetuadas a um objeto de SemaphoreSecurity não afetam os níveis de acesso de semáforo nomeado até que tem de chamar o <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>método para atribuir o objeto de segurança alterada para o semáforo nomeado.</xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>       Para copiar segurança de controlo de acesso de um semáforo para outro, utilize o <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=fullName>método para obter um objeto de SemaphoreSecurity que representa as regras de acesso e auditoria para o semáforo primeiro, em seguida, utilizar o <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>método ou um construtor que aceite um objeto de SemaphoreSecurity, para atribuir essas regras para o segundo semáforo.</xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName> </xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=fullName>       Os utilizadores com um investimento na linguagem de definição de descritor de segurança (SDDL) podem utilizar o <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A>método para definir regras de acesso para um semáforo com nome e o <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A>método para obter uma cadeia que representa as regras de acesso no formato SDDL.</xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> </xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> Não é recomendado para um novo desenvolvimento.      > [!NOTE] > Segurança em objetos de sincronização não é suportada para Windows 98 ou Windows Millennium Edition."
  example:
  - "The following code example demonstrates the separation between <xref:System.Security.AccessControl.AccessControlType> rules and <xref:System.Security.AccessControl.AccessControlType> rules, and shows the combination of rights in compatible rules. The example creates a SemaphoreSecurity object, adds rules that allow and deny various rights for the current user, and displays the resulting pair of rules. The example then allows new rights for the current user and displays the result, showing that the new rights are merged with the existing <xref:System.Security.AccessControl.AccessControlType> rule.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:System.Threading.Semaphore> object. Examples that attach security objects can be found in <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=fullName> and <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-cs[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/add/codesnippet/csharp/t-system.security.access_8_1.cs)]\n [!code-vb[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/add/codesnippet/visualbasic/t-system.security.access_8_1.vb)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(false)]

      public sealed class SemaphoreSecurity : System.Security.AccessControl.NativeObjectSecurity
  inheritance:
  - System.Object
  - System.Security.AccessControl.ObjectSecurity
  - System.Security.AccessControl.CommonObjectSecurity
  - System.Security.AccessControl.NativeObjectSecurity
  implements: []
  inheritedMembers:
  - System.Security.AccessControl.CommonObjectSecurity.AddAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.AddAuditRule(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.GetAccessRules(System.Boolean,System.Boolean,System.Type)
  - System.Security.AccessControl.CommonObjectSecurity.GetAuditRules(System.Boolean,System.Boolean,System.Type)
  - System.Security.AccessControl.CommonObjectSecurity.ModifyAccess(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AccessRule,System.Boolean@)
  - System.Security.AccessControl.CommonObjectSecurity.ModifyAudit(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AuditRule,System.Boolean@)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAccessRuleAll(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAuditRule(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAuditRuleAll(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.ResetAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.SetAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.SetAuditRule(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.Runtime.InteropServices.SafeHandle,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.Runtime.InteropServices.SafeHandle,System.Security.AccessControl.AccessControlSections,System.Object)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.String,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.String,System.Security.AccessControl.AccessControlSections,System.Object)
  - System.Security.AccessControl.ObjectSecurity.AccessRulesModified
  - System.Security.AccessControl.ObjectSecurity.AreAccessRulesCanonical
  - System.Security.AccessControl.ObjectSecurity.AreAccessRulesProtected
  - System.Security.AccessControl.ObjectSecurity.AreAuditRulesCanonical
  - System.Security.AccessControl.ObjectSecurity.AreAuditRulesProtected
  - System.Security.AccessControl.ObjectSecurity.AuditRulesModified
  - System.Security.AccessControl.ObjectSecurity.GetGroup(System.Type)
  - System.Security.AccessControl.ObjectSecurity.GetOwner(System.Type)
  - System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm
  - System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm(System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.GroupModified
  - System.Security.AccessControl.ObjectSecurity.IsContainer
  - System.Security.AccessControl.ObjectSecurity.IsDS
  - System.Security.AccessControl.ObjectSecurity.IsSddlConversionSupported
  - System.Security.AccessControl.ObjectSecurity.ModifyAccessRule(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AccessRule,System.Boolean@)
  - System.Security.AccessControl.ObjectSecurity.ModifyAuditRule(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AuditRule,System.Boolean@)
  - System.Security.AccessControl.ObjectSecurity.OwnerModified
  - System.Security.AccessControl.ObjectSecurity.Persist(System.Boolean,System.String,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.PurgeAccessRules(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.PurgeAuditRules(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.ReadLock
  - System.Security.AccessControl.ObjectSecurity.ReadUnlock
  - System.Security.AccessControl.ObjectSecurity.SetAccessRuleProtection(System.Boolean,System.Boolean)
  - System.Security.AccessControl.ObjectSecurity.SetAuditRuleProtection(System.Boolean,System.Boolean)
  - System.Security.AccessControl.ObjectSecurity.SetGroup(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.SetOwner(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm(System.Byte[])
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm(System.Byte[],System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm(System.String)
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm(System.String,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.WriteLock
  - System.Security.AccessControl.ObjectSecurity.WriteUnlock
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.#ctor
  id: '#ctor'
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: SemaphoreSecurity()
  nameWithType: SemaphoreSecurity.SemaphoreSecurity()
  fullName: System.Security.AccessControl.SemaphoreSecurity.SemaphoreSecurity()
  type: Constructor
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Security.AccessControl.SemaphoreSecurity&quot;> </xref> classe com valores predefinidos."
  remarks: "Um novo <xref:System.Security.AccessControl.SemaphoreSecurity>objeto sempre começa com uma lista vazia de acesso discricionário (DACL), que nega todos os acessos para todos os utilizadores.</xref:System.Security.AccessControl.SemaphoreSecurity>"
  syntax:
    content: public SemaphoreSecurity ();
    parameters: []
  overload: System.Security.AccessControl.SemaphoreSecurity.#ctor*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Esta classe não é suportada no Windows 98 ou edição de Millennium do Windows."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.#ctor(System.String,System.Security.AccessControl.AccessControlSections)
  id: '#ctor(System.String,System.Security.AccessControl.AccessControlSections)'
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: SemaphoreSecurity(String,AccessControlSections)
  nameWithType: SemaphoreSecurity.SemaphoreSecurity(String,AccessControlSections)
  fullName: System.Security.AccessControl.SemaphoreSecurity.SemaphoreSecurity(String,AccessControlSections)
  type: Constructor
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Security.AccessControl.SemaphoreSecurity&quot;> </xref> classe com as secções que se especificado, as regras de segurança do controlo de acesso de semáforo sistema com o nome especificado."
  remarks: "Este construtor permite-lhe obter a segurança de controlo de acesso para o semáforo um sistema com nome sem criar primeiro um <xref:System.Threading.Semaphore>objeto.</xref:System.Threading.Semaphore>       Atenção tem de ser executada ao trabalhar com objetos do sistema com nome. Se houver um objeto de sistema com o nome `name` que não é um semáforo, a segurança de acesso de controlo pode ser obtida."
  syntax:
    content: public SemaphoreSecurity (string name, System.Security.AccessControl.AccessControlSections includeSections);
    parameters:
    - id: name
      type: System.String
      description: "O nome do semáforo sistema cujas regras de segurança do controlo de acesso estão a ser obtidos."
    - id: includeSections
      type: System.Security.AccessControl.AccessControlSections
      description: "Uma combinação de <xref href=&quot;System.Security.AccessControl.AccessControlSections&quot;> </xref> sinalizadores especificando as secções a obter."
  overload: System.Security.AccessControl.SemaphoreSecurity.#ctor*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Esta classe não é suportada no Windows 98 ou edição de Millennium do Windows."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.AccessRightType
  id: AccessRightType
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: AccessRightType
  nameWithType: SemaphoreSecurity.AccessRightType
  fullName: System.Security.AccessControl.SemaphoreSecurity.AccessRightType
  type: Property
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Obtém a enumeração que o <xref href=&quot;System.Security.AccessControl.SemaphoreSecurity&quot;> </xref> utiliza para representar os direitos de acesso de classe."
  remarks: "Classes que derivam de <xref:System.Security.AccessControl.ObjectSecurity>substituição de classe a <xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A>propriedade e devolver o tipo que utilizam para representar os direitos de acesso.</xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> </xref:System.Security.AccessControl.ObjectSecurity> Quando trabalha com matrizes ou coleções que contenham vários tipos de objetos de segurança, utilize esta propriedade para determinar o tipo de enumeração correto a utilizar com cada objeto de segurança."
  syntax:
    content: public override Type AccessRightType { get; }
    return:
      type: System.Type
      description: "A <xref:System.Type>objeto que representa o <xref href=&quot;System.Security.AccessControl.SemaphoreRights&quot;> </xref> enumeração.</xref:System.Type>"
  overload: System.Security.AccessControl.SemaphoreSecurity.AccessRightType*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  id: AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  nameWithType: SemaphoreSecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  fullName: System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Cria uma nova regra de controlo de acesso para o utilizador especificado, com os direitos de acesso especificado, o controlo de acesso e sinalizadores."
  remarks: "O modo recomendado para criar regras de controlo de acesso está a utilizar os construtores da <xref:System.Security.AccessControl.SemaphoreAccessRule>classe.</xref:System.Security.AccessControl.SemaphoreAccessRule>      > [!NOTE] > Apesar dos sinalizadores de herança e propagação serem sem significado para semaphores com nome, é possível especificar não seja recomendado, porque este perdas de tempo complicates a manutenção de regras, por exemplo, interferir com a combinação de regras que de outra forma seriam compatível."
  syntax:
    content: public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);
    parameters:
    - id: identityReference
      type: System.Security.Principal.IdentityReference
      description: "Um <xref href=&quot;System.Security.Principal.IdentityReference&quot;> </xref> que identifica o utilizador ou grupo a regra se aplica."
    - id: accessMask
      type: System.Int32
      description: "Uma combinação bit a bit de <xref href=&quot;System.Security.AccessControl.SemaphoreRights&quot;> </xref> valores especificar os direitos de acesso para permitir ou negar, converter para um número inteiro."
    - id: isInherited
      type: System.Boolean
      description: "Sem significado para com o nome semaphores, porque não têm nenhuma hierarquia."
    - id: inheritanceFlags
      type: System.Security.AccessControl.InheritanceFlags
      description: "Sem significado para com o nome semaphores, porque não têm nenhuma hierarquia."
    - id: propagationFlags
      type: System.Security.AccessControl.PropagationFlags
      description: "Sem significado para com o nome semaphores, porque não têm nenhuma hierarquia."
    - id: type
      type: System.Security.AccessControl.AccessControlType
      description: "Um do <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> valores especificar se os direitos são permitidos ou negados."
    return:
      type: System.Security.AccessControl.AccessRule
      description: "A <xref href=&quot;System.Security.AccessControl.SemaphoreAccessRule&quot;> </xref> objeto que representa os direitos especificados para o utilizador especificado."
  overload: System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>accessMask</code>, <code>inheritanceFlags</code>, <code>propagationFlags</code>, ou <code>type</code> Especifica um valor inválido."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>identityReference</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - ou - <code>accessMask</code> é zero."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>identityReference</code>é nenhum tipo <xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>, nem um tipo como <xref href=&quot;System.Security.Principal.NTAccount&quot;> </xref> que pode ser convertido no tipo <xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.AccessRuleType
  id: AccessRuleType
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: AccessRuleType
  nameWithType: SemaphoreSecurity.AccessRuleType
  fullName: System.Security.AccessControl.SemaphoreSecurity.AccessRuleType
  type: Property
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Obtém o tipo que o <xref href=&quot;System.Security.AccessControl.SemaphoreSecurity&quot;> </xref> utiliza para representar as regras de acesso de classe."
  remarks: "Classes que derivam de <xref:System.Security.AccessControl.ObjectSecurity>substituição de classe a <xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A>propriedade e devolver o tipo que utilizam para representar as regras de acesso.</xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> </xref:System.Security.AccessControl.ObjectSecurity> Quando trabalha com matrizes ou coleções que contenham vários tipos de objetos de segurança, utilize esta propriedade para determinar o tipo de regra de acesso corretas para utilizar com cada objeto de segurança."
  syntax:
    content: public override Type AccessRuleType { get; }
    return:
      type: System.Type
      description: "A <xref:System.Type>objeto que representa o <xref href=&quot;System.Security.AccessControl.SemaphoreAccessRule&quot;> </xref> classe</xref:System.Type>"
  overload: System.Security.AccessControl.SemaphoreSecurity.AccessRuleType*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  id: AddAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: AddAccessRule(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.AddAccessRule(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(SemaphoreAccessRule)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Procura uma regra correspondente com o qual a nova regra possam ser intercalada. Se não for encontrada nenhuma, adiciona a nova regra."
  remarks: "O método AddAccessRule procura regras com o mesmo utilizador ou grupo e o mesmo <xref:System.Security.AccessControl.AccessControlType>como `rule`.</xref:System.Security.AccessControl.AccessControlType> Se não for encontrada nenhuma, `rule` é adicionado. Se for encontrada uma regra correspondente, os direitos no `rule` são intercaladas com a regra existente."
  example:
  - "The following code example demonstrates the separation between <xref:System.Security.AccessControl.AccessControlType> rules and <xref:System.Security.AccessControl.AccessControlType> rules, and shows the combination of rights in compatible rules. The example creates a <xref:System.Security.AccessControl.SemaphoreSecurity> object, adds rules that allow and deny various rights for the current user, and displays the resulting pair of rules. The example then allows new rights for the current user and displays the result, showing that the new rights are merged with the existing <xref:System.Security.AccessControl.AccessControlType> rule.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:System.Threading.Semaphore> object. Examples that attach security objects can be found in <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=fullName> and <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-cs[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/add/codesnippet/csharp/5be6d691-cc28-4e1b-ae9c-_1.cs)]\n [!code-vb[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/add/codesnippet/visualbasic/5be6d691-cc28-4e1b-ae9c-_1.vb)]"
  syntax:
    content: public void AddAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.SemaphoreAccessRule
      description: "A regra de controlo de acesso para adicionar."
  overload: System.Security.AccessControl.SemaphoreSecurity.AddAccessRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.AddAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  id: AddAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: AddAuditRule(SemaphoreAuditRule)
  nameWithType: SemaphoreSecurity.AddAuditRule(SemaphoreAuditRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.AddAuditRule(SemaphoreAuditRule)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Procura uma regra de auditoria com a qual a nova regra pode ser intercalada. Se não for encontrada nenhuma, adiciona a nova regra."
  remarks: "O método AddAuditRule procura regras com o mesmo utilizador ou grupo como `rule`. Se não for encontrada nenhuma, `rule` é adicionado. Se for encontrada uma regra correspondente, os sinalizadores no `rule` são intercaladas para a regra existente."
  syntax:
    content: public void AddAuditRule (System.Security.AccessControl.SemaphoreAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.SemaphoreAuditRule
      description: "A regra de auditoria para adicionar. O utilizador especificado por esta regra determina a pesquisa."
  overload: System.Security.AccessControl.SemaphoreSecurity.AddAuditRule*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  id: AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  nameWithType: SemaphoreSecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  fullName: System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Cria uma nova regra de auditoria, especificando o utilizador que a regra se aplica, os direitos de acesso para auditoria e o resultado que aciona a regra de auditoria."
  remarks: "O modo recomendado para criar regras de auditoria é utilizar os construtores da <xref:System.Security.AccessControl.SemaphoreAuditRule>classe.</xref:System.Security.AccessControl.SemaphoreAuditRule>      > [!NOTE] > Apesar dos sinalizadores de herança e propagação serem sem significado para semaphores com nome, é possível de especificá-los. Isto não é recomendado, porque este perdas de tempo complicates a manutenção de regras, por exemplo, interferir com a combinação de regras que de outra forma seriam compatível."
  syntax:
    content: public override System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);
    parameters:
    - id: identityReference
      type: System.Security.Principal.IdentityReference
      description: "Um <xref href=&quot;System.Security.Principal.IdentityReference&quot;> </xref> que identifica o utilizador ou grupo a regra se aplica."
    - id: accessMask
      type: System.Int32
      description: "Uma combinação bit a bit de <xref href=&quot;System.Security.AccessControl.SemaphoreRights&quot;> </xref> valores especificar os direitos de acesso a auditoria, converter para um número inteiro."
    - id: isInherited
      type: System.Boolean
      description: "Sem significado para identificadores de espera com nome, porque não têm nenhuma hierarquia."
    - id: inheritanceFlags
      type: System.Security.AccessControl.InheritanceFlags
      description: "Sem significado para identificadores de espera com nome, porque não têm nenhuma hierarquia."
    - id: propagationFlags
      type: System.Security.AccessControl.PropagationFlags
      description: "Sem significado para identificadores de espera com nome, porque não têm nenhuma hierarquia."
    - id: flags
      type: System.Security.AccessControl.AuditFlags
      description: "Uma combinação bit a bit de <xref href=&quot;System.Security.AccessControl.AuditFlags&quot;> </xref> valores que especifique se a auditoria de acesso com êxito, falha de acesso ou ambos."
    return:
      type: System.Security.AccessControl.AuditRule
      description: "A <xref href=&quot;System.Security.AccessControl.SemaphoreAuditRule&quot;> </xref> objeto que representa a regra de auditoria especificado para o utilizador especificado. O tipo de retorno do método é a classe base, <xref href=&quot;System.Security.AccessControl.AuditRule&quot;> </xref>, mas o valor de retorno pode ser convertido em segurança para a classe derivada."
  overload: System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>accessMask</code>, <code>inheritanceFlags</code>, <code>propagationFlags</code>, ou <code>flags</code> Especifica um valor inválido."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>identityReference</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - ou - <code>accessMask</code> é zero."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>identityReference</code>é nenhum tipo <xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>, nem um tipo como <xref href=&quot;System.Security.Principal.NTAccount&quot;> </xref> que pode ser convertido no tipo <xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.AuditRuleType
  id: AuditRuleType
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: AuditRuleType
  nameWithType: SemaphoreSecurity.AuditRuleType
  fullName: System.Security.AccessControl.SemaphoreSecurity.AuditRuleType
  type: Property
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Obtém o tipo que o <xref href=&quot;System.Security.AccessControl.SemaphoreSecurity&quot;> </xref> utiliza para representar regras de auditoria de classe."
  remarks: "Classes que derivam de <xref:System.Security.AccessControl.ObjectSecurity>substituição de classe a <xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A>propriedade e devolver o tipo que utilizam para representar os direitos de auditoria.</xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> </xref:System.Security.AccessControl.ObjectSecurity> Quando trabalha com matrizes ou coleções que contenham vários tipos de objetos de segurança, utilize esta propriedade para determinar o tipo de regra de auditoria correta a utilizar com cada objeto de segurança."
  syntax:
    content: public override Type AuditRuleType { get; }
    return:
      type: System.Type
      description: "A <xref:System.Type>objeto que representa o <xref href=&quot;System.Security.AccessControl.SemaphoreAuditRule&quot;> </xref> classe</xref:System.Type>"
  overload: System.Security.AccessControl.SemaphoreSecurity.AuditRuleType*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  id: RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: RemoveAccessRule(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.RemoveAccessRule(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(SemaphoreAccessRule)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Procura uma regra de controlo de acesso com o mesmo utilizador e <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> (permitir ou negar) como a regra especificada e com compatível herança e sinalizadores de propagação; se for encontrada essa uma regra, os direitos contidos na regra de acesso especificado são removidos do mesmo."
  remarks: "Atual <xref:System.Security.AccessControl.SemaphoreSecurity>é procurada uma regra que tem o mesmo utilizador e o mesmo <xref:System.Security.AccessControl.AccessControlType>valor como `rule`.</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.SemaphoreSecurity> Se nenhuma regra tal for encontrada, foi efetuada nenhuma ação e o método devolve `false`. Se forem encontradas regras de correspondência, os sinalizadores de herança e de compatibilidade são verificados para compatibilidade com os sinalizadores especificados na `rule`. Não se for encontrada nenhuma regra compatível, foi efetuada nenhuma ação e o método devolve `false`. Se for encontrada qualquer regra com sinalizadores compatíveis, os direitos especificados `rule` são removidas da regra compatível, e o método devolve `true`. Se `rule` especifica direitos não contidos na regra compatível, foi efetuada nenhuma ação no que respeita a esses direitos. Se todos os direitos são removidos da regra compatível, a regra completa é removida do atual <xref:System.Security.AccessControl.SemaphoreSecurity>objeto.</xref:System.Security.AccessControl.SemaphoreSecurity>      > [!IMPORTANT] > Embora possa especificar sinalizadores de herança e propagação para as regras de acesso do semáforo, criando-los com o <xref:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory%2A>método, isto não é recomendado.</xref:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory%2A> Herança e propagação não tem nenhum significado para semaphores nomeados e efetuam a manutenção de regras de acesso mais complicada."
  example:
  - "The following code example demonstrates the use of the RemoveAccessRule method to remove rights from an <xref:System.Security.AccessControl.AccessControlType> rule in a <xref:System.Security.AccessControl.SemaphoreSecurity> object. It also shows that other rights in `rule` are ignored.  \n  \n The example creates a <xref:System.Security.AccessControl.SemaphoreSecurity> object and adds rules that allow and deny various rights for the current user. The rights allowed include <xref:System.Security.AccessControl.SemaphoreRights>, <xref:System.Security.AccessControl.SemaphoreRights>, and <xref:System.Security.AccessControl.SemaphoreRights>. The example then creates a new rule for the current user, including <xref:System.Security.AccessControl.SemaphoreRights> and <xref:System.Security.AccessControl.SemaphoreRights> rights, and uses that rule with the RemoveAccessRule method to remove <xref:System.Security.AccessControl.SemaphoreRights> from the <xref:System.Security.AccessControl.AccessControlType> rule in the <xref:System.Security.AccessControl.SemaphoreSecurity> object. The extraneous <xref:System.Security.AccessControl.SemaphoreRights> right in `rule` is ignored.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:System.Threading.Semaphore> object. Examples that attach security objects can be found in <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=fullName> and <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-cs[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule#1](~/add/codesnippet/csharp/967006c5-d60e-4018-a570-_1.cs)]\n [!code-vb[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule#1](~/add/codesnippet/visualbasic/967006c5-d60e-4018-a570-_1.vb)]"
  syntax:
    content: public bool RemoveAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.SemaphoreAccessRule
      description: "A <xref href=&quot;System.Security.AccessControl.SemaphoreAccessRule&quot;> </xref> Especifica que o utilizador e <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> para procurar e um conjunto de sinalizadores de herança e propagação de uma correspondência de regras, se encontrar, tem de ser compatível com. Especifica os direitos para remover a regra compatível, se encontrar."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se for encontrada uma regra compatível; caso contrário <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(System.Security.AccessControl.SemaphoreAccessRule)
  id: RemoveAccessRuleAll(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: RemoveAccessRuleAll(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.RemoveAccessRuleAll(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(SemaphoreAccessRule)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Regras de controlo com o mesmo utilizador de acesso de procura para todos os e <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> (permitir ou negar) especificado como regra e, se encontrar remove-los."
  remarks: "Atual <xref:System.Security.AccessControl.SemaphoreSecurity>objeto será pesquisado as regras que têm o mesmo utilizador e o mesmo <xref:System.Security.AccessControl.AccessControlType>valor como `rule`.</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.SemaphoreSecurity> Quaisquer direitos especificados por `rule` são ignoradas quando efetuar esta pesquisa. Se não for encontradas nenhuma regras de correspondência, não é necessária nenhuma ação."
  example:
  - "The following code example shows that the RemoveAccessRuleAll method removes all rules that match user and <xref:System.Security.AccessControl.AccessControlType>, ignoring rights.  \n  \n The example creates a <xref:System.Security.AccessControl.SemaphoreSecurity> object, adds rules that allow and deny various rights for the current user, and then merges additional rights into the <xref:System.Security.AccessControl.AccessControlType> rule. The example then creates a new rule that allows the current user to take ownership, and uses that rule to remove the <xref:System.Security.AccessControl.AccessControlType> rule from the <xref:System.Security.AccessControl.SemaphoreSecurity> object.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:System.Threading.Semaphore> object. Examples that attach security objects can be found in <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=fullName> and <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-vb[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll#1](~/add/codesnippet/visualbasic/0b2e6ab3-65bc-4eea-922e-_1.vb)]\n [!code-cs[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll#1](~/add/codesnippet/csharp/0b2e6ab3-65bc-4eea-922e-_1.cs)]"
  syntax:
    content: public void RemoveAccessRuleAll (System.Security.AccessControl.SemaphoreAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.SemaphoreAccessRule
      description: "A <xref href=&quot;System.Security.AccessControl.SemaphoreAccessRule&quot;> </xref> Especifica que o utilizador e <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> para procurar. Quaisquer direitos especificados por esta regra são ignorados."
  overload: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule)
  id: RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: RemoveAccessRuleSpecific(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.RemoveAccessRuleSpecific(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(SemaphoreAccessRule)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Procura de uma regra de controlo de acesso que corresponde exatamente a especificado regra e, se encontrar remove-lo."
  remarks: "A regra é removida apenas se corresponde exatamente `rule` em todos os detalhes, incluindo sinalizadores. Outras regras com o mesmo utilizador e <xref:System.Security.AccessControl.AccessControlType>não são afetadas.</xref:System.Security.AccessControl.AccessControlType>      > [!IMPORTANT] > Uma regra representa uma ou mais subjacente controlo entradas de acesso (ACE), e estas entradas são dividir ou combinadas, conforme necessário, ao modificar as regras de segurança de acesso para um utilizador. Assim, uma regra já não pode existir no formato específico tinha quando foi adicionado e, caso em que o método RemoveAccessRuleSpecific o não é possível removê-lo."
  example:
  - "The following code example shows that the RemoveAccessRuleSpecific method requires an exact match in order to remove a rule, and that rules to allow and deny rights are independent of each other.  \n  \n The example creates a <xref:System.Security.AccessControl.SemaphoreSecurity> object, adds rules that allow and deny various rights for the current user, and then merges additional rights into the <xref:System.Security.AccessControl.AccessControlType> access rule. The example then passes the original <xref:System.Security.AccessControl.AccessControlType> rule to the RemoveAccessRuleSpecific method, and displays the results, showing that nothing is deleted. The example then constructs a rule that matches the <xref:System.Security.AccessControl.AccessControlType> rule in the <xref:System.Security.AccessControl.SemaphoreSecurity> object, and successfully uses the RemoveAccessRuleSpecific method to remove the rule.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:System.Threading.Semaphore> object. Examples that attach security objects can be found in <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=fullName> and <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-vb[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific#1](~/add/codesnippet/visualbasic/0797aedd-e0bb-444b-b25e-_1.vb)]\n [!code-cs[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific#1](~/add/codesnippet/csharp/0797aedd-e0bb-444b-b25e-_1.cs)]"
  syntax:
    content: public void RemoveAccessRuleSpecific (System.Security.AccessControl.SemaphoreAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.SemaphoreAccessRule
      description: "O <xref href=&quot;System.Security.AccessControl.SemaphoreAccessRule&quot;> </xref> para remover."
  overload: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  id: RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: RemoveAuditRule(SemaphoreAuditRule)
  nameWithType: SemaphoreSecurity.RemoveAuditRule(SemaphoreAuditRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(SemaphoreAuditRule)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Procura uma regra de controlo de auditoria com o mesmo utilizador a regra especificado e com compatível herança e sinalizadores de propagação; Se for encontrada uma regra compatível, os direitos contidos na regra especificada são removidos do mesmo."
  remarks: "Atual <xref:System.Security.AccessControl.SemaphoreSecurity>é procurada uma regra de auditoria que tem o mesmo utilizador `rule`.</xref:System.Security.AccessControl.SemaphoreSecurity> Se nenhuma regra tal for encontrada, foi efetuada nenhuma ação e o método devolve `false`. Se forem encontradas regras de correspondência, os sinalizadores de herança e de compatibilidade são verificados para compatibilidade com os sinalizadores especificados na `rule`. Não se for encontrada nenhuma regra compatível, foi efetuada nenhuma ação e o método devolve `false`. Se for encontrada qualquer regra com sinalizadores compatíveis, os direitos especificados `rule` são removidas da regra compatível, e o método devolve `true`. Se `rule` especifica direitos não contidos na regra compatível, foi efetuada nenhuma ação no que respeita a esses direitos. Se todos os direitos são removidos da regra compatível, a regra completa é removida do atual <xref:System.Security.AccessControl.SemaphoreSecurity>objeto.</xref:System.Security.AccessControl.SemaphoreSecurity>      > [!IMPORTANT] > Embora possa especificar sinalizadores de herança e propagação para as regras de auditoria do semáforo, criando-los com o <xref:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory%2A>método, isto não é recomendado.</xref:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory%2A> Herança e propagação não tem nenhum significado para semaphores nomeados e efetuam a manutenção das regras de auditoria mais complicada."
  syntax:
    content: public bool RemoveAuditRule (System.Security.AccessControl.SemaphoreAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.SemaphoreAuditRule
      description: "A <xref href=&quot;System.Security.AccessControl.SemaphoreAuditRule&quot;> </xref> Especifica que o utilizador para procurar e um conjunto de sinalizadores de herança e propagação de que a regra uma correspondência, se encontrar, tem de ser compatível com. Especifica os direitos para remover a regra compatível, se encontrar."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se for encontrada uma regra compatível; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll(System.Security.AccessControl.SemaphoreAuditRule)
  id: RemoveAuditRuleAll(System.Security.AccessControl.SemaphoreAuditRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: RemoveAuditRuleAll(SemaphoreAuditRule)
  nameWithType: SemaphoreSecurity.RemoveAuditRuleAll(SemaphoreAuditRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll(SemaphoreAuditRule)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Pesquisa para todas as regras com o mesmo utilizador a regra especificada de auditoria e, se encontrar, remove-os."
  remarks: "Atual <xref:System.Security.AccessControl.SemaphoreSecurity>serão pesquisadas as regras de auditoria que têm o mesmo utilizador `rule`.</xref:System.Security.AccessControl.SemaphoreSecurity> Quaisquer direitos especificados por `rule` são ignoradas quando efetuar esta pesquisa. Todas as regras de correspondência são removidas. Se não for encontradas nenhuma regras de correspondência, não é necessária nenhuma ação."
  syntax:
    content: public void RemoveAuditRuleAll (System.Security.AccessControl.SemaphoreAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.SemaphoreAuditRule
      description: "A <xref href=&quot;System.Security.AccessControl.SemaphoreAuditRule&quot;> </xref> Especifica que o utilizador para procurar. Quaisquer direitos especificados por esta regra são ignorados."
  overload: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.SemaphoreAuditRule)
  id: RemoveAuditRuleSpecific(System.Security.AccessControl.SemaphoreAuditRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: RemoveAuditRuleSpecific(SemaphoreAuditRule)
  nameWithType: SemaphoreSecurity.RemoveAuditRuleSpecific(SemaphoreAuditRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific(SemaphoreAuditRule)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Procura de uma regra de auditoria que corresponde exatamente ao especificado regra e, se encontrar remove-lo."
  remarks: "A regra é removida apenas se corresponde exatamente `rule` em todos os detalhes, incluindo sinalizadores. Não são afetadas outras regras de auditoria para o mesmo utilizador.      > [!IMPORTANT] > Uma regra representa uma ou mais subjacente controlo entradas de acesso (ACE), e estas entradas são dividir ou combinadas, conforme necessário, ao modificar as regras de segurança de auditoria para um utilizador. Assim, uma regra já não pode existir no formato específico tinha quando foi adicionado e, caso em que o método RemoveAuditRuleSpecific o não é possível removê-lo."
  syntax:
    content: public void RemoveAuditRuleSpecific (System.Security.AccessControl.SemaphoreAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.SemaphoreAuditRule
      description: "O <xref href=&quot;System.Security.AccessControl.SemaphoreAuditRule&quot;> </xref> para remover."
  overload: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  id: ResetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: ResetAccessRule(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.ResetAccessRule(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule(SemaphoreAccessRule)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Remove todas as regras de controlo de acesso com o mesmo utilizador regra especificada, independentemente da <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref>e, em seguida, adiciona a regra especificada."
  remarks: "Se existem quaisquer regras de acesso cujo utilizador corresponde à regra de especificado, `rule` é adicionado."
  example:
  - "The following code example shows how the ResetAccessRule method replaces all rules for the matching user with the rule specified for the match.  \n  \n The example creates a <xref:System.Security.AccessControl.SemaphoreSecurity> object and adds rules that allow and deny various rights for the current user. The example then creates a new rule that allows the current user full control, and uses the ResetAccessRule method to replace both of the existing rules with the new rule.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:System.Threading.Semaphore> object. Examples that attach security objects can be found in <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=fullName> and <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-cs[System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule#1](~/add/codesnippet/csharp/950b9d2b-d0bb-443e-8790-_1.cs)]\n [!code-vb[System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule#1](~/add/codesnippet/visualbasic/950b9d2b-d0bb-443e-8790-_1.vb)]"
  syntax:
    content: public void ResetAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.SemaphoreAccessRule
      description: "The <xref href=&quot;System.Security.AccessControl.SemaphoreAccessRule&quot;></xref> to add. O utilizador especificado por esta regra determina as regras para remover antes de é adicionada esta regra."
  overload: System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  id: SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: SetAccessRule(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.SetAccessRule(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(SemaphoreAccessRule)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Remove todas as regras de controlo de acesso com o mesmo utilizador e <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> (permitir ou negar) como a regra especificada e, em seguida, adiciona a regra especificada."
  remarks: "Se a regra especificada tem <xref:System.Security.AccessControl.AccessControlType>, o efeito deste método é remover todas as <xref:System.Security.AccessControl.AccessControlType>regras para o utilizador especificado, substituindo-las com a regra especificada.</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.AccessControlType> Se a regra especificada tem <xref:System.Security.AccessControl.AccessControlType>, todos os <xref:System.Security.AccessControl.AccessControlType>regras para o utilizador especificado são substituídas com a regra especificada.</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.AccessControlType>       Se existem quaisquer regras cujo utilizador e <xref:System.Security.AccessControl.AccessControlType>corresponde à regra especificada, `rule` é adicionado.</xref:System.Security.AccessControl.AccessControlType>"
  example:
  - "The following code example shows how the SetAccessRule method removes all rules that match both the user and the <xref:System.Security.AccessControl.AccessControlType> of `rule`, replacing them with `rule`.  \n  \n The example creates a <xref:System.Security.AccessControl.SemaphoreSecurity> object and adds rules that allow and deny various rights for the current user. The example then creates a new rule that allows the current user full control, and uses the SetAccessRule method to replace the existing Allow rule with the new rule. The rule that denies access is not affected.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:System.Threading.Semaphore> object. Examples that attach security objects can be found in <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=fullName> and <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-vb[System.Security.AccessControl.SemaphoreSecurity.SetAccessRule#1](~/add/codesnippet/visualbasic/8a133971-d359-43dd-87ab-_1.vb)]\n [!code-cs[System.Security.AccessControl.SemaphoreSecurity.SetAccessRule#1](~/add/codesnippet/csharp/8a133971-d359-43dd-87ab-_1.cs)]"
  syntax:
    content: public void SetAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.SemaphoreAccessRule
      description: "The <xref href=&quot;System.Security.AccessControl.SemaphoreAccessRule&quot;></xref> to add. O utilizador e <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> desta regra determinar as regras para remover antes de é adicionada esta regra."
  overload: System.Security.AccessControl.SemaphoreSecurity.SetAccessRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.SetAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  id: SetAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: SetAuditRule(SemaphoreAuditRule)
  nameWithType: SemaphoreSecurity.SetAuditRule(SemaphoreAuditRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.SetAuditRule(SemaphoreAuditRule)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Remove todas as regras com o mesmo utilizador regra especificada, de auditoria, independentemente do <xref href=&quot;System.Security.AccessControl.AuditFlags&quot;> </xref> valor e, em seguida, adiciona a regra especificada."
  remarks: "Se existem quaisquer regras de auditoria cujo utilizador corresponde à regra de especificado, `rule` é adicionado."
  syntax:
    content: public void SetAuditRule (System.Security.AccessControl.SemaphoreAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.SemaphoreAuditRule
      description: "The <xref href=&quot;System.Security.AccessControl.SemaphoreAuditRule&quot;></xref> to add. O utilizador especificado por esta regra determina as regras para remover antes de é adicionada esta regra."
  overload: System.Security.AccessControl.SemaphoreSecurity.SetAuditRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
references:
- uid: System.Security.AccessControl.NativeObjectSecurity
  isExternal: false
  name: System.Security.AccessControl.NativeObjectSecurity
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Security.AccessControl.SemaphoreSecurity.#ctor
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: SemaphoreSecurity()
  nameWithType: SemaphoreSecurity.SemaphoreSecurity()
  fullName: System.Security.AccessControl.SemaphoreSecurity.SemaphoreSecurity()
- uid: System.Security.AccessControl.SemaphoreSecurity.#ctor(System.String,System.Security.AccessControl.AccessControlSections)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: SemaphoreSecurity(String,AccessControlSections)
  nameWithType: SemaphoreSecurity.SemaphoreSecurity(String,AccessControlSections)
  fullName: System.Security.AccessControl.SemaphoreSecurity.SemaphoreSecurity(String,AccessControlSections)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Security.AccessControl.AccessControlSections
  parent: System.Security.AccessControl
  isExternal: false
  name: AccessControlSections
  nameWithType: AccessControlSections
  fullName: System.Security.AccessControl.AccessControlSections
- uid: System.Security.AccessControl.SemaphoreSecurity.AccessRightType
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AccessRightType
  nameWithType: SemaphoreSecurity.AccessRightType
  fullName: System.Security.AccessControl.SemaphoreSecurity.AccessRightType
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  nameWithType: SemaphoreSecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  fullName: System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
- uid: System.Security.AccessControl.AccessRule
  parent: System.Security.AccessControl
  isExternal: false
  name: AccessRule
  nameWithType: AccessRule
  fullName: System.Security.AccessControl.AccessRule
- uid: System.Security.Principal.IdentityReference
  parent: System.Security.Principal
  isExternal: false
  name: IdentityReference
  nameWithType: IdentityReference
  fullName: System.Security.Principal.IdentityReference
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Security.AccessControl.InheritanceFlags
  parent: System.Security.AccessControl
  isExternal: false
  name: InheritanceFlags
  nameWithType: InheritanceFlags
  fullName: System.Security.AccessControl.InheritanceFlags
- uid: System.Security.AccessControl.PropagationFlags
  parent: System.Security.AccessControl
  isExternal: false
  name: PropagationFlags
  nameWithType: PropagationFlags
  fullName: System.Security.AccessControl.PropagationFlags
- uid: System.Security.AccessControl.AccessControlType
  parent: System.Security.AccessControl
  isExternal: false
  name: AccessControlType
  nameWithType: AccessControlType
  fullName: System.Security.AccessControl.AccessControlType
- uid: System.Security.AccessControl.SemaphoreSecurity.AccessRuleType
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AccessRuleType
  nameWithType: SemaphoreSecurity.AccessRuleType
  fullName: System.Security.AccessControl.SemaphoreSecurity.AccessRuleType
- uid: System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AddAccessRule(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.AddAccessRule(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(SemaphoreAccessRule)
- uid: System.Security.AccessControl.SemaphoreAccessRule
  parent: System.Security.AccessControl
  isExternal: false
  name: SemaphoreAccessRule
  nameWithType: SemaphoreAccessRule
  fullName: System.Security.AccessControl.SemaphoreAccessRule
- uid: System.Security.AccessControl.SemaphoreSecurity.AddAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AddAuditRule(SemaphoreAuditRule)
  nameWithType: SemaphoreSecurity.AddAuditRule(SemaphoreAuditRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.AddAuditRule(SemaphoreAuditRule)
- uid: System.Security.AccessControl.SemaphoreAuditRule
  parent: System.Security.AccessControl
  isExternal: false
  name: SemaphoreAuditRule
  nameWithType: SemaphoreAuditRule
  fullName: System.Security.AccessControl.SemaphoreAuditRule
- uid: System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  nameWithType: SemaphoreSecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  fullName: System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
- uid: System.Security.AccessControl.AuditRule
  parent: System.Security.AccessControl
  isExternal: false
  name: AuditRule
  nameWithType: AuditRule
  fullName: System.Security.AccessControl.AuditRule
- uid: System.Security.AccessControl.AuditFlags
  parent: System.Security.AccessControl
  isExternal: false
  name: AuditFlags
  nameWithType: AuditFlags
  fullName: System.Security.AccessControl.AuditFlags
- uid: System.Security.AccessControl.SemaphoreSecurity.AuditRuleType
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AuditRuleType
  nameWithType: SemaphoreSecurity.AuditRuleType
  fullName: System.Security.AccessControl.SemaphoreSecurity.AuditRuleType
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAccessRule(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.RemoveAccessRule(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(SemaphoreAccessRule)
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAccessRuleAll(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.RemoveAccessRuleAll(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(SemaphoreAccessRule)
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAccessRuleSpecific(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.RemoveAccessRuleSpecific(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(SemaphoreAccessRule)
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAuditRule(SemaphoreAuditRule)
  nameWithType: SemaphoreSecurity.RemoveAuditRule(SemaphoreAuditRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(SemaphoreAuditRule)
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll(System.Security.AccessControl.SemaphoreAuditRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAuditRuleAll(SemaphoreAuditRule)
  nameWithType: SemaphoreSecurity.RemoveAuditRuleAll(SemaphoreAuditRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll(SemaphoreAuditRule)
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.SemaphoreAuditRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAuditRuleSpecific(SemaphoreAuditRule)
  nameWithType: SemaphoreSecurity.RemoveAuditRuleSpecific(SemaphoreAuditRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific(SemaphoreAuditRule)
- uid: System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: ResetAccessRule(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.ResetAccessRule(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule(SemaphoreAccessRule)
- uid: System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: SetAccessRule(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.SetAccessRule(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(SemaphoreAccessRule)
- uid: System.Security.AccessControl.SemaphoreSecurity.SetAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: SetAuditRule(SemaphoreAuditRule)
  nameWithType: SemaphoreSecurity.SetAuditRule(SemaphoreAuditRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.SetAuditRule(SemaphoreAuditRule)
- uid: System.Security.AccessControl.SemaphoreSecurity.#ctor*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: SemaphoreSecurity
  nameWithType: SemaphoreSecurity.SemaphoreSecurity
- uid: System.Security.AccessControl.SemaphoreSecurity.AccessRightType*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AccessRightType
  nameWithType: SemaphoreSecurity.AccessRightType
- uid: System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AccessRuleFactory
  nameWithType: SemaphoreSecurity.AccessRuleFactory
- uid: System.Security.AccessControl.SemaphoreSecurity.AccessRuleType*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AccessRuleType
  nameWithType: SemaphoreSecurity.AccessRuleType
- uid: System.Security.AccessControl.SemaphoreSecurity.AddAccessRule*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AddAccessRule
  nameWithType: SemaphoreSecurity.AddAccessRule
- uid: System.Security.AccessControl.SemaphoreSecurity.AddAuditRule*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AddAuditRule
  nameWithType: SemaphoreSecurity.AddAuditRule
- uid: System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AuditRuleFactory
  nameWithType: SemaphoreSecurity.AuditRuleFactory
- uid: System.Security.AccessControl.SemaphoreSecurity.AuditRuleType*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AuditRuleType
  nameWithType: SemaphoreSecurity.AuditRuleType
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAccessRule
  nameWithType: SemaphoreSecurity.RemoveAccessRule
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAccessRuleAll
  nameWithType: SemaphoreSecurity.RemoveAccessRuleAll
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAccessRuleSpecific
  nameWithType: SemaphoreSecurity.RemoveAccessRuleSpecific
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAuditRule
  nameWithType: SemaphoreSecurity.RemoveAuditRule
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAuditRuleAll
  nameWithType: SemaphoreSecurity.RemoveAuditRuleAll
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAuditRuleSpecific
  nameWithType: SemaphoreSecurity.RemoveAuditRuleSpecific
- uid: System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: ResetAccessRule
  nameWithType: SemaphoreSecurity.ResetAccessRule
- uid: System.Security.AccessControl.SemaphoreSecurity.SetAccessRule*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: SetAccessRule
  nameWithType: SemaphoreSecurity.SetAccessRule
- uid: System.Security.AccessControl.SemaphoreSecurity.SetAuditRule*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: SetAuditRule
  nameWithType: SemaphoreSecurity.SetAuditRule
