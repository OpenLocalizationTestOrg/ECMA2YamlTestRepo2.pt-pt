### YamlMime:ManagedReference
items:
- uid: System.Windows.Threading.Dispatcher
  id: Dispatcher
  children:
  - System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Object[])
  - System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  - System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  - System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  - System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  - System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)
  - System.Windows.Threading.Dispatcher.CheckAccess
  - System.Windows.Threading.Dispatcher.CurrentDispatcher
  - System.Windows.Threading.Dispatcher.DisableProcessing
  - System.Windows.Threading.Dispatcher.ExitAllFrames
  - System.Windows.Threading.Dispatcher.FromThread(System.Threading.Thread)
  - System.Windows.Threading.Dispatcher.HasShutdownFinished
  - System.Windows.Threading.Dispatcher.HasShutdownStarted
  - System.Windows.Threading.Dispatcher.Hooks
  - System.Windows.Threading.Dispatcher.Invoke(System.Action)
  - System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority)
  - System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  - System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  - System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)
  - System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  - System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0})
  - System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  - System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  - System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  - System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)
  - System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)
  - System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  - System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})
  - System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  - System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  - System.Windows.Threading.Dispatcher.InvokeShutdown
  - System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)
  - System.Windows.Threading.Dispatcher.Run
  - System.Windows.Threading.Dispatcher.ShutdownFinished
  - System.Windows.Threading.Dispatcher.ShutdownStarted
  - System.Windows.Threading.Dispatcher.Thread
  - System.Windows.Threading.Dispatcher.UnhandledException
  - System.Windows.Threading.Dispatcher.UnhandledExceptionFilter
  - System.Windows.Threading.Dispatcher.ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)
  - System.Windows.Threading.Dispatcher.VerifyAccess
  - System.Windows.Threading.Dispatcher.Yield
  - System.Windows.Threading.Dispatcher.Yield(System.Windows.Threading.DispatcherPriority)
  langs:
  - csharp
  name: Dispatcher
  nameWithType: Dispatcher
  fullName: System.Windows.Threading.Dispatcher
  type: Class
  summary: "Fornece serviços para gerir a fila de itens de trabalho de um thread."
  remarks: "O Dispatcher mantém uma fila prioritários de itens de trabalho de um thread específico.       Quando um distribuidor é criado num thread, torna-se o distribuidor apenas que pode ser associado ao thread, mesmo que o emissor foi encerrado.       Se tentar obter o <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>para o thread actual e um distribuidor não está associado o thread, será criado um Dispatcher.</xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> Um distribuidor também é criado quando cria um <xref:System.Windows.Threading.DispatcherObject>.</xref:System.Windows.Threading.DispatcherObject> Se criar um distribuidor no thread de segundo plano, não se esqueça de encerrar o distribuidor antes de sair do thread.       Se um distribuidor está a ser encerrado, não podendo ser reiniciada.       No [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], um <xref:System.Windows.Threading.DispatcherObject>só pode ser acedido pelo emissor que está associada.</xref:System.Windows.Threading.DispatcherObject>  Por exemplo, um thread de segundo plano não é possível atualizar o conteúdo de um <xref:System.Windows.Controls.Button>que se encontra associado o Dispatcher no [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] thread.</xref:System.Windows.Controls.Button>  Para que o thread de segundo plano aceder a <xref:System.Windows.Controls.ContentControl.Content%2A>propriedade o <xref:System.Windows.Controls.Button>, o thread de segundo plano deve delegar o trabalho para o emissor associado a [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] thread.</xref:System.Windows.Controls.Button> </xref:System.Windows.Controls.ContentControl.Content%2A>  Isto é conseguido através da utilização de um <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é síncrona e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  A operação é adicionada à fila de emissor em <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> especificado       Se <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>denomina-se num distribuidor que foi encerrado, a propriedade de estado de devolvido <xref:System.Windows.Threading.DispatcherOperation>está definido como <xref:System.Windows.Threading.DispatcherOperationStatus>.</xref:System.Windows.Threading.DispatcherOperationStatus> </xref:System.Windows.Threading.DispatcherOperation> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       Todos os métodos no distribuidor, com exceção do <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, são free-threaded.</xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>       Objetos que derivem de <xref:System.Windows.Threading.DispatcherObject>têm afinidade de threads.</xref:System.Windows.Threading.DispatcherObject>       Objetos que derivem de <xref:System.Windows.Freezable>são free-threaded quando estes são interrompidas.</xref:System.Windows.Freezable>  Para obter mais informações, consulte [descrição geral de objetos Freezable](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example shows how to place an operation onto a Dispatcher.  For the full source code of this example, see [Single-Threaded Application with Long-Running Calculation Sample](http://go.microsoft.com/fwlink/?LinkID=160038).  \n  \n First, a delegate is created that accepts no arguments.  \n  \n [!code-vb[ThreadingPrimeNumber#ThreadingPrimeNumberInit](~/add/codesnippet/visualbasic/t-system.windows.threadi_2_1.vb)]\n [!code-cs[ThreadingPrimeNumber#ThreadingPrimeNumberInit](~/add/codesnippet/csharp/t-system.windows.threadi_2_1.cs)]  \n  \n Next, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> is called.  This call to <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> takes two parameters: the priority, which is set to <xref:System.Windows.Threading.DispatcherPriority?displayProperty=fullName>, and the callback, which is passed in through an instance of the delegate `NextPrimeDelegate`.  \n  \n [!code-vb[ThreadingPrimeNumber#ThreadingPrimeNumberBeingInvoke](~/add/codesnippet/visualbasic/t-system.windows.threadi_2_2.vb)]\n [!code-cs[ThreadingPrimeNumber#ThreadingPrimeNumberBeingInvoke](~/add/codesnippet/csharp/t-system.windows.threadi_2_2.cs)]"
  syntax:
    content: public sealed class Dispatcher
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Object[])
  id: BeginInvoke(System.Delegate,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvoke(Delegate,Object[])
  nameWithType: Dispatcher.BeginInvoke(Delegate,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(Delegate,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa o delegado especificado no modo assíncrono com os argumentos especificados no thread que o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> foi criado."
  remarks: "O <xref:System.Windows.Threading.DispatcherOperation>objecto devolvido por <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>pode ser utilizado em várias formas para interagir com o delegado especificado, tais como: - alteração o <xref:System.Windows.Threading.DispatcherPriority>do delegado porque está pendente execução de eventos da fila.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.DispatcherOperation>      -Remover o delegado de fila de eventos.      -A aguardar que o delegado devolver.      -Obter o valor que o delegado devolve após-é executado.       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona; Por conseguinte, controlo devolve imediatamente para o objeto de chamar após é chamado.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       No [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], apenas o thread que criou um <xref:System.Windows.Threading.DispatcherObject>pode aceder a esse objeto.</xref:System.Windows.Threading.DispatcherObject> Por exemplo, um thread de segundo plano é puserem do thread de IU principal não é possível atualizar o conteúdo de um <xref:System.Windows.Controls.Button>que foi criado num thread de IU.</xref:System.Windows.Controls.Button> Para que o thread de segundo plano aceder a propriedade de conteúdo a <xref:System.Windows.Controls.Button>, o thread de segundo plano deve delegar o trabalho para o <xref:System.Windows.Threading.Dispatcher>associada ao thread da IU.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> Isto é conseguido através da utilização de um <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é síncrona e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> A operação é adicionada à fila de eventos <xref:System.Windows.Threading.Dispatcher>em <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> especificado</xref:System.Windows.Threading.Dispatcher>       Se <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é chamado um <xref:System.Windows.Threading.Dispatcher>que foi encerrado, a propriedade de estado de devolvido <xref:System.Windows.Threading.DispatcherOperation>está definido como <xref:System.Windows.Threading.DispatcherOperationStatus>.</xref:System.Windows.Threading.DispatcherOperationStatus> </xref:System.Windows.Threading.DispatcherOperation> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation BeginInvoke (Delegate method, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "O delegado para um método que utiliza os parâmetros especificados na `args`, que é feita pelo <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos."
    - id: args
      type: System.Object[]
      description: "Uma matriz de objetos para passar como argumentos para o método especificado. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "Um objeto, que é devolvido imediatamente após <xref:System.Windows.Threading.Dispatcher.BeginInvoke*>denomina-se, que pode ser utilizado para interagir com o delegado como está pendente de execução de eventos fila.</xref:System.Windows.Threading.Dispatcher.BeginInvoke*>"
  overload: System.Windows.Threading.Dispatcher.BeginInvoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  id: BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvoke(DispatcherPriority,Delegate)
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate)
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa o delegado especificado no modo assíncrono com a prioridade especificado no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado."
  remarks: "Se várias chamadas de BeginInvoke são efetuadas em simultâneo <xref:System.Windows.Threading.DispatcherPriority>, estes serão executados pela ordem as chamadas efetuadas.</xref:System.Windows.Threading.DispatcherPriority>       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>Devolve um <xref:System.Windows.Threading.DispatcherOperation>objeto que pode ser utilizado para interagir com o delegado quando o delegado de eventos é a fila.</xref:System.Windows.Threading.DispatcherOperation></xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       O <xref:System.Windows.Threading.DispatcherOperation>objecto devolvido por <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>pode ser utilizado em várias formas para interagir com o delegado especificado, tais como: - alteração o <xref:System.Windows.Threading.DispatcherPriority>do delegado porque está pendente execução de eventos da fila.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.DispatcherOperation>      -Remover o delegado de fila de eventos.      -A aguardar que o delegado devolver.      -Obter o valor que o delegado devolve após-é executado.       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona; Por conseguinte, controlo devolve imediatamente para o objeto de chamar após é chamado.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       No [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], apenas o thread que criou um <xref:System.Windows.Threading.DispatcherObject>pode aceder a esse objeto.</xref:System.Windows.Threading.DispatcherObject>  Por exemplo, um thread de segundo plano é puserem do thread de IU principal não é possível atualizar o conteúdo de um <xref:System.Windows.Controls.Button>que foi criado num thread de IU.</xref:System.Windows.Controls.Button>  Para que o thread de segundo plano aceder a propriedade de conteúdo a <xref:System.Windows.Controls.Button>, o thread de segundo plano deve delegar o trabalho para o <xref:System.Windows.Threading.Dispatcher>associada ao thread da IU.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Isto é conseguido através da utilização de um <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é síncrona e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  A operação é adicionada à fila de eventos <xref:System.Windows.Threading.Dispatcher>em <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> especificado</xref:System.Windows.Threading.Dispatcher>       Se <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é chamado um <xref:System.Windows.Threading.Dispatcher>que foi encerrado, a propriedade de estado de devolvido <xref:System.Windows.Threading.DispatcherOperation>está definido como <xref:System.Windows.Threading.DispatcherOperationStatus>.</xref:System.Windows.Threading.DispatcherOperationStatus> </xref:System.Windows.Threading.DispatcherOperation> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>"
  example:
  - "The following example shows how to place an operation onto a <xref:System.Windows.Threading.Dispatcher>.  For the full source code of this example, see [Single-Threaded Application with Long-Running Calculation Sample](http://go.microsoft.com/fwlink/?LinkID=160038).  \n  \n First, a delegate is created that accepts no arguments.  \n  \n [!code-vb[ThreadingPrimeNumber#ThreadingPrimeNumberInit](~/add/codesnippet/visualbasic/8c08cb62-5b5f-4560-a7bd-_1.vb)]\n [!code-cs[ThreadingPrimeNumber#ThreadingPrimeNumberInit](~/add/codesnippet/csharp/8c08cb62-5b5f-4560-a7bd-_1.cs)]  \n  \n Next, BeginInvoke is called.  Because every <xref:System.Windows.Threading.DispatcherObject> has a property that returns the <xref:System.Windows.Threading.Dispatcher> it is associated with, the desired <xref:System.Windows.Threading.Dispatcher> is obtained by querying the <xref:System.Windows.Threading.DispatcherObject>, in this case a <xref:System.Windows.Controls.Button> named `startStopButton`.   The call to BeginInvoke takes two parameters: the priority, which is set to <xref:System.Windows.Threading.DispatcherPriority?displayProperty=fullName>, and the callback, which is passed in through an instance of the delegate `NextPrimeDelegate`.  \n  \n [!code-vb[ThreadingPrimeNumber#ThreadingPrimeNumberBeingInvoke](~/add/codesnippet/visualbasic/8c08cb62-5b5f-4560-a7bd-_2.vb)]\n [!code-cs[ThreadingPrimeNumber#ThreadingPrimeNumberBeingInvoke](~/add/codesnippet/csharp/8c08cb62-5b5f-4560-a7bd-_2.cs)]"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade, relativo às outras operações no pendentes a <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos, o método especificado é invocada."
    - id: method
      type: System.Delegate
      description: "O delegado para um método que não necessita de nenhum argumentos, que é feita pelo <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "Um objeto, que é devolvido imediatamente após <xref:System.Windows.Threading.Dispatcher.BeginInvoke*>denomina-se, que pode ser utilizado para interagir com o delegado como está pendente de execução de eventos fila.</xref:System.Windows.Threading.Dispatcher.BeginInvoke*>"
  overload: System.Windows.Threading.Dispatcher.BeginInvoke*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>Não é um <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  id: BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvoke(Delegate,DispatcherPriority,Object[])
  nameWithType: Dispatcher.BeginInvoke(Delegate,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(Delegate,DispatcherPriority,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa o delegado especificado no modo assíncrono com os argumentos especificados, com a prioridade especificada, no thread que o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> foi criado."
  remarks: "O <xref:System.Windows.Threading.DispatcherOperation>objecto devolvido por <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>pode ser utilizado em várias formas para interagir com o delegado especificado, tais como: - alteração o <xref:System.Windows.Threading.DispatcherPriority>do delegado porque está pendente execução de eventos da fila.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.DispatcherOperation>      -Remover o delegado de fila de eventos.      -A aguardar que o delegado devolver.      -Obter o valor que o delegado devolve após-é executado.       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona; Por conseguinte, controlo devolve imediatamente para o objeto de chamar após é chamado.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       No [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], apenas o thread que criou um <xref:System.Windows.Threading.DispatcherObject>pode aceder a esse objeto.</xref:System.Windows.Threading.DispatcherObject> Por exemplo, um thread de segundo plano é puserem do thread de IU principal não é possível atualizar o conteúdo de um <xref:System.Windows.Controls.Button>que foi criado num thread de IU.</xref:System.Windows.Controls.Button> Para que o thread de segundo plano aceder a propriedade de conteúdo a <xref:System.Windows.Controls.Button>, o thread de segundo plano deve delegar o trabalho para o <xref:System.Windows.Threading.Dispatcher>associada ao thread da IU.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> Isto é conseguido através da utilização de um <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é síncrona e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> A operação é adicionada à fila de eventos <xref:System.Windows.Threading.Dispatcher>em <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> especificado</xref:System.Windows.Threading.Dispatcher>       Se <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é chamado um <xref:System.Windows.Threading.Dispatcher>que foi encerrado, a propriedade de estado de devolvido <xref:System.Windows.Threading.DispatcherOperation>está definido como <xref:System.Windows.Threading.DispatcherOperationStatus>.</xref:System.Windows.Threading.DispatcherOperationStatus> </xref:System.Windows.Threading.DispatcherOperation> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation BeginInvoke (Delegate method, System.Windows.Threading.DispatcherPriority priority, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "O delegado para um método que utiliza os parâmetros especificados na `args`, que é feita pelo <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade, relativo às outras operações no pendentes a <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos, o método especificado é invocada."
    - id: args
      type: System.Object[]
      description: "Uma matriz de objetos para passar como argumentos para o método especificado. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "Um objeto, que é devolvido imediatamente após <xref:System.Windows.Threading.Dispatcher.BeginInvoke*>denomina-se, que pode ser utilizado para interagir com o delegado como está pendente de execução de eventos fila.</xref:System.Windows.Threading.Dispatcher.BeginInvoke*>"
  overload: System.Windows.Threading.Dispatcher.BeginInvoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  id: BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvoke(DispatcherPriority,Delegate,Object)
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa o delegado especificado de forma assíncrona com a prioridade especificada e com o argumento especificado no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado."
  remarks: "`Arg`pode ser `null` se forem necessárias sem argumentos.       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>Devolve um <xref:System.Windows.Threading.DispatcherOperation>objeto que pode ser utilizado para interagir com o delegado quando o delegado de eventos é a fila.</xref:System.Windows.Threading.DispatcherOperation></xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       O <xref:System.Windows.Threading.DispatcherOperation>objecto devolvido por <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>pode ser utilizado em várias formas para interagir com o delegado especificado, tais como: - alteração o <xref:System.Windows.Threading.DispatcherPriority>do delegado porque está pendente execução de eventos da fila.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.DispatcherOperation>      -Remover o delegado de fila de eventos.      -A aguardar que o delegado devolver.      -Obter o valor que o delegado devolve após-é executado.       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona; Por conseguinte, controlo devolve imediatamente para o objeto de chamar após é chamado.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       No [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], apenas o thread que criou um <xref:System.Windows.Threading.DispatcherObject>pode aceder a esse objeto.</xref:System.Windows.Threading.DispatcherObject>  Por exemplo, um thread de segundo plano é puserem do thread de IU principal não é possível atualizar o conteúdo de um <xref:System.Windows.Controls.Button>que foi criado num thread de IU.</xref:System.Windows.Controls.Button>  Para que o thread de segundo plano aceder a propriedade de conteúdo a <xref:System.Windows.Controls.Button>, o thread de segundo plano deve delegar o trabalho para o <xref:System.Windows.Threading.Dispatcher>associada ao thread da IU.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Isto é conseguido através da utilização de um <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é síncrona e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  A operação é adicionada à fila de eventos <xref:System.Windows.Threading.Dispatcher>em <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> especificado</xref:System.Windows.Threading.Dispatcher>       Se vários <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>as chamadas são efetuadas em simultâneo <xref:System.Windows.Threading.DispatcherPriority>, estes serão executados pela ordem as chamadas efetuadas.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       Se <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é chamado um <xref:System.Windows.Threading.Dispatcher>que foi encerrado, a propriedade de estado de devolvido <xref:System.Windows.Threading.DispatcherOperation>está definido como <xref:System.Windows.Threading.DispatcherOperationStatus>.</xref:System.Windows.Threading.DispatcherOperationStatus> </xref:System.Windows.Threading.DispatcherOperation> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>"
  example:
  - "The following example shows how to place an operation onto a <xref:System.Windows.Threading.Dispatcher>.  \n  \n First, a delegate is created that accepts one argument, in this case a string.  \n  \n [!code-vb[ThreadingWeatherForecast#ThreadingWeatherDelegates](~/add/codesnippet/visualbasic/threadingweatherforecastsample/window1.xaml.vb#threadingweatherdelegates)]\n [!code-cs[ThreadingWeatherForecast#ThreadingWeatherDelegates](~/add/codesnippet/csharp/ThreadingWeatherForecastSample/Window1.xaml.cs#threadingweatherdelegates)]  \n  \n Next, BeginInvoke is called.  Because every <xref:System.Windows.Threading.DispatcherObject> has a property that returns the <xref:System.Windows.Threading.Dispatcher> it is associated with, the desired <xref:System.Windows.Threading.Dispatcher> is obtained by querying the <xref:System.Windows.Threading.DispatcherObject>, in this case a <xref:System.Windows.Controls.Grid> named `tomorrowsWeather`. The call to BeginInvoke takes three parameters: the priority, which is set to <xref:System.Windows.Threading.DispatcherPriority?displayProperty=fullName>; the callback, which is passed in through an instance of the delegate `OneArgDelegate`; and a string named `weather`, which is the argument for the callback.  \n  \n [!code-vb[threadingweatherforecast#ThreadingWeatherDispatcherOneArge](~/add/codesnippet/visualbasic/threadingweatherforecastsample/window1.xaml.vb#threadingweatherdispatcheronearge)]\n [!code-cs[threadingweatherforecast#ThreadingWeatherDispatcherOneArge](~/add/codesnippet/csharp/ThreadingWeatherForecastSample/Window1.xaml.cs#threadingweatherdispatcheronearge)]"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade, relativo às outras operações no pendentes a <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos, o método especificado é invocada."
    - id: method
      type: System.Delegate
      description: "Um método que assume um argumento, o que é feito por um delegado a <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos."
    - id: arg
      type: System.Object
      description: "O objeto para passar como um argumento para o método especificado."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "Um objeto, que é devolvido imediatamente após <xref:System.Windows.Threading.Dispatcher.BeginInvoke*>denomina-se, que pode ser utilizado para interagir com o delegado como está pendente de execução de eventos fila.</xref:System.Windows.Threading.Dispatcher.BeginInvoke*>"
  overload: System.Windows.Threading.Dispatcher.BeginInvoke*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>Não é um <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  id: BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa o delegado especificado no modo assíncrono com a prioridade especificada e com a matriz de argumentos especificada no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado."
  remarks: "O `arg` parâmetro pode ser `null` se forem necessárias sem argumentos.       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>Devolve um <xref:System.Windows.Threading.DispatcherOperation>objeto que pode ser utilizado para interagir com o delegado quando o delegado de eventos é a fila.</xref:System.Windows.Threading.DispatcherOperation></xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       O <xref:System.Windows.Threading.DispatcherOperation>objecto devolvido por <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>pode ser utilizado em várias formas para interagir com o delegado especificado, tais como: - alteração o <xref:System.Windows.Threading.DispatcherPriority>do delegado porque está pendente execução de eventos da fila.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.DispatcherOperation>      -Remover o delegado de fila de eventos.      -A aguardar que o delegado devolver.      -Obter o valor que o delegado devolve após-é executado.       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona; Por conseguinte, controlo devolve imediatamente para o objeto de chamar após é chamado.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       No [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], apenas o thread que criou um <xref:System.Windows.Threading.DispatcherObject>pode aceder a esse objeto.</xref:System.Windows.Threading.DispatcherObject>  Por exemplo, um thread de segundo plano é puserem do thread de IU principal não é possível atualizar o conteúdo de um <xref:System.Windows.Controls.Button>que foi criado num thread de IU.</xref:System.Windows.Controls.Button>  Para que o thread de segundo plano aceder a propriedade de conteúdo a <xref:System.Windows.Controls.Button>, o thread de segundo plano deve delegar o trabalho para o <xref:System.Windows.Threading.Dispatcher>associada ao thread da IU.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Isto é conseguido através da utilização de um <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é síncrona e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  A operação é adicionada à fila de eventos <xref:System.Windows.Threading.Dispatcher>em <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> especificado</xref:System.Windows.Threading.Dispatcher>       Se vários <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>as chamadas são efetuadas em simultâneo <xref:System.Windows.Threading.DispatcherPriority>, estes serão executados pela ordem as chamadas efetuadas.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       Se <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é chamado um <xref:System.Windows.Threading.Dispatcher>que foi encerrado, a propriedade de estado de devolvido <xref:System.Windows.Threading.DispatcherOperation>está definido como <xref:System.Windows.Threading.DispatcherOperationStatus>.</xref:System.Windows.Threading.DispatcherOperationStatus> </xref:System.Windows.Threading.DispatcherOperation> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg, object[] args);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade, relativo às outras operações no pendentes a <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos, o método especificado é invocada."
    - id: method
      type: System.Delegate
      description: "Um delegado a um método que demora vários argumentos, que é feita pelo <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos."
    - id: arg
      type: System.Object
      description: "O objeto para passar como um argumento para o método especificado."
    - id: args
      type: System.Object[]
      description: "Uma matriz de objetos para passar como argumentos para o método especificado."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "Um objeto, que é devolvido imediatamente após <xref:System.Windows.Threading.Dispatcher.BeginInvoke*>denomina-se, que pode ser utilizado para interagir com o delegado como está pendente de execução no <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila.</xref:System.Windows.Threading.Dispatcher.BeginInvoke*>"
  overload: System.Windows.Threading.Dispatcher.BeginInvoke*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;></xref>Não é uma prioridade válida."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)
  id: BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvokeShutdown(DispatcherPriority)
  nameWithType: Dispatcher.BeginInvokeShutdown(DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.BeginInvokeShutdown(DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Inicia o encerramento do <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> no modo assíncrono."
  remarks: "BeginInvokeShutdown exige permissões de IU sem restrições.       Quando o <xref:System.Windows.Threading.Dispatcher>começa a encerrar o <xref:System.Windows.Threading.Dispatcher.ShutdownStarted>o evento é gerado e <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>está definido como `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownStarted> </xref:System.Windows.Threading.Dispatcher>       O <xref:System.Windows.Threading.Dispatcher>não será encerrado completamente até que a fila de eventos unwinds.</xref:System.Windows.Threading.Dispatcher>       Quando o distribuidor conclui a ser encerrado, o <xref:System.Windows.Threading.Dispatcher.ShutdownFinished>o evento é gerado e o <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>propriedade está definida como `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownFinished>       Depois de iniciar o processo de encerramento, todas as pendentes trabalho itens na fila foram abortadas."
  syntax:
    content: public void BeginInvokeShutdown (System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade no qual pretende começar a encerrar o dispatcher."
  overload: System.Windows.Threading.Dispatcher.BeginInvokeShutdown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.CheckAccess
  id: CheckAccess
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: CheckAccess()
  nameWithType: Dispatcher.CheckAccess()
  fullName: System.Windows.Threading.Dispatcher.CheckAccess()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Determina se o thread de chamada de thread associado a este <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
  remarks: "Apenas o <xref:System.Windows.Threading.Dispatcher>que um <xref:System.Windows.Threading.DispatcherObject>é criado no pode aceder ao objeto.</xref:System.Windows.Threading.DispatcherObject> </xref:System.Windows.Threading.Dispatcher>  Utilize <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>para aceder ao objeto a partir de um thread diferente.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>       CheckAccess pode ser chamado a partir de qualquer thread.       A diferença entre CheckAccess e <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A>é CheckAccess devolve um valor boleano que indica se o thread de chamada tem acesso para o <xref:System.Windows.Threading.Dispatcher>e <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A>emite uma exceção.</xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A>"
  example:
  - "The following example uses CheckAccess to determine whether a thread has access to a <xref:System.Windows.Controls.Button>.  The CheckAccess method on the <xref:System.Windows.Threading.Dispatcher> associated with the <xref:System.Windows.Controls.Button> is called to verify access to the thread.  If the calling thread has access to the <xref:System.Windows.Threading.Dispatcher>, the <xref:System.Windows.Controls.Button> is updated by accessing the members of the <xref:System.Windows.Controls.Button>; otherwise, a delegate, which accepts a <xref:System.Windows.Controls.Button> as an argument, is placed onto the <xref:System.Windows.Threading.Dispatcher>.  The <xref:System.Windows.Threading.Dispatcher> will delegate the work of updating the <xref:System.Windows.Controls.Button>.  \n  \n [!code-cs[DispatcherAccessSample#DispatcherAccessCheckAccess](~/add/codesnippet/csharp/DispatcherAccessSample/Window1.xaml.cs#dispatcheraccesscheckaccess)]\n [!code-vb[DispatcherAccessSample#DispatcherAccessCheckAccess](~/add/codesnippet/visualbasic/dispatcheraccesssample/window1.xaml.vb#dispatcheraccesscheckaccess)]"
  syntax:
    content: public bool CheckAccess ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o thread de chamada é o thread associado a este <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Threading.Dispatcher.CheckAccess*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.CurrentDispatcher
  id: CurrentDispatcher
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: CurrentDispatcher
  nameWithType: Dispatcher.CurrentDispatcher
  fullName: System.Windows.Threading.Dispatcher.CurrentDispatcher
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Obtém o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> para o thread atualmente em execução e cria um novo <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> se já não estiver associado o thread."
  remarks: "Se um <xref:System.Windows.Threading.Dispatcher>não está associada ao thread actual, um novo <xref:System.Windows.Threading.Dispatcher>será criada.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher>  Não é o caso do <xref:System.Windows.Threading.Dispatcher.FromThread%2A>método.</xref:System.Windows.Threading.Dispatcher.FromThread%2A>  <xref:System.Windows.Threading.Dispatcher.FromThread%2A>irá devolver `null` se não houver um distribuidor associado ao thread especificado.</xref:System.Windows.Threading.Dispatcher.FromThread%2A>"
  syntax:
    content: public static System.Windows.Threading.Dispatcher CurrentDispatcher { get; }
    return:
      type: System.Windows.Threading.Dispatcher
      description: "O dispatcher associado ao thread actual."
  overload: System.Windows.Threading.Dispatcher.CurrentDispatcher*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.DisableProcessing
  id: DisableProcessing
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: DisableProcessing()
  nameWithType: Dispatcher.DisableProcessing()
  fullName: System.Windows.Threading.Dispatcher.DisableProcessing()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Desativa o processamento do <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila."
  remarks: "Desativar o processamento do emissor é um método avançado que se destina a eliminar a possibilidade de reentrancy relacionado com.       Os efeitos da desativação de processamento são os seguintes:- [!INCLUDE[TLA2#tla_clr#initcap](~/add/includes/tla2sharptla-clrsharpinitcap-md.md)] bloqueios serão não pump mensagens internamente.      - <xref:System.Windows.Threading.DispatcherFrame>Objetos não são permitidos para ser enviado.</xref:System.Windows.Threading.DispatcherFrame>      -O processamento da mensagem não é permitido.       O <xref:System.Windows.Threading.DispatcherProcessingDisabled>estrutura DisableProcessing devolve quando é chamado pode ser utilizada para voltar a ativar o processamento do emissor.</xref:System.Windows.Threading.DispatcherProcessingDisabled>  Chamar <xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A>no <xref:System.Windows.Threading.DispatcherProcessingDisabled>estrutura novamente permite o processamento.</xref:System.Windows.Threading.DispatcherProcessingDisabled> </xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A>       DisableProcessing só pode ser chamado no thread de <xref:System.Windows.Threading.Dispatcher>está associado.</xref:System.Windows.Threading.Dispatcher>"
  example:
  - "The following example shows how to disable dispatcher processing and re-enable dispatcher processing.  DisableProcessing is called in a **using** statement.  DisableProcessing returns a <xref:System.Windows.Threading.DispatcherProcessingDisabled> structure that is used as the object to be disposed when the **using** block finishes.  When <xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A> is called on the <xref:System.Windows.Threading.DispatcherProcessingDisabled> structure, dispatcher processing is re-enabled.  \n  \n [!code-vb[DispatcherSnippets#DispatcherDisableProcessing](~/add/codesnippet/visualbasic/dispatchersnippets/window1.xaml.vb#dispatcherdisableprocessing)]\n [!code-cs[DispatcherSnippets#DispatcherDisableProcessing](~/add/codesnippet/csharp/DispatcherSnippets/Window1.xaml.cs#dispatcherdisableprocessing)]"
  syntax:
    content: public System.Windows.Threading.DispatcherProcessingDisabled DisableProcessing ();
    parameters: []
    return:
      type: System.Windows.Threading.DispatcherProcessingDisabled
      description: "Uma estrutura utilizada para voltar a ativar o processamento do emissor."
  overload: System.Windows.Threading.Dispatcher.DisableProcessing*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.ExitAllFrames
  id: ExitAllFrames
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: ExitAllFrames()
  nameWithType: Dispatcher.ExitAllFrames()
  fullName: System.Windows.Threading.Dispatcher.ExitAllFrames()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Pedidos de que todos os fotogramas sair, incluindo frames aninhadas."
  syntax:
    content: public static void ExitAllFrames ();
    parameters: []
  overload: System.Windows.Threading.Dispatcher.ExitAllFrames*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.FromThread(System.Threading.Thread)
  id: FromThread(System.Threading.Thread)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: FromThread(Thread)
  nameWithType: Dispatcher.FromThread(Thread)
  fullName: System.Windows.Threading.Dispatcher.FromThread(Thread)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Obtém o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> para o thread especificado."
  remarks: "Se o distribuidor não está disponível para o thread especificado, `null` vai ser devolvido.       FromThread não cria um <xref:System.Windows.Threading.Dispatcher>num thread que não tem um <xref:System.Windows.Threading.Dispatcher>.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher>   Um novo <xref:System.Windows.Threading.Dispatcher>é criado num thread que ainda não tiver um <xref:System.Windows.Threading.Dispatcher>ao tentar obter o <xref:System.Windows.Threading.Dispatcher>utilizando o <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>propriedade.</xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher>"
  syntax:
    content: public static System.Windows.Threading.Dispatcher FromThread (System.Threading.Thread thread);
    parameters:
    - id: thread
      type: System.Threading.Thread
      description: "O thread para obter o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> do."
    return:
      type: System.Windows.Threading.Dispatcher
      description: "O dispatcher para <code> thread </code>."
  overload: System.Windows.Threading.Dispatcher.FromThread*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.HasShutdownFinished
  id: HasShutdownFinished
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: HasShutdownFinished
  nameWithType: Dispatcher.HasShutdownFinished
  fullName: System.Windows.Threading.Dispatcher.HasShutdownFinished
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Determina se o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> terminou a encerrar."
  remarks: "Quando o <xref:System.Windows.Threading.Dispatcher>começa a encerrar o <xref:System.Windows.Threading.Dispatcher.ShutdownStarted>o evento é gerado e <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>está definido como `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownStarted> </xref:System.Windows.Threading.Dispatcher>       O <xref:System.Windows.Threading.Dispatcher>não encerramento completamente até que a fila de eventos unwinds.</xref:System.Windows.Threading.Dispatcher>       Quando o distribuidor conclui a ser encerrado, o <xref:System.Windows.Threading.Dispatcher.ShutdownFinished>o evento é gerado e a propriedade HasShutdownFinished está definida como `true`.</xref:System.Windows.Threading.Dispatcher.ShutdownFinished>       Depois de iniciar o processo de encerramento, todas as pendentes trabalho itens na fila foram abortadas."
  syntax:
    content: public bool HasShutdownFinished { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o dispatcher concluiu a encerrar; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Threading.Dispatcher.HasShutdownFinished*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.HasShutdownStarted
  id: HasShutdownStarted
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: HasShutdownStarted
  nameWithType: Dispatcher.HasShutdownStarted
  fullName: System.Windows.Threading.Dispatcher.HasShutdownStarted
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Determina se o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está a encerrar."
  remarks: "Quando o <xref:System.Windows.Threading.Dispatcher>começa a encerrar o <xref:System.Windows.Threading.Dispatcher.ShutdownStarted>o evento é gerado e HasShutdownStarted está definido como `true`.</xref:System.Windows.Threading.Dispatcher.ShutdownStarted> </xref:System.Windows.Threading.Dispatcher>       O <xref:System.Windows.Threading.Dispatcher>não será encerrado completamente até que a fila de eventos unwinds.</xref:System.Windows.Threading.Dispatcher>       Quando o distribuidor conclui a ser encerrado, o <xref:System.Windows.Threading.Dispatcher.ShutdownFinished>o evento é gerado e o <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>propriedade está definida como `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownFinished>       Depois de iniciar o processo de encerramento, todas as pendentes trabalho itens na fila foram abortadas."
  syntax:
    content: public bool HasShutdownStarted { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> iniciou-se para baixo; caso contrário, a encerrar <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Threading.Dispatcher.HasShutdownStarted*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Hooks
  id: Hooks
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Hooks
  nameWithType: Dispatcher.Hooks
  fullName: System.Windows.Threading.Dispatcher.Hooks
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Obtém a coleção de hooks que fornecem informações sobre eventos adicionais sobre o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
  remarks: "O <xref:System.Windows.Threading.DispatcherHooks>classe fornece informações sobre eventos adicionais sobre o <xref:System.Windows.Threading.Dispatcher>, tais como o <xref:System.Windows.Threading.Dispatcher>está inativo ou quando uma operação tem competed.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.DispatcherHooks>"
  syntax:
    content: public System.Windows.Threading.DispatcherHooks Hooks { get; }
    return:
      type: System.Windows.Threading.DispatcherHooks
      description: "Hooks associadas a este <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
  overload: System.Windows.Threading.Dispatcher.Hooks*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action)
  id: Invoke(System.Action)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Action)
  nameWithType: Dispatcher.Invoke(Action)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa especificado <xref:System.Action>forma síncrona no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado.</xref:System.Action>"
  syntax:
    content: public void Invoke (Action callback);
    parameters:
    - id: callback
      type: System.Action
      description: "Um delegado invocar através do distribuidor."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority)
  id: Invoke(System.Action,System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Action,DispatcherPriority)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa especificado <xref:System.Action>em sincronia com a prioridade especificada no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado.</xref:System.Action>"
  syntax:
    content: public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: callback
      type: System.Action
      description: "Um delegado invocar através do distribuidor."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade que determina a ordem pela qual a chamada de retorno especificada é invocada relativo as outras operações no pendentes a <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Object[])
  id: Invoke(System.Delegate,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Delegate,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa o delegado especificado com os argumentos especificados de forma síncrona no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado."
  remarks: "No [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], apenas o thread que criou um <xref:System.Windows.Threading.DispatcherObject>pode aceder a esse objeto.</xref:System.Windows.Threading.DispatcherObject> Por exemplo, um thread de segundo plano é puserem do thread de IU principal não é possível atualizar o conteúdo de um <xref:System.Windows.Controls.Button>que foi criado num thread de IU.</xref:System.Windows.Controls.Button> Para que o thread de segundo plano aceder a propriedade de conteúdo a <xref:System.Windows.Controls.Button>, o thread de segundo plano deve delegar o trabalho para o <xref:System.Windows.Threading.Dispatcher>associada ao thread da IU.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> Isto é conseguido através da utilização de um <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é síncrona e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> A operação é adicionada à fila de eventos <xref:System.Windows.Threading.Dispatcher>em <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> especificado</xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é uma operação síncrona; Por conseguinte, controlo não irá retornar ao chamar objeto até após a chamada de retorno devolve.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (Delegate method, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "Um delegado para um método que utiliza os parâmetros especificados na `args`, que é feita pelo <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos."
    - id: args
      type: System.Object[]
      description: "Uma matriz de objetos para passar como argumentos para o método especificado. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Object
      description: "O valor devolvido do delegado que está a ser invocado ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se o delegado não tem nenhum valor de retorno."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,Delegate)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa o delegado especificado em sincronia com a prioridade especificado no thread no qual o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado."
  remarks: "No [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], apenas o thread que criou um <xref:System.Windows.Threading.DispatcherObject>pode aceder a esse objeto.</xref:System.Windows.Threading.DispatcherObject>  Por exemplo, um thread de segundo plano é puserem do thread de IU principal não é possível atualizar o conteúdo de um <xref:System.Windows.Controls.Button>que foi criado num thread de IU.</xref:System.Windows.Controls.Button>  Para que o thread de segundo plano aceder a propriedade de conteúdo a <xref:System.Windows.Controls.Button>, o thread de segundo plano deve delegar o trabalho para o <xref:System.Windows.Threading.Dispatcher>associada ao thread da IU.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Isto é conseguido através da utilização de um <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é síncrona e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  A operação é adicionada à fila de eventos <xref:System.Windows.Threading.Dispatcher>em <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> especificado</xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é uma operação síncrona; Por conseguinte, controlo não irá retornar ao chamar objeto até após a chamada de retorno devolve.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  example:
  - "The following example places a delegate onto a <xref:System.Windows.Threading.Dispatcher> at <xref:System.Windows.Threading.DispatcherPriority> using Invoke.  \n  \n [!code-vb[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/add/codesnippet/visualbasic/invalidaterequerywithsystemtimer/window1.xaml.vb#systemtimerdispatcherinvoke)]\n [!code-cs[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/add/codesnippet/csharp/InvalidateRequeryWithSystemTimer/Window1.xaml.cs#systemtimerdispatcherinvoke)]"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade, relativo às outras operações no pendentes a <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos, o método especificado é invocada."
    - id: method
      type: System.Delegate
      description: "Um delegado a um método que não necessita de nenhum argumentos, que é feita pelo <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos."
    return:
      type: System.Object
      description: "O valor devolvido do delegado que está a ser invocado ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se o delegado não tem nenhum valor de retorno."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>priority</code>é igual ao <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>Não é uma prioridade válida."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  id: Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Action,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa especificado <xref:System.Action>em sincronia com a prioridade especificada no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado.</xref:System.Action>"
  syntax:
    content: public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: callback
      type: System.Action
      description: "Um delegado invocar através do distribuidor."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade que determina a ordem pela qual a chamada de retorno especificada é invocada relativo as outras operações no pendentes a <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Um objeto que indica se deve cancelar a ação."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Object[])
  id: Invoke(System.Delegate,System.TimeSpan,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Delegate,TimeSpan,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,TimeSpan,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,TimeSpan,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa o delegado especificado dentro do intervalo de tempo designado com a prioridade especificado com os argumentos especificados de forma síncrona no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado."
  remarks: "No [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], apenas o thread que criou um <xref:System.Windows.Threading.DispatcherObject>pode aceder a esse objeto.</xref:System.Windows.Threading.DispatcherObject> Por exemplo, um thread de segundo plano é puserem do thread de IU principal não é possível atualizar o conteúdo de um <xref:System.Windows.Controls.Button>que foi criado num thread de IU.</xref:System.Windows.Controls.Button> Para que o thread de segundo plano aceder a propriedade de conteúdo a <xref:System.Windows.Controls.Button>, o thread de segundo plano deve delegar o trabalho para o <xref:System.Windows.Threading.Dispatcher>associada ao thread da IU.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> Isto é conseguido através da utilização de um <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é síncrona e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> A operação é adicionada à fila de eventos <xref:System.Windows.Threading.Dispatcher>em <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> especificado</xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é uma operação síncrona; Por conseguinte, controlo não irá retornar ao chamar objeto até após a chamada de retorno devolve.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (Delegate method, TimeSpan timeout, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "Um delegado para um método que utiliza os parâmetros especificados na `args`, que é feita pelo <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos."
    - id: timeout
      type: System.TimeSpan
      description: "A quantidade máxima de tempo a aguardar a conclusão da operação."
    - id: args
      type: System.Object[]
      description: "Uma matriz de objetos para passar como argumentos para o método especificado. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Object
      description: "O valor devolvido do delegado que está a ser invocado ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se o delegado não tem nenhum valor de retorno."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  id: Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Delegate,DispatcherPriority,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,DispatcherPriority,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa o delegado especificado com a prioridade especificado com os argumentos especificados de forma síncrona no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado."
  remarks: "No [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], apenas o thread que criou um <xref:System.Windows.Threading.DispatcherObject>pode aceder a esse objeto.</xref:System.Windows.Threading.DispatcherObject> Por exemplo, um thread de segundo plano é puserem do thread de IU principal não é possível atualizar o conteúdo de um <xref:System.Windows.Controls.Button>que foi criado num thread de IU.</xref:System.Windows.Controls.Button> Para que o thread de segundo plano aceder a propriedade de conteúdo a <xref:System.Windows.Controls.Button>, o thread de segundo plano deve delegar o trabalho para o <xref:System.Windows.Threading.Dispatcher>associada ao thread da IU.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> Isto é conseguido através da utilização de um <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é síncrona e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> A operação é adicionada à fila de eventos <xref:System.Windows.Threading.Dispatcher>em <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> especificado</xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é uma operação síncrona; Por conseguinte, controlo não irá retornar ao chamar objeto até após a chamada de retorno devolve.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (Delegate method, System.Windows.Threading.DispatcherPriority priority, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "Um delegado para um método que utiliza os parâmetros especificados na `args`, que é feita pelo <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade, relativo às outras operações no pendentes a <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos, o método especificado é invocada."
    - id: args
      type: System.Object[]
      description: "Uma matriz de objetos para passar como argumentos para o método especificado. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Object
      description: "O valor devolvido do delegado que está a ser invocado ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se o delegado não tem nenhum valor de retorno."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,Delegate,Object)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate,Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa o delegado especificado com a prioridade especificada com o argumento especificado de forma síncrona no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado."
  remarks: "`Arg`pode ser `null` se um argumento não é necessária no [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], apenas o thread que criou um <xref:System.Windows.Threading.DispatcherObject>pode aceder a esse objeto.</xref:System.Windows.Threading.DispatcherObject>  Por exemplo, um thread de segundo plano é puserem do thread de IU principal não é possível atualizar o conteúdo de um <xref:System.Windows.Controls.Button>que foi criado num thread de IU.</xref:System.Windows.Controls.Button>  Para que o thread de segundo plano aceder a propriedade de conteúdo a <xref:System.Windows.Controls.Button>, o thread de segundo plano deve delegar o trabalho para o <xref:System.Windows.Threading.Dispatcher>associada ao thread da IU.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Isto é conseguido através da utilização de um <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é síncrona e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  A operação é adicionada à fila de eventos <xref:System.Windows.Threading.Dispatcher>em <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> especificado</xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é uma operação síncrona; Por conseguinte, controlo não irá retornar ao chamar objeto até após a chamada de retorno devolve.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade, relativo às outras operações no pendentes a <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos, o método especificado é invocada."
    - id: method
      type: System.Delegate
      description: "Um método que assume um argumento, o que é feito por um delegado a <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos."
    - id: arg
      type: System.Object
      description: "Um objeto para passar como um argumento para o método especificado."
    return:
      type: System.Object
      description: "O valor devolvido do delegado que está a ser invocado ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se o delegado não tem nenhum valor de retorno."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>priority</code>é igual ao <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>Não é uma prioridade válida."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,TimeSpan,Delegate)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa o delegado especificado em sincronia com a prioridade especificada e com o valor de limite de tempo especificado no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> foi criado."
  remarks: "No [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], apenas o thread que criou um <xref:System.Windows.Threading.DispatcherObject>pode aceder a esse objeto.</xref:System.Windows.Threading.DispatcherObject>  Por exemplo, um thread de segundo plano é puserem do thread de IU principal não é possível atualizar o conteúdo de um <xref:System.Windows.Controls.Button>que foi criado num thread de IU.</xref:System.Windows.Controls.Button>  Para que o thread de segundo plano aceder a propriedade de conteúdo a <xref:System.Windows.Controls.Button>, o thread de segundo plano deve delegar o trabalho para o <xref:System.Windows.Threading.Dispatcher>associada ao thread da IU.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Isto é conseguido através da utilização de um <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é síncrona e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  A operação é adicionada à fila de eventos <xref:System.Windows.Threading.Dispatcher>em <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> especificado</xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é uma operação síncrona; Por conseguinte, controlo não irá retornar ao chamar objeto até após a chamada de retorno devolve.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade, relativo às outras operações no pendentes a <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos, o método especificado é invocada."
    - id: timeout
      type: System.TimeSpan
      description: "O tempo máximo para aguardar a conclusão da operação."
    - id: method
      type: System.Delegate
      description: "O delegado para um método que não necessita de nenhum argumentos, que é feita pelo <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos."
    return:
      type: System.Object
      description: "O valor devolvido do delegado que está a ser invocado ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se o delegado não tem nenhum valor de retorno."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  id: Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa especificado <xref:System.Action>em sincronia com a prioridade especificada no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado.</xref:System.Action>"
  syntax:
    content: public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, TimeSpan timeout);
    parameters:
    - id: callback
      type: System.Action
      description: "Um delegado invocar através do distribuidor."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade que determina a ordem pela qual a chamada de retorno especificada é invocada relativo as outras operações no pendentes a <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Um objeto que indica se deve cancelar a ação."
    - id: timeout
      type: System.TimeSpan
      description: "A quantidade mínima de tempo de espera para a operação iniciar."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])
  id: Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa o delegado especificado dentro do intervalo de tempo designado com a prioridade especificado com os argumentos especificados de forma síncrona no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado."
  remarks: "No [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], apenas o thread que criou um <xref:System.Windows.Threading.DispatcherObject>pode aceder a esse objeto.</xref:System.Windows.Threading.DispatcherObject> Por exemplo, um thread de segundo plano é puserem do thread de IU principal não é possível atualizar o conteúdo de um <xref:System.Windows.Controls.Button>que foi criado num thread de IU.</xref:System.Windows.Controls.Button> Para que o thread de segundo plano aceder a propriedade de conteúdo a <xref:System.Windows.Controls.Button>, o thread de segundo plano deve delegar o trabalho para o <xref:System.Windows.Threading.Dispatcher>associada ao thread da IU.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> Isto é conseguido através da utilização de um <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é síncrona e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> A operação é adicionada à fila de eventos <xref:System.Windows.Threading.Dispatcher>em <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> especificado</xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é uma operação síncrona; Por conseguinte, controlo não irá retornar ao chamar objeto até após a chamada de retorno devolve.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (Delegate method, TimeSpan timeout, System.Windows.Threading.DispatcherPriority priority, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "Um delegado para um método que utiliza os parâmetros especificados na `args`, que é feita pelo <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos."
    - id: timeout
      type: System.TimeSpan
      description: "A quantidade máxima de tempo a aguardar a conclusão da operação."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade, relativo às outras operações no pendentes a <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos, o método especificado é invocada."
    - id: args
      type: System.Object[]
      description: "Uma matriz de objetos para passar como argumentos para o método especificado. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Object
      description: "O valor devolvido do delegado que está a ser invocado ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se o delegado não tem nenhum valor de retorno."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,Delegate,Object,Object[])
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate,Object,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa o delegado especificado com a prioridade especificado com os argumentos especificados de forma síncrona no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado."
  remarks: "`Arg`pode ser `null` se um argumento não é necessária no [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], apenas o thread que criou um <xref:System.Windows.Threading.DispatcherObject>pode aceder a esse objeto.</xref:System.Windows.Threading.DispatcherObject>  Por exemplo, um thread de segundo plano é puserem do thread de IU principal não é possível atualizar o conteúdo de um <xref:System.Windows.Controls.Button>que foi criado num thread de IU.</xref:System.Windows.Controls.Button>  Para que o thread de segundo plano aceder a propriedade de conteúdo a <xref:System.Windows.Controls.Button>, o thread de segundo plano deve delegar o trabalho para o <xref:System.Windows.Threading.Dispatcher>associada ao thread da IU.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Isto é conseguido através da utilização de um <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é síncrona e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  A operação é adicionada à fila de eventos <xref:System.Windows.Threading.Dispatcher>em <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> especificado</xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é uma operação síncrona; Por conseguinte, controlo não irá retornar ao chamar objeto até após a chamada de retorno devolve.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg, object[] args);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade, relativo às outras operações no pendentes a <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos, o método especificado é invocada."
    - id: method
      type: System.Delegate
      description: "Um delegado a um método que demora vários argumentos, que é feita pelo <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos."
    - id: arg
      type: System.Object
      description: "Um objeto para passar como um argumento para o método especificado."
    - id: args
      type: System.Object[]
      description: "Uma matriz de objetos para passar como argumentos para o método especificado."
    return:
      type: System.Object
      description: "O valor devolvido do delegado que está a ser invocado ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se o delegado não tem nenhum valor de retorno."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>priority</code>é igual ao <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>Não é uma prioridade válida."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa o delegado especificado com a prioridade especificada com o argumento especificado de forma síncrona no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado."
  remarks: "`Arg`pode ser `null` se um argumento não é necessária no [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], apenas o thread que criou um <xref:System.Windows.Threading.DispatcherObject>pode aceder a esse objeto.</xref:System.Windows.Threading.DispatcherObject>  Por exemplo, um thread de segundo plano é puserem do thread de IU principal não é possível atualizar o conteúdo de um <xref:System.Windows.Controls.Button>que foi criado num thread de IU.</xref:System.Windows.Controls.Button>  Para que o thread de segundo plano aceder a propriedade de conteúdo a <xref:System.Windows.Controls.Button>, o thread de segundo plano deve delegar o trabalho para o <xref:System.Windows.Threading.Dispatcher>associada ao thread da IU.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Isto é conseguido através da utilização de um <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é síncrona e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  A operação é adicionada à fila de eventos <xref:System.Windows.Threading.Dispatcher>em <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> especificado</xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é uma operação síncrona; Por conseguinte, controlo não irá retornar ao chamar objeto até após a chamada de retorno devolve.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade, relativo às outras operações no pendentes a <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos, o método especificado é invocada."
    - id: timeout
      type: System.TimeSpan
      description: "O tempo máximo para aguardar a conclusão da operação."
    - id: method
      type: System.Delegate
      description: "Um delegado a um método que demora vários argumentos, que é feita pelo <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos."
    - id: arg
      type: System.Object
      description: "Um objeto para passar como um argumento para o método especificado. Isto pode ser <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se forem necessárias sem argumentos."
    return:
      type: System.Object
      description: "O valor devolvido do delegado que está a ser invocado ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se o delegado não tem nenhum valor de retorno."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>priority</code>é igual ao <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>Não é uma prioridade válida."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa o delegado especificado com a prioridade especificado com os argumentos especificados de forma síncrona no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado."
  remarks: "`Arg`pode ser `null` se um argumento não é necessária.       No [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], apenas o thread que criou um <xref:System.Windows.Threading.DispatcherObject>pode aceder a esse objeto.</xref:System.Windows.Threading.DispatcherObject>  Por exemplo, um thread de segundo plano é puserem do thread de IU principal não é possível atualizar o conteúdo de um <xref:System.Windows.Controls.Button>que foi criado num thread de IU.</xref:System.Windows.Controls.Button>  Para que o thread de segundo plano aceder a propriedade de conteúdo a <xref:System.Windows.Controls.Button>, o thread de segundo plano deve delegar o trabalho para o <xref:System.Windows.Threading.Dispatcher>associada ao thread da IU.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Isto é conseguido através da utilização de um <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é síncrona e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é assíncrona.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  A operação é adicionada à fila de eventos <xref:System.Windows.Threading.Dispatcher>em <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> especificado</xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>é uma operação síncrona; Por conseguinte, controlo não irá retornar ao chamar objeto até após a chamada de retorno devolve.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg, object[] args);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade, relativo às outras operações no pendentes a <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos, o método especificado é invocada."
    - id: timeout
      type: System.TimeSpan
      description: "O tempo máximo para aguardar a conclusão da operação."
    - id: method
      type: System.Delegate
      description: "Um delegado a um método que demora vários argumentos, que é feita pelo <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> fila de eventos."
    - id: arg
      type: System.Object
      description: "Um objeto para passar como um argumento para o método especificado."
    - id: args
      type: System.Object[]
      description: "Uma matriz de objetos para passar como argumentos para o método especificado."
    return:
      type: System.Object
      description: "O valor devolvido do delegado que está a ser invocado ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se o delegado não tem nenhum valor de retorno."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>priority</code>é igual ao <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>Não é um <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0})
  id: Invoke``1(System.Func{``0})
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Func<TResult>)
  nameWithType: Dispatcher.Invoke(Func<TResult>)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public TResult Invoke<TResult> (Func<TResult> callback);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "A adicionar."
    return:
      type: TResult
      description: "A adicionar."
  overload: System.Windows.Threading.Dispatcher.Invoke<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  id: Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Func<TResult>,DispatcherPriority)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public TResult Invoke<TResult> (Func<TResult> callback, System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "A adicionar."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A adicionar."
    return:
      type: TResult
      description: "A adicionar."
  overload: System.Windows.Threading.Dispatcher.Invoke<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  id: Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public TResult Invoke<TResult> (Func<TResult> callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "A adicionar."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A adicionar."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "A adicionar."
    return:
      type: TResult
      description: "A adicionar."
  overload: System.Windows.Threading.Dispatcher.Invoke<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  id: Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public TResult Invoke<TResult> (Func<TResult> callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, TimeSpan timeout);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "A adicionar."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A adicionar."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "A adicionar."
    - id: timeout
      type: System.TimeSpan
      description: "A adicionar."
    return:
      type: TResult
      description: "A adicionar."
  overload: System.Windows.Threading.Dispatcher.Invoke<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)
  id: InvokeAsync(System.Action)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Action)
  nameWithType: Dispatcher.InvokeAsync(Action)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa especificado <xref:System.Action>assíncrona no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado.</xref:System.Action>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback);
    parameters:
    - id: callback
      type: System.Action
      description: "Um delegado invocar através do distribuidor."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "Um objeto, que é devolvida imediatamente após InvokeAsync é designado, que pode ser utilizado para interagir com o delegado como está pendente de execução de eventos fila."
  overload: System.Windows.Threading.Dispatcher.InvokeAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)
  id: InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Action,DispatcherPriority)
  nameWithType: Dispatcher.InvokeAsync(Action,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action,DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa especificado <xref:System.Action>assíncrona com a prioridade especificada no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado.</xref:System.Action>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback, System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: callback
      type: System.Action
      description: "Um delegado invocar através do distribuidor."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade que determina a ordem pela qual a chamada de retorno especificada é invocada relativo as outras operações no pendentes a <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "Um objeto, que é devolvida imediatamente após InvokeAsync é designado, que pode ser utilizado para interagir com o delegado como está pendente de execução de eventos fila."
  overload: System.Windows.Threading.Dispatcher.InvokeAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  id: InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Action,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.InvokeAsync(Action,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action,DispatcherPriority,CancellationToken)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Executa especificado <xref:System.Action>assíncrona com a prioridade especificada no thread de <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado.</xref:System.Action>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: callback
      type: System.Action
      description: "Um delegado invocar através do distribuidor."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade que determina a ordem pela qual a chamada de retorno especificada é invocada relativo as outras operações no pendentes a <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Um objeto que indica se deve cancelar a ação."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "Um objeto, que é devolvida imediatamente após InvokeAsync é designado, que pode ser utilizado para interagir com o delegado como está pendente de execução de eventos fila."
  overload: System.Windows.Threading.Dispatcher.InvokeAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})
  id: InvokeAsync``1(System.Func{``0})
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Func<TResult>)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public System.Windows.Threading.DispatcherOperation<TResult> InvokeAsync<TResult> (Func<TResult> callback);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "A adicionar."
    return:
      type: System.Windows.Threading.DispatcherOperation`1
      description: "A adicionar."
  overload: System.Windows.Threading.Dispatcher.InvokeAsync<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  id: InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Func<TResult>,DispatcherPriority)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public System.Windows.Threading.DispatcherOperation<TResult> InvokeAsync<TResult> (Func<TResult> callback, System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "A adicionar."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A adicionar."
    return:
      type: System.Windows.Threading.DispatcherOperation`1
      description: "A adicionar."
  overload: System.Windows.Threading.Dispatcher.InvokeAsync<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  id: InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public System.Windows.Threading.DispatcherOperation<TResult> InvokeAsync<TResult> (Func<TResult> callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "A adicionar."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A adicionar."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "A adicionar."
    return:
      type: System.Windows.Threading.DispatcherOperation`1
      description: "A adicionar."
  overload: System.Windows.Threading.Dispatcher.InvokeAsync<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeShutdown
  id: InvokeShutdown
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeShutdown()
  nameWithType: Dispatcher.InvokeShutdown()
  fullName: System.Windows.Threading.Dispatcher.InvokeShutdown()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Inicia o processo de encerramento do <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> forma síncrona."
  remarks: "InvokeShutdown exige permissões de IU sem restrições.       Quando o <xref:System.Windows.Threading.Dispatcher>começa a encerrar o <xref:System.Windows.Threading.Dispatcher.ShutdownStarted>o evento é gerado e <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>está definido como `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownStarted> </xref:System.Windows.Threading.Dispatcher>       O <xref:System.Windows.Threading.Dispatcher>não será encerrado completamente até que a fila de eventos unwinds.</xref:System.Windows.Threading.Dispatcher>       Quando o distribuidor conclui a ser encerrado, o <xref:System.Windows.Threading.Dispatcher.ShutdownFinished>o evento é gerado e o <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>propriedade está definida como `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownFinished>       Depois de iniciar o processo de encerramento, todas as pendentes trabalho itens na fila foram abortadas."
  syntax:
    content: public void InvokeShutdown ();
    parameters: []
  overload: System.Windows.Threading.Dispatcher.InvokeShutdown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)
  id: PushFrame(System.Windows.Threading.DispatcherFrame)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: PushFrame(DispatcherFrame)
  nameWithType: Dispatcher.PushFrame(DispatcherFrame)
  fullName: System.Windows.Threading.Dispatcher.PushFrame(DispatcherFrame)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Introduz um ciclo de execução."
  remarks: "A <xref:System.Windows.Threading.DispatcherFrame>representa um ciclo que processa os itens de trabalho pendentes.</xref:System.Windows.Threading.DispatcherFrame>       O Dispatcher processa a fila de item de trabalho em ciclo.  O ciclo é referido como moldura.  O ciclo inicial é normalmente iniciado pela aplicação chamando <xref:System.Windows.Threading.Dispatcher.Run%2A>.</xref:System.Windows.Threading.Dispatcher.Run%2A>       PushFrame introduz um ciclo representado pelo parâmetro `frame`.  Em cada iteração do ciclo, o <xref:System.Windows.Threading.Dispatcher>irá verificar a <xref:System.Windows.Threading.DispatcherFrame.Continue%2A>propriedade o <xref:System.Windows.Threading.DispatcherFrame>classe para determinar se o ciclo deve continuar ou se se deverá ser interrompida.</xref:System.Windows.Threading.DispatcherFrame> </xref:System.Windows.Threading.DispatcherFrame.Continue%2A> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.DispatcherFrame>permite a <xref:System.Windows.Threading.DispatcherFrame.Continue%2A>propriedade ser definida explicitamente e respeita a <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>propriedade <xref:System.Windows.Threading.Dispatcher>.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.DispatcherFrame.Continue%2A></xref:System.Windows.Threading.DispatcherFrame>  Isto significa que quando o <xref:System.Windows.Threading.Dispatcher>começa a encerrar, fotogramas que utilizam a predefinição <xref:System.Windows.Threading.DispatcherFrame>implementação será fechada, que permite que todos os aninhada frames sair.</xref:System.Windows.Threading.DispatcherFrame> </xref:System.Windows.Threading.Dispatcher>"
  example:
  - "The following example shows how to use a <xref:System.Windows.Threading.DispatcherFrame> to achieve similar results as the [!INCLUDE[TLA#tla_winforms](~/add/includes/ajax-current-ext-md.md)] <xref:System.Windows.Forms.Application.DoEvents%2A> method.  \n  \n [!code-vb[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/add/codesnippet/visualbasic/dispatchersnippets/window1.xaml.vb#dispatcherdispatcherframedoevents)]\n [!code-cs[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/add/codesnippet/csharp/DispatcherSnippets/Window1.xaml.cs#dispatcherdispatcherframedoevents)]"
  syntax:
    content: public static void PushFrame (System.Windows.Threading.DispatcherFrame frame);
    parameters:
    - id: frame
      type: System.Windows.Threading.DispatcherFrame
      description: "A frame para o distribuidor processar."
  overload: System.Windows.Threading.Dispatcher.PushFrame*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>frame</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref:System.Windows.Threading.Dispatcher.HasShutdownFinished*>is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>       -or-       <code>frame</code> is running on a different <xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>.</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished*>       - ou - o processamento do emissor foi desativado."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Run
  id: Run
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Run()
  nameWithType: Dispatcher.Run()
  fullName: System.Windows.Threading.Dispatcher.Run()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Pushes o intervalo de execução principal na fila de eventos do <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
  remarks: "O <xref:System.Windows.Threading.Dispatcher>processa a fila de eventos em ciclo.</xref:System.Windows.Threading.Dispatcher>  O ciclo é referido como moldura.  O ciclo inicial é normalmente iniciado pela aplicação chamando executar.       O intervalo de execução principal continuará até o <xref:System.Windows.Threading.Dispatcher>for encerrado.</xref:System.Windows.Threading.Dispatcher>"
  syntax:
    content: public static void Run ();
    parameters: []
  overload: System.Windows.Threading.Dispatcher.Run*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.ShutdownFinished
  id: ShutdownFinished
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: ShutdownFinished
  nameWithType: Dispatcher.ShutdownFinished
  fullName: System.Windows.Threading.Dispatcher.ShutdownFinished
  type: Event
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Ocorre quando o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> conclusão do encerramento."
  remarks: "Quando o processo de encerramento de uma <xref:System.Windows.Threading.Dispatcher>é iniciado, o <xref:System.Windows.Threading.Dispatcher.ShutdownStarted>o evento é gerado e <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>está definido como `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownStarted> </xref:System.Windows.Threading.Dispatcher>       O <xref:System.Windows.Threading.Dispatcher>não encerramento completamente até que a fila de eventos unwinds.</xref:System.Windows.Threading.Dispatcher>       Quando o distribuidor conclui a encerrar, é gerado o evento ShutdownFinished e <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>propriedade está definida como `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>       Depois de iniciar o processo de encerramento, todas as pendentes trabalho itens na fila foram abortadas."
  syntax:
    content: public event EventHandler ShutdownFinished;
    return:
      type: System.EventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.ShutdownStarted
  id: ShutdownStarted
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: ShutdownStarted
  nameWithType: Dispatcher.ShutdownStarted
  fullName: System.Windows.Threading.Dispatcher.ShutdownStarted
  type: Event
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Ocorre quando o <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> começa a encerrar."
  remarks: "Quando o processo de encerramento de uma <xref:System.Windows.Threading.Dispatcher>é iniciado, o evento ShutdownStarted é gerado e <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>está definido como `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.Dispatcher>       O <xref:System.Windows.Threading.Dispatcher>não encerramento completamente até que a fila de eventos unwinds.</xref:System.Windows.Threading.Dispatcher>       Quando o distribuidor conclui a ser encerrado, o <xref:System.Windows.Threading.Dispatcher.ShutdownFinished>o evento é gerado e o <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>propriedade está definida como `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownFinished>       Depois de iniciar o processo de encerramento, todas as pendentes trabalho itens na fila foram abortadas."
  syntax:
    content: public event EventHandler ShutdownStarted;
    return:
      type: System.EventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Thread
  id: Thread
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Thread
  nameWithType: Dispatcher.Thread
  fullName: System.Windows.Threading.Dispatcher.Thread
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Obtém o thread isto <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> está associado."
  syntax:
    content: public System.Threading.Thread Thread { get; }
    return:
      type: System.Threading.Thread
      description: "O thread."
  overload: System.Windows.Threading.Dispatcher.Thread*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.UnhandledException
  id: UnhandledException
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: UnhandledException
  nameWithType: Dispatcher.UnhandledException
  fullName: System.Windows.Threading.Dispatcher.UnhandledException
  type: Event
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Ocorre quando uma exceção do thread é acionada e não identificada durante a execução de um delegado por way de <> </> *> ou <> </> *>."
  remarks: "Este evento é desencadeado quando uma exceção que foi emitida durante a execução de um delegado por way de <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>é não identificadas.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>       Um processador pode marcar a exceção como processada, que irá impedir que o processador de exceções interna que está a ser chamado.       Processadores de eventos para este evento têm de ser escritos com cuidado para evitar criar exceções secundárias e para detetar quaisquer que ocorrem. Recomenda-se para evitar a atribuição de memória ou fazer qualquer recurso operações intensivas de processador.       O <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter>evento fornece um meio para não gerar o evento UnhandledException.</xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter>  O <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter>o evento é gerado pela primeira vez e se <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A>no <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs>está definido como `false`, o evento UnhandledException não será gerado.</xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs> </xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A> </xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter>"
  syntax:
    content: public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler UnhandledException;
    return:
      type: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.UnhandledExceptionFilter
  id: UnhandledExceptionFilter
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: UnhandledExceptionFilter
  nameWithType: Dispatcher.UnhandledExceptionFilter
  fullName: System.Windows.Threading.Dispatcher.UnhandledExceptionFilter
  type: Event
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Ocorre quando uma exceção do thread é acionada e não identificada durante a execução de um delegado por way de <> </> *> ou <> </> *> quando na fase de filtro."
  remarks: "Este evento é desencadeado durante a fase de filtro para uma exceção que é gerada durante a execução de um delegado por way de <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>e é não identificadas.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>       A pilha de chamadas não é descarregar nesta fase (exceção de primeira hipótese).       Processadores de eventos para este evento têm de ser escritos com cuidado para evitar criar exceções secundárias e para detetar quaisquer que ocorrem.  Recomenda-se para evitar a atribuição de memória ou fazer qualquer recurso operações intensivas de processador.       O evento UnhandledExceptionFilter fornece um meio para não gerar o <xref:System.Windows.Threading.Dispatcher.UnhandledException>eventos.</xref:System.Windows.Threading.Dispatcher.UnhandledException>  O evento de UnhandledExceptionFilter é gerado pela primeira vez e se <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A>no <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs>está definido como `false`, a <xref:System.Windows.Threading.Dispatcher.UnhandledException>evento não será gerado.</xref:System.Windows.Threading.Dispatcher.UnhandledException> </xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs> </xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A>"
  syntax:
    content: public event System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler UnhandledExceptionFilter;
    return:
      type: System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)
  id: ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: ValidatePriority(DispatcherPriority,String)
  nameWithType: Dispatcher.ValidatePriority(DispatcherPriority,String)
  fullName: System.Windows.Threading.Dispatcher.ValidatePriority(DispatcherPriority,String)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Determina se especificado <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref> é uma prioridade válida."
  syntax:
    content: public static void ValidatePriority (System.Windows.Threading.DispatcherPriority priority, string parameterName);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade para verificar."
    - id: parameterName
      type: System.String
      description: "Uma cadeia que será devolvida pela exceção que ocorre se a prioridade é inválida."
  overload: System.Windows.Threading.Dispatcher.ValidatePriority*
  exceptions:
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>Não é um <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.VerifyAccess
  id: VerifyAccess
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: VerifyAccess()
  nameWithType: Dispatcher.VerifyAccess()
  fullName: System.Windows.Threading.Dispatcher.VerifyAccess()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Determina se o thread de chamada tem acesso a este <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
  remarks: "Apenas o thread de <xref:System.Windows.Threading.Dispatcher>é criado no possam aceder <xref:System.Windows.Threading.Dispatcher>.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher>       Este método é público; Por conseguinte, qualquer thread pode verificar se tem acesso ao <xref:System.Windows.Threading.Dispatcher>.</xref:System.Windows.Threading.Dispatcher>       A diferença entre <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A>e VerifyAccess <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A>devolve um valor boleano se o thread de chamada não tiver acesso para o <xref:System.Windows.Threading.Dispatcher>e VerifyAccess emite uma exceção.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> </xref:System.Windows.Threading.Dispatcher.CheckAccess%2A>"
  example:
  - "The following example uses VerifyAccess to determine whether a thread has access to the thread that a <xref:System.Windows.Controls.Button> was created on.  The method takes an object as an argument, which is cast to a <xref:System.Windows.Controls.Button>.  The VerifyAccess method on the <xref:System.Windows.Threading.Dispatcher> of the <xref:System.Windows.Controls.Button> is called to verify access to the thread.  \n  \n If the calling thread has access to the <xref:System.Windows.Threading.Dispatcher>, the <xref:System.Windows.Controls.Button> is updated by just accessing the members of the <xref:System.Windows.Controls.Button>.  \n  \n If the calling thread does not have access, an <xref:System.InvalidOperationException> is thrown.  This example catches the exception and pushes a delegate, which accepts a <xref:System.Windows.Controls.Button> as an argument, onto the <xref:System.Windows.Threading.Dispatcher> of the <xref:System.Windows.Controls.Button>.  This <xref:System.Windows.Threading.Dispatcher> will do the work of updating the <xref:System.Windows.Controls.Button>.  \n  \n [!code-cs[DispatcherAccessSample#DispatcherAccessVerifyAccess](~/add/codesnippet/csharp/DispatcherAccessSample/Window1.xaml.cs#dispatcheraccessverifyaccess)]\n [!code-vb[DispatcherAccessSample#DispatcherAccessVerifyAccess](~/add/codesnippet/visualbasic/dispatcheraccesssample/window1.xaml.vb#dispatcheraccessverifyaccess)]"
  syntax:
    content: public void VerifyAccess ();
    parameters: []
  overload: System.Windows.Threading.Dispatcher.VerifyAccess*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O thread de chamada não tem acesso a este <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Yield
  id: Yield
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Yield()
  nameWithType: Dispatcher.Yield()
  fullName: System.Windows.Threading.Dispatcher.Yield()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Cria um objeto passível de espera que gera o controlo de volta para o distribuidor atual e fornece uma oportunidade para o emissor a processar outros eventos de forma assíncrona."
  remarks: "Este método proporciona uma forma de libertar temporariamente controlo de execução para o distribuidor atual, pelo que pode efetuar outras tarefas, tais como a processar outros eventos. Utilize o `await`, ou `Await` no Visual Basic, operador no valor de retorno para devolver o controlo para o distribuidor atual. Utilize este método se pretender dar uma oportunidade para processar os eventos enquanto a aplicação está a fazer uma grande quantidade de trabalho no thread de IU a sua aplicação. Por exemplo, pode utilizar este método num ciclo de longa execução que atualiza um controlo.       Este método é equivalente ao chamar o <xref:System.Windows.Threading.Dispatcher.Yield%28System.Windows.Threading.DispatcherPriority%29>método e transmitir em <xref:System.Windows.Threading.DispatcherPriority?displayProperty=fullName>.</xref:System.Windows.Threading.DispatcherPriority?displayProperty=fullName> </xref:System.Windows.Threading.Dispatcher.Yield%28System.Windows.Threading.DispatcherPriority%29>"
  syntax:
    content: public static System.Windows.Threading.DispatcherPriorityAwaitable Yield ();
    parameters: []
    return:
      type: System.Windows.Threading.DispatcherPriorityAwaitable
      description: "Um objeto passível de espera que gera o controlo de volta para o distribuidor atual e fornece uma oportunidade para o emissor a processar outros eventos de forma assíncrona."
  overload: System.Windows.Threading.Dispatcher.Yield*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Yield(System.Windows.Threading.DispatcherPriority)
  id: Yield(System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Yield(DispatcherPriority)
  nameWithType: Dispatcher.Yield(DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Yield(DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Cria um objeto passível de espera que gera o controlo de volta para o distribuidor atual e fornece uma oportunidade para o emissor a processar outros eventos de forma assíncrona.  O trabalho que ocorre quando o controlo devolve o código a aguardar o resultado deste método é agendado com a prioridade especificada."
  remarks: "Este método proporciona uma forma de libertar temporariamente controlo de execução para o distribuidor atual, pelo que pode efetuar outras tarefas, tais como a processar outros eventos. Utilize o `await`, ou `Await` no Visual Basic, operador no valor de retorno para devolver o controlo para o distribuidor atual. Utilize este método se pretender dar uma oportunidade para processar os eventos enquanto a aplicação está a fazer uma grande quantidade de trabalho no thread de IU a sua aplicação. Por exemplo, pode utilizar este método num ciclo de longa execução que atualiza um controlo."
  syntax:
    content: public static System.Windows.Threading.DispatcherPriorityAwaitable Yield (System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "A prioridade que agendar a continuação."
    return:
      type: System.Windows.Threading.DispatcherPriorityAwaitable
      description: "Um objeto passível de espera que gera o controlo de volta para o distribuidor atual e fornece uma oportunidade para o emissor a processar outros eventos de forma assíncrona."
  overload: System.Windows.Threading.Dispatcher.Yield*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke(Delegate,Object[])
  nameWithType: Dispatcher.BeginInvoke(Delegate,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(Delegate,Object[])
- uid: System.Windows.Threading.DispatcherOperation
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherOperation
  nameWithType: DispatcherOperation
  fullName: System.Windows.Threading.DispatcherOperation
- uid: System.Delegate
  parent: System
  isExternal: true
  name: Delegate
  nameWithType: Delegate
  fullName: System.Delegate
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke(DispatcherPriority,Delegate)
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate)
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate)
- uid: System.Windows.Threading.DispatcherPriority
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherPriority
  nameWithType: DispatcherPriority
  fullName: System.Windows.Threading.DispatcherPriority
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke(Delegate,DispatcherPriority,Object[])
  nameWithType: Dispatcher.BeginInvoke(Delegate,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(Delegate,DispatcherPriority,Object[])
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke(DispatcherPriority,Delegate,Object)
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object)
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
- uid: System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvokeShutdown(DispatcherPriority)
  nameWithType: Dispatcher.BeginInvokeShutdown(DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.BeginInvokeShutdown(DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.CheckAccess
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: CheckAccess()
  nameWithType: Dispatcher.CheckAccess()
  fullName: System.Windows.Threading.Dispatcher.CheckAccess()
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.Threading.Dispatcher.CurrentDispatcher
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: CurrentDispatcher
  nameWithType: Dispatcher.CurrentDispatcher
  fullName: System.Windows.Threading.Dispatcher.CurrentDispatcher
- uid: System.Windows.Threading.Dispatcher
  parent: System.Windows.Threading
  isExternal: false
  name: Dispatcher
  nameWithType: Dispatcher
  fullName: System.Windows.Threading.Dispatcher
- uid: System.Windows.Threading.Dispatcher.DisableProcessing
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: DisableProcessing()
  nameWithType: Dispatcher.DisableProcessing()
  fullName: System.Windows.Threading.Dispatcher.DisableProcessing()
- uid: System.Windows.Threading.DispatcherProcessingDisabled
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherProcessingDisabled
  nameWithType: DispatcherProcessingDisabled
  fullName: System.Windows.Threading.DispatcherProcessingDisabled
- uid: System.Windows.Threading.Dispatcher.ExitAllFrames
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ExitAllFrames()
  nameWithType: Dispatcher.ExitAllFrames()
  fullName: System.Windows.Threading.Dispatcher.ExitAllFrames()
- uid: System.Windows.Threading.Dispatcher.FromThread(System.Threading.Thread)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: FromThread(Thread)
  nameWithType: Dispatcher.FromThread(Thread)
  fullName: System.Windows.Threading.Dispatcher.FromThread(Thread)
- uid: System.Threading.Thread
  parent: System.Threading
  isExternal: false
  name: Thread
  nameWithType: Thread
  fullName: System.Threading.Thread
- uid: System.Windows.Threading.Dispatcher.HasShutdownFinished
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: HasShutdownFinished
  nameWithType: Dispatcher.HasShutdownFinished
  fullName: System.Windows.Threading.Dispatcher.HasShutdownFinished
- uid: System.Windows.Threading.Dispatcher.HasShutdownStarted
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: HasShutdownStarted
  nameWithType: Dispatcher.HasShutdownStarted
  fullName: System.Windows.Threading.Dispatcher.HasShutdownStarted
- uid: System.Windows.Threading.Dispatcher.Hooks
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Hooks
  nameWithType: Dispatcher.Hooks
  fullName: System.Windows.Threading.Dispatcher.Hooks
- uid: System.Windows.Threading.DispatcherHooks
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherHooks
  nameWithType: DispatcherHooks
  fullName: System.Windows.Threading.DispatcherHooks
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Action)
  nameWithType: Dispatcher.Invoke(Action)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action)
- uid: System.Action
  parent: System
  isExternal: true
  name: Action
  nameWithType: Action
  fullName: System.Action
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Action,DispatcherPriority)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Delegate,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,Object[])
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,Delegate)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Action,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken)
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Delegate,TimeSpan,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,TimeSpan,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,TimeSpan,Object[])
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Delegate,DispatcherPriority,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,DispatcherPriority,Object[])
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,Delegate,Object)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate,Object)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,TimeSpan,Delegate)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,Delegate,Object,Object[])
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate,Object,Object[])
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0})
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Func<TResult>)
  nameWithType: Dispatcher.Invoke(Func<TResult>)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>)
- uid: TResult
  isExternal: true
  name: TResult
  nameWithType: TResult
  fullName: TResult
- uid: System.Func{TResult}
  parent: System
  isExternal: true
  name: Func<TResult>
  nameWithType: Func<TResult>
  fullName: System.Func<TResult>
  spec.csharp:
  - uid: System.Func`1
    name: Func
    nameWithType: Func
    fullName: Func<TResult>
  - name: <
    nameWithType: <
    fullName: <
  - uid: TResult
    name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Func<TResult>,DispatcherPriority)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Action)
  nameWithType: Dispatcher.InvokeAsync(Action)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action)
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Action,DispatcherPriority)
  nameWithType: Dispatcher.InvokeAsync(Action,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action,DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Action,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.InvokeAsync(Action,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action,DispatcherPriority,CancellationToken)
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Func<TResult>)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>)
- uid: System.Windows.Threading.DispatcherOperation`1
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherOperation<TResult>
  nameWithType: DispatcherOperation<TResult>
  fullName: System.Windows.Threading.DispatcherOperation<TResult>
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Func<TResult>,DispatcherPriority)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
- uid: System.Windows.Threading.Dispatcher.InvokeShutdown
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeShutdown()
  nameWithType: Dispatcher.InvokeShutdown()
  fullName: System.Windows.Threading.Dispatcher.InvokeShutdown()
- uid: System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: PushFrame(DispatcherFrame)
  nameWithType: Dispatcher.PushFrame(DispatcherFrame)
  fullName: System.Windows.Threading.Dispatcher.PushFrame(DispatcherFrame)
- uid: System.Windows.Threading.DispatcherFrame
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherFrame
  nameWithType: DispatcherFrame
  fullName: System.Windows.Threading.DispatcherFrame
- uid: System.Windows.Threading.Dispatcher.Run
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Run()
  nameWithType: Dispatcher.Run()
  fullName: System.Windows.Threading.Dispatcher.Run()
- uid: System.Windows.Threading.Dispatcher.ShutdownFinished
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ShutdownFinished
  nameWithType: Dispatcher.ShutdownFinished
  fullName: System.Windows.Threading.Dispatcher.ShutdownFinished
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Windows.Threading.Dispatcher.ShutdownStarted
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ShutdownStarted
  nameWithType: Dispatcher.ShutdownStarted
  fullName: System.Windows.Threading.Dispatcher.ShutdownStarted
- uid: System.Windows.Threading.Dispatcher.Thread
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Thread
  nameWithType: Dispatcher.Thread
  fullName: System.Windows.Threading.Dispatcher.Thread
- uid: System.Windows.Threading.Dispatcher.UnhandledException
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: UnhandledException
  nameWithType: Dispatcher.UnhandledException
  fullName: System.Windows.Threading.Dispatcher.UnhandledException
- uid: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherUnhandledExceptionEventHandler
  nameWithType: DispatcherUnhandledExceptionEventHandler
  fullName: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
- uid: System.Windows.Threading.Dispatcher.UnhandledExceptionFilter
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: UnhandledExceptionFilter
  nameWithType: Dispatcher.UnhandledExceptionFilter
  fullName: System.Windows.Threading.Dispatcher.UnhandledExceptionFilter
- uid: System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherUnhandledExceptionFilterEventHandler
  nameWithType: DispatcherUnhandledExceptionFilterEventHandler
  fullName: System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler
- uid: System.Windows.Threading.Dispatcher.ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ValidatePriority(DispatcherPriority,String)
  nameWithType: Dispatcher.ValidatePriority(DispatcherPriority,String)
  fullName: System.Windows.Threading.Dispatcher.ValidatePriority(DispatcherPriority,String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.Threading.Dispatcher.VerifyAccess
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: VerifyAccess()
  nameWithType: Dispatcher.VerifyAccess()
  fullName: System.Windows.Threading.Dispatcher.VerifyAccess()
- uid: System.Windows.Threading.Dispatcher.Yield
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Yield()
  nameWithType: Dispatcher.Yield()
  fullName: System.Windows.Threading.Dispatcher.Yield()
- uid: System.Windows.Threading.DispatcherPriorityAwaitable
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherPriorityAwaitable
  nameWithType: DispatcherPriorityAwaitable
  fullName: System.Windows.Threading.DispatcherPriorityAwaitable
- uid: System.Windows.Threading.Dispatcher.Yield(System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Yield(DispatcherPriority)
  nameWithType: Dispatcher.Yield(DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Yield(DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.BeginInvoke*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke
  nameWithType: Dispatcher.BeginInvoke
- uid: System.Windows.Threading.Dispatcher.BeginInvokeShutdown*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvokeShutdown
  nameWithType: Dispatcher.BeginInvokeShutdown
- uid: System.Windows.Threading.Dispatcher.CheckAccess*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: CheckAccess
  nameWithType: Dispatcher.CheckAccess
- uid: System.Windows.Threading.Dispatcher.CurrentDispatcher*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: CurrentDispatcher
  nameWithType: Dispatcher.CurrentDispatcher
- uid: System.Windows.Threading.Dispatcher.DisableProcessing*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: DisableProcessing
  nameWithType: Dispatcher.DisableProcessing
- uid: System.Windows.Threading.Dispatcher.ExitAllFrames*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ExitAllFrames
  nameWithType: Dispatcher.ExitAllFrames
- uid: System.Windows.Threading.Dispatcher.FromThread*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: FromThread
  nameWithType: Dispatcher.FromThread
- uid: System.Windows.Threading.Dispatcher.HasShutdownFinished*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: HasShutdownFinished
  nameWithType: Dispatcher.HasShutdownFinished
- uid: System.Windows.Threading.Dispatcher.HasShutdownStarted*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: HasShutdownStarted
  nameWithType: Dispatcher.HasShutdownStarted
- uid: System.Windows.Threading.Dispatcher.Hooks*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Hooks
  nameWithType: Dispatcher.Hooks
- uid: System.Windows.Threading.Dispatcher.Invoke*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke
  nameWithType: Dispatcher.Invoke
- uid: System.Windows.Threading.Dispatcher.Invoke<TResult>*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke<TResult>
  nameWithType: Dispatcher.Invoke<TResult>
- uid: System.Windows.Threading.Dispatcher.InvokeAsync*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync
  nameWithType: Dispatcher.InvokeAsync
- uid: System.Windows.Threading.Dispatcher.InvokeAsync<TResult>*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync<TResult>
  nameWithType: Dispatcher.InvokeAsync<TResult>
- uid: System.Windows.Threading.Dispatcher.InvokeShutdown*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeShutdown
  nameWithType: Dispatcher.InvokeShutdown
- uid: System.Windows.Threading.Dispatcher.PushFrame*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: PushFrame
  nameWithType: Dispatcher.PushFrame
- uid: System.Windows.Threading.Dispatcher.Run*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Run
  nameWithType: Dispatcher.Run
- uid: System.Windows.Threading.Dispatcher.Thread*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Thread
  nameWithType: Dispatcher.Thread
- uid: System.Windows.Threading.Dispatcher.ValidatePriority*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ValidatePriority
  nameWithType: Dispatcher.ValidatePriority
- uid: System.Windows.Threading.Dispatcher.VerifyAccess*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: VerifyAccess
  nameWithType: Dispatcher.VerifyAccess
- uid: System.Windows.Threading.Dispatcher.Yield*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Yield
  nameWithType: Dispatcher.Yield
