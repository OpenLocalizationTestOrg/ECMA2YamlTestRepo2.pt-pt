### YamlMime:ManagedReference
items:
- uid: System.Security.SecurityManager
  id: SecurityManager
  children:
  - System.Security.SecurityManager.CheckExecutionRights
  - System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture
  - System.Security.SecurityManager.GetStandardSandbox(System.Security.Policy.Evidence)
  - System.Security.SecurityManager.GetZoneAndOrigin(System.Collections.ArrayList@,System.Collections.ArrayList@)
  - System.Security.SecurityManager.IsGranted(System.Security.IPermission)
  - System.Security.SecurityManager.LoadPolicyLevelFromFile(System.String,System.Security.PolicyLevelType)
  - System.Security.SecurityManager.LoadPolicyLevelFromString(System.String,System.Security.PolicyLevelType)
  - System.Security.SecurityManager.PolicyHierarchy
  - System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence)
  - System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence[])
  - System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet@)
  - System.Security.SecurityManager.ResolvePolicyGroups(System.Security.Policy.Evidence)
  - System.Security.SecurityManager.ResolveSystemPolicy(System.Security.Policy.Evidence)
  - System.Security.SecurityManager.SavePolicy
  - System.Security.SecurityManager.SavePolicyLevel(System.Security.Policy.PolicyLevel)
  - System.Security.SecurityManager.SecurityEnabled
  langs:
  - csharp
  name: SecurityManager
  nameWithType: SecurityManager
  fullName: System.Security.SecurityManager
  type: Class
  summary: "Fornece o ponto de acesso principal para interagir com o sistema de segurança de classes. Esta classe não pode ser herdada."
  remarks: "A segurança fornece métodos para aceder e manipular a configuração da política de segurança. Não é possível criar instâncias do SecurityManager."
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public static class SecurityManager
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Security.SecurityManager.CheckExecutionRights
  id: CheckExecutionRights
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: CheckExecutionRights
  nameWithType: SecurityManager.CheckExecutionRights
  fullName: System.Security.SecurityManager.CheckExecutionRights
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Obtém ou define um valor que indica se código tem de ter <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref> para executar."
  remarks: "Se esta propriedade é `false`, mesmo código sem <xref:System.Security.Permissions.SecurityPermissionFlag>pode ser executado.</xref:System.Security.Permissions.SecurityPermissionFlag> Verificação de execução é cara e pode eliminar as vantagens de resolução de política em diferido. Esta propriedade é fornecida para desativar a execução de verificação quando necessário.       Uma alteração para esta propriedade não é continuada até <xref:System.Security.SecurityManager.SavePolicy%2A>é chamado.</xref:System.Security.SecurityManager.SavePolicy%2A> Novos processos não serão afetados pela alteração até que este é continuada no registo."
  syntax:
    content: public static bool CheckExecutionRights { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o código tem de ter <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref> para executar; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Security.SecurityManager.CheckExecutionRights*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O código que chama este método não tem <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref>."
  platform:
  - net462
- uid: System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture
  id: CurrentThreadRequiresSecurityContextCapture
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: CurrentThreadRequiresSecurityContextCapture()
  nameWithType: SecurityManager.CurrentThreadRequiresSecurityContextCapture()
  fullName: System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Determina se o thread atual requer uma captura de contexto de segurança se o estado de segurança tem de ser recriada posteriormente no tempo."
  remarks: "Pode utilizar o método CurrentThreadRequiresSecurityContextCapture antes que colocar em cache dados confidenciais que são obtidos após exigências de segurança com êxito.       Se o <xref:System.Security.CodeAccessPermission.Assert%2A>método foi chamado superior na pilha, os dados não devem ser colocados em cache sem capturar o contexto de segurança correspondente.</xref:System.Security.CodeAccessPermission.Assert%2A> Dados confidenciais, caso contrário, que são obtidos num <xref:System.Security.CodeAccessPermission.Assert%2A>podem tornar-se disponível para o código que já não estar em execução com que <xref:System.Security.CodeAccessPermission.Assert%2A>no local.</xref:System.Security.CodeAccessPermission.Assert%2A> </xref:System.Security.CodeAccessPermission.Assert%2A>      > [!IMPORTANT] > O valor de retorno é fiável apenas quando é `false`, o que significa que o thread não fique requerem uma captura de contexto de segurança. O método pode devolver true, quando uma captura de contexto de segurança não é necessária evitar vulnerabilidades de segurança.       CurrentThreadRequiresSecurityContextCapture é crítica de segurança porque a sua utilização principal é evitar o contexto de segurança desnecessários captura, que indica que o código de utilizá-lo é segurança confidenciais e tem de ser auditado."
  syntax:
    content: public static bool CurrentThreadRequiresSecurityContextCapture ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>Se a pilha contém não domínios de aplicação parcialmente fidedigna, nenhum assemblagens parcialmente fidedignas e não está ativa <> </> *> ou <> </> *> Modificadores; <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> se o language runtime não pode garantir que a pilha contém nenhuma destas."
  overload: System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture*
  exceptions: []
  platform:
  - net462
- uid: System.Security.SecurityManager.GetStandardSandbox(System.Security.Policy.Evidence)
  id: GetStandardSandbox(System.Security.Policy.Evidence)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: GetStandardSandbox(Evidence)
  nameWithType: SecurityManager.GetStandardSandbox(Evidence)
  fullName: System.Security.SecurityManager.GetStandardSandbox(Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Obtém um conjunto de permissões que é seguro conceder a uma aplicação que tenha a provas fornecida."
  remarks: "> [!NOTE]> No [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], provas de anfitrião no `evidence` tem de conter <xref:System.Security.Policy.Zone?displayProperty=fullName>provas.</xref:System.Security.Policy.Zone?displayProperty=fullName>   >> A tabela seguinte mostra os conjuntos de permissões que são devolvidos para cada zona.      | Zona | Conjunto de permissões |   |----------|--------------------|   | <xref:System.Security.SecurityZone>| `FullTrust`|   | <xref:System.Security.SecurityZone>| `LocalIntranet`|   | <xref:System.Security.SecurityZone>| `Internet`|   | <xref:System.Security.SecurityZone>| `Internet`|   | <xref:System.Security.SecurityZone>| Nenhum |   | <xref:System.Security.SecurityZone>| Nenhum |       Outros provas, tais como <xref:System.Security.Policy.Url>ou <xref:System.Security.Policy.Site>, pode ser considerada.</xref:System.Security.Policy.Site> </xref:System.Security.Policy.Url> </xref:System.Security.SecurityZone> </xref:System.Security.SecurityZone> </xref:System.Security.SecurityZone> </xref:System.Security.SecurityZone> </xref:System.Security.SecurityZone> </xref:System.Security.SecurityZone>       O conjunto de permissões devolvido pode ser utilizado por uma sandbox para executar a aplicação. Tenha em atenção que este método não especificar a política, mas que ajuda a um anfitrião para determinar se o conjunto de permissões solicitado por uma aplicação é razoável. Este método pode ser utilizado para mapear uma zona a uma sandbox."
  example:
  - "The following example shows how to use the GetStandardSandbox method to obtain the permission set for a sandboxed application. For more information about running an application in a sandbox, see [How to: Run Partially Trusted Code in a Sandbox](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[sandboxingApis#1](~/add/codesnippet/visualbasic/2aad9996-0182-4c3d-a405-_1.vb)]\n [!code-cs[sandboxingApis#1](~/add/codesnippet/csharp/2aad9996-0182-4c3d-a405-_1.cs)]"
  syntax:
    content: public static System.Security.PermissionSet GetStandardSandbox (System.Security.Policy.Evidence evidence);
    parameters:
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "A prova de anfitrião para corresponder a um conjunto de permissões."
    return:
      type: System.Security.PermissionSet
      description: "Um conjunto de permissões que pode ser utilizado como um conjunto para a aplicação que tenha a fornecido provas de permissões."
  overload: System.Security.SecurityManager.GetStandardSandbox*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>evidence</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.SecurityManager.GetZoneAndOrigin(System.Collections.ArrayList@,System.Collections.ArrayList@)
  id: GetZoneAndOrigin(System.Collections.ArrayList@,System.Collections.ArrayList@)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: GetZoneAndOrigin(ArrayList,ArrayList)
  nameWithType: SecurityManager.GetZoneAndOrigin(ArrayList,ArrayList)
  fullName: System.Security.SecurityManager.GetZoneAndOrigin(ArrayList,ArrayList)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Obtém a identidade de zona concedida e conjuntos de permissões de identidade do URL para a assemblagem atual."
  remarks: "A alternativa recomendada para este método é utilizar o URL e horário provas para a assemblagem em execução para chamar <xref:System.Security.SecurityManager.ResolvePolicy%2A>para cada tipo de prova.</xref:System.Security.SecurityManager.ResolvePolicy%2A> Os conjuntos de permissão devolvidos o <xref:System.Security.SecurityManager.ResolvePolicy%2A>chamadas identificam as permissões concedidas à assemblagem em execução com base na respetiva zona e o URL de origem.</xref:System.Security.SecurityManager.ResolvePolicy%2A>      > [!NOTE] > Este membro faz um pedido de ligação para a chave pública ECMA, que não é uma chave criptográfica válida, mas uma chave de pseudo. Dentro do .NET Framework o pedido de ligação para a chave de pseudo ECMA é automaticamente convertido para um pedido de ligação para a chave pública da Microsoft. A exceção de segurança baseia-se a chave pública do Microsoft, não a chave de pseudo ECMA."
  syntax:
    content: public static void GetZoneAndOrigin (out System.Collections.ArrayList zone, out System.Collections.ArrayList origin);
    parameters:
    - id: zone
      type: System.Collections.ArrayList
      description: "Um parâmetro de saída que contém um <xref href=&quot;System.Collections.ArrayList&quot;> </xref> de concedida <xref:System.Security.Permissions.ZoneIdentityPermissionAttribute.Zone*>objetos.</xref:System.Security.Permissions.ZoneIdentityPermissionAttribute.Zone*>"
    - id: origin
      type: System.Collections.ArrayList
      description: "Um parâmetro de saída que contém um <xref href=&quot;System.Collections.ArrayList&quot;> </xref> de concedida <xref href=&quot;System.Security.Permissions.UrlIdentityPermission&quot;> </xref> objetos."
  overload: System.Security.SecurityManager.GetZoneAndOrigin*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O pedido para <xref href=&quot;System.Security.Permissions.StrongNameIdentityPermission&quot;> </xref> falhou."
  platform:
  - net462
- uid: System.Security.SecurityManager.IsGranted(System.Security.IPermission)
  id: IsGranted(System.Security.IPermission)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: IsGranted(IPermission)
  nameWithType: SecurityManager.IsGranted(IPermission)
  fullName: System.Security.SecurityManager.IsGranted(IPermission)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Determina se uma permissão é concedida ao chamador."
  remarks: "Concessão de permissões é determinado através da política e é diferente de um pedido sujeitos substituições, tais como uma asserção. Além disso, IsGranted apenas os testes a concessão da chamada código assemblagem, independente de outros os chamadores na pilha."
  syntax:
    content: public static bool IsGranted (System.Security.IPermission perm);
    parameters:
    - id: perm
      type: System.Security.IPermission
      description: "A permissão para testar contra a concessão do chamador."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se as permissões concedidas ao chamador incluem a permissão <code> perm </code>; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Security.SecurityManager.IsGranted*
  exceptions: []
  platform:
  - net462
- uid: System.Security.SecurityManager.LoadPolicyLevelFromFile(System.String,System.Security.PolicyLevelType)
  id: LoadPolicyLevelFromFile(System.String,System.Security.PolicyLevelType)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: LoadPolicyLevelFromFile(String,PolicyLevelType)
  nameWithType: SecurityManager.LoadPolicyLevelFromFile(String,PolicyLevelType)
  fullName: System.Security.SecurityManager.LoadPolicyLevelFromFile(String,PolicyLevelType)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Carrega um <xref href=&quot;System.Security.Policy.PolicyLevel&quot;> </xref> do ficheiro especificado."
  syntax:
    content: public static System.Security.Policy.PolicyLevel LoadPolicyLevelFromFile (string path, System.Security.PolicyLevelType type);
    parameters:
    - id: path
      type: System.String
      description: "O caminho físico para um ficheiro que contém as informações de política de segurança."
    - id: type
      type: System.Security.PolicyLevelType
      description: "Um dos valores da enumeração que especifica o tipo de nível de política para ser carregado."
    return:
      type: System.Security.Policy.PolicyLevel
      description: "O nível de política carregado."
  overload: System.Security.SecurityManager.LoadPolicyLevelFromFile*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O ficheiro indicado pelo <code> path </code> parâmetro não existe."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O código que chama este método não tem <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref>.       - ou - o código que chama este método não tem <xref href=&quot;System.Security.Permissions.FileIOPermissionAccess&quot;> </xref>.       - ou - o código que chama este método não tem <xref href=&quot;System.Security.Permissions.FileIOPermissionAccess&quot;> </xref>.       - ou - o código que chama este método não tem <xref href=&quot;System.Security.Permissions.FileIOPermissionAccess&quot;> </xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Este método utiliza a política acesso a código (CAS) de segurança, que é obsoleta no [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]. Para ativar a política CAS para compatibilidade com versões anteriores do .NET Framework, utilize o [ &lt;legacyCasPolicy&gt; elemento](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)."
  platform:
  - net462
- uid: System.Security.SecurityManager.LoadPolicyLevelFromString(System.String,System.Security.PolicyLevelType)
  id: LoadPolicyLevelFromString(System.String,System.Security.PolicyLevelType)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: LoadPolicyLevelFromString(String,PolicyLevelType)
  nameWithType: SecurityManager.LoadPolicyLevelFromString(String,PolicyLevelType)
  fullName: System.Security.SecurityManager.LoadPolicyLevelFromString(String,PolicyLevelType)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Carrega um <xref href=&quot;System.Security.Policy.PolicyLevel&quot;> </xref> da cadeia especificada."
  syntax:
    content: public static System.Security.Policy.PolicyLevel LoadPolicyLevelFromString (string str, System.Security.PolicyLevelType type);
    parameters:
    - id: str
      type: System.String
      description: "A representação XML de um nível de política de segurança no mesmo formulário em que é apresentado no ficheiro de configuração."
    - id: type
      type: System.Security.PolicyLevelType
      description: "Um dos valores da enumeração que especifica o tipo de nível de política para ser carregado."
    return:
      type: System.Security.Policy.PolicyLevel
      description: "O nível de política carregado."
  overload: System.Security.SecurityManager.LoadPolicyLevelFromString*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>str</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O <code> str </code> parâmetro não é válido."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O código que chama este método não tem <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref>."
  platform:
  - net462
- uid: System.Security.SecurityManager.PolicyHierarchy
  id: PolicyHierarchy
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: PolicyHierarchy()
  nameWithType: SecurityManager.PolicyHierarchy()
  fullName: System.Security.SecurityManager.PolicyHierarchy()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Fornece um enumerador para aceder à hierarquia de política de segurança por níveis, tais como a política de computador e a política de utilizador."
  remarks: "O enumerador devolvido fornece sucessivas <xref:System.Security.Policy.PolicyLevel>objetos que representam a política a respetiva (máquina, utilizador, enterprise, o domínio de aplicação) ao nível da hierarquia.</xref:System.Security.Policy.PolicyLevel> Estes objetos são os objetos de política em direto; alterar estes objetos pode ter resultados imprevisíveis.       Política mínimo hierarquia é constituída por um nível de máquina, um nível empresarial e um nível de utilizador. No entanto, a hierarquia pode incluir níveis adicionais."
  syntax:
    content: public static System.Collections.IEnumerator PolicyHierarchy ();
    parameters: []
    return:
      type: System.Collections.IEnumerator
      description: "O enumerador de <xref href=&quot;System.Security.Policy.PolicyLevel&quot;> </xref> objetos que compõem a hierarquia de política de segurança."
  overload: System.Security.SecurityManager.PolicyHierarchy*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Este método utiliza a política acesso a código (CAS) de segurança, que é obsoleta no [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]. Para ativar a política CAS para compatibilidade com versões anteriores do .NET Framework, utilize o [ &lt;legacyCasPolicy&gt; elemento](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O código que chama este método não tem <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref>."
  platform:
  - net462
- uid: System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence)
  id: ResolvePolicy(System.Security.Policy.Evidence)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: ResolvePolicy(Evidence)
  nameWithType: SecurityManager.ResolvePolicy(Evidence)
  fullName: System.Security.SecurityManager.ResolvePolicy(Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Determina o que permissões para conceder ao código com base na provas especificada."
  remarks: "Este método invoca o motor de política de segurança, fornecendo-lo com prova de identidade o código de chamada. O resultado é determinado pela política de segurança."
  syntax:
    content: public static System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence evidence);
    parameters:
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "A prova definir utilizada para avaliar a política."
    return:
      type: System.Security.PermissionSet
      description: "O conjunto de permissões que podem ser concedidas pelo sistema de segurança."
  overload: System.Security.SecurityManager.ResolvePolicy*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Este método utiliza a política acesso a código (CAS) de segurança, que é obsoleta no [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]. Para ativar a política CAS para compatibilidade com versões anteriores do .NET Framework, utilize o [ &lt;legacyCasPolicy&gt; elemento](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)."
  platform:
  - net462
- uid: System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence[])
  id: ResolvePolicy(System.Security.Policy.Evidence[])
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: ResolvePolicy(Evidence[])
  nameWithType: SecurityManager.ResolvePolicy(Evidence[])
  fullName: System.Security.SecurityManager.ResolvePolicy(Evidence[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Determina o que permissões para conceder ao código com base na provas especificada."
  remarks: "Este método invoca o motor de política de segurança, fornecendo-la com uma matriz de <xref:System.Security.Policy.Evidence>objetos.</xref:System.Security.Policy.Evidence> O conjunto de permissões devolvido representa apenas essas permissões que se aplicam a cada provas na matriz. Estas permissões são equivalentes para ou um subconjunto das permissões de política seria ter concedidas para cada provas individuais. Este método funciona como se foram efetuar uma intersecção nos resultados de política em cada um de resolver o <xref:System.Security.Policy.Evidence>objetos na matriz.</xref:System.Security.Policy.Evidence>"
  syntax:
    content: public static System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence[] evidences);
    parameters:
    - id: evidences
      type: System.Security.Policy.Evidence[]
      description: "Uma matriz de objetos de provas utilizados para avaliar a política."
    return:
      type: System.Security.PermissionSet
      description: "O conjunto de permissões que é adequado para todas as provas fornecida."
  overload: System.Security.SecurityManager.ResolvePolicy*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Este método utiliza a política acesso a código (CAS) de segurança, que é obsoleta no [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]. Para ativar a política CAS para compatibilidade com versões anteriores do .NET Framework, utilize o [ &lt;legacyCasPolicy&gt; elemento](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)."
  platform:
  - net462
- uid: System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet@)
  id: ResolvePolicy(System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet@)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: ResolvePolicy(Evidence,PermissionSet,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: SecurityManager.ResolvePolicy(Evidence,PermissionSet,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.Security.SecurityManager.ResolvePolicy(Evidence,PermissionSet,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Determina o que permissões para conceder ao código com base nos pedidos e provas especificada."
  remarks: "Este método invoca o motor de política de segurança, fornecendo-lo, com prova de identidade de chamada do código e o conjunto de permissões, o código de pedidos. O resultado é determinado pela política de segurança. Este método devolve o conjunto de permissões que deverá ser concedida pelo sistema de segurança e devolve o conjunto de permissões que seriam negado como um parâmetro de saída. As permissões efetivas concedidas são as no conjunto concedido que não estão no conjunto de negado."
  syntax:
    content: public static System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence evidence, System.Security.PermissionSet reqdPset, System.Security.PermissionSet optPset, System.Security.PermissionSet denyPset, out System.Security.PermissionSet denied);
    parameters:
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "A prova definir utilizada para avaliar a política."
    - id: reqdPset
      type: System.Security.PermissionSet
      description: "As permissões necessárias, que tem de executar o código."
    - id: optPset
      type: System.Security.PermissionSet
      description: "As permissões opcionais que serão utilizadas se concedidas, mas não são necessários o código executar."
    - id: denyPset
      type: System.Security.PermissionSet
      description: "As permissões negadas que nunca devem ser concedidas o código mesmo, de outra forma de política permite-lo."
    - id: denied
      type: System.Security.PermissionSet
      description: "Um parâmetro de saída que contém o conjunto de permissões não concedida."
    return:
      type: System.Security.PermissionSet
      description: "O conjunto de permissões que deverá ser concedida pelo sistema de segurança."
  overload: System.Security.SecurityManager.ResolvePolicy*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Este método utiliza a política acesso a código (CAS) de segurança, que é obsoleta no [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]. Para ativar a política CAS para compatibilidade com versões anteriores do .NET Framework, utilize o [ &lt;legacyCasPolicy&gt; elemento](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)."
  - type: System.Security.Policy.PolicyException
    commentId: T:System.Security.Policy.PolicyException
    description: "Política de falha conceder as permissões necessárias mínimas especificadas pelo <code> reqdPset </code> parâmetro."
  platform:
  - net462
- uid: System.Security.SecurityManager.ResolvePolicyGroups(System.Security.Policy.Evidence)
  id: ResolvePolicyGroups(System.Security.Policy.Evidence)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: ResolvePolicyGroups(Evidence)
  nameWithType: SecurityManager.ResolvePolicyGroups(Evidence)
  fullName: System.Security.SecurityManager.ResolvePolicyGroups(Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Obtém um conjunto de grupos de código correspondentes a provas especificada."
  remarks: "Este método é útil analisar como uma configuração de política especificado funciona com a tipos específicos de prova.       Grupos de código serão devolvidos de todos os níveis aplicáveis da hierarquia de política que correspondam a `evidence` parâmetro."
  syntax:
    content: public static System.Collections.IEnumerator ResolvePolicyGroups (System.Security.Policy.Evidence evidence);
    parameters:
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "A prova definido em relação a que a política é avaliada."
    return:
      type: System.Collections.IEnumerator
      description: "Uma enumeração do conjunto de grupos de código a provas de correspondência."
  overload: System.Security.SecurityManager.ResolvePolicyGroups*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Este método utiliza a política acesso a código (CAS) de segurança, que é obsoleta no [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]. Para ativar a política CAS para compatibilidade com versões anteriores do .NET Framework, utilize o [ &lt;legacyCasPolicy&gt; elemento](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)."
  platform:
  - net462
- uid: System.Security.SecurityManager.ResolveSystemPolicy(System.Security.Policy.Evidence)
  id: ResolveSystemPolicy(System.Security.Policy.Evidence)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: ResolveSystemPolicy(Evidence)
  nameWithType: SecurityManager.ResolveSystemPolicy(Evidence)
  fullName: System.Security.SecurityManager.ResolveSystemPolicy(Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Determina as permissões para conceder ao código com base no provas especificada, excluindo a política para o <xref href=&quot;System.AppDomain&quot;> </xref> nível."
  remarks: "Este método invoca o motor de política de segurança e fornece-lhe uma prova de identidade o código de chamada. O resultado é determinado pela política de segurança do sistema não incluindo quaisquer <xref:System.AppDomain>política.</xref:System.AppDomain>"
  syntax:
    content: public static System.Security.PermissionSet ResolveSystemPolicy (System.Security.Policy.Evidence evidence);
    parameters:
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "A prova definir utilizada para avaliar a política."
    return:
      type: System.Security.PermissionSet
      description: "O conjunto de permissões que podem ser concedidas pelo sistema de segurança."
  overload: System.Security.SecurityManager.ResolveSystemPolicy*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Este método utiliza a política acesso a código (CAS) de segurança, que é obsoleta no [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]. Para ativar a política CAS para compatibilidade com versões anteriores do .NET Framework, utilize o [ &lt;legacyCasPolicy&gt; elemento](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)."
  platform:
  - net462
- uid: System.Security.SecurityManager.SavePolicy
  id: SavePolicy
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: SavePolicy()
  nameWithType: SecurityManager.SavePolicy()
  fullName: System.Security.SecurityManager.SavePolicy()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Guarda o estado de política de segurança modificado."
  remarks: "Este método poupa a política conforme exposta pelo <xref:System.Security.SecurityManager.PolicyHierarchy%2A>, <xref:System.Security.Policy.PolicyLevel>, e outras classes que representam a configuração da política de segurança.</xref:System.Security.Policy.PolicyLevel> </xref:System.Security.SecurityManager.PolicyHierarchy%2A> A menos que este método é denominado, as alterações efetuadas para os objetos de política não serão guardadas e não irão afetar a aplicação subsequentes executa."
  syntax:
    content: public static void SavePolicy ();
    parameters: []
  overload: System.Security.SecurityManager.SavePolicy*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Este método utiliza a política acesso a código (CAS) de segurança, que é obsoleta no [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]. Para ativar a política CAS para compatibilidade com versões anteriores do .NET Framework, utilize o [ &lt;legacyCasPolicy&gt; elemento](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O código que chama este método não tem <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref>."
  platform:
  - net462
- uid: System.Security.SecurityManager.SavePolicyLevel(System.Security.Policy.PolicyLevel)
  id: SavePolicyLevel(System.Security.Policy.PolicyLevel)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: SavePolicyLevel(PolicyLevel)
  nameWithType: SecurityManager.SavePolicyLevel(PolicyLevel)
  fullName: System.Security.SecurityManager.SavePolicyLevel(PolicyLevel)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Guarda um nível de política de segurança modificado carregado com <xref:System.Security.SecurityManager.LoadPolicyLevelFromFile*>.</xref:System.Security.SecurityManager.LoadPolicyLevelFromFile*>"
  remarks: "O <xref:System.Security.Policy.PolicyLevel>será guardado na mesma localização a partir do qual carregada.</xref:System.Security.Policy.PolicyLevel>"
  syntax:
    content: public static void SavePolicyLevel (System.Security.Policy.PolicyLevel level);
    parameters:
    - id: level
      type: System.Security.Policy.PolicyLevel
      description: "O objeto de nível política sejam guardados."
  overload: System.Security.SecurityManager.SavePolicyLevel*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O código que chama este método não tem <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Este método utiliza a política acesso a código (CAS) de segurança, que é obsoleta no [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]. Para ativar a política CAS para compatibilidade com versões anteriores do .NET Framework, utilize o [ &lt;legacyCasPolicy&gt; elemento](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)."
  platform:
  - net462
- uid: System.Security.SecurityManager.SecurityEnabled
  id: SecurityEnabled
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: SecurityEnabled
  nameWithType: SecurityManager.SecurityEnabled
  fullName: System.Security.SecurityManager.SecurityEnabled
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Obtém ou define um valor que indica se a segurança está ativada."
  remarks: "Esta propriedade é utilizada pelo [Caspol.exe (ferramenta de política de segurança de acesso do código)](~/add/includes/ajax-current-ext-md.md) `-security` (`-s`) a opção para desativar a segurança baseada no código.              SecurityEnabled fornece uma forma para os administradores desativar a segurança de acesso de código. Quando a segurança de acesso de código estiver desativada, todos os pedidos de acesso de código concluída com êxito. Efetivamente, esta ação garante todo o código `FullTrust`. Segurança de acesso de código de Desativação contornar o sistema de segurança para que pode executar código ligeiramente melhor do que a concessão de política de segurança equivalente `FullTrust` para todo o código. Esta propriedade não desativar a segurança baseada em funções; Por conseguinte, <xref:System.Security.Permissions.PrincipalPermission>exigências não são afetadas.</xref:System.Security.Permissions.PrincipalPermission>      > [!CAUTION] > Segurança de acesso de código de Desativação faz com que o sistema vulnerável a ataques por código malicioso tais como vírus e worms. Desativar a segurança de acesso de código não bloqueia automaticamente código gerido a execução de qualquer forma. TI causas apenas código para executar sem restrição pelo sistema de segurança de acesso de código gerido e só devem ser feitas com o máximo é necessário ter muito cuidado. Desativar a segurança para obter um desempenho adicional só deve ser efetuada quando foram executadas outras medidas de segurança para ajudar a proteger a segurança do sistema. Exemplos de outras precauções de segurança incluem a desligar a partir de redes públicas, fisicamente proteger computadores e assim sucessivamente.       Uma alteração para esta propriedade não é continuada no registo até <xref:System.Security.SecurityManager.SavePolicy%2A>é chamado.</xref:System.Security.SecurityManager.SavePolicy%2A> Novos processos não serão afetados pela alteração até que este é continuada no registo. Alterar o valor desta propriedade num processo em execução não necessariamente alterar o estado da forma esperada. Para garantir que as alterações tenham sido aplicadas, tem de chamar <xref:System.Security.SecurityManager.SavePolicy%2A>e iniciar um processo de novo.</xref:System.Security.SecurityManager.SavePolicy%2A>"
  syntax:
    content: public static bool SecurityEnabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se estiver ativada a segurança; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Security.SecurityManager.SecurityEnabled*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O código que chama este método não tem <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref>."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.Security.Policy.PolicyException
  parent: System.Security.Policy
  isExternal: false
  name: PolicyException
  nameWithType: PolicyException
  fullName: System.Security.Policy.PolicyException
- uid: System.Security.SecurityManager.CheckExecutionRights
  parent: System.Security.SecurityManager
  isExternal: false
  name: CheckExecutionRights
  nameWithType: SecurityManager.CheckExecutionRights
  fullName: System.Security.SecurityManager.CheckExecutionRights
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture
  parent: System.Security.SecurityManager
  isExternal: false
  name: CurrentThreadRequiresSecurityContextCapture()
  nameWithType: SecurityManager.CurrentThreadRequiresSecurityContextCapture()
  fullName: System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture()
- uid: System.Security.SecurityManager.GetStandardSandbox(System.Security.Policy.Evidence)
  parent: System.Security.SecurityManager
  isExternal: false
  name: GetStandardSandbox(Evidence)
  nameWithType: SecurityManager.GetStandardSandbox(Evidence)
  fullName: System.Security.SecurityManager.GetStandardSandbox(Evidence)
- uid: System.Security.PermissionSet
  parent: System.Security
  isExternal: false
  name: PermissionSet
  nameWithType: PermissionSet
  fullName: System.Security.PermissionSet
- uid: System.Security.Policy.Evidence
  parent: System.Security.Policy
  isExternal: false
  name: Evidence
  nameWithType: Evidence
  fullName: System.Security.Policy.Evidence
- uid: System.Security.SecurityManager.GetZoneAndOrigin(System.Collections.ArrayList@,System.Collections.ArrayList@)
  parent: System.Security.SecurityManager
  isExternal: false
  name: GetZoneAndOrigin(ArrayList,ArrayList)
  nameWithType: SecurityManager.GetZoneAndOrigin(ArrayList,ArrayList)
  fullName: System.Security.SecurityManager.GetZoneAndOrigin(ArrayList,ArrayList)
- uid: System.Collections.ArrayList
  parent: System.Collections
  isExternal: false
  name: ArrayList
  nameWithType: ArrayList
  fullName: System.Collections.ArrayList
- uid: System.Security.SecurityManager.IsGranted(System.Security.IPermission)
  parent: System.Security.SecurityManager
  isExternal: false
  name: IsGranted(IPermission)
  nameWithType: SecurityManager.IsGranted(IPermission)
  fullName: System.Security.SecurityManager.IsGranted(IPermission)
- uid: System.Security.IPermission
  parent: System.Security
  isExternal: false
  name: IPermission
  nameWithType: IPermission
  fullName: System.Security.IPermission
- uid: System.Security.SecurityManager.LoadPolicyLevelFromFile(System.String,System.Security.PolicyLevelType)
  parent: System.Security.SecurityManager
  isExternal: false
  name: LoadPolicyLevelFromFile(String,PolicyLevelType)
  nameWithType: SecurityManager.LoadPolicyLevelFromFile(String,PolicyLevelType)
  fullName: System.Security.SecurityManager.LoadPolicyLevelFromFile(String,PolicyLevelType)
- uid: System.Security.Policy.PolicyLevel
  parent: System.Security.Policy
  isExternal: false
  name: PolicyLevel
  nameWithType: PolicyLevel
  fullName: System.Security.Policy.PolicyLevel
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Security.PolicyLevelType
  parent: System.Security
  isExternal: false
  name: PolicyLevelType
  nameWithType: PolicyLevelType
  fullName: System.Security.PolicyLevelType
- uid: System.Security.SecurityManager.LoadPolicyLevelFromString(System.String,System.Security.PolicyLevelType)
  parent: System.Security.SecurityManager
  isExternal: false
  name: LoadPolicyLevelFromString(String,PolicyLevelType)
  nameWithType: SecurityManager.LoadPolicyLevelFromString(String,PolicyLevelType)
  fullName: System.Security.SecurityManager.LoadPolicyLevelFromString(String,PolicyLevelType)
- uid: System.Security.SecurityManager.PolicyHierarchy
  parent: System.Security.SecurityManager
  isExternal: false
  name: PolicyHierarchy()
  nameWithType: SecurityManager.PolicyHierarchy()
  fullName: System.Security.SecurityManager.PolicyHierarchy()
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence)
  parent: System.Security.SecurityManager
  isExternal: false
  name: ResolvePolicy(Evidence)
  nameWithType: SecurityManager.ResolvePolicy(Evidence)
  fullName: System.Security.SecurityManager.ResolvePolicy(Evidence)
- uid: System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence[])
  parent: System.Security.SecurityManager
  isExternal: false
  name: ResolvePolicy(Evidence[])
  nameWithType: SecurityManager.ResolvePolicy(Evidence[])
  fullName: System.Security.SecurityManager.ResolvePolicy(Evidence[])
- uid: System.Security.Policy.Evidence[]
  parent: System.Security.Policy
  isExternal: false
  name: Evidence
  nameWithType: Evidence
  fullName: System.Security.Policy.Evidence[]
  spec.csharp:
  - uid: System.Security.Policy.Evidence
    name: Evidence
    nameWithType: Evidence
    fullName: Evidence[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet@)
  parent: System.Security.SecurityManager
  isExternal: false
  name: ResolvePolicy(Evidence,PermissionSet,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: SecurityManager.ResolvePolicy(Evidence,PermissionSet,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.Security.SecurityManager.ResolvePolicy(Evidence,PermissionSet,PermissionSet,PermissionSet,PermissionSet)
- uid: System.Security.SecurityManager.ResolvePolicyGroups(System.Security.Policy.Evidence)
  parent: System.Security.SecurityManager
  isExternal: false
  name: ResolvePolicyGroups(Evidence)
  nameWithType: SecurityManager.ResolvePolicyGroups(Evidence)
  fullName: System.Security.SecurityManager.ResolvePolicyGroups(Evidence)
- uid: System.Security.SecurityManager.ResolveSystemPolicy(System.Security.Policy.Evidence)
  parent: System.Security.SecurityManager
  isExternal: false
  name: ResolveSystemPolicy(Evidence)
  nameWithType: SecurityManager.ResolveSystemPolicy(Evidence)
  fullName: System.Security.SecurityManager.ResolveSystemPolicy(Evidence)
- uid: System.Security.SecurityManager.SavePolicy
  parent: System.Security.SecurityManager
  isExternal: false
  name: SavePolicy()
  nameWithType: SecurityManager.SavePolicy()
  fullName: System.Security.SecurityManager.SavePolicy()
- uid: System.Security.SecurityManager.SavePolicyLevel(System.Security.Policy.PolicyLevel)
  parent: System.Security.SecurityManager
  isExternal: false
  name: SavePolicyLevel(PolicyLevel)
  nameWithType: SecurityManager.SavePolicyLevel(PolicyLevel)
  fullName: System.Security.SecurityManager.SavePolicyLevel(PolicyLevel)
- uid: System.Security.SecurityManager.SecurityEnabled
  parent: System.Security.SecurityManager
  isExternal: false
  name: SecurityEnabled
  nameWithType: SecurityManager.SecurityEnabled
  fullName: System.Security.SecurityManager.SecurityEnabled
- uid: System.Security.SecurityManager.CheckExecutionRights*
  parent: System.Security.SecurityManager
  isExternal: false
  name: CheckExecutionRights
  nameWithType: SecurityManager.CheckExecutionRights
- uid: System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture*
  parent: System.Security.SecurityManager
  isExternal: false
  name: CurrentThreadRequiresSecurityContextCapture
  nameWithType: SecurityManager.CurrentThreadRequiresSecurityContextCapture
- uid: System.Security.SecurityManager.GetStandardSandbox*
  parent: System.Security.SecurityManager
  isExternal: false
  name: GetStandardSandbox
  nameWithType: SecurityManager.GetStandardSandbox
- uid: System.Security.SecurityManager.GetZoneAndOrigin*
  parent: System.Security.SecurityManager
  isExternal: false
  name: GetZoneAndOrigin
  nameWithType: SecurityManager.GetZoneAndOrigin
- uid: System.Security.SecurityManager.IsGranted*
  parent: System.Security.SecurityManager
  isExternal: false
  name: IsGranted
  nameWithType: SecurityManager.IsGranted
- uid: System.Security.SecurityManager.LoadPolicyLevelFromFile*
  parent: System.Security.SecurityManager
  isExternal: false
  name: LoadPolicyLevelFromFile
  nameWithType: SecurityManager.LoadPolicyLevelFromFile
- uid: System.Security.SecurityManager.LoadPolicyLevelFromString*
  parent: System.Security.SecurityManager
  isExternal: false
  name: LoadPolicyLevelFromString
  nameWithType: SecurityManager.LoadPolicyLevelFromString
- uid: System.Security.SecurityManager.PolicyHierarchy*
  parent: System.Security.SecurityManager
  isExternal: false
  name: PolicyHierarchy
  nameWithType: SecurityManager.PolicyHierarchy
- uid: System.Security.SecurityManager.ResolvePolicy*
  parent: System.Security.SecurityManager
  isExternal: false
  name: ResolvePolicy
  nameWithType: SecurityManager.ResolvePolicy
- uid: System.Security.SecurityManager.ResolvePolicyGroups*
  parent: System.Security.SecurityManager
  isExternal: false
  name: ResolvePolicyGroups
  nameWithType: SecurityManager.ResolvePolicyGroups
- uid: System.Security.SecurityManager.ResolveSystemPolicy*
  parent: System.Security.SecurityManager
  isExternal: false
  name: ResolveSystemPolicy
  nameWithType: SecurityManager.ResolveSystemPolicy
- uid: System.Security.SecurityManager.SavePolicy*
  parent: System.Security.SecurityManager
  isExternal: false
  name: SavePolicy
  nameWithType: SecurityManager.SavePolicy
- uid: System.Security.SecurityManager.SavePolicyLevel*
  parent: System.Security.SecurityManager
  isExternal: false
  name: SavePolicyLevel
  nameWithType: SecurityManager.SavePolicyLevel
- uid: System.Security.SecurityManager.SecurityEnabled*
  parent: System.Security.SecurityManager
  isExternal: false
  name: SecurityEnabled
  nameWithType: SecurityManager.SecurityEnabled
