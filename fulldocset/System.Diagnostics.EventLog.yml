### YamlMime:ManagedReference
items:
- uid: System.Diagnostics.EventLog
  id: EventLog
  children:
  - System.Diagnostics.EventLog.#ctor
  - System.Diagnostics.EventLog.#ctor(System.String)
  - System.Diagnostics.EventLog.#ctor(System.String,System.String)
  - System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)
  - System.Diagnostics.EventLog.BeginInit
  - System.Diagnostics.EventLog.Clear
  - System.Diagnostics.EventLog.Close
  - System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)
  - System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)
  - System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)
  - System.Diagnostics.EventLog.Delete(System.String)
  - System.Diagnostics.EventLog.Delete(System.String,System.String)
  - System.Diagnostics.EventLog.DeleteEventSource(System.String)
  - System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)
  - System.Diagnostics.EventLog.Dispose(System.Boolean)
  - System.Diagnostics.EventLog.EnableRaisingEvents
  - System.Diagnostics.EventLog.EndInit
  - System.Diagnostics.EventLog.Entries
  - System.Diagnostics.EventLog.EntryWritten
  - System.Diagnostics.EventLog.Exists(System.String)
  - System.Diagnostics.EventLog.Exists(System.String,System.String)
  - System.Diagnostics.EventLog.GetEventLogs
  - System.Diagnostics.EventLog.GetEventLogs(System.String)
  - System.Diagnostics.EventLog.Log
  - System.Diagnostics.EventLog.LogDisplayName
  - System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)
  - System.Diagnostics.EventLog.MachineName
  - System.Diagnostics.EventLog.MaximumKilobytes
  - System.Diagnostics.EventLog.MinimumRetentionDays
  - System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)
  - System.Diagnostics.EventLog.OverflowAction
  - System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)
  - System.Diagnostics.EventLog.Source
  - System.Diagnostics.EventLog.SourceExists(System.String)
  - System.Diagnostics.EventLog.SourceExists(System.String,System.String)
  - System.Diagnostics.EventLog.SynchronizingObject
  - System.Diagnostics.EventLog.WriteEntry(System.String)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  - System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])
  - System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  - System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])
  - System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  langs:
  - csharp
  name: EventLog
  nameWithType: EventLog
  fullName: System.Diagnostics.EventLog
  type: Class
  summary: "Permite a interação com registos de eventos do Windows."
  remarks: "Registo de eventos permite-lhe aceder ou personalizar os registos de eventos do Windows, que registam as informações sobre eventos importantes de software ou hardware. Utilizar o registo de eventos, pode ler a partir de registos existentes, escrever entradas de registos, criar ou eliminar origens de eventos, elimine os registos e responder a entradas de registo. Também pode criar novos registos durante a criação de uma origem de evento.      > [!IMPORTANT] > Este tipo implementa o <xref:System.IDisposable>interface.</xref:System.IDisposable> Quando tiver terminado com o tipo, deve eliminar-direta ou indiretamente. Para eliminar diretamente do tipo, chame o <xref:System.IDisposable.Dispose%2A>método um `try` / `catch` bloco.</xref:System.IDisposable.Dispose%2A> Para eliminar indiretamente dele, utilize uma construção de idioma, tais como `using` (em c#) ou `Using` (em Visual Basic). Para obter mais informações, consulte a secção &quot;Utilizar um objeto que implementa IDisposable&quot; o <xref:System.IDisposable>tópico de interface.</xref:System.IDisposable>       Além de fornecer acesso aos registos de eventos individuais e as respetivas entradas, a classe de registo de eventos permite-lhe aceder a coleção de todos os registos de eventos. Pode utilizar o `static` membros do registo de eventos para eliminar os registos, obter listas de registo, crie ou elimine uma origem ou determinar se um computador já contém uma origem específica.       Existem três registos de eventos de predefinição: aplicações, sistema e segurança. Um registo de segurança é só de leitura. Outras aplicações e serviços, que instalar, como o Active Directory, poderão ter registos de eventos adicionais.       Existem considerações de segurança quando utilizar a classe de registo de eventos. Registo de eventos requer <xref:System.Diagnostics.EventLogPermission>permissões para as ações específicas no .NET Framework 2.0 e versões posteriores, ou fidedignidade total no 1.0 de Framework .NET e 1.1.</xref:System.Diagnostics.EventLogPermission> Recomendamos que <xref:System.Diagnostics.EventLogPermission>não ser concedido ao código parcialmente fidedigno.</xref:System.Diagnostics.EventLogPermission>  Nunca deverá passar qualquer objeto de registo de eventos, incluindo <xref:System.Diagnostics.EventLogEntryCollection>e <xref:System.Diagnostics.EventLogEntry>objetos, para código menos fidedigno.</xref:System.Diagnostics.EventLogEntry> </xref:System.Diagnostics.EventLogEntryCollection> Por exemplo, criar um objeto de registo de eventos, escrever uma entrada e, em seguida, transmitir o registo de eventos objeto código parcialmente fidedigno pode criar um problema de segurança, porque a capacidade de ler e escrever no registo de eventos permite que o código para efetuar ações como emitir mensagens de registo de eventos no nome das outra aplicação.       A partir do Windows Vista, o controlo de conta de utilizador (UAC) determina as credenciais de um utilizador. Se for um membro do grupo Administradores incorporado, são atribuídos dois tokens de acesso de tempo de execução: um token de acesso de utilizador padrão e um token de acesso de administrador. Por predefinição, está na função de utilizador padrão. Para executar o código que acede ao registo de segurança, deve primeiro elevar as suas credenciais de utilizador padrão ao administrador. Para fazer isto quando iniciar uma aplicação, abrindo o menu de atalho para a aplicação (se estiver a utilizar um rato, clique com botão direito no ícone de aplicação) e com a indicação de que pretende executar como administrador.       Pode utilizar o registo de eventos para criar registos de eventos personalizados que pode ver através do Visualizador de eventos do servidor. Utilize o <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A>método para apresentar um nome para o registo de eventos localizado no Visualizador de eventos.</xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> Utilize o <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>método para configurar o comportamento do seu registo de eventos quando atinge o tamanho máximo do registo.</xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>       Para ler a partir de um registo de eventos, especifique o nome do registo (<xref:System.Diagnostics.EventLog.Log%2A> propriedade) e o nome de computador do servidor (<xref:System.Diagnostics.EventLog.MachineName%2A> propriedade para o registo de eventos.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> Se não especificar o nome de computador do servidor, o computador local, &quot;.&quot;, é assumido. Não é necessário especificar a origem do evento (<xref:System.Diagnostics.EventLog.Source%2A> propriedade), porque uma origem é necessária apenas para escrever nos registos.</xref:System.Diagnostics.EventLog.Source%2A> O <xref:System.Diagnostics.EventLog.Entries%2A>propriedade é preenchida automaticamente com lista o registo de eventos de entradas.</xref:System.Diagnostics.EventLog.Entries%2A>       Para escrever um registo de eventos, especifique ou crie uma origem de evento (<xref:System.Diagnostics.EventLog.Source%2A> propriedade).</xref:System.Diagnostics.EventLog.Source%2A> Tem de ter credenciais administrativas no computador para criar uma nova origem de evento. A origem do evento regista a aplicação com o registo de eventos como uma origem válida de entradas. Pode utilizar a origem do evento ao escrever no registo apenas um cada vez. O <xref:System.Diagnostics.EventLog.Source%2A>propriedade pode ser qualquer cadeia aleatória, mas o nome tem de ser diferente de outras origens no computador.</xref:System.Diagnostics.EventLog.Source%2A> A origem do evento é, geralmente, o nome da aplicação ou de outra cadeia de identificação. Tentativa de criar um duplicado <xref:System.Diagnostics.EventLog.Source%2A>valor emite uma exceção.</xref:System.Diagnostics.EventLog.Source%2A> No entanto, um único registo de eventos pode ser associado com várias origens.       Se a origem do evento para o registo de eventos associado a instância de registo de eventos não existir, é criada uma nova origem de evento. Para criar uma origem de evento no Windows Vista e posterior ou o Windows Server 2003, tem de ter credenciais administrativas.       Este requisito é porque todos os registos de eventos, incluindo registos de segurança, tem de ser procurados para determinar se a origem do evento é exclusiva. A partir do Windows Vista, os utilizadores não têm permissão para aceder ao registo de segurança; Por conseguinte, um <xref:System.Security.SecurityException>é emitida.</xref:System.Security.SecurityException>      > [!IMPORTANT] > Criar ou eliminar uma origem de evento requer sincronização do código subjacente através da utilização de uma exclusão mútua com nome. Se uma aplicação altamente privilegiada bloqueia a exclusão mútua com nome, a tentar criar ou eliminar uma origem de evento faz com que a aplicação deixar de responder até que o bloqueio é libertado. Para ajudar a evitar este problema, nunca conceder <xref:System.Security.Permissions.SecurityPermissionFlag>permissão para código não fidedigno.</xref:System.Security.Permissions.SecurityPermissionFlag> Além disso, <xref:System.Security.Permissions.SecurityPermissionFlag>permissão potencialmente permite outras permissões ser ignorada e só deve ser concedida ao código altamente fidedigno.</xref:System.Security.Permissions.SecurityPermissionFlag>       Aplicações e serviços devem escrever o registo de aplicação ou um registo personalizado. Controladores de dispositivo devem escrever o registo do sistema. Se não definir explicitamente a <xref:System.Diagnostics.EventLog.Log%2A>propriedade, as predefinições de registo de eventos no registo de aplicação.</xref:System.Diagnostics.EventLog.Log%2A>      > [!NOTE] > Não há nada para proteger uma aplicação de escrita como qualquer origem registada.  Se uma aplicação é concedida <xref:System.Diagnostics.EventLogPermissionAccess>permissão, pode escrever eventos no registo para qualquer registada no computador de origem válido.</xref:System.Diagnostics.EventLogPermissionAccess>       Utilize o <xref:System.Diagnostics.EventLog.WriteEvent%2A>e <xref:System.Diagnostics.EventLog.WriteEntry%2A>métodos para escrever eventos de um registo de eventos.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.WriteEvent%2A> Tem de especificar uma origem de evento para escrever eventos; tem de criar e configurar a origem do evento antes de escrever a entrada primeiro com a origem.       Crie a nova origem de evento durante a instalação da aplicação. Isto permite que o tempo para o sistema operativo atualizar a lista de origens de eventos registados e a respetiva configuração. Se o sistema operativo ainda não atualizado a respetiva lista de origens de eventos e tentar escrever um evento com a nova origem, que a operação de escrita irá falhar. Pode configurar uma nova origem utilizando um <xref:System.Diagnostics.EventLogInstaller>objeto ou a <xref:System.Diagnostics.EventLog.CreateEventSource%2A>método.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Tem de ter credenciais administrativas no computador para criar uma nova origem de evento.       Pode escrever apenas um registo de eventos cada origem de cada vez; No entanto, a aplicação pode utilizar várias origens para escrever vários registos de eventos. Por exemplo, a aplicação poderá necessitar de várias origens configuradas para diferentes registos de eventos ou ficheiros de recursos diferentes. Para alterar os detalhes da configuração de uma origem existente, tem de eliminar a origem e, em seguida, crie-a com a nova configuração. Se outras aplicações ou componentes utilizam a origem existente, crie uma nova origem com a configuração atualizada, em vez de eliminar a origem existente.       Pode registar a origem do evento com recursos localizados para as cadeias de categoria e mensagem de evento. A aplicação pode escrever entradas de registo de eventos utilizando identificadores de recursos em vez de especificar os valores de cadeia real. Consulte o <xref:System.Diagnostics.EventLogInstaller>e <xref:System.Diagnostics.EventSourceCreationData>classes para obter mais informações sobre como configurar a origem com ficheiros de recursos.</xref:System.Diagnostics.EventSourceCreationData> </xref:System.Diagnostics.EventLogInstaller>       Se a sua aplicação escreve valores de cadeia diretamente o registo de eventos, não dispõe de definir o recurso de propriedades de ficheiro para a origem. A origem tem de ser configurada para escrever entradas localizadas ou de escrita diretas cadeias. Se a sua aplicação escreve entradas utilizando identificadores de recursos e valores de cadeia, tem de registar duas origens separadas. Por exemplo, configurar uma origem com ficheiros de recursos e, em seguida, utilize essa origem no <xref:System.Diagnostics.EventLog.WriteEvent%2A>método escrever entradas utilizando identificadores de recursos para o registo de eventos.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Em seguida, criar uma origem diferente sem ficheiros de recursos e utilize essa origem no <xref:System.Diagnostics.EventLog.WriteEntry%2A>método escrever cadeias diretamente o registo de eventos através dessa origem.</xref:System.Diagnostics.EventLog.WriteEntry%2A>       Quando escrever eventos, tem de especificar, pelo menos, uma cadeia de mensagem ou o identificador de recurso para uma cadeia de mensagem. Outras propriedades de evento são opcionais. Os exemplos de definições de evento opcional incluem o seguinte:-pode definir o <xref:System.Diagnostics.EventLogEntryType>para especificar o ícone que apresenta o Visualizador de eventos para a entrada.</xref:System.Diagnostics.EventLogEntryType>      -Pode especificar um identificador de categoria para o evento, se a aplicação utiliza categorias para filtragem de eventos.      -Pode anexar dados binários para a entrada de evento se pretender associar informações adicionais um determinado evento.      > [!IMPORTANT] > Registo de eventos consome espaço em disco, tempo de processador e outros recursos do sistema. É importante iniciar sessão apenas com informações essenciais. Recomendamos que coloca chamadas de registo de eventos num caminho de erro, em vez do caminho de código principal, por isso, estes não afetem negativamente desempenho.       Para obter uma lista de valores de propriedade inicial para uma instância do registo de eventos, consulte o <xref:System.Diagnostics.EventLog.%23ctor%2A>construtor.</xref:System.Diagnostics.EventLog.%23ctor%2A>"
  example:
  - "The following example creates the event source `MySource` if it doesn't already exist, and writes an entry to the event log `MyNewLog`.  \n  \n> [!NOTE]\n>  Starting with Windows Vista, you must run this application as an administrator.  \n  \n [!code-cs[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/csharp/t-system.diagnostics.eve_0_1.cs)]\n [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/cpp/t-system.diagnostics.eve_0_1.cpp)]\n [!code-vb[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/visualbasic/t-system.diagnostics.eve_0_1.vb)]"
  syntax:
    content: >-
      [System.ComponentModel.DefaultEvent("EntryWritten")]

      [System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      [System.Diagnostics.MonitoringDescription("EventLogDesc")]

      public class EventLog : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements:
  - System.ComponentModel.ISupportInitialize
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.Site
  - System.ComponentModel.Component.ToString
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Diagnostics.EventLog.#ctor
  id: '#ctor'
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EventLog()
  nameWithType: EventLog.EventLog()
  fullName: System.Diagnostics.EventLog.EventLog()
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> classe. Associe a instância qualquer registo."
  remarks: "Antes de chamar <xref:System.Diagnostics.EventLog.WriteEntry%2A>, especifique o <xref:System.Diagnostics.EventLog.Source%2A>propriedade o <xref:System.Diagnostics.EventLog>instância.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> Se apenas ao ler <xref:System.Diagnostics.EventLog.Entries%2A>do registo, pode em alternativa especificar apenas o <xref:System.Diagnostics.EventLog.Log%2A>e <xref:System.Diagnostics.EventLog.MachineName%2A>Propriedades.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Entries%2A>      > [!NOTE] > Se não especificar um <xref:System.Diagnostics.EventLog.MachineName%2A>, o computador local (&quot;.&quot;) é assumido.</xref:System.Diagnostics.EventLog.MachineName%2A>       A tabela seguinte mostra os valores de propriedade inicial para uma instância do <xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog>      | Propriedade | Valor inicial |   |--------------|-------------------|   | <xref:System.Diagnostics.EventLog.Source%2A>| Uma cadeia vazia (&quot;&quot;). | | <xref:System.Diagnostics.EventLog.Log%2A>| Uma cadeia vazia (&quot;&quot;). | | <xref:System.Diagnostics.EventLog.MachineName%2A>| O computador local (&quot;.&quot;). |</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Source%2A>"
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_9_1.cs)]\n [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_9_1.cpp)]\n [!code-vb[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_9_1.vb)]"
  syntax:
    content: public EventLog ();
    parameters: []
  overload: System.Diagnostics.EventLog.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.#ctor(System.String)
  id: '#ctor(System.String)'
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EventLog(String)
  nameWithType: EventLog.EventLog(String)
  fullName: System.Diagnostics.EventLog.EventLog(String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> classe. Associa a instância de um registo no computador local."
  remarks: "Esta sobrecarga de define o <xref:System.Diagnostics.EventLog.Log%2A>propriedade para o `logName` parâmetro.</xref:System.Diagnostics.EventLog.Log%2A> Antes de chamar <xref:System.Diagnostics.EventLog.WriteEntry%2A>, especifique o <xref:System.Diagnostics.EventLog.Source%2A>propriedade o <xref:System.Diagnostics.EventLog>instância.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> Se apenas ao ler <xref:System.Diagnostics.EventLog.Entries%2A>do registo, pode em alternativa especificar apenas o <xref:System.Diagnostics.EventLog.Log%2A>e <xref:System.Diagnostics.EventLog.MachineName%2A>Propriedades.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Entries%2A>      > [!NOTE] > Se não especificar um <xref:System.Diagnostics.EventLog.MachineName%2A>, o computador local (&quot;.&quot;) é assumido.</xref:System.Diagnostics.EventLog.MachineName%2A> Esta sobrecarga do construtor Especifica o <xref:System.Diagnostics.EventLog.Log%2A>propriedade, mas pode alterar esta antes de ler o <xref:System.Diagnostics.EventLog.Entries%2A>propriedade.</xref:System.Diagnostics.EventLog.Entries%2A> </xref:System.Diagnostics.EventLog.Log%2A>       Se a origem especificar no <xref:System.Diagnostics.EventLog.Source%2A>propriedade é exclusiva de outras origens no computador, uma chamada subsequente para <xref:System.Diagnostics.EventLog.WriteEntry%2A>cria um registo com o nome especificado, se já existir.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A>       A tabela seguinte mostra os valores de propriedade inicial para uma instância do <xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog>      | Propriedade | Valor inicial |   |--------------|-------------------|   | <xref:System.Diagnostics.EventLog.Source%2A>| Uma cadeia vazia (&quot;&quot;). | | <xref:System.Diagnostics.EventLog.Log%2A>| O `logName` parâmetro. |   | <xref:System.Diagnostics.EventLog.MachineName%2A>| O computador local (&quot;.&quot;). |</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Source%2A>"
  example:
  - "The following example reads entries in the event log, \"myNewLog\", on the local computer.  \n  \n [!code-cpp[Classic EventLog.EventLog1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_13_1.cpp)]\n [!code-cs[Classic EventLog.EventLog1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_13_1.cs)]\n [!code-vb[Classic EventLog.EventLog1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_13_1.vb)]"
  syntax:
    content: public EventLog (string logName);
    parameters:
    - id: logName
      type: System.String
      description: "O nome do registo num computador local."
  overload: System.Diagnostics.EventLog.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "O nome do registo é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O nome do registo é inválido."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.#ctor(System.String,System.String)
  id: '#ctor(System.String,System.String)'
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EventLog(String,String)
  nameWithType: EventLog.EventLog(String,String)
  fullName: System.Diagnostics.EventLog.EventLog(String,String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> classe. Associa a instância de um registo no computador especificado."
  remarks: "Esta sobrecarga de define o <xref:System.Diagnostics.EventLog.Log%2A>propriedade para o `logName` parâmetro e o <xref:System.Diagnostics.EventLog.MachineName%2A>propriedade para o `machineName` parâmetro.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> Antes de chamar <xref:System.Diagnostics.EventLog.WriteEntry%2A>, especifique a <xref:System.Diagnostics.EventLog.Source%2A>propriedade de <xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> Se apenas ao ler <xref:System.Diagnostics.EventLog.Entries%2A>do registo, pode em alternativa especificar apenas o <xref:System.Diagnostics.EventLog.Log%2A>e <xref:System.Diagnostics.EventLog.MachineName%2A>Propriedades.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Entries%2A>      > [!NOTE] > Esta sobrecarga do construtor Especifica o <xref:System.Diagnostics.EventLog.Log%2A>e <xref:System.Diagnostics.EventLog.MachineName%2A>Propriedades, mas pode alterar o antes de ler o <xref:System.Diagnostics.EventLog.Entries%2A>propriedade.</xref:System.Diagnostics.EventLog.Entries%2A> </xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A>       A tabela seguinte mostra os valores de propriedade inicial para uma instância do <xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog>      | Propriedade | Valor inicial |   |--------------|-------------------|   | <xref:System.Diagnostics.EventLog.Source%2A>| Uma cadeia vazia (&quot;&quot;). | | <xref:System.Diagnostics.EventLog.Log%2A>| O `logName` parâmetro. |   | <xref:System.Diagnostics.EventLog.MachineName%2A>| O `machineName` parâmetro. |</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Source%2A>"
  example:
  - "The following example reads entries in the event log, \"myNewLog\", on the computer \"myServer\".  \n  \n [!code-cs[Classic EventLog.EventLog2 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_0_1.cs)]\n [!code-cpp[Classic EventLog.EventLog2 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_0_1.cpp)]\n [!code-vb[Classic EventLog.EventLog2 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_0_1.vb)]"
  syntax:
    content: public EventLog (string logName, string machineName);
    parameters:
    - id: logName
      type: System.String
      description: "O nome do registo num computador especificado."
    - id: machineName
      type: System.String
      description: "O computador no qual o registo existe."
  overload: System.Diagnostics.EventLog.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "O nome do registo é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O nome do registo é inválido.       - ou - o nome do computador é inválido."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)
  id: '#ctor(System.String,System.String,System.String)'
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EventLog(String,String,String)
  nameWithType: EventLog.EventLog(String,String,String)
  fullName: System.Diagnostics.EventLog.EventLog(String,String,String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> classe. Associa a instância de um registo no computador especificado e cria ou atribui a origem especificada para o <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref>."
  remarks: "Define a este construtor o <xref:System.Diagnostics.EventLog.Log%2A>propriedade para o `logName` parâmetro, a <xref:System.Diagnostics.EventLog.MachineName%2A>propriedade para o `machineName` parâmetro e o <xref:System.Diagnostics.EventLog.Source%2A>propriedade para o `source` parâmetro.</xref:System.Diagnostics.EventLog.Source%2A> </xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> A <xref:System.Diagnostics.EventLog.Source%2A>propriedade é necessária ao escrever um registo de eventos.</xref:System.Diagnostics.EventLog.Source%2A> No entanto, se forem só de leitura de um registo de eventos, apenas o <xref:System.Diagnostics.EventLog.Log%2A>e <xref:System.Diagnostics.EventLog.MachineName%2A>são necessárias as propriedades (desde que o registo de eventos no servidor tem uma origem associada já).</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> Se estiver apenas a leitura do registo de eventos, poderá suffice outra sobrecarga do construtor.       A tabela seguinte mostra os valores de propriedade inicial para uma instância do <xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog>      | Propriedade | Valor inicial |   |--------------|-------------------|   | <xref:System.Diagnostics.EventLog.Source%2A>| O `source` parâmetro. |   | <xref:System.Diagnostics.EventLog.Log%2A>| O `logName` parâmetro. |   | <xref:System.Diagnostics.EventLog.MachineName%2A>| O `machineName` parâmetro. |</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Source%2A>"
  example:
  - "The following example writes an entry to an event log, \"MyNewLog\", on the local computer, using the source \"MySource\".  \n  \n [!code-cs[Classic EventLog.EventLog3 Example#1](~/add/codesnippet/csharp/fd99d44e-2d79-45f8-97e3-_1.cs)]\n [!code-cpp[Classic EventLog.EventLog3 Example#1](~/add/codesnippet/cpp/fd99d44e-2d79-45f8-97e3-_1.cpp)]\n [!code-vb[Classic EventLog.EventLog3 Example#1](~/add/codesnippet/visualbasic/fd99d44e-2d79-45f8-97e3-_1.vb)]"
  syntax:
    content: public EventLog (string logName, string machineName, string source);
    parameters:
    - id: logName
      type: System.String
      description: "O nome do registo num computador especificado"
    - id: machineName
      type: System.String
      description: "O computador no qual o registo existe."
    - id: source
      type: System.String
      description: "A origem de entradas de registo de eventos."
  overload: System.Diagnostics.EventLog.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "O nome do registo é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O nome do registo é inválido.       - ou - o nome do computador é inválido."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.BeginInit
  id: BeginInit
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: BeginInit()
  nameWithType: EventLog.BeginInit()
  fullName: System.Diagnostics.EventLog.BeginInit()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Começa a inicialização de uma <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> utilizados num formulário ou utilizado por outro componente. A inicialização ocorre no tempo de execução."
  remarks: "O [!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)] design ambiente utiliza este método para iniciar a inicialização de um componente utilizado num formulário ou por outro componente. O <xref:System.Diagnostics.EventLog.EndInit%2A>método termina a inicialização.</xref:System.Diagnostics.EventLog.EndInit%2A> Utilizar o BeginInit e <xref:System.Diagnostics.EventLog.EndInit%2A>métodos impedem que o controlo que está a ser utilizada antes de ser completamente inicializada.</xref:System.Diagnostics.EventLog.EndInit%2A>"
  syntax:
    content: public void BeginInit ();
    parameters: []
  overload: System.Diagnostics.EventLog.BeginInit*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>já foi inicializado."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Clear
  id: Clear
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Clear()
  nameWithType: EventLog.Clear()
  fullName: System.Diagnostics.EventLog.Clear()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Remove todas as entradas do registo de eventos."
  remarks: "Registos de eventos estão definidos com um tamanho máximo que determina o número de entradas podem conter. Quando um registo de eventos está cheia, deixa de gravar novas informações de evento ou começa a substituir entradas anteriores. Se parar a gravação de eventos, pode utilizar este método para limpar o registo de entradas existentes e permitir que seja inicie novamente a gravação de eventos. Tem de ter permissões de administrador no computador no qual o registo reside para limpar entradas de registo de eventos.       Desmarque fecha o registo de eventos, disponibiliza os identificadores de evento, obtém novo de leitura e escrita identificadores e reopens o registo de eventos. Eventos recebidos após a chamada para o método não são eliminados, juntamente com os eventos existentes."
  example:
  - "The following example clears an event log.  \n  \n> [!CAUTION]\n>  Because Application, System, Security, and other non-custom logs can contain crucial information; be sure to specify a custom log before executing this example code. This example deletes the custom log `myNewLog`.  \n  \n [!code-cs[Classic EventLog.Clear Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_11_1.cs)]\n [!code-vb[Classic EventLog.Clear Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_11_1.vb)]\n [!code-cpp[Classic EventLog.Clear Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_11_1.cpp)]"
  syntax:
    content: public void Clear ();
    parameters: []
  overload: System.Diagnostics.EventLog.Clear*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O registo de eventos não foi limpo com êxito.       - ou - não é possível abrir o registo. Um código de erro do Windows não está disponível."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Não é especificado um valor para o <xref:System.Diagnostics.EventLog.Log*>propriedade.</xref:System.Diagnostics.EventLog.Log*> Certifique-se de que o nome do registo não é uma cadeia vazia."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O registo não existe."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Close
  id: Close
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Close()
  nameWithType: EventLog.Close()
  fullName: System.Diagnostics.EventLog.Close()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Fechar o registo de eventos e as versões de leitura e escrita identificadores."
  remarks: "O método Fechar é chamado pelo protegida <xref:System.ComponentModel.Component.Dispose%2A>método.</xref:System.ComponentModel.Component.Dispose%2A> Não é necessário invocar fechar antes de chamar <xref:System.ComponentModel.Component.Dispose%2A>.</xref:System.ComponentModel.Component.Dispose%2A>"
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Diagnostics.EventLog.Close*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Identificador do registo de eventos de leitura ou escrita identificador não foi lançada com êxito."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)
  id: CreateEventSource(System.Diagnostics.EventSourceCreationData)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: CreateEventSource(EventSourceCreationData)
  nameWithType: EventLog.CreateEventSource(EventSourceCreationData)
  fullName: System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Estabelece uma origem de evento válido para escrever eventos localizados mensagens, utilizando as propriedades de configuração especificado para a origem do evento e o registo de eventos correspondente."
  remarks: "Use this overload to configure a new source for writing entries to an event log on the local computer or a remote computer. It is not necessary to use this method to read from an event log.  \n  \n The CreateEventSource method uses the input `sourceData`<xref:System.Diagnostics.EventSourceCreationData.Source%2A>, <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> and <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> properties to create registry values on the target computer for the new source and its associated event log. A new source name cannot match an existing source name or an existing event log name on the target computer. If the <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> property is not set, the source is registered for the Application event log. If the <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> is not set, the source is registered on the local computer.  \n  \n> [!NOTE]\n>  To create an event source in Windows Vista and later or Windows Server 2003, you must have administrative privileges.  \n>   \n>  The reason for this requirement is that all event logs, including security, must be searched to determine whether the event source is unique. Starting with Windows Vista, users do not have permission to access the security log; therefore, a <xref:System.Security.SecurityException> is thrown.  \n>   \n>  Starting with Windows Vista, User Account Control (UAC) determines the privileges of a user. If you are a member of the Built-in Administrators group, you are assigned two run-time access tokens: a standard user access token and an administrator access token. By default, you are in the standard user role. To execute the code that accesses the security log, you must first elevate your privileges from standard user to administrator. You can do this when you start an application by right-clicking the application icon and indicating that you want to run as an administrator.  \n  \n Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> and <xref:System.Diagnostics.EventLog.WriteEntry%2A> to write events to an event log. You must specify an event source to write events; you must create and configure the event source before writing the first entry with the source.  \n  \n Create the new event source during the installation of your application. This allows time for the operating system to refresh its list of registered event sources and their configuration. If the operating system has not refreshed its list of event sources, and you attempt to write an event with the new source, the write operation will fail. You can configure a new source using an <xref:System.Diagnostics.EventLogInstaller>, or using the <xref:System.Diagnostics.EventLog.CreateEventSource%2A> method. You must have administrative rights on the computer to create a new event source.  \n  \n You can create an event source for an existing event log or a new event log. When you create a new source for a new event log, the system registers the source for that log, but the log is not created until the first entry is written to it.  \n  \n The operating system stores event logs as files. When you use <xref:System.Diagnostics.EventLogInstaller> or <xref:System.Diagnostics.EventLog.CreateEventSource%2A> to create a new event log, the associated file is stored in the %SystemRoot%\\System32\\Config directory on the specified computer. The file name is set by appending the first 8 characters of the <xref:System.Diagnostics.EventLog.Log%2A> property with the \".evt\" file name extension.  \n  \n Each source can only write to only one event log at a time; however, your application can use multiple sources to write to multiple event logs. For example, your application might require multiple sources configured for different event logs or different resource files.  \n  \n You can register the event source with localized resource file(s) for your event category and message strings. Your application can write event log entries using resource identifiers, rather than specifying the actual string. The Event Viewer uses the resource identifier to find and display the corresponding string from the localized resource file based on current language settings. You can register a separate file for event categories, messages and parameter insertion strings, or you can register the same resource file for all three types of strings. Use the <xref:System.Diagnostics.EventSourceCreationData.CategoryCount%2A>, <xref:System.Diagnostics.EventSourceCreationData.CategoryResourceFile%2A>, <xref:System.Diagnostics.EventSourceCreationData.MessageResourceFile%2A>, and <xref:System.Diagnostics.EventSourceCreationData.ParameterResourceFile%2A> properties to configure the source to write localized entries to the event log. If your application writes strings values directly to the event log, you do not need to set these properties.  \n  \n The source must be configured either for writing localized entries or for writing direct strings. If your application writes entries using both resource identifiers and string values, you must register two separate sources. For example, configure one source with resource files, and then use that source in the <xref:System.Diagnostics.EventLog.WriteEvent%2A> method to write entries using resource identifiers to the event log. Then create a different source without resource files, and use that source in the <xref:System.Diagnostics.EventLog.WriteEntry%2A> method to write strings directly to the event log using that source.  \n  \n To change the configuration details of an existing source, you must delete the source and then create it with the new configuration. If other applications or components use the existing source, create a new source with the updated configuration rather than deleting the existing source.  \n  \n> [!NOTE]\n>  If a source is configured for an event log, and you reconfigure it for another event log, you must restart the computer for the changes to take effect."
  example:
  - "The following example determines whether the event source named `SampleApplicationSource` is registered on the local computer. If the event source does not exist, the example sets the message resource file for the source and creates the new event source. Finally, the example sets the localized display name for the event log, using the resource identifier value in `DisplayNameMsgId` and the resource file path in `messageFile`.  \n  \n [!code-cpp[EventLog_WriteEvent#6](~/add/codesnippet/cpp/4fd418fb-73e7-42a9-9ba2-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#6](~/add/codesnippet/visualbasic/4fd418fb-73e7-42a9-9ba2-_1.vb)]\n [!code-cs[EventLog_WriteEvent#6](~/add/codesnippet/csharp/4fd418fb-73e7-42a9-9ba2-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings. Specifically, resource identifier 5001 is defined for the localized name of the event log.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public static void CreateEventSource (System.Diagnostics.EventSourceCreationData sourceData);
    parameters:
    - id: sourceData
      type: System.Diagnostics.EventSourceCreationData
      description: "As propriedades de configuração para a origem do evento e o respetivo registo de eventos de destino."
  overload: System.Diagnostics.EventLog.CreateEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The computer name specified in <code>sourceData</code> is not valid.  \n  \n \\- or -  \n  \n The source name specified in <code>sourceData</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The log name specified in <code>sourceData</code> is not valid. Event log names must consist of printable characters and cannot include the characters '*', '?', or '\\\\'.  \n  \n \\- or -  \n  \n The log name specified in <code>sourceData</code> is not valid for user log creation. The Event log names AppEvent, SysEvent, and SecEvent are reserved for system use.  \n  \n \\- or -  \n  \n The log name matches an existing event source name.  \n  \n \\- or -  \n  \n The source name specified in <code>sourceData</code> results in a registry key path longer than 254 characters.  \n  \n \\- or -  \n  \n The first 8 characters of the log name specified in <code>sourceData</code> are not unique.  \n  \n \\- or -  \n  \n The source name specified in <code>sourceData</code> is already registered.  \n  \n \\- or -  \n  \n The source name specified in <code>sourceData</code> matches an existing event log name."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave de registo para o registo de eventos."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>sourceData</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)
  id: CreateEventSource(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: CreateEventSource(String,String)
  nameWithType: EventLog.CreateEventSource(String,String)
  fullName: System.Diagnostics.EventLog.CreateEventSource(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Estabelece o nome de origem especificada como uma origem de evento válido para escrever entradas de um registo no computador local. Este método também pode criar um novo registo personalizado no computador local."
  remarks: "Use this overload to create a custom log or to create and register a <xref:System.Diagnostics.EventLog.Source%2A> to an existing log on the local computer.  \n  \n If `logName` is `null` or an empty string (\"\") when you call <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, the log defaults to the Application log. If the log does not exist on the local computer, the system creates a custom log and registers your application as a <xref:System.Diagnostics.EventLog.Source%2A> for that log.  \n  \n> [!NOTE]\n>  To create an event source in Windows Vista and later or Windows Server 2003, you must have administrative privileges.  \n>   \n>  The reason for this requirement is that all event logs, including security, must be searched to determine whether the event source is unique. Starting with Windows Vista, users do not have permission to access the security log; therefore, a <xref:System.Security.SecurityException> is thrown.  \n>   \n>  In Windows Vista and later, User Account Control (UAC) determines the privileges of a user. If you are a member of the Built-in Administrators group, you are assigned two run-time access tokens: a standard user access token and an administrator access token. By default, you are in the standard user role. To execute the code that accesses the security log, you must first elevate your privileges from standard user to administrator. You can do this when you start an application by right-clicking the application icon and indicating that you want to run as an administrator.  \n  \n You only need to create an event source if you are writing to the event log. Before writing an entry to an event log, you must register the event source with the event log as a valid source of events. When you write a log entry, the system uses the <xref:System.Diagnostics.EventLog.Source%2A> to find the appropriate log in which to place your entry. If you are reading the event log, you can either specify the <xref:System.Diagnostics.EventLog.Source%2A>, or a <xref:System.Diagnostics.EventLog.Log%2A> and <xref:System.Diagnostics.EventLog.MachineName%2A>.  \n  \n> [!NOTE]\n>  You are not required to specify the <xref:System.Diagnostics.EventLog.MachineName%2A> if you are connecting to a log on the local computer. If you do not specify the <xref:System.Diagnostics.EventLog.MachineName%2A> when reading from a log, the local computer (\".\") is assumed.  \n  \n Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> and <xref:System.Diagnostics.EventLog.WriteEntry%2A> to write events to an event log. You must specify an event source to write events; you must create and configure the event source before writing the first entry with the source.  \n  \n Create the new event source during the installation of your application. This allows time for the operating system to refresh its list of registered event sources and their configuration. If the operating system has not refreshed its list of event sources, and you attempt to write an event with the new source, the write operation will fail. You can configure a new source using an <xref:System.Diagnostics.EventLogInstaller>, or using the <xref:System.Diagnostics.EventLog.CreateEventSource%2A> method. You must have administrative rights on the computer to create a new event source.  \n  \n You can create an event source for an existing event log or a new event log. When you create a new source for a new event log, the system registers the source for that log, but the log is not created until the first entry is written to it.  \n  \n The operating system stores event logs as files. When you use <xref:System.Diagnostics.EventLogInstaller> or <xref:System.Diagnostics.EventLog.CreateEventSource%2A> to create a new event log, the associated file is stored in the %SystemRoot%\\System32\\Config directory on the specified computer. The file name is set by appending the first 8 characters of the <xref:System.Diagnostics.EventLog.Log%2A> property with the \".evt\" file name extension.  \n  \n The source must be unique on the local computer; a new source name cannot match an existing source name or an existing event log name. Each source can write to only one event log at a time; however, your application can use multiple sources to write to multiple event logs. For example, your application might require multiple sources configured for different event logs or different resource files.  \n  \n The source must be configured either for writing localized entries or for writing direct strings. If your application writes entries using both resource identifiers and string values, you must register two separate sources. For example, configure one source with resource files, and then use that source in the <xref:System.Diagnostics.EventLog.WriteEvent%2A> method to write entries using resource identifiers to the event log. Then create a different source without resource files, and use that source in the <xref:System.Diagnostics.EventLog.WriteEntry%2A> method to write strings directly to the event log using that source.  \n  \n To change the configuration details of an existing source, you must delete the source and then create it with the new configuration. If other applications or components use the existing source, create a new source with the updated configuration rather than deleting the existing source.  \n  \n> [!NOTE]\n>  If a source has already been mapped to a log and you remap it to a new log, you must restart the computer for the changes to take effect."
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_15_1.cs)]\n [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_15_1.cpp)]\n [!code-vb[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_15_1.vb)]"
  syntax:
    content: public static void CreateEventSource (string source, string logName);
    parameters:
    - id: source
      type: System.String
      description: "O nome de origem através do qual a aplicação está registada no computador local."
    - id: logName
      type: System.String
      description: "O nome do registo de entradas de origem são escritas para. Os valores possíveis incluem aplicações, sistema ou um registo de eventos personalizado."
  overload: System.Diagnostics.EventLog.CreateEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>source</code> is an empty string (\"\") or <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>logName</code> is not a valid event log name. Event log names must consist of printable characters, and cannot include the characters '*', '?', or '\\\\'.  \n  \n \\- or -  \n  \n <code>logName</code> is not valid for user log creation. The event log names AppEvent, SysEvent, and SecEvent are reserved for system use.  \n  \n \\- or -  \n  \n The log name matches an existing event source name.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters.  \n  \n \\- or -  \n  \n The first 8 characters of <code>logName</code> match the first 8 characters of an existing event log name.  \n  \n \\- or -  \n  \n The source cannot be registered because it already exists on the local computer.  \n  \n \\- or -  \n  \n The source name matches an existing event log name."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave de registo para o registo de eventos no computador local."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)
  id: CreateEventSource(System.String,System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: CreateEventSource(String,String,String)
  nameWithType: EventLog.CreateEventSource(String,String,String)
  fullName: System.Diagnostics.EventLog.CreateEventSource(String,String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Estabelece o nome de origem especificada como uma origem de evento válido para escrever entradas de um registo no computador especificado. Este método também pode ser utilizado para criar um novo registo personalizado no computador especificado."
  remarks: "Use this overload to create a custom log or to create and register a <xref:System.Diagnostics.EventLog.Source%2A> to an existing log on the specified computer.  \n  \n If `logName` is `null` or an empty string (\"\") when you call <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, the log defaults to the Application log. If the log does not exist on the specified computer, the system creates a custom log and registers your application as a <xref:System.Diagnostics.EventLog.Source%2A> for that log.  \n  \n You only need to create an event source if you are writing to the event log. Before writing an entry to an event log, you must register the event source with the event log as a valid source of events. When you write a log entry, the system uses the <xref:System.Diagnostics.EventLog.Source%2A> to find the appropriate log in which to place your entry. If you are reading the event log, you can either specify the <xref:System.Diagnostics.EventLog.Source%2A>, or a <xref:System.Diagnostics.EventLog.Log%2A> and <xref:System.Diagnostics.EventLog.MachineName%2A>.  \n  \n> [!NOTE]\n>  To create an event source in Windows Vista and later or Windows Server 2003, you must have administrative privileges.  \n>   \n>  The reason for this requirement is that all event logs, including security, must be searched to determine whether the event source is unique. In Windows Vista and later, users do not have permission to access the security log; therefore, a <xref:System.Security.SecurityException> is thrown.  \n>   \n>  In Windows Vista and later, User Account Control (UAC) determines the privileges of a user. If you are a member of the Built-in Administrators group, you are assigned two run-time access tokens: a standard user access token and an administrator access token. By default, you are in the standard user role. To execute the code that accesses the security log, you must first elevate your privileges from standard user to administrator. You can do this when you start an application by right-clicking the application icon and indicating that you want to run as an administrator.  \n  \n Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> and <xref:System.Diagnostics.EventLog.WriteEntry%2A> to write events to an event log. You must specify an event source to write events; you must create and configure the event source before writing the first entry with the source.  \n  \n Create the new event source during the installation of your application. This allows time for the operating system to refresh its list of registered event sources and their configuration. If the operating system has not refreshed its list of event sources, and you attempt to write an event with the new source, the write operation will fail. You can configure a new source using an <xref:System.Diagnostics.EventLogInstaller>, or using the <xref:System.Diagnostics.EventLog.CreateEventSource%2A> method. You must have administrative rights on the computer to create a new event source.  \n  \n You can create an event source for an existing event log or a new event log. When you create a new source for a new event log, the system registers the source for that log, but the log is not created until the first entry is written to it.  \n  \n The operating system stores event logs as files. When you use <xref:System.Diagnostics.EventLogInstaller> or <xref:System.Diagnostics.EventLog.CreateEventSource%2A> to create a new event log, the associated file is stored in the %SystemRoot%\\System32\\Config directory on the specified computer. The file name is set by appending the first 8 characters of the <xref:System.Diagnostics.EventLog.Log%2A> property with the \".evt\" file name extension.  \n  \n The source must be unique on the local computer; a new source name cannot match an existing source name or an existing event log name. Each source can write to only one event log at a time; however, your application can use multiple sources to write to multiple event logs. For example, your application might require multiple sources configured for different event logs or different resource files.  \n  \n The source must be configured either for writing localized entries or for writing direct strings. If your application writes entries using both resource identifiers and string values, you must register two separate sources. For example, configure one source with resource files, and then use that source in the <xref:System.Diagnostics.EventLog.WriteEvent%2A> method to write entries using resource identifiers to the event log. Then create a different source without resource files, and use that source in the <xref:System.Diagnostics.EventLog.WriteEntry%2A> method to write strings directly to the event log using that source.  \n  \n To change the configuration details of an existing source, you must delete the source and then create it with the new configuration. If other applications or components use the existing source, create a new source with the updated configuration rather than deleting the existing source.  \n  \n> [!NOTE]\n>  If a source has already been mapped to a log and you remap it to a new log, you must restart the computer for the changes to take effect."
  example:
  - "The following example creates the source `MySource` on the computer `MyServer`, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/cpp/86732307-05e6-4c1a-b98e-_1.cpp)]\n [!code-cs[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/csharp/86732307-05e6-4c1a-b98e-_1.cs)]\n [!code-vb[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/visualbasic/86732307-05e6-4c1a-b98e-_1.vb)]"
  syntax:
    content: public static void CreateEventSource (string source, string logName, string machineName);
    parameters:
    - id: source
      type: System.String
      description: "A origem através do qual a aplicação está registada no computador especificado."
    - id: logName
      type: System.String
      description: "O nome do registo de entradas de origem são escritas para. Os valores possíveis incluem aplicações, sistema ou um registo de eventos personalizado. Se não especificar um valor, `logName` as predefinições de aplicação."
    - id: machineName
      type: System.String
      description: "O nome do computador para registar esta origem de evento, ou &quot;.&quot; para o computador local."
  overload: System.Diagnostics.EventLog.CreateEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>machineName</code> is not a valid computer name.  \n  \n \\- or -  \n  \n <code>source</code> is an empty string (\"\") or <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>logName</code> is not a valid event log name. Event log names must consist of printable characters, and cannot include the characters '*', '?', or '\\\\'.  \n  \n \\- or -  \n  \n <code>logName</code> is not valid for user log creation. The event log names AppEvent, SysEvent, and SecEvent are reserved for system use.  \n  \n \\- or -  \n  \n The log name matches an existing event source name.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters.  \n  \n \\- or -  \n  \n The first 8 characters of <code>logName</code> match the first 8 characters of an existing event log name on the specified computer.  \n  \n \\- or -  \n  \n The source cannot be registered because it already exists on the specified computer.  \n  \n \\- or -  \n  \n The source name matches an existing event source name."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave de registo para o registo de eventos no computador especificado."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Delete(System.String)
  id: Delete(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Delete(String)
  nameWithType: EventLog.Delete(String)
  fullName: System.Diagnostics.EventLog.Delete(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Remove um registo de eventos do computador local."
  remarks: "Utilize este método quando o registo que pretende eliminar está no computador local. Pode eliminar qualquer registo no computador, desde que tem as permissões de registo adequados.       Eliminar remove o registo especificado pelo `logName` do computador local. Se pretender eliminar apenas a origem registada um registo, chamar <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> Se apenas pretender eliminar as entradas de registo, chamar <xref:System.Diagnostics.EventLog.Clear%2A>.</xref:System.Diagnostics.EventLog.Clear%2A> Eliminar e <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>são `static` métodos, pelo que pode ser chamados na classe de si próprio.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> Não é necessário criar uma nova instância do <xref:System.Diagnostics.EventLog>para chamar o método.</xref:System.Diagnostics.EventLog>       O método Delete elimina primeiro o ficheiro que contém o conteúdo do registo. Em seguida, acede ao registo e remove todas as origens de eventos registadas para esse registo. Se a recriar o registo posteriormente, deve registar as origens de eventos novamente, se estão a ser reutilizadas. Se não registar as origens de eventos e outros utilizadores de escrita para uma origem de evento sem especificar um nome de registo, será criada a origem do evento no registo de eventos de aplicações. Por conseguinte, as aplicações que foram anteriormente conseguir escrever entradas no registo eliminado e recriado irão escrever no registo de aplicação em vez disso, porque contém agora a origem do evento.      > [!NOTE] > Recriar um registo de eventos pode ser um processo difícil. Evite a eliminação de alguns dos registos de eventos criados pelo sistema, tais como o registo de aplicações.       Eliminar um registo através de uma chamada para eliminar automaticamente elimina as origens registadas para esse registo. Isto pode fazer com outras aplicações utilizando esse registo não operacionais."
  example:
  - "The following example deletes a log from the local computer. The example determines the log from its source.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_12_1.cpp)]\n [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_12_1.vb)]\n [!code-cs[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_12_1.cs)]"
  syntax:
    content: public static void Delete (string logName);
    parameters:
    - id: logName
      type: System.String
      description: 'O nome do registo a eliminar. Os valores possíveis incluem: aplicação, segurança, sistema e quaisquer registos de eventos personalizados no computador.'
  overload: System.Diagnostics.EventLog.Delete*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>logName</code>é uma cadeia vazia (&quot;&quot;) ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The registry key for the event log could not be opened on the local computer.  \n  \n \\- or -  \n  \n The log does not exist on the local computer."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O registo de eventos não foi limpo com êxito.       - ou - não é possível abrir o registo. Um código de erro do Windows não está disponível."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Delete(System.String,System.String)
  id: Delete(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Delete(String,String)
  nameWithType: EventLog.Delete(String,String)
  fullName: System.Diagnostics.EventLog.Delete(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Remove um registo de eventos do computador especificado."
  remarks: "Utilize este método quando o registo que pretende eliminar está num computador remoto. Pode eliminar qualquer registo no computador, desde que tem as permissões de registo adequados.       <xref:System.Diagnostics.EventLog.Delete%2A>Remove o registo especificado pelo `logName` do computador especificado pelo `machineName`.</xref:System.Diagnostics.EventLog.Delete%2A> Se pretender eliminar apenas a origem registada um registo, chamar <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> Se apenas pretender eliminar as entradas de registo, chamar <xref:System.Diagnostics.EventLog.Clear%2A>.</xref:System.Diagnostics.EventLog.Clear%2A> <xref:System.Diagnostics.EventLog.Delete%2A>e <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>são `static` métodos, pelo que pode ser chamados na classe de si próprio.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A></xref:System.Diagnostics.EventLog.Delete%2A> Não é necessário criar uma instância de <xref:System.Diagnostics.EventLog>para chamar o método.</xref:System.Diagnostics.EventLog>       Este método elimina primeiro o ficheiro que contém o conteúdo do registo. Em seguida, acede ao registo e remove todas as origens de eventos registadas para esse registo. Se a recriar o registo posteriormente, deve registar as origens de eventos novamente, se estão a ser reutilizadas. Se não registar as origens de eventos e outros utilizadores de escrita para uma origem de evento sem especificar um nome de registo, será criada a origem do evento no registo de eventos de aplicações. Por conseguinte, as aplicações que foram anteriormente conseguir escrever entradas no registo eliminado e recriado irão escrever no registo de aplicação em vez disso, porque contém agora a origem do evento.      > [!NOTE] > Recriar um registo de eventos pode ser um processo difícil. Evite a eliminação de alguns dos registos de eventos criados pelo sistema, tais como o registo de aplicações.       Eliminar um registo através de uma chamada para <xref:System.Diagnostics.EventLog.Delete%2A>elimina automaticamente as origens registadas desse registo.</xref:System.Diagnostics.EventLog.Delete%2A> Isto pode fazer com outras aplicações utilizando esse registo não operacionais."
  example:
  - "The following example deletes a log from the specified computer. The example determines the log from its source.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cs[Classic EventLog.Delete1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_17_1.cs)]\n [!code-cpp[Classic EventLog.Delete1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_17_1.cpp)]\n [!code-vb[Classic EventLog.Delete1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_17_1.vb)]"
  syntax:
    content: public static void Delete (string logName, string machineName);
    parameters:
    - id: logName
      type: System.String
      description: 'O nome do registo a eliminar. Os valores possíveis incluem: aplicação, segurança, sistema e quaisquer registos de eventos personalizados no computador especificado.'
    - id: machineName
      type: System.String
      description: "O nome do computador para eliminar o registo, ou &quot;.&quot; para o computador local."
  overload: System.Diagnostics.EventLog.Delete*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>logName</code> is an empty string (\"\") or <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>machineName</code> is not a valid computer name."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The registry key for the event log could not be opened on the specified computer.  \n  \n \\- or -  \n  \n The log does not exist on the specified computer."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O registo de eventos não foi limpo com êxito.       - ou - não é possível abrir o registo. Um código de erro do Windows não está disponível."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.DeleteEventSource(System.String)
  id: DeleteEventSource(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: DeleteEventSource(String)
  nameWithType: EventLog.DeleteEventSource(String)
  fullName: System.Diagnostics.EventLog.DeleteEventSource(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Remove o registo de origem do evento do registo de eventos no computador local."
  remarks: "Utilize este método para remover o registo de um <xref:System.Diagnostics.EventLog.Source%2A>do computador local.</xref:System.Diagnostics.EventLog.Source%2A> DeleteEventSource acede ao registo no computador local e remove o registo da aplicação como uma origem válida de eventos.       Pode remover o seu componente como uma origem válida de eventos se que já não é necessária para escrever entradas para esse registo. Por exemplo, pode fazê-se precisar de alterar o seu componente do registo de um para outro. Porque só pode ser registada um registo de uma origem de cada vez, alterar o registo requer a remover o registo atual.       DeleteEventSource remove apenas a origem registada um registo. Se pretender remover o registo de si próprio, chamar <xref:System.Diagnostics.EventLog.Delete%2A>.</xref:System.Diagnostics.EventLog.Delete%2A> Se apenas pretender eliminar as entradas de registo, chamar <xref:System.Diagnostics.EventLog.Clear%2A>.</xref:System.Diagnostics.EventLog.Clear%2A> <xref:System.Diagnostics.EventLog.Delete%2A>e são DeleteEventSource `static` métodos, pelo que pode ser chamados na classe de si próprio.</xref:System.Diagnostics.EventLog.Delete%2A> Não é necessário criar uma instância de <xref:System.Diagnostics.EventLog>para chamar o método.</xref:System.Diagnostics.EventLog>       Eliminar um registo através de uma chamada para <xref:System.Diagnostics.EventLog.Delete%2A>elimina automaticamente as origens registadas desse registo.</xref:System.Diagnostics.EventLog.Delete%2A> Isto pode fazer com outras aplicações utilizando esse registo não operacionais.      > [!NOTE] > Se uma origem já foi mapeada para um registo e remapeá-lo para um novo registo, tem de reiniciar o computador para que as alterações entrem em vigor."
  example:
  - "The following example deletes a source from the local computer. The example determines the log from its source, and then deletes the log.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_8_1.cpp)]\n [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_8_1.vb)]\n [!code-cs[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_8_1.cs)]"
  syntax:
    content: public static void DeleteEventSource (string source);
    parameters:
    - id: source
      type: System.String
      description: "O nome pelo qual a aplicação está registada no sistema de registo de eventos."
  overload: System.Diagnostics.EventLog.DeleteEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> parameter does not exist in the registry of the local computer.  \n  \n \\- or -  \n  \n You do not have write access on the registry key for the event log."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)
  id: DeleteEventSource(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: DeleteEventSource(String,String)
  nameWithType: EventLog.DeleteEventSource(String,String)
  fullName: System.Diagnostics.EventLog.DeleteEventSource(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Remove o registo da origem de eventos da aplicação do computador especificado."
  remarks: "Utilize esta sobrecarga para remover o registo de um <xref:System.Diagnostics.EventLog.Source%2A>de um computador remoto.</xref:System.Diagnostics.EventLog.Source%2A> <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>acede ao registo no computador especificado pelo `machineName` e remove o registo da aplicação como uma origem válida de eventos.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A>       Pode remover o seu componente como uma origem válida de eventos se que já não é necessária para escrever entradas para esse registo. Por exemplo, pode fazê-se precisar de alterar o seu componente do registo de um para outro. Porque só pode ser registada um registo de uma origem de cada vez, alterar o registo requer a remover o registo atual.       <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>Remove apenas a origem registada um registo.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> Se pretender remover o registo de si próprio, chamar <xref:System.Diagnostics.EventLog.Delete%2A>.</xref:System.Diagnostics.EventLog.Delete%2A> Se apenas pretender eliminar as entradas de registo, chamar <xref:System.Diagnostics.EventLog.Clear%2A>.</xref:System.Diagnostics.EventLog.Clear%2A> <xref:System.Diagnostics.EventLog.Delete%2A>e <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>são `static` métodos, pelo que pode ser chamados na classe de si próprio.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A></xref:System.Diagnostics.EventLog.Delete%2A> Não é necessário criar uma instância de <xref:System.Diagnostics.EventLog>para chamar o método.</xref:System.Diagnostics.EventLog>       Eliminar um registo através de uma chamada para <xref:System.Diagnostics.EventLog.Delete%2A>elimina automaticamente as origens registadas desse registo.</xref:System.Diagnostics.EventLog.Delete%2A> Isto pode fazer com outras aplicações utilizando esse registo não operacionais.      > [!NOTE] > Se uma origem já foi mapeada para um registo e remapeá-lo para um novo registo, tem de reiniciar o computador para que as alterações entrem em vigor."
  example:
  - "The following example deletes a source from the specified computer. The example determines the log from its source, and then deletes the log.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cs[Classic EventLog.Delete1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_6_1.cs)]\n [!code-cpp[Classic EventLog.Delete1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_6_1.cpp)]\n [!code-vb[Classic EventLog.Delete1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_6_1.vb)]"
  syntax:
    content: public static void DeleteEventSource (string source, string machineName);
    parameters:
    - id: source
      type: System.String
      description: "O nome pelo qual a aplicação está registada no sistema de registo de eventos."
    - id: machineName
      type: System.String
      description: "O nome do computador para remover o registo, ou &quot;.&quot; para o computador local."
  overload: System.Diagnostics.EventLog.DeleteEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>machineName</code> parameter is invalid.  \n  \n \\- or -  \n  \n The <code>source</code> parameter does not exist in the registry of the specified computer.  \n  \n \\- or -  \n  \n You do not have write access on the registry key for the event log."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>source</code>não pode ser eliminada porque no registo, a chave de registo principal para <code>source</code> não contém uma subchave de com o mesmo nome."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: EventLog.Dispose(Boolean)
  fullName: System.Diagnostics.EventLog.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Liberta os recursos não geridos utilizados pelo <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref>e opcionalmente liberta os recursos geridos."
  remarks: "Este método é denominado pelo público `Dispose()`método e o <xref:System.Object.Finalize%2A>método.</xref:System.Object.Finalize%2A> `Dispose()`invoca protegida `Dispose(Boolean)` método com o `disposing` parâmetro definido como `true`. <xref:System.Object.Finalize%2A>invoca `Dispose` com `disposing` definido como `false`.</xref:System.Object.Finalize%2A>       Quando o `disposing` parâmetro for true, este método versões retidos por quaisquer objetos geridos de todos os recursos que este <xref:System.Diagnostics.EventLog>referências.</xref:System.Diagnostics.EventLog> Este método invoca o `Dispose()` método de cada objeto referenciado."
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Para libertar recursos geridos e; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para libertar recursos apenas não geridos."
  overload: System.Diagnostics.EventLog.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.EnableRaisingEvents
  id: EnableRaisingEvents
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EnableRaisingEvents
  nameWithType: EventLog.EnableRaisingEvents
  fullName: System.Diagnostics.EventLog.EnableRaisingEvents
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define um valor que indica se o <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> recebe <xref href=&quot;System.Diagnostics.EventLog.EntryWritten&quot;> </xref> notificações de eventos."
  remarks: "A propriedade EnableRaisingEvents determina se o <xref:System.Diagnostics.EventLog>desencadeia eventos quando entradas são escritas no registo.</xref:System.Diagnostics.EventLog> Quando a propriedade é `true`, componentes que recebem o <xref:System.Diagnostics.EventLog.EntryWritten>eventos receberão a notificação sempre que uma entrada é escrita no registo de que é especificado o <xref:System.Diagnostics.EventLog.Log%2A>propriedade.</xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.EntryWritten> Se for EnableRaisingEvents `false`, não há eventos são gerados.      > [!NOTE] > Pode receber notificações de eventos apenas quando entradas são escritas no computador local. Não é possível receber notificações para entradas escritas em computadores remotos."
  example:
  - "The following example handles an <xref:System.Diagnostics.EventLog.EntryWritten> event.  \n  \n [!code-cs[Classic EventLog.EnableRaisingEvents Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_32_1.cs)]\n [!code-vb[Classic EventLog.EnableRaisingEvents Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_32_1.vb)]\n [!code-cpp[Classic EventLog.EnableRaisingEvents Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_32_1.cpp)]"
  syntax:
    content: public bool EnableRaisingEvents { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> recebe a notificação quando uma entrada está escrito no registo; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.EventLog.EnableRaisingEvents*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O registo de eventos estiver num computador remoto."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.EndInit
  id: EndInit
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EndInit()
  nameWithType: EventLog.EndInit()
  fullName: System.Diagnostics.EventLog.EndInit()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Termina a inicialização de uma <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> utilizados num formulário ou por outro componente. A inicialização ocorre no tempo de execução."
  remarks: "O [!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)] design ambiente utiliza este método para terminar a inicialização de um componente utilizado num formulário ou por outro componente. O <xref:System.Diagnostics.EventLog.BeginInit%2A>método inicia a inicialização.</xref:System.Diagnostics.EventLog.BeginInit%2A> Utilizar o <xref:System.Diagnostics.EventLog.BeginInit%2A>e métodos de EndInit impede que o controlo a ser utilizada antes de ser completamente inicializada.</xref:System.Diagnostics.EventLog.BeginInit%2A>"
  syntax:
    content: public void EndInit ();
    parameters: []
  overload: System.Diagnostics.EventLog.EndInit*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Entries
  id: Entries
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Entries
  nameWithType: EventLog.Entries
  fullName: System.Diagnostics.EventLog.Entries
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o conteúdo do registo de eventos."
  remarks: "Utilize o membro de entradas durante a leitura do registo de eventos.       Porque a propriedade é só de leitura, não é possível modificar uma entrada ou escrever no registo com as entradas. Em vez disso, especifique um <xref:System.Diagnostics.EventLog.Source%2A>e chame <xref:System.Diagnostics.EventLog.WriteEntry%2A>escrever uma nova entrada de registo.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A> Pode utilizar as entradas para contabilizar o número de entradas no registo de eventos e ver cada <xref:System.Diagnostics.EventLogEntry>na coleção.</xref:System.Diagnostics.EventLogEntry> Utilize o indexada <xref:System.Diagnostics.EventLogEntryCollection.Item%2A>Membro para obter informações sobre uma entrada específica, tal como <xref:System.Diagnostics.EventLogEntry.Message%2A>, <xref:System.Diagnostics.EventLogEntry.Category%2A>, <xref:System.Diagnostics.EventLogEntry.TimeWritten%2A>, ou <xref:System.Diagnostics.EventLogEntry.EntryType%2A>.</xref:System.Diagnostics.EventLogEntry.EntryType%2A> </xref:System.Diagnostics.EventLogEntry.TimeWritten%2A> </xref:System.Diagnostics.EventLogEntry.Category%2A> </xref:System.Diagnostics.EventLogEntry.Message%2A> </xref:System.Diagnostics.EventLogEntryCollection.Item%2A>       Não é necessário especificar um <xref:System.Diagnostics.EventLog.Source%2A>quando apenas ler a partir de um registo.</xref:System.Diagnostics.EventLog.Source%2A> Pode especificar apenas o <xref:System.Diagnostics.EventLog.Log%2A>nome e <xref:System.Diagnostics.EventLog.MachineName%2A>Propriedades (nome de computador do servidor) para o <xref:System.Diagnostics.EventLog>instância.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> Em ambos os casos, o membro de entradas é preenchido automaticamente com lista o registo de eventos de entradas. Pode selecionar o índice apropriado para um item nesta lista para ler as entradas individuais.       Uma distinção importante entre ler e escrever entradas de registo é que não é necessário chamar explicitamente um método de leitura. Depois do <xref:System.Diagnostics.EventLog.Log%2A>e <xref:System.Diagnostics.EventLog.MachineName%2A>especificado, a propriedade de entradas for automaticamente povoada.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> Se alterar o valor do <xref:System.Diagnostics.EventLog.Log%2A>ou <xref:System.Diagnostics.EventLog.MachineName%2A>propriedade, as entradas de propriedade é repovoada da próxima vez que leia o mesmo.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A>      > [!NOTE] > Não são necessários para especificar que o <xref:System.Diagnostics.EventLog.MachineName%2A>se estiver a ligar a um registo.</xref:System.Diagnostics.EventLog.MachineName%2A> Se não especificar o <xref:System.Diagnostics.EventLog.MachineName%2A>, o computador local, &quot;.&quot;, é assumido.</xref:System.Diagnostics.EventLog.MachineName%2A>"
  example:
  - "The following example reads entries in the event log, \"MyNewLog\", on the local computer.  \n  \n [!code-cs[Classic EventLog.Entries Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_23_1.cs)]\n [!code-cpp[Classic EventLog.Entries Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_23_1.cpp)]\n [!code-vb[Classic EventLog.Entries Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_23_1.vb)]"
  syntax:
    content: public System.Diagnostics.EventLogEntryCollection Entries { get; }
    return:
      type: System.Diagnostics.EventLogEntryCollection
      description: "Um <xref href=&quot;System.Diagnostics.EventLogEntryCollection&quot;> </xref> que contém as entradas no registo de eventos. Cada entrada está associada uma instância do <xref href=&quot;System.Diagnostics.EventLogEntry&quot;> </xref> classe."
  overload: System.Diagnostics.EventLog.Entries*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.EntryWritten
  id: EntryWritten
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EntryWritten
  nameWithType: EventLog.EntryWritten
  fullName: System.Diagnostics.EventLog.EntryWritten
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ocorre quando uma entrada é escrita um registo de eventos no computador local."
  remarks: "Para obter notificações de eventos, tem de definir <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A>para `true`.</xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> Apenas pode receber notificações de eventos quando entradas são escritas no computador local. Não é possível receber notificações para entradas escritas em computadores remotos.       Quando cria um delegado EntryWritten, identifique o método que irá processar o evento. Para associar o evento com o processador de eventos, adicione uma instância do delegado para o evento. O processador de eventos é chamado sempre que o evento ocorre, até que remova o delegado. Para obter mais informações sobre como lidar com os eventos com delegados, consulte [eventos](~/add/includes/ajax-current-ext-md.md).       O sistema responde a <xref:System.Diagnostics.EventLog.WriteEntry%2A>apenas se o último evento de escrita Ocorreu pelo menos seis segundos.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Isto implica só irá receber uma notificação de eventos EntryWritten dentro de um intervalo de seis segundo, mesmo que altere a mais do que um registo de eventos ocorre. Se introduzir um intervalo de suspensão suficientemente longo (cerca de 10 segundos) entre chamadas para <xref:System.Diagnostics.EventLog.WriteEntry%2A>, que é menos provável que não ocorrido um evento.</xref:System.Diagnostics.EventLog.WriteEntry%2A> No entanto, se os eventos de escrita ocorrem mais frequentemente, poderá não receber a notificação de evento até que o próximo intervalo. Normalmente, as notificações de eventos em falta não são perdidas, mas um atraso."
  example:
  - "The following example handles an entry written event.  \n  \n [!code-cs[Classic EventLog.EntryWritten Example#1](~/add/codesnippet/csharp/e-system.diagnostics.eve_1.cs)]\n [!code-cpp[Classic EventLog.EntryWritten Example#1](~/add/codesnippet/cpp/e-system.diagnostics.eve_1.cpp)]\n [!code-vb[Classic EventLog.EntryWritten Example#1](~/add/codesnippet/visualbasic/e-system.diagnostics.eve_1.vb)]"
  syntax:
    content: public event System.Diagnostics.EntryWrittenEventHandler EntryWritten;
    return:
      type: System.Diagnostics.EntryWrittenEventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Exists(System.String)
  id: Exists(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Exists(String)
  nameWithType: EventLog.Exists(String)
  fullName: System.Diagnostics.EventLog.Exists(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Determina se o registo existe no computador local."
  remarks: "Utilize este método para determinar se existe um registo no computador local. Se pretende determinar se existe uma origem no computador local, utilizar <xref:System.Diagnostics.EventLog.SourceExists%2A>.</xref:System.Diagnostics.EventLog.SourceExists%2A>       Porque este método acede ao registo, tem de ter as permissões de registo adequados no computador local; caso contrário, a consulta devolve `false`.       Uma vez que não é possível atribuir um novo registo de nome de um registo existente no mesmo computador, utilize este método antes de criar um novo registo para determinar se especificado `logName` já existe no computador local. O `logName` parâmetro não é sensível às maiúsculas e minúsculas.       Existe é um `static` método, pode ser chamado na classe de si próprio. Não é necessário criar uma instância de <xref:System.Diagnostics.EventLog>chamar Exists.</xref:System.Diagnostics.EventLog>"
  example:
  - >-
    [!code-cpp[EventLog_Exists_1#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_4_1.cpp)]
     [!code-vb[EventLog_Exists_1#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_4_1.vb)]
     [!code-cs[EventLog_Exists_1#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_4_1.cs)]
  syntax:
    content: public static bool Exists (string logName);
    parameters:
    - id: logName
      type: System.String
      description: 'O nome do registo para procurar. Os valores possíveis incluem: aplicação, segurança, sistema, outros registos de aplicação específicos (tais como as associadas ao Active Directory) ou qualquer registo personalizado no computador.'
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o registo de existir no computador local; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.EventLog.Exists*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "É o logName <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> ou o valor está vazio."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Exists(System.String,System.String)
  id: Exists(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Exists(String,String)
  nameWithType: EventLog.Exists(String,String)
  fullName: System.Diagnostics.EventLog.Exists(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Determina se o registo existe no computador especificado."
  remarks: "Utilize este método para determinar se existe um registo num computador remoto. Se pretende determinar se existe uma origem num computador remoto, utilize <xref:System.Diagnostics.EventLog.SourceExists%2A>.</xref:System.Diagnostics.EventLog.SourceExists%2A>       Porque este método acede ao registo, tem de ter as permissões de registo adequados no computador especificado; caso contrário, a consulta devolve `false`.       Uma vez que não é possível atribuir um novo registo de nome de um registo existente no mesmo computador, utilize este método antes de criar um novo registo para determinar se um com especificado `logName` já existe no servidor especificado pelo `machineName` parâmetro. O `logName` e `machineName` parâmetros não são sensíveis a maiúsculas e minúsculas.       <xref:System.Diagnostics.EventLog.Exists%2A>é um `static` método, pode ser chamado na classe de si próprio.</xref:System.Diagnostics.EventLog.Exists%2A> Não é necessário criar uma nova instância de <xref:System.Diagnostics.EventLog>chamar <xref:System.Diagnostics.EventLog.Exists%2A>.</xref:System.Diagnostics.EventLog.Exists%2A> </xref:System.Diagnostics.EventLog>"
  syntax:
    content: public static bool Exists (string logName, string machineName);
    parameters:
    - id: logName
      type: System.String
      description: 'O registo de que pretende procurar. Os valores possíveis incluem: aplicação, segurança, sistema, outros registos de aplicação específicos (tais como as associadas ao Active Directory) ou qualquer registo personalizado no computador.'
    - id: machineName
      type: System.String
      description: "O nome do computador no qual pretende procurar o registo, ou &quot;.&quot; para o computador local."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o registo de existir no computador especificado; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.EventLog.Exists*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O <code> machineName </code> parâmetro é um formato inválido. Certifique-se de que utilizou a sintaxe correta para o computador no qual esteja a pesquisar.       - ou - <code> logName </code> é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> ou o valor está vazio."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.GetEventLogs
  id: GetEventLogs
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: GetEventLogs()
  nameWithType: EventLog.GetEventLogs()
  fullName: System.Diagnostics.EventLog.GetEventLogs()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Procura todos os registos de eventos no computador local e cria uma matriz de <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> objetos que contêm a lista."
  remarks: "A matriz de <xref:System.Diagnostics.EventLog>objectos é um instantâneo de todos os registos de eventos no computador local, quando é efetuada a chamada para GetEventLogs.</xref:System.Diagnostics.EventLog> Não é uma coleção dinâmica, pelo que não reflete a eliminação ou criação de registos em tempo real. Deverá certificar-se de que existe um registo na matriz antes de ler ou escrever no mesmo. A matriz normalmente inclui, pelo menos, três registos: aplicações, sistema e segurança. Se tiver criado registos personalizados no computador local, serão apresentados na matriz bem.       Para obter a lista de registos de eventos, tem de ter as permissões de registo adequados. Estas permissões são idênticos aos necessários para invocar <xref:System.Diagnostics.EventLog.Exists%2A>e <xref:System.Diagnostics.EventLog.SourceExists%2A>.</xref:System.Diagnostics.EventLog.SourceExists%2A> </xref:System.Diagnostics.EventLog.Exists%2A>"
  example:
  - "The following example enumerates the event logs defined on the local computer, and displays configuration details for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_10_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/m-system.diagnostics.eve_10_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/m-system.diagnostics.eve_10_1.cs)]"
  syntax:
    content: public static System.Diagnostics.EventLog[] GetEventLogs ();
    parameters: []
    return:
      type: System.Diagnostics.EventLog[]
      description: "Uma matriz do tipo <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> que representa os registos no computador local."
  overload: System.Diagnostics.EventLog.GetEventLogs*
  exceptions:
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Não dispõe de acesso de leitura ao registo.       - ou - não existe nenhum serviço de registo de eventos no computador."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.GetEventLogs(System.String)
  id: GetEventLogs(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: GetEventLogs(String)
  nameWithType: EventLog.GetEventLogs(String)
  fullName: System.Diagnostics.EventLog.GetEventLogs(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Procura todos os registos de eventos no computador especificado e cria uma matriz de <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> objetos que contêm a lista."
  remarks: "A matriz de <xref:System.Diagnostics.EventLog>objectos é um instantâneo de todos os registos de eventos no computador especificado pelo `machineName` parâmetro quando a chamada para <xref:System.Diagnostics.EventLog.GetEventLogs%2A>é efetuada.</xref:System.Diagnostics.EventLog.GetEventLogs%2A> </xref:System.Diagnostics.EventLog> Não é uma coleção dinâmica, pelo que não reflete a eliminação ou criação de registos em tempo real. Deverá certificar-se de que existe um registo na matriz antes de ler ou escrever no mesmo. A matriz normalmente inclui, pelo menos, três registos: aplicações, sistema e segurança. Se tiver criado registos personalizados no computador especificado, serão apresentados na matriz bem.       <xref:System.Diagnostics.EventLog.GetEventLogs%2A>é um `static` método, pode ser chamado no <xref:System.Diagnostics.EventLog>classe propriamente dito.</xref:System.Diagnostics.EventLog></xref:System.Diagnostics.EventLog.GetEventLogs%2A> Não é necessário criar uma instância de um <xref:System.Diagnostics.EventLog>objeto para efetuar uma chamada ao método.</xref:System.Diagnostics.EventLog>       Para obter a lista de registos de eventos, tem de ter as permissões de registo adequados. Estas permissões são idênticos aos necessários para invocar <xref:System.Diagnostics.EventLog.Exists%2A>e <xref:System.Diagnostics.EventLog.SourceExists%2A>.</xref:System.Diagnostics.EventLog.SourceExists%2A> </xref:System.Diagnostics.EventLog.Exists%2A>"
  example:
  - "The following example gets a list of logs on the computer \"myServer\". It then outputs the name of each log.  \n  \n [!code-cpp[Classic EventLog.GetEventLogs1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_18_1.cpp)]\n [!code-cs[Classic EventLog.GetEventLogs1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_18_1.cs)]\n [!code-vb[Classic EventLog.GetEventLogs1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_18_1.vb)]"
  syntax:
    content: public static System.Diagnostics.EventLog[] GetEventLogs (string machineName);
    parameters:
    - id: machineName
      type: System.String
      description: "O computador em que pretende procurar os registos de eventos."
    return:
      type: System.Diagnostics.EventLog[]
      description: "Uma matriz do tipo <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> que representa os registos no computador especificado."
  overload: System.Diagnostics.EventLog.GetEventLogs*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O <code> machineName </code> parâmetro é um nome de computador inválidos."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não dispõe de acesso de leitura ao registo.       - ou - não existe nenhum serviço de registo de eventos no computador."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Log
  id: Log
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Log
  nameWithType: EventLog.Log
  fullName: System.Diagnostics.EventLog.Log
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define o nome do registo para ler a partir de ou escrever."
  remarks: "Three log files exist by default on the server: Application, System, and Security. Applications and services use the Application log file. Device drivers use the System log file. The system generates success and failure audit events in the Security log when auditing is turned on. If you have other applications installed, like Active Directory on Windows servers, there might be other default log files. In addition, you can create custom log files on a local or remote computer. Custom logs help organize your entries in a more detailed way than is allowed when your components write events to the default Application log.  \n  \n> [!NOTE]\n>  Log names are limited to eight characters. According to the system, MyLogSample1 and MyLogSample2 are the same log.  \n  \n If you write to an event log, it is not enough to specify the Log property. You must associate a <xref:System.Diagnostics.EventLog.Source%2A> property with your event log resource to connect it to a particular log. It is not necessary to specify a <xref:System.Diagnostics.EventLog.Source%2A> when only reading from a log, but an event source must be associated with the event log resource in the server's registry. You can specify only the Log name and <xref:System.Diagnostics.EventLog.MachineName%2A> (server computer name) to read from it.  \n  \n> [!NOTE]\n>  You are not required to specify the <xref:System.Diagnostics.EventLog.MachineName%2A> if you are connecting to a log. If you do not specify the <xref:System.Diagnostics.EventLog.MachineName%2A>, the local computer (\".\") is assumed.  \n  \n If the <xref:System.Diagnostics.EventLog.Source%2A> property has not been specified, a call to Log returns an empty string if Log has not been explicitly set (by setting the Log property, or through the constructor). If the <xref:System.Diagnostics.EventLog.Source%2A> has been specified, Log returns the name of the log to which that source was registered.  \n  \n A source can only be registered to one log at a time. If the <xref:System.Diagnostics.EventLog.Source%2A> property was set for an instance of <xref:System.Diagnostics.EventLog>, you cannot change the Log property for that <xref:System.Diagnostics.EventLog> without changing the value of <xref:System.Diagnostics.EventLog.Source%2A> or calling <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> first. If you change the Log property after the <xref:System.Diagnostics.EventLog.Source%2A> property has been set, writing a log entry throws an exception.  \n  \n The operating system stores event logs as files. When you use <xref:System.Diagnostics.EventLogInstaller> or <xref:System.Diagnostics.EventLog.CreateEventSource%2A> to create a new event log, the associated file is stored in the %SystemRoot%\\System32\\Config directory on the specified computer. The file name is set by appending the first 8 characters of the Log property with the \".evt\" file name extension.  \n  \n You cannot create a new log using the Log property alone (without specifying a source for the log). You can call <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, passing in a new log name as a parameter, and then call <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. However, the intent is usually either to create (and write entries to) new application-specific logs, or to read from existing logs.  \n  \n If the Log value changes, the event log is closed and all event handles are released.  \n  \n> [!CAUTION]\n>  If you set the Log property to the name of a log that does not exist, the system attaches the <xref:System.Diagnostics.EventLog> to the Application log, but does not warn you that it is using a log other than the one you specified."
  example:
  - "The following example reads entries in the event log, \"NewEventLog\", on the local computer.  \n  \n [!code-cpp[Classic EventLog.Log Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_17_1.cpp)]\n [!code-cs[Classic EventLog.Log Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_17_1.cs)]\n [!code-vb[Classic EventLog.Log Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_17_1.vb)]"
  syntax:
    content: public string Log { get; set; }
    return:
      type: System.String
      description: "O nome do registo. Isto pode ser aplicações, sistema, segurança ou um nome de registo personalizado. A predefinição é uma cadeia vazia (&quot;&quot;)."
  overload: System.Diagnostics.EventLog.Log*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.LogDisplayName
  id: LogDisplayName
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: LogDisplayName
  nameWithType: EventLog.LogDisplayName
  fullName: System.Diagnostics.EventLog.LogDisplayName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o nome amigável do registo de eventos."
  remarks: "> [!NOTE]> No Windows Vista e posterior, os utilizadores não têm permissão para aceder ao registo de segurança. Se estiver a executar o Windows Vista ou posterior como um utilizador, obterá um <xref:System.Security.SecurityException>Quando tentar aceder o nome a apresentar para um evento no registo de segurança.</xref:System.Security.SecurityException>   >> No Windows Vista e posterior, o controlo de conta de utilizador (UAC) determina os privilégios de utilizador. Se for um membro do grupo Administradores incorporado, são atribuídos dois tokens de acesso de tempo de execução: um token de acesso de utilizador padrão e um token de acesso de administrador. Por predefinição, está na função de utilizador padrão. Para executar o código que acede ao registo de segurança, deve primeiro elevar os privilégios de utilizador padrão ao administrador. Pode fazê-lo quando iniciar uma aplicação ao clicar no ícone de aplicação e com a indicação de que pretende executar como administrador."
  example:
  - "The following example enumerates the event logs defined on the local computer and displays the LogDisplayName for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_29_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/p-system.diagnostics.eve_29_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/p-system.diagnostics.eve_29_1.cs)]"
  syntax:
    content: public string LogDisplayName { get; }
    return:
      type: System.String
      description: "Um nome que representa o registo de eventos no Visualizador de eventos do sistema."
  overload: System.Diagnostics.EventLog.LogDisplayName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Especificado <xref:System.Diagnostics.EventLog.Log*>não existe no registo para este computador.</xref:System.Diagnostics.EventLog.Log*>"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)
  id: LogNameFromSourceName(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: LogNameFromSourceName(String,String)
  nameWithType: EventLog.LogNameFromSourceName(String,String)
  fullName: System.Diagnostics.EventLog.LogNameFromSourceName(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o nome do registo em que a origem especificada está registada."
  remarks: "A origem do evento indica que regista o evento. É, muitas vezes, o nome da aplicação ou o nome de um subcomponente da aplicação, se a aplicação é grande. Aplicações e serviços, devem escrever o registo de aplicação ou um registo personalizado. Controladores de dispositivo devem escrever o registo do sistema.       Quando cria uma nova origem, só pode escrever um registo de cada vez, o sistema regista a aplicação com o registo de eventos como uma origem válida de entradas. O <xref:System.Diagnostics.EventLog.Source%2A>propriedade pode ser qualquer cadeia, mas o nome não pode ser utilizado por outras origens no computador.</xref:System.Diagnostics.EventLog.Source%2A> Tentativa de criar um duplicado <xref:System.Diagnostics.EventLog.Source%2A>valor emite uma exceção.</xref:System.Diagnostics.EventLog.Source%2A> No entanto, um único registo de eventos pode ter várias origens diferentes ao escrever no mesmo."
  example:
  - "The following example deletes a source from the local computer. The example determines the log from its source, and then deletes the log.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_2_1.cpp)]\n [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_2_1.vb)]\n [!code-cs[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_2_1.cs)]"
  syntax:
    content: public static string LogNameFromSourceName (string source, string machineName);
    parameters:
    - id: source
      type: System.String
      description: "O nome da origem de evento."
    - id: machineName
      type: System.String
      description: "O nome do computador no qual pretende procurar, ou &quot;.&quot; para o computador local."
    return:
      type: System.String
      description: "O nome do registo associado a fonte especificada no registo."
  overload: System.Diagnostics.EventLog.LogNameFromSourceName*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.MachineName
  id: MachineName
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: MachineName
  nameWithType: EventLog.MachineName
  fullName: System.Diagnostics.EventLog.MachineName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define o nome do computador no qual pretende ler ou escrever eventos no registo."
  remarks: "Se escrever um registo de eventos, precisa de associar uma <xref:System.Diagnostics.EventLog.Source%2A>com o objeto de registo de eventos a ligá-lo para um registo específico.</xref:System.Diagnostics.EventLog.Source%2A> Não é necessário especificar a <xref:System.Diagnostics.EventLog.Source%2A>propriedade quando apenas ler a partir de um registo.</xref:System.Diagnostics.EventLog.Source%2A> Pode especificar apenas o <xref:System.Diagnostics.EventLog.Log%2A>nome e MachineName (nome de computador do servidor).</xref:System.Diagnostics.EventLog.Log%2A>      > [!NOTE] > Não será necessário especificar o MachineName se estiver a ligar a um registo. Se não especificar MachineName, o computador local (&quot;.&quot;) é assumido.       Só pode ser registada um registo de uma origem de cada vez. Se o <xref:System.Diagnostics.EventLog.Source%2A>propriedade foi definida para uma instância do <xref:System.Diagnostics.EventLog>, não é possível alterar a propriedade MachineName para esse <xref:System.Diagnostics.EventLog>sem alterar o valor de <xref:System.Diagnostics.EventLog.Source%2A>ou chamar <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>primeiro.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> </xref:System.Diagnostics.EventLog.Source%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> Se alterar a propriedade MachineName, o <xref:System.Diagnostics.EventLog>fecha todos os identificadores e reattaches no registo e origem no novo computador.</xref:System.Diagnostics.EventLog>       O valor de MachineName não pode ser uma cadeia vazia. Se não for explicitamente definida, assume como o computador local (&quot;.&quot;)."
  example:
  - "The following example reads entries in the event log, \"NewEventLog\", on a specified computer.  \n  \n [!code-cs[Classic EventLog.MachineName Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_6_1.cs)]\n [!code-vb[Classic EventLog.MachineName Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_6_1.vb)]\n [!code-cpp[Classic EventLog.MachineName Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_6_1.cpp)]"
  syntax:
    content: public string MachineName { get; set; }
    return:
      type: System.String
      description: "O nome do servidor no qual reside no registo de eventos. A predefinição é o computador local (&quot;.&quot;)."
  overload: System.Diagnostics.EventLog.MachineName*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O nome do computador é inválido."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.MaximumKilobytes
  id: MaximumKilobytes
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: MaximumKilobytes
  nameWithType: EventLog.MaximumKilobytes
  fullName: System.Diagnostics.EventLog.MaximumKilobytes
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define o tamanho máximo de eventos de registo em quilobytes."
  remarks: "A propriedade MaximumKilobytes representa o limite de tamanho do ficheiro de registo de eventos. Quando o registo de eventos atingir o limite de tamanho, configurado <xref:System.Diagnostics.EventLog.OverflowAction%2A>valor determina se as novas entradas são eliminadas ou se novas entradas substituir as entradas mais antigas.</xref:System.Diagnostics.EventLog.OverflowAction%2A>      > [!NOTE] > Esta propriedade representa uma definição de configuração para o registo de eventos representado por esta instância. Quando o registo de eventos atinge o tamanho máximo, esta propriedade especifica a forma como o sistema operativo processa novas entradas escritas por todas as origens de eventos registadas para o registo de eventos."
  example:
  - "The following example enumerates the event logs defined on the local computer, and displays configuration details for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_15_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/p-system.diagnostics.eve_15_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/p-system.diagnostics.eve_15_1.cs)]"
  syntax:
    content: public long MaximumKilobytes { get; set; }
    return:
      type: System.Int64
      description: "O tamanho máximo de registo de eventos em quilobytes. A predefinição é 512, que indica um tamanho de ficheiro máximo de quilobytes 512."
  overload: System.Diagnostics.EventLog.MaximumKilobytes*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "O valor especificado é inferior a 64, ou superior ao 4194240 ou não um múltiplo par de 64."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <xref:System.Diagnostics.EventLog.Log*> value is not a valid log name.  \n  \n \\- or -  \n  \n The registry key for the event log could not be opened on the target computer."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.MinimumRetentionDays
  id: MinimumRetentionDays
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: MinimumRetentionDays
  nameWithType: EventLog.MinimumRetentionDays
  fullName: System.Diagnostics.EventLog.MinimumRetentionDays
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o número de dias a manter as entradas no registo de eventos."
  remarks: "Utilize a propriedade de MinimumRetentionDays para examinar a definição atual para um registo de eventos. Utilize <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>para alterar o número mínimo de dias que deve ser retida cada entrada no registo de eventos.</xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>       O valor de MinimumRetentionDays depende o comportamento de capacidade excedida configurado do registo de eventos. Se o <xref:System.Diagnostics.OverflowAction>para um registo de eventos for definida como <xref:System.Diagnostics.OverflowAction>, em seguida, o valor de MinimumRetentionDays é 0.</xref:System.Diagnostics.OverflowAction> </xref:System.Diagnostics.OverflowAction> Se o <xref:System.Diagnostics.OverflowAction>para um registo de eventos for definida como <xref:System.Diagnostics.OverflowAction>, em seguida, o valor de MinimumRetentionDays é de -1.</xref:System.Diagnostics.OverflowAction> </xref:System.Diagnostics.OverflowAction> Se o <xref:System.Diagnostics.OverflowAction>para um registo de eventos for definida como <xref:System.Diagnostics.OverflowAction>, em seguida, o valor de MinimumRetentionDays é maior que zero e representa o número de dias a manter as entradas de registo de eventos quando o registo de eventos está cheia.</xref:System.Diagnostics.OverflowAction> </xref:System.Diagnostics.OverflowAction>       O comportamento de capacidade excedida só ocorre quando um registo de eventos atingir o limite de tamanho. Quando um <xref:System.Diagnostics.EventLog>tem respetivo <xref:System.Diagnostics.EventLog.OverflowAction%2A>definido como <xref:System.Diagnostics.OverflowAction>e o registo de eventos atinge o tamanho máximo, em seguida, novas entradas são escritas apenas se o podem substituir entradas cuja idade excede o período de MinimumRetentionDays.</xref:System.Diagnostics.OverflowAction> </xref:System.Diagnostics.EventLog.OverflowAction%2A> </xref:System.Diagnostics.EventLog> Manter entradas de evento durante um período mínimo é adequada quando o registo de eventos é arquivado regularmente. Caso contrário, o risco de perder novas entradas quando o registo de eventos atingir o limite. Para evitar a perda de novas informações de evento, defina os dias mínimos de retenção para eventos com base na sua agenda de arquivo para um determinado registo de eventos."
  example:
  - "The following example enumerates the event logs defined on the local computer, and displays configuration details for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_12_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/p-system.diagnostics.eve_12_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/p-system.diagnostics.eve_12_1.cs)]"
  syntax:
    content: public int MinimumRetentionDays { get; }
    return:
      type: System.Int32
      description: "O número de dias que as entradas no registo de eventos são retidas. O valor predefinido é de 7."
  overload: System.Diagnostics.EventLog.MinimumRetentionDays*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)
  id: ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: ModifyOverflowPolicy(OverflowAction,Int32)
  nameWithType: EventLog.ModifyOverflowPolicy(OverflowAction,Int32)
  fullName: System.Diagnostics.EventLog.ModifyOverflowPolicy(OverflowAction,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Altera o comportamento para escrever novas entradas quando o registo de eventos atinge o tamanho de ficheiro máximo configurado."
  remarks: "O comportamento de capacidade excedida de um registo de eventos Especifica o que acontece quando novas entradas estão a ser escrito para um registo que foi atingido o tamanho máximo do ficheiro.      > [!NOTE] > O comportamento de capacidade excedida entra em vigor apenas quando um registo de eventos atinge o tamanho de ficheiro máximo. O comportamento de capacidade excedida não afeta a escrever uma nova entrada de um registo que possam acomodá entradas de registo de eventos adicionais.       O método ModifyOverflowPolicy configura o comportamento de capacidade excedida de um registo de eventos. <xref:System.Diagnostics.EventLog>instância.</xref:System.Diagnostics.EventLog> Depois de chamar este método para o registo de eventos especificado pelo <xref:System.Diagnostics.EventLog.Log%2A>propriedade, o <xref:System.Diagnostics.EventLog.OverflowAction%2A>e <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>valores de propriedade refletem o comportamento de capacidade excedida recentemente configurada.</xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> </xref:System.Diagnostics.EventLog.OverflowAction%2A> </xref:System.Diagnostics.EventLog.Log%2A>      > [!NOTE] > Esta propriedade representa uma definição de configuração para o registo de eventos representado por esta instância. Quando o registo de eventos atinge o tamanho máximo, esta propriedade especifica a forma como o sistema operativo processa novas entradas escritas por todas as origens de eventos registadas para o registo de eventos.       Definir o `action` parâmetro <xref:System.Diagnostics.OverflowAction>para indicar que uma nova entrada substitui a entrada mais antiga quando o <xref:System.Diagnostics.EventLog>atinge o tamanho máximo.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.OverflowAction> Se o `action` parâmetro está definido como <xref:System.Diagnostics.OverflowAction>, a `retentionDays` valor do parâmetro será ignorado.</xref:System.Diagnostics.OverflowAction>       Definir o `action` parâmetro <xref:System.Diagnostics.OverflowAction>para indicar que cada nova entrada substitui as entradas mais antigas quando o <xref:System.Diagnostics.EventLog>atinge o tamanho máximo.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.OverflowAction> Especifique o número de dias que devem ser retidos eventos no registo com o `retentionDays` parâmetro. Escrito dentro do período de retenção de eventos não são substituídos por novas entradas.       Definir o `action` parâmetro <xref:System.Diagnostics.OverflowAction>Rejeitar novos eventos quando é atingido o tamanho máximo do registo.</xref:System.Diagnostics.OverflowAction> Se o `action` parâmetro está definido como <xref:System.Diagnostics.OverflowAction>, a `retentionDays` valor do parâmetro será ignorado.</xref:System.Diagnostics.OverflowAction>      > [!CAUTION] > Definir a política de capacidade excedida <xref:System.Diagnostics.OverflowAction>Especifica que as novas entradas são rejeitadas quando o registo de eventos está cheia.</xref:System.Diagnostics.OverflowAction> Se utilizar esta definição, certifique-se de que o registo de eventos regularmente arquivado e limpa para evitar atingir o limite de tamanho máximo."
  example:
  - "The following example displays the configured overflow policy for a specified event log, and allows the user to select a new overflow policy setting for the event log.  \n  \n [!code-vb[EventLogProperties#3](~/add/codesnippet/visualbasic/0b0fc273-a638-4af9-ae99-_1.vb)]\n [!code-cpp[EventLogProperties#3](~/add/codesnippet/cpp/0b0fc273-a638-4af9-ae99-_1.cpp)]\n [!code-cs[EventLogProperties#3](~/add/codesnippet/csharp/0b0fc273-a638-4af9-ae99-_1.cs)]"
  syntax:
    content: public void ModifyOverflowPolicy (System.Diagnostics.OverflowAction action, int retentionDays);
    parameters:
    - id: action
      type: System.Diagnostics.OverflowAction
      description: "O comportamento de capacidade excedida de escrita novas entradas de registo de eventos."
    - id: retentionDays
      type: System.Int32
      description: "O número mínimo de dias em que cada entrada de registo de eventos é retida. Este parâmetro só é utilizado se `action` está definido como <xref href=&quot;System.Diagnostics.OverflowAction&quot;> </xref>."
  overload: System.Diagnostics.EventLog.ModifyOverflowPolicy*
  exceptions:
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>action</code>Não é um <xref:System.Diagnostics.EventLog.OverflowAction*> valor."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>retentionDays</code>é menor que um, ou superior a 365."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <xref:System.Diagnostics.EventLog.Log*> value is not a valid log name.  \n  \n \\- or -  \n  \n The registry key for the event log could not be opened on the target computer."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.OverflowAction
  id: OverflowAction
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: OverflowAction
  nameWithType: EventLog.OverflowAction
  fullName: System.Diagnostics.EventLog.OverflowAction
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o comportamento configurado para armazenar novas entradas quando o registo de eventos atinge o tamanho de ficheiro de registo máximo."
  remarks: "Registos de eventos aumentam de tamanho como novos eventos são escritos nos mesmos. Cada registo de eventos tem um limite de tamanho máximo configurado; o <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A>propriedade define o número máximo de quilobytes permitidos para o tamanho de ficheiro de registo de eventos.</xref:System.Diagnostics.EventLog.MaximumKilobytes%2A>       Utilize o valor da propriedade OverflowAction para examinar o comportamento de capacidade excedida configurado para um registo de eventos, o tamanho máximo. Utilize o <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>método para alterar o comportamento de capacidade excedida de um registo de eventos.</xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>      > [!NOTE] > O comportamento de capacidade excedida entra em vigor apenas quando um registo de eventos atinge o tamanho de ficheiro máximo. O comportamento de capacidade excedida não afeta a escrever uma nova entrada de um registo que possam acomodá entradas de registo de eventos adicionais."
  example:
  - "The following example enumerates the event logs defined on the local computer, and displays configuration details for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_28_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/p-system.diagnostics.eve_28_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/p-system.diagnostics.eve_28_1.cs)]"
  syntax:
    content: public System.Diagnostics.OverflowAction OverflowAction { get; }
    return:
      type: System.Diagnostics.OverflowAction
      description: "O <xref href=&quot;System.Diagnostics.OverflowAction&quot;> </xref> valor que especifica o comportamento para armazenar novas entradas quando o registo de eventos atinge o tamanho do registo máximo configurado. A predefinição é <xref href=&quot;System.Diagnostics.OverflowAction&quot;> </xref>."
  overload: System.Diagnostics.EventLog.OverflowAction*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)
  id: RegisterDisplayName(System.String,System.Int64)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: RegisterDisplayName(String,Int64)
  nameWithType: EventLog.RegisterDisplayName(String,Int64)
  fullName: System.Diagnostics.EventLog.RegisterDisplayName(String,Int64)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Especifica o nome localizado do registo de eventos, o que é apresentado no servidor do Visualizador de eventos."
  remarks: "Utilize RegisterDisplayName para registar e apresentar um nome localizado no Visualizador de eventos para registos de eventos personalizados.       O identificador de recurso especificado tem de corresponder a uma cadeia localizada definida no ficheiro de recursos. O Visualizador de eventos apresenta o nome de registo de eventos personalizado utilizando a cadeia localizada e as definições de idioma atual. Por exemplo, pode definir vários nomes de registo de eventos localizados para idiomas diferentes no seu ficheiro de recursos. O Visualizador de eventos apresenta a cadeia localizada correspondente às definições de idioma do utilizador atual.       Se o Visualizador de eventos não é possível carregar a cadeia localizada no ficheiro de recurso, ou não se foi registado nenhum nome a apresentar para o registo de eventos, em seguida, o Visualizador de eventos apresenta o nome do registo de eventos definido no <xref:System.Diagnostics.EventLog.Log%2A>.</xref:System.Diagnostics.EventLog.Log%2A>      > [!NOTE] > Não terá de registar um nome a apresentar para os registos de eventos predefinidos. O sistema operativo regista os nomes a apresentar localizados para os registos de eventos de aplicações, sistema e segurança."
  example:
  - "The following example determines whether the event source named `SampleApplicationSource` is registered on the local computer. If the event source does not exist, the example sets the message resource file for the source and creates the new event source. Finally, the example sets the localized display name for the event log, using the resource identifier value in `DisplayNameMsgId` and the resource file path in `messageFile`.  \n  \n [!code-cpp[EventLog_WriteEvent#6](~/add/codesnippet/cpp/m-system.diagnostics.eve_1_1.cpp)]\n [!code-vb[EventLog_WriteEvent#6](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_1_1.vb)]\n [!code-cs[EventLog_WriteEvent#6](~/add/codesnippet/csharp/m-system.diagnostics.eve_1_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings. Specifically, resource identifier 5001 is defined for the localized name of the event log.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public void RegisterDisplayName (string resourceFile, long resourceId);
    parameters:
    - id: resourceFile
      type: System.String
      description: "O caminho completamente especificado para um ficheiro de recurso localizado."
    - id: resourceId
      type: System.Int64
      description: "O identificador de recurso que indexa uma cadeia localizada no ficheiro de recursos."
  overload: System.Diagnostics.EventLog.RegisterDisplayName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <xref:System.Diagnostics.EventLog.Log*> value is not a valid log name.  \n  \n \\- or -  \n  \n The registry key for the event log could not be opened on the target computer."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>resourceFile </code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Source
  id: Source
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Source
  nameWithType: EventLog.Source
  fullName: System.Diagnostics.EventLog.Source
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define o nome de origem para registar e utilizar ao escrever o registo de eventos."
  remarks: "A origem do evento indica que regista o evento. É, muitas vezes, o nome da aplicação ou o nome de um subcomponente da aplicação, se a aplicação é grande. Aplicações e serviços, devem escrever o registo de aplicação ou um registo personalizado. Controladores de dispositivo devem escrever o registo do sistema.       Só tem de especificar uma origem de evento se estiver a escrever um registo de eventos. Antes de escrever uma entrada para um registo de eventos, tem de registar a origem do evento no registo de eventos como uma origem válida de eventos. Quando escreve uma entrada de registo, o sistema utiliza a propriedade de origem para localizar o registo adequado onde colocar a sua entrada. Se estiver a ler o registo de eventos, pode especificar a origem ou uma <xref:System.Diagnostics.EventLog.Log%2A>e <xref:System.Diagnostics.EventLog.MachineName%2A>.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A>      > [!NOTE] > Não é necessário especificar o <xref:System.Diagnostics.EventLog.MachineName%2A>se estiver a ligar a um registo no computador local.</xref:System.Diagnostics.EventLog.MachineName%2A> Se não especificar o <xref:System.Diagnostics.EventLog.MachineName%2A>, o computador local (&quot;.&quot;) é assumido.</xref:System.Diagnostics.EventLog.MachineName%2A>       Utilização <xref:System.Diagnostics.EventLog.WriteEvent%2A>e <xref:System.Diagnostics.EventLog.WriteEntry%2A>escrever eventos de um registo de eventos.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.WriteEvent%2A> Tem de especificar uma origem de evento para escrever eventos; tem de criar e configurar a origem do evento antes de escrever a entrada primeiro com a origem.       Crie a nova origem de evento durante a instalação da aplicação. Isto permite que o tempo para o sistema operativo atualizar a lista de origens de eventos registados e a respetiva configuração. Se o sistema operativo não tem de atualizar a lista de origens de eventos e a tentativa de escrever um evento com a nova origem, que a operação de escrita irá falhar. Pode configurar uma nova origem utilizando um <xref:System.Diagnostics.EventLogInstaller>, ou utilizando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A>método.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Tem de ter direitos administrativos no computador para criar uma nova origem de evento.       Pode criar uma origem de evento para um registo de eventos existente ou um novo registo de eventos. Quando cria uma nova origem para um novo registo de eventos, o sistema regista a origem para esse registo, mas o registo não é criado até que a primeira entrada é escrita.       A origem tem de ser exclusiva no computador local; um novo nome de origem não pode corresponder a um nome de origem existente ou um nome existente do registo de eventos. Pode escrever apenas um registo de eventos cada origem de cada vez; No entanto, a aplicação pode utilizar várias origens para escrever vários registos de eventos. Por exemplo, a aplicação poderá necessitar de várias origens configuradas para diferentes registos de eventos ou ficheiros de recursos diferentes.       Se alterar o valor de origem, o <xref:System.Diagnostics.EventLog>para que este se encontra registada será fechada e todos os identificadores de evento são lançados.</xref:System.Diagnostics.EventLog>       A origem tem de ser configurada para escrever entradas localizadas ou de escrita diretas cadeias. Se a sua aplicação escreve entradas utilizando identificadores de recursos e valores de cadeia, tem de registar duas origens separadas. Por exemplo, configurar uma origem com ficheiros de recursos e, em seguida, utilize essa origem no <xref:System.Diagnostics.EventLog.WriteEvent%2A>método escrever entradas utilizando identificadores de recursos para o registo de eventos.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Em seguida, criar uma origem diferente sem ficheiros de recursos e utilize essa origem no <xref:System.Diagnostics.EventLog.WriteEntry%2A>método escrever cadeias diretamente o registo de eventos através dessa origem.</xref:System.Diagnostics.EventLog.WriteEntry%2A>       Para alterar os detalhes da configuração de uma origem existente, tem de eliminar a origem e, em seguida, crie-a com a nova configuração. Se outras aplicações ou componentes utilizam a origem existente, crie uma nova origem com a configuração atualizada, em vez de eliminar a origem existente.      > [!NOTE] > Se uma origem já foi mapeada para um registo e remapeá-lo para um novo registo, tem de reiniciar o computador para que as alterações entrem em vigor."
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.Source Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_18_1.cs)]\n [!code-vb[Classic EventLog.Source Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_18_1.vb)]\n [!code-cpp[Classic EventLog.Source Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_18_1.cpp)]"
  syntax:
    content: public string Source { get; set; }
    return:
      type: System.String
      description: "O nome registado no registo de eventos como uma origem de entradas. A predefinição é uma cadeia vazia (&quot;&quot;)."
  overload: System.Diagnostics.EventLog.Source*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O nome da origem resulta num caminho chave de registo mais de 254 carateres."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.SourceExists(System.String)
  id: SourceExists(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: SourceExists(String)
  nameWithType: EventLog.SourceExists(String)
  fullName: System.Diagnostics.EventLog.SourceExists(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Determina se uma origem de evento é registada no computador local."
  remarks: "Utilize este método para determinar se existe uma origem de eventos no computador local. Se pretende determinar se existe um registo no computador local, utilizar <xref:System.Diagnostics.EventLog.Exists%2A>.</xref:System.Diagnostics.EventLog.Exists%2A>       Porque este método acede ao registo, tem de ter as permissões de registo adequados no computador local; caso contrário, um <xref:System.Security.SecurityException>será emitida.</xref:System.Security.SecurityException>      > [!NOTE] > Para procurar uma origem de evento no Windows Vista e posterior ou o Windows Server 2003, tem de ter privilégios administrativos.   >> A razão para este requisito é que todos os registos de eventos, incluindo a segurança, tem de ser procurados para determinar se a origem do evento é exclusiva. A partir do Windows Vista, os utilizadores não têm permissão para aceder ao registo de segurança; Por conseguinte, um <xref:System.Security.SecurityException>é emitida.</xref:System.Security.SecurityException>   >> Começando com o Windows Vista, controlo de conta de utilizador (UAC) determina os privilégios de utilizador. Se for um membro do grupo Administradores incorporado, são atribuídos dois tokens de acesso de tempo de execução: um token de acesso de utilizador padrão e um token de acesso de administrador. Por predefinição, está na função de utilizador padrão. Para executar o código que acede ao contadores de desempenho, primeiro tem elevar os privilégios de utilizador padrão ao administrador. Pode fazê-lo quando iniciar uma aplicação ao clicar no ícone de aplicação e com a indicação de que pretende executar como administrador.      > [!NOTE] > Um serviço que está a executar sob a <xref:System.ServiceProcess.ServiceAccount>conta não tem os privilégios necessários para executar este método.</xref:System.ServiceProcess.ServiceAccount> A solução é verificar se a origem de eventos existe no <xref:System.ServiceProcess.ServiceInstaller>, e se não existir, para criar a origem no instalador do.</xref:System.ServiceProcess.ServiceInstaller>       Porque não é possível conceder uma nova origem de nome de uma origem existente no mesmo computador, utilize este método antes de tentar chamar <xref:System.Diagnostics.EventLog.CreateEventSource%2A>para se certificar de que uma origem com o nome especificado pelo `source` já não existe no computador local.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> O `source` parâmetro não é sensível."
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.Source Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_14_1.cs)]\n [!code-vb[Classic EventLog.Source Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_14_1.vb)]\n [!code-cpp[Classic EventLog.Source Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_14_1.cpp)]"
  syntax:
    content: public static bool SourceExists (string source);
    parameters:
    - id: source
      type: System.String
      description: "O nome da origem de evento."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a origem do evento é registada no computador local; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.EventLog.SourceExists*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<code>source</code>Não foi encontrada, mas não foi possível procurar alguns ou todos os registos de eventos."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.SourceExists(System.String,System.String)
  id: SourceExists(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: SourceExists(String,String)
  nameWithType: EventLog.SourceExists(String,String)
  fullName: System.Diagnostics.EventLog.SourceExists(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Determina se uma origem de evento é registada num computador especificado."
  remarks: "Utilize este método para determinar a existência de uma origem de evento num computador especificado pelo `machineName` parâmetro. Se pretende determinar se existe um registo no computador especificado, utilize <xref:System.Diagnostics.EventLog.Exists%2A>.</xref:System.Diagnostics.EventLog.Exists%2A>       Porque este método acede ao registo, tem de ter as permissões de registo adequados num determinado servidor; caso contrário, um <xref:System.Security.SecurityException>será emitida.</xref:System.Security.SecurityException>      > [!NOTE] > Para procurar uma origem de evento no Windows Vista e posterior ou o Windows Server 2003, tem de ter privilégios administrativos.   >> A razão para este requisito é que todos os registos de eventos, incluindo a segurança, tem de ser procurados para determinar se a origem do evento é exclusiva. A partir do Windows Vista, os utilizadores não têm permissão para aceder ao registo de segurança; Por conseguinte, um <xref:System.Security.SecurityException>é emitida.</xref:System.Security.SecurityException>   >> Começando com o Windows Vista, controlo de conta de utilizador (UAC) determina os privilégios de utilizador. Se for um membro do grupo Administradores incorporado, são atribuídos dois tokens de acesso de tempo de execução: um token de acesso de utilizador padrão e um token de acesso de administrador. Por predefinição, está na função de utilizador padrão. Para executar o código que acede ao contadores de desempenho, primeiro tem elevar os privilégios de utilizador padrão ao administrador. Pode fazê-lo quando iniciar uma aplicação ao clicar no ícone de aplicação e com a indicação de que pretende executar como administrador.      > [!NOTE] > Um serviço que está a executar sob a <xref:System.ServiceProcess.ServiceAccount>conta não tem os privilégios necessários para executar este método.</xref:System.ServiceProcess.ServiceAccount> A solução é verificar se a origem de eventos existe no <xref:System.ServiceProcess.ServiceInstaller>, e se não existir, para criar a origem no instalador do.</xref:System.ServiceProcess.ServiceInstaller>       Porque não é possível conceder uma nova origem de nome de uma origem existente no mesmo computador, utilize este método antes de tentar chamar <xref:System.Diagnostics.EventLog.CreateEventSource%2A>para se certificar de que uma origem com o nome especificado pelo `source` já não existe no computador.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> O `source` e `machineName` parâmetros não são sensíveis a maiúsculas e minúsculas.       <xref:System.Diagnostics.EventLog.SourceExists%2A>é um `static` método, pode ser chamado na classe de si próprio.</xref:System.Diagnostics.EventLog.SourceExists%2A> Não é necessário criar uma instância de <xref:System.Diagnostics.EventLog>chamar <xref:System.Diagnostics.EventLog.SourceExists%2A>.</xref:System.Diagnostics.EventLog.SourceExists%2A> </xref:System.Diagnostics.EventLog>"
  example:
  - "The following example creates the source `MySource` on the computer `MyServer`, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_16_1.cpp)]\n [!code-cs[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_16_1.cs)]\n [!code-vb[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_16_1.vb)]"
  syntax:
    content: public static bool SourceExists (string source, string machineName);
    parameters:
    - id: source
      type: System.String
      description: "O nome da origem de evento."
    - id: machineName
      type: System.String
      description: "O nome do computador em que pretende procurar, ou &quot;.&quot; para o computador local."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a origem do evento é registada num determinado computador; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.EventLog.SourceExists*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>machineName</code>é um nome de computador inválidos."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<code>source</code>Não foi encontrada, mas não foi possível procurar alguns ou todos os registos de eventos."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.SynchronizingObject
  id: SynchronizingObject
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: SynchronizingObject
  nameWithType: EventLog.SynchronizingObject
  fullName: System.Diagnostics.EventLog.SynchronizingObject
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define o objeto utilizado para empacotar referências das chamadas do processador de eventos emitidas como resultado de uma <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> escrita eventos de entrada."
  remarks: "Quando é SynchronizingObject `null`, métodos de processamento de <xref:System.Diagnostics.EventLog.EntryWritten>evento são chamado num thread de conjunto de threads de sistema.</xref:System.Diagnostics.EventLog.EntryWritten> Para obter mais informações sobre agrupamentos de thread do sistema, consulte <xref:System.Threading.ThreadPool>.</xref:System.Threading.ThreadPool>       Quando o <xref:System.Diagnostics.EventLog.EntryWritten>evento é processado por um visual Windows Forms componente, por exemplo, um botão, o componente a aceder através do conjunto de threads de sistema poderão não funcionar, ou poderá resultar numa exceção.</xref:System.Diagnostics.EventLog.EntryWritten> Evitar o problema definindo SynchronizingObject como um componente do Windows Forms, o que faz com que os métodos de processamento de <xref:System.Diagnostics.EventLog.EntryWritten>eventos ser chamado no mesmo thread em que o componente foi criado.</xref:System.Diagnostics.EventLog.EntryWritten>       Se o <xref:System.Diagnostics.EventLog>é utilizado no interior [!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)] no designer de Windows Forms, SynchronizingObject é automaticamente definido para o controlo que contém o <xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog> Por exemplo, se colocar um <xref:System.Diagnostics.EventLog>no designer para Form1 (que herda de <xref:System.Windows.Forms.Form>) a propriedade SynchronizingObject <xref:System.Diagnostics.EventLog>está definido para a instância do Form1.</xref:System.Diagnostics.EventLog> </xref:System.Windows.Forms.Form> </xref:System.Diagnostics.EventLog>"
  syntax:
    content: public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }
    return:
      type: System.ComponentModel.ISynchronizeInvoke
      description: "O <xref href=&quot;System.ComponentModel.ISynchronizeInvoke&quot;> </xref> utilizado para empacotar referências das chamadas do processador de eventos emitidas como resultado de uma <xref href=&quot;System.Diagnostics.EventLog.EntryWritten&quot;> </xref> eventos no registo de eventos."
  overload: System.Diagnostics.EventLog.SynchronizingObject*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String)
  id: WriteEntry(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String)
  nameWithType: EventLog.WriteEntry(String)
  fullName: System.Diagnostics.EventLog.WriteEntry(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Escreve uma entrada de tipo de informações, com o texto da mensagem especificada, o registo de eventos."
  remarks: "Utilize este método para escrever uma entrada de informações para o registo de eventos associado a este <xref:System.Diagnostics.EventLog>instância.</xref:System.Diagnostics.EventLog> Se pretender especificar quaisquer outros <xref:System.Diagnostics.EventLogEntryType>Utilize uma sobrecarga de <xref:System.Diagnostics.EventLog.WriteEntry%2A>.</xref:System.Diagnostics.EventLog.WriteEntry%2A> diferentes</xref:System.Diagnostics.EventLogEntryType>      > [!NOTE] > O `message` cadeia não pode conter %*n*, onde *n* é um valor de número inteiro (por exemplo, %1), porque o Visualizador de eventos trata-la como uma cadeia de inserção. Porque um protocolo de Internet, a versão 6 (IPv6) endereço pode conter esta sequência de caracteres, não pode registar uma mensagem de evento que contém um endereço IPv6.       Tem de definir a <xref:System.Diagnostics.EventLog.Source%2A>propriedade no seu <xref:System.Diagnostics.EventLog>componente antes de poder escrever entradas no registo.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> Tem de criar e configurar a origem do evento antes de escrever a entrada primeiro com a origem.       Crie a nova origem de evento durante a instalação da aplicação. Isto permite que o tempo para o sistema operativo atualizar a lista de origens de eventos registados e a respetiva configuração. Se o sistema operativo não tem de atualizar a lista de origens de eventos e a tentativa de escrever um evento com a nova origem, que a operação de escrita irá falhar. Pode configurar uma nova origem utilizando um <xref:System.Diagnostics.EventLogInstaller>, ou utilizando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A>método.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Tem de ter direitos administrativos no computador para criar uma nova origem de evento.       Se a origem especificada no <xref:System.Diagnostics.EventLog.Source%2A>propriedade deste <xref:System.Diagnostics.EventLog>instância não está registada no computador que o componente está a escrever, <xref:System.Diagnostics.EventLog.WriteEntry%2A>chamadas <xref:System.Diagnostics.EventLog.CreateEventSource%2A>e regista a origem.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Se não especificar um <xref:System.Diagnostics.EventLog.MachineName%2A>para sua <xref:System.Diagnostics.EventLog>instância antes de chamar <xref:System.Diagnostics.EventLog.CreateEventSource%2A>ou <xref:System.Diagnostics.EventLog.WriteEntry%2A>, o computador local (&quot;.&quot;) é assumido.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       Se o sistema tem de registar <xref:System.Diagnostics.EventLog.Source%2A>através de uma chamada para <xref:System.Diagnostics.EventLog.WriteEntry%2A>e a <xref:System.Diagnostics.EventLog.Log%2A>propriedade não foi definida na sua <xref:System.Diagnostics.EventLog>instância, o registo de predefinições para o registo da aplicação.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Muitas das exceções listadas acima foram geradas por erros gerados durante o processo de registo <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>       A origem tem de ser configurada para escrever entradas localizadas ou de escrita diretas cadeias. O <xref:System.Diagnostics.EventLog.WriteEntry%2A>método escreve a cadeia fornecida diretamente o registo de eventos; não utilize um ficheiro de recursos de mensagem localizável.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Utilize o <xref:System.Diagnostics.EventLog.WriteEvent%2A>método para escrever eventos utilizando um ficheiro de recursos localizados da mensagem.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Se a sua aplicação escreve entradas utilizando identificadores de recursos e valores de cadeia, tem de registar duas origens separadas. Por exemplo, configurar uma origem com ficheiros de recursos e, em seguida, utilize essa origem no <xref:System.Diagnostics.EventLog.WriteEvent%2A>método escrever entradas utilizando identificadores de recursos para o registo de eventos.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Em seguida, criar uma origem diferente sem ficheiros de recursos e utilize essa origem no <xref:System.Diagnostics.EventLog.WriteEntry%2A>método escrever cadeias diretamente o registo de eventos através dessa origem.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Se escreve uma entrada para um computador remoto, o valor da mensagem (a cadeia de texto) poderá não ser o que esperar se o computador remoto não está a executar o .NET Framework.      > [!NOTE] > Se o `message` parâmetro contém um caráter NUL, a mensagem no registo de eventos é terminada no caráter NUL."
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_7_1.cs)]\n [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_7_1.cpp)]\n [!code-vb[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_7_1.vb)]"
  syntax:
    content: public void WriteEntry (string message);
    parameters:
    - id: message
      type: System.String
      description: "A cadeia a escrever o registo de eventos."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave de registo para o registo de eventos."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O sistema operativo reportou um erro ao escrever a entrada de evento no registo de eventos. Um código de erro do Windows não está disponível."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)
  id: WriteEntry(System.String,System.Diagnostics.EventLogEntryType)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,EventLogEntryType)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Escreve um erro, aviso, informações, auditoria com êxito ou a entrada de auditoria de falha com o texto da mensagem fornecida para o registo de eventos."
  remarks: "Utilize este método para escrever uma entrada de um especificado <xref:System.Diagnostics.EventLogEntryType>no registo de eventos.</xref:System.Diagnostics.EventLogEntryType> O `type` indicado por um ícone e o texto da coluna de tipo no Visualizador de eventos para um registo.      > [!NOTE] > O `message` cadeia não pode conter %*n*, onde *n* é um valor de número inteiro (por exemplo, %1), porque o Visualizador de eventos trata-la como uma cadeia de inserção. Porque um protocolo de Internet, a versão 6 (IPv6) endereço pode conter esta sequência de caracteres, não pode registar uma mensagem de evento que contém um endereço IPv6.       Tem de definir a <xref:System.Diagnostics.EventLog.Source%2A>propriedade no seu <xref:System.Diagnostics.EventLog>componente antes de poder escrever entradas no registo.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> Tem de criar e configurar a origem do evento antes de escrever a entrada primeiro com a origem.       Crie a nova origem de evento durante a instalação da aplicação. Isto permite que o tempo para o sistema operativo atualizar a lista de origens de eventos registados e a respetiva configuração. Se o sistema operativo não tem de atualizar a lista de origens de eventos e a tentativa de escrever um evento com a nova origem, que a operação de escrita irá falhar. Pode configurar uma nova origem utilizando um <xref:System.Diagnostics.EventLogInstaller>, ou utilizando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A>método.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Tem de ter direitos administrativos no computador para criar uma nova origem de evento.       Se a origem especificada no <xref:System.Diagnostics.EventLog.Source%2A>propriedade deste <xref:System.Diagnostics.EventLog>instância não está registada no computador que o componente está a escrever, <xref:System.Diagnostics.EventLog.WriteEntry%2A>chamadas <xref:System.Diagnostics.EventLog.CreateEventSource%2A>e regista a origem.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Se não especificar um <xref:System.Diagnostics.EventLog.MachineName%2A>para sua <xref:System.Diagnostics.EventLog>instância antes de chamar <xref:System.Diagnostics.EventLog.CreateEventSource%2A>ou <xref:System.Diagnostics.EventLog.WriteEntry%2A>, o computador local (&quot;.&quot;) é assumido.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       Se o sistema tem de registar <xref:System.Diagnostics.EventLog.Source%2A>através de uma chamada para <xref:System.Diagnostics.EventLog.WriteEntry%2A>e a <xref:System.Diagnostics.EventLog.Log%2A>propriedade não foi definida na sua <xref:System.Diagnostics.EventLog>instância, o registo de predefinições para o registo da aplicação.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Muitas exceções listadas acima foram geradas por erros gerados durante o processo de registo <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>       A origem tem de ser configurada para escrever entradas localizadas ou de escrita diretas cadeias. O <xref:System.Diagnostics.EventLog.WriteEntry%2A>método escreve a cadeia fornecida diretamente o registo de eventos; não utilize um ficheiro de recursos de mensagem localizável.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Utilize o <xref:System.Diagnostics.EventLog.WriteEvent%2A>método para escrever eventos utilizando um ficheiro de recursos localizados da mensagem.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Se a sua aplicação escreve entradas utilizando identificadores de recursos e valores de cadeia, tem de registar duas origens separadas. Por exemplo, configurar uma origem com ficheiros de recursos e, em seguida, utilize essa origem no <xref:System.Diagnostics.EventLog.WriteEvent%2A>método escrever entradas utilizando identificadores de recursos para o registo de eventos.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Em seguida, criar uma origem diferente sem ficheiros de recursos e utilize essa origem no <xref:System.Diagnostics.EventLog.WriteEntry%2A>método escrever cadeias diretamente o registo de eventos através dessa origem.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Se escreve uma entrada para um computador remoto, o valor da mensagem (a cadeia de texto) poderá não ser o que esperar se o computador remoto não está a executar o .NET Framework.      > [!NOTE] > Se o `message` parâmetro contém um caráter NUL, a mensagem no registo de eventos é terminada no caráter NUL."
  example:
  - "The following example writes a warning entry to an event log, \"MyNewLog\", on the local computer.  \n  \n [!code-cpp[Classic EventLog.WriteEntry2 Example#1](~/add/codesnippet/cpp/19aeba79-224e-4604-90d9-_1.cpp)]\n [!code-cs[Classic EventLog.WriteEntry2 Example#1](~/add/codesnippet/csharp/19aeba79-224e-4604-90d9-_1.cs)]\n [!code-vb[Classic EventLog.WriteEntry2 Example#1](~/add/codesnippet/visualbasic/19aeba79-224e-4604-90d9-_1.vb)]"
  syntax:
    content: public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type);
    parameters:
    - id: message
      type: System.String
      description: "A cadeia a escrever o registo de eventos."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "Um do <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> valores."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>Não é um <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave de registo para o registo de eventos."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O sistema operativo reportou um erro ao escrever a entrada de evento no registo de eventos. Um código de erro do Windows não está disponível."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String)
  id: WriteEntry(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String)
  nameWithType: EventLog.WriteEntry(String,String)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Escreve uma entrada de tipo de informações com o texto da mensagem fornecida para o registo de eventos, utilizando a origem de evento registadas especificado."
  remarks: "Utilize este método para escrever uma entrada de informações para o registo de eventos, utilizando uma origem que já está registada como uma origem de evento para o registo adequado. Se pretender especificar quaisquer outros <xref:System.Diagnostics.EventLogEntryType>Utilize uma sobrecarga de <xref:System.Diagnostics.EventLog.WriteEntry%2A>.</xref:System.Diagnostics.EventLog.WriteEntry%2A> diferentes</xref:System.Diagnostics.EventLogEntryType>       Tem de criar e configurar a origem do evento antes de escrever a entrada primeiro com a origem. Crie a nova origem de evento durante a instalação da aplicação. Isto permite que o tempo para o sistema operativo atualizar a lista de origens de eventos registados e a respetiva configuração. Se o sistema operativo não tem de atualizar a lista de origens de eventos e a tentativa de escrever um evento com a nova origem, que a operação de escrita irá falhar. Pode configurar uma nova origem utilizando um <xref:System.Diagnostics.EventLogInstaller>, ou utilizando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A>método.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Tem de ter direitos administrativos no computador para criar uma nova origem de evento.       A origem tem de ser configurada para escrever entradas localizadas ou de escrita diretas cadeias. O <xref:System.Diagnostics.EventLog.WriteEntry%2A>método escreve a cadeia fornecida diretamente o registo de eventos; não utilize um ficheiro de recursos de mensagem localizável.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Utilize o <xref:System.Diagnostics.EventLog.WriteEvent%2A>método para escrever eventos utilizando um ficheiro de recursos localizados da mensagem.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Se a sua aplicação escreve entradas utilizando identificadores de recursos e valores de cadeia, tem de registar duas origens separadas. Por exemplo, configurar uma origem com ficheiros de recursos e, em seguida, utilize essa origem no <xref:System.Diagnostics.EventLog.WriteEvent%2A>método escrever entradas utilizando identificadores de recursos para o registo de eventos.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Em seguida, criar uma origem diferente sem ficheiros de recursos e utilize essa origem no <xref:System.Diagnostics.EventLog.WriteEntry%2A>método escrever cadeias diretamente o registo de eventos através dessa origem.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Se o `message` parâmetro contém um caráter NUL, a mensagem no registo de eventos é terminada no caráter NUL.   >> O `message` cadeia não pode conter %*n*, onde *n* é um valor de número inteiro (por exemplo, %1), porque o Visualizador de eventos trata-la como uma cadeia de inserção. Porque um protocolo de Internet, a versão 6 (IPv6) endereço pode conter esta sequência de caracteres, não pode registar uma mensagem de evento que contém um endereço IPv6."
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cpp[Classic EventLog.WriteEntry1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_3_1.cpp)]\n [!code-cs[Classic EventLog.WriteEntry1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_3_1.cs)]\n [!code-vb[Classic EventLog.WriteEntry1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_3_1.vb)]"
  syntax:
    content: public static void WriteEntry (string source, string message);
    parameters:
    - id: source
      type: System.String
      description: "A origem através do qual a aplicação está registada no computador especificado."
    - id: message
      type: System.String
      description: "A cadeia a escrever o registo de eventos."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave de registo para o registo de eventos."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O sistema operativo reportou um erro ao escrever a entrada de evento no registo de eventos. Um código de erro do Windows não está disponível."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  id: WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,EventLogEntryType,Int32)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Escreve uma entrada com o texto da mensagem fornecida e o identificador de evento definido pela aplicação para o registo de eventos."
  remarks: "Utilize este método para escrever uma entrada com um definido pela aplicação `eventID` ao registo de eventos. O `eventID` juntamente com a origem de identificar exclusivamente um evento. Cada aplicação pode definir os seus próprios eventos numerados e as cadeias de descrição para o qual efectuam o mapeamento. Visualizadores de evento apresentam estes valores de cadeia para o ajudar a compreender o que aconteceu e sugerir que ações de utilizador.      > [!NOTE] > O `message` cadeia não pode conter %*n*, onde *n* é um valor de número inteiro (por exemplo, %1), porque o Visualizador de eventos trata-la como uma cadeia de inserção. Porque um protocolo de Internet, a versão 6 (IPv6) endereço pode conter esta sequência de caracteres, não pode registar uma mensagem de evento que contém um endereço IPv6.       Para além do identificador de evento, pode especificar um <xref:System.Diagnostics.EventLogEntryType>para o evento que está a ser escrito no registo de eventos.</xref:System.Diagnostics.EventLogEntryType> O `type` indicado por um ícone e o texto da coluna de tipo no Visualizador de eventos para um registo. Este parâmetro indica se o tipo de evento é erro, aviso, informações, auditoria com êxito ou auditoria de falhas.       Tem de definir a <xref:System.Diagnostics.EventLog.Source%2A>propriedade no seu <xref:System.Diagnostics.EventLog>componente antes de poder escrever entradas no registo.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> Tem de criar e configurar a origem do evento antes de escrever a entrada primeiro com a origem.       Crie a nova origem de evento durante a instalação da aplicação. Isto permite que o tempo para o sistema operativo atualizar a lista de origens de eventos registados e a respetiva configuração. Se o sistema operativo não tem de atualizar a lista de origens de eventos e a tentativa de escrever um evento com a nova origem, que a operação de escrita irá falhar. Pode configurar uma nova origem utilizando um <xref:System.Diagnostics.EventLogInstaller>, ou utilizando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A>método.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Tem de ter direitos administrativos no computador para criar uma nova origem de evento.       Se a origem especificada no <xref:System.Diagnostics.EventLog.Source%2A>propriedade deste <xref:System.Diagnostics.EventLog>instância não está registada no computador que o componente está a escrever, <xref:System.Diagnostics.EventLog.WriteEntry%2A>chamadas <xref:System.Diagnostics.EventLog.CreateEventSource%2A>e regista a origem.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Se não especificar um <xref:System.Diagnostics.EventLog.MachineName%2A>para sua <xref:System.Diagnostics.EventLog>instância antes de chamar <xref:System.Diagnostics.EventLog.CreateEventSource%2A>ou <xref:System.Diagnostics.EventLog.WriteEntry%2A>, o computador local (&quot;.&quot;) é assumido.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       Se o sistema tem de registar <xref:System.Diagnostics.EventLog.Source%2A>através de uma chamada para <xref:System.Diagnostics.EventLog.WriteEntry%2A>e a <xref:System.Diagnostics.EventLog.Log%2A>propriedade não foi definida na sua <xref:System.Diagnostics.EventLog>instância, o registo de predefinições para o registo da aplicação.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Muitas exceções listadas acima foram geradas por erros gerados durante o processo de registo <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>       A origem tem de ser configurada para escrever entradas localizadas ou de escrita diretas cadeias. O <xref:System.Diagnostics.EventLog.WriteEntry%2A>método escreve a cadeia fornecida diretamente o registo de eventos; não utilize um ficheiro de recursos de mensagem localizável.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Utilize o <xref:System.Diagnostics.EventLog.WriteEvent%2A>método para escrever eventos utilizando um ficheiro de recursos localizados da mensagem.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Se a sua aplicação escreve entradas utilizando identificadores de recursos e valores de cadeia, tem de registar duas origens separadas. Por exemplo, configurar uma origem com ficheiros de recursos e, em seguida, utilize essa origem no <xref:System.Diagnostics.EventLog.WriteEvent%2A>método escrever entradas utilizando identificadores de recursos para o registo de eventos.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Em seguida, criar uma origem diferente sem ficheiros de recursos e utilize essa origem no <xref:System.Diagnostics.EventLog.WriteEntry%2A>método escrever cadeias diretamente o registo de eventos através dessa origem.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Se escreve uma entrada para um computador remoto, o valor da mensagem (a cadeia de texto) poderá não ser o que esperar se o computador remoto não está a executar o .NET Framework.      > [!NOTE] > Se o `message` parâmetro contém um caráter NUL, a mensagem no registo de eventos é terminada no caráter NUL."
  example:
  - >-
    [!code-cpp[EventLog_WriteEntry_1_3#3](~/add/codesnippet/cpp/597042ed-6d84-4ccf-a867-_1.cpp)]
     [!code-cs[EventLog_WriteEntry_1_3#3](~/add/codesnippet/csharp/597042ed-6d84-4ccf-a867-_1.cs)]
     [!code-vb[EventLog_WriteEntry_1_3#3](~/add/codesnippet/visualbasic/597042ed-6d84-4ccf-a867-_1.vb)]
  syntax:
    content: public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID);
    parameters:
    - id: message
      type: System.String
      description: "A cadeia a escrever o registo de eventos."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "Um do <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> valores."
    - id: eventID
      type: System.Int32
      description: "O identificador específico da aplicação para o evento."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave de registo para o registo de eventos."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>Não é um <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O sistema operativo reportou um erro ao escrever a entrada de evento no registo de eventos. Um código de erro do Windows não está disponível."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)
  id: WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String,EventLogEntryType)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Escreve um erro, aviso, informações, auditoria com êxito ou a entrada de auditoria de falha com o texto da mensagem fornecida para o registo de eventos, utilizando a origem de evento registadas especificado."
  remarks: "Utilize este método para escrever uma entrada de um especificado <xref:System.Diagnostics.EventLogEntryType>para o registo de eventos, utilizando uma origem já registada como uma origem de evento para o registo adequado.</xref:System.Diagnostics.EventLogEntryType> O `type` indicado por um ícone e o texto da coluna de tipo no Visualizador de eventos para um registo.      > [!NOTE] > O `message` cadeia não pode conter %*n*, onde *n* é um valor de número inteiro (por exemplo, %1), porque o Visualizador de eventos trata-la como uma cadeia de inserção. Porque um protocolo de Internet, a versão 6 (IPv6) endereço pode conter esta sequência de caracteres, não pode registar uma mensagem de evento que contém um endereço IPv6.       Tem de criar e configurar a origem do evento antes de escrever a entrada primeiro com a origem. Crie a nova origem de evento durante a instalação da aplicação. Isto permite que o tempo para o sistema operativo atualizar a lista de origens de eventos registados e a respetiva configuração. Se o sistema operativo não tem de atualizar a lista de origens de eventos e a tentativa de escrever um evento com a nova origem, que a operação de escrita irá falhar. Pode configurar uma nova origem utilizando um <xref:System.Diagnostics.EventLogInstaller>, ou utilizando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A>método.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Tem de ter direitos administrativos no computador para criar uma nova origem de evento.       A origem tem de ser configurada para escrever entradas localizadas ou de escrita diretas cadeias. O <xref:System.Diagnostics.EventLog.WriteEntry%2A>método escreve a cadeia fornecida diretamente o registo de eventos; não utilize um ficheiro de recursos de mensagem localizável.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Utilize o <xref:System.Diagnostics.EventLog.WriteEvent%2A>método para escrever eventos utilizando um ficheiro de recursos localizados da mensagem.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Se a sua aplicação escreve entradas utilizando identificadores de recursos e valores de cadeia, tem de registar duas origens separadas. Por exemplo, configurar uma origem com ficheiros de recursos e, em seguida, utilize essa origem no <xref:System.Diagnostics.EventLog.WriteEvent%2A>método escrever entradas utilizando identificadores de recursos para o registo de eventos.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Em seguida, criar uma origem diferente sem ficheiros de recursos e utilize essa origem no <xref:System.Diagnostics.EventLog.WriteEntry%2A>método escrever cadeias diretamente o registo de eventos através dessa origem.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Se o `message` parâmetro contém um caráter NUL, a mensagem no registo de eventos é terminada no caráter NUL."
  example:
  - "The following example writes a warning entry to an event log, \"MyNewLog\", on the local computer.  \n  \n [!code-cs[Classic EventLog.WriteEntry3 Example#1](~/add/codesnippet/csharp/c03f903c-8fbd-441f-afe0-_1.cs)]\n [!code-vb[Classic EventLog.WriteEntry3 Example#1](~/add/codesnippet/visualbasic/c03f903c-8fbd-441f-afe0-_1.vb)]\n [!code-cpp[Classic EventLog.WriteEntry3 Example#1](~/add/codesnippet/cpp/c03f903c-8fbd-441f-afe0-_1.cpp)]"
  syntax:
    content: public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type);
    parameters:
    - id: source
      type: System.String
      description: "A origem através do qual a aplicação está registada no computador especificado."
    - id: message
      type: System.String
      description: "A cadeia a escrever o registo de eventos."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "Um do <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> valores."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave de registo para o registo de eventos."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>Não é um <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O sistema operativo reportou um erro ao escrever a entrada de evento no registo de eventos. Um código de erro do Windows não está disponível."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  id: WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,EventLogEntryType,Int32,Int16)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Escreve uma entrada com o texto da mensagem fornecida, identificador de evento definido pela aplicação e categoria definido pela aplicação para o registo de eventos."
  remarks: "Utilize este método para escrever uma entrada com um definido pela aplicação `category` ao registo de eventos. O Visualizador de eventos utiliza a categoria para filtrar eventos escritos por uma origem de evento. O Visualizador de eventos pode apresentar a categoria como um valor numérico ou pode utilizar a categoria como um identificador de recurso para apresentar uma cadeia de categorias localizadas.      > [!NOTE] > O `category` parâmetro deve ser um valor positivo. Valores negativos categoria são apresentados como um número positivo complementares de eventos Viewer. Por exemplo, um –10 é apresentado como 65,526, um –1 como 65535.      > [!NOTE] > O `message` cadeia não pode conter %*n*, onde *n* é um valor de número inteiro (por exemplo, %1), porque o Visualizador de eventos trata-la como uma cadeia de inserção. Porque um protocolo de Internet, a versão 6 (IPv6) endereço pode conter esta sequência de caracteres, não pode registar uma mensagem de evento que contém um endereço IPv6.       Para apresentar as cadeias de categorias localizadas no Visualizador de eventos, tem de utilizar uma origem de evento configurado com um ficheiro de recursos de categoria e defina o `category` para um identificador de recurso no ficheiro de recursos de categoria. Se a origem do evento não tem um ficheiro de recursos de categoria configurado ou especificado `category` não indexar uma cadeia no ficheiro de recursos de categoria, em seguida, o Visualizador de eventos apresenta o valor numérico categoria para essa entrada. Configurar o ficheiro de recursos de categoria, juntamente com o número de cadeias da categoria no ficheiro de recursos, com o <xref:System.Diagnostics.EventLogInstaller>ou a <xref:System.Diagnostics.EventSourceCreationData>classe.</xref:System.Diagnostics.EventSourceCreationData> </xref:System.Diagnostics.EventLogInstaller>       Para além de categoria, pode especificar um identificador de evento para o evento que está a ser escrito no registo de eventos. Os identificadores de evento, juntamente com a origem do evento, identificam exclusivamente um evento. Cada aplicação pode definir os seus próprios eventos numerados e as cadeias de descrição para o qual efectuam o mapeamento. Visualizadores de evento apresentam estes valores de cadeia para o ajudar a compreender o que aconteceu e sugerir que ações de utilizador.       Por fim, pode especificar um <xref:System.Diagnostics.EventLogEntryType>para o evento que está a ser escrito no registo de eventos.</xref:System.Diagnostics.EventLogEntryType> O `type` indicado por um ícone e o texto da coluna de tipo no Visualizador de eventos para um registo. Este parâmetro indica se o tipo de evento é erro, aviso, informações, auditoria com êxito ou auditoria de falhas.       Tem de definir a <xref:System.Diagnostics.EventLog.Source%2A>propriedade no seu <xref:System.Diagnostics.EventLog>componente antes de poder escrever entradas no registo.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> Tem de criar e configurar a origem do evento antes de escrever a entrada primeiro com a origem.       Crie a nova origem de evento durante a instalação da aplicação. Isto permite que o tempo para o sistema operativo atualizar a lista de origens de eventos registados e a respetiva configuração. Se o sistema operativo não tem de atualizar a lista de origens de eventos e a tentativa de escrever um evento com a nova origem, que a operação de escrita irá falhar. Pode configurar uma nova origem utilizando um <xref:System.Diagnostics.EventLogInstaller>, ou utilizando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A>método.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Tem de ter direitos administrativos no computador para criar uma nova origem de evento.       Se a origem especificada no <xref:System.Diagnostics.EventLog.Source%2A>propriedade deste <xref:System.Diagnostics.EventLog>instância não está registada no computador que o componente está a escrever, <xref:System.Diagnostics.EventLog.WriteEntry%2A>chamadas <xref:System.Diagnostics.EventLog.CreateEventSource%2A>e regista a origem.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Se não especificar um <xref:System.Diagnostics.EventLog.MachineName%2A>para sua <xref:System.Diagnostics.EventLog>instância antes de chamar <xref:System.Diagnostics.EventLog.CreateEventSource%2A>ou <xref:System.Diagnostics.EventLog.WriteEntry%2A>, o computador local (&quot;.&quot;) é assumido.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       Se o sistema tem de registar <xref:System.Diagnostics.EventLog.Source%2A>através de uma chamada para <xref:System.Diagnostics.EventLog.WriteEntry%2A>e a <xref:System.Diagnostics.EventLog.Log%2A>propriedade não foi definida na sua <xref:System.Diagnostics.EventLog>instância, o registo de predefinições para o registo da aplicação.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Muitas exceções listadas acima foram geradas por erros gerados durante o processo de registo <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>       A origem tem de ser configurada para escrever entradas localizadas ou de escrita diretas cadeias. O <xref:System.Diagnostics.EventLog.WriteEntry%2A>método escreve a cadeia fornecida diretamente o registo de eventos; não utilize um ficheiro de recursos de mensagem localizável.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Utilize o <xref:System.Diagnostics.EventLog.WriteEvent%2A>método para escrever eventos utilizando um ficheiro de recursos localizados da mensagem.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Se a sua aplicação escreve entradas utilizando identificadores de recursos e valores de cadeia, tem de registar duas origens separadas. Por exemplo, configurar uma origem com ficheiros de recursos e, em seguida, utilize essa origem no <xref:System.Diagnostics.EventLog.WriteEvent%2A>método escrever entradas utilizando identificadores de recursos para o registo de eventos.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Em seguida, criar uma origem diferente sem ficheiros de recursos e utilize essa origem no <xref:System.Diagnostics.EventLog.WriteEntry%2A>método escrever cadeias diretamente o registo de eventos através dessa origem.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Se escreve uma entrada para um computador remoto, o valor da mensagem (a cadeia de texto) poderá não ser o que esperar se o computador remoto não está a executar o .NET Framework.      > [!NOTE] > Se o `message` parâmetro contém um caráter NUL, a mensagem no registo de eventos é terminada no caráter NUL."
  example:
  - >-
    [!code-cpp[EventLog_WriteEntry_1_3#3](~/add/codesnippet/cpp/b3db94bc-a96c-4168-a8f0-_1.cpp)]
     [!code-cs[EventLog_WriteEntry_1_3#3](~/add/codesnippet/csharp/b3db94bc-a96c-4168-a8f0-_1.cs)]
     [!code-vb[EventLog_WriteEntry_1_3#3](~/add/codesnippet/visualbasic/b3db94bc-a96c-4168-a8f0-_1.vb)]
  syntax:
    content: public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);
    parameters:
    - id: message
      type: System.String
      description: "A cadeia a escrever o registo de eventos."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "Um do <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> valores."
    - id: eventID
      type: System.Int32
      description: "O identificador específico da aplicação para o evento."
    - id: category
      type: System.Int16
      description: "A subcategoria específicos da aplicação associada com a mensagem."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave de registo para o registo de eventos."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>Não é um <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O sistema operativo reportou um erro ao escrever a entrada de evento no registo de eventos. Um código de erro do Windows não está disponível."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  id: WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String,EventLogEntryType,Int32)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Escreve uma entrada com o texto da mensagem fornecida e o identificador de evento definido pela aplicação para o registo de eventos, utilizando a origem de evento registadas especificado."
  remarks: "Utilize este método para escrever uma entrada com um definido pela aplicação `eventID` ao registo de eventos, utilizar uma origem já registado como uma origem de evento para o registo adequado. O `eventID`, juntamente com a origem de identificar exclusivamente um evento. Cada aplicação pode definir os seus próprios eventos numerados e as cadeias de descrição para o qual efectuam o mapeamento. Visualizadores de evento apresentam estas cadeias ao utilizador para o ajudar a compreender o que aconteceu e sugerir que ações de utilizador.      > [!NOTE] > O `message` cadeia não pode conter %*n*, onde *n* é um valor de número inteiro (por exemplo, %1), porque o Visualizador de eventos trata-la como uma cadeia de inserção. Porque um protocolo de Internet, a versão 6 (IPv6) endereço pode conter esta sequência de caracteres, não pode registar uma mensagem de evento que contém um endereço IPv6.       Para além do identificador de evento, esta sobrecarga de <xref:System.Diagnostics.EventLog.WriteEntry%2A>permite-lhe especificar uma <xref:System.Diagnostics.EventLogEntryType>para o evento que está a ser escrito no registo de eventos.</xref:System.Diagnostics.EventLogEntryType> </xref:System.Diagnostics.EventLog.WriteEntry%2A> O `type` indicado por um ícone e o texto da coluna de tipo no Visualizador de eventos para um registo. Este parâmetro indica se o tipo de evento é erro, aviso, informações, auditoria com êxito ou auditoria de falhas.       Tem de criar e configurar a origem do evento antes de escrever a entrada primeiro com a origem. Crie a nova origem de evento durante a instalação da aplicação. Isto permite que o tempo para o sistema operativo atualizar a lista de origens de eventos registados e a respetiva configuração. Se o sistema operativo não tem de atualizar a lista de origens de eventos e a tentativa de escrever um evento com a nova origem, que a operação de escrita irá falhar. Pode configurar uma nova origem utilizando um <xref:System.Diagnostics.EventLogInstaller>, ou utilizando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A>método.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Tem de ter direitos administrativos no computador para criar uma nova origem de evento.       A origem tem de ser configurada para escrever entradas localizadas ou de escrita diretas cadeias. O <xref:System.Diagnostics.EventLog.WriteEntry%2A>método escreve a cadeia fornecida diretamente o registo de eventos; não utilize um ficheiro de recursos de mensagem localizável.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Utilize o <xref:System.Diagnostics.EventLog.WriteEvent%2A>método para escrever eventos utilizando um ficheiro de recursos localizados da mensagem.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Se a sua aplicação escreve entradas utilizando identificadores de recursos e valores de cadeia, tem de registar duas origens separadas. Por exemplo, configurar uma origem com ficheiros de recursos e, em seguida, utilize essa origem no <xref:System.Diagnostics.EventLog.WriteEvent%2A>método escrever entradas utilizando identificadores de recursos para o registo de eventos.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Em seguida, criar uma origem diferente sem ficheiros de recursos e utilize essa origem no <xref:System.Diagnostics.EventLog.WriteEntry%2A>método escrever cadeias diretamente o registo de eventos através dessa origem.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Se o `message` parâmetro contém um caráter NUL, a mensagem no registo de eventos é terminada no caráter NUL."
  example:
  - >-
    [!code-cs[EventLog_WriteEntry_4#1](~/add/codesnippet/csharp/2d8498b8-a54d-48c9-9ee7-_1.cs)]
     [!code-cpp[EventLog_WriteEntry_4#1](~/add/codesnippet/cpp/2d8498b8-a54d-48c9-9ee7-_1.cpp)]
     [!code-vb[EventLog_WriteEntry_4#1](~/add/codesnippet/visualbasic/2d8498b8-a54d-48c9-9ee7-_1.vb)]
  syntax:
    content: public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID);
    parameters:
    - id: source
      type: System.String
      description: "A origem através do qual a aplicação está registada no computador especificado."
    - id: message
      type: System.String
      description: "A cadeia a escrever o registo de eventos."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "Um do <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> valores."
    - id: eventID
      type: System.Int32
      description: "O identificador específico da aplicação para o evento."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave de registo para o registo de eventos."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>Não é um <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O sistema operativo reportou um erro ao escrever a entrada de evento no registo de eventos. Um código de erro do Windows não está disponível."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  id: WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Escreve uma entrada com o texto da mensagem fornecida, identificador de evento definido pela aplicação e definidas pela aplicação categoria no registo de eventos e acrescenta dados binários para a mensagem."
  remarks: "Utilize esta sobrecarga de para escrever dados de evento específicos definido pela aplicação para o registo de eventos. O Visualizador de eventos não interpretar dados; Apresenta os dados não processados apenas num formato de texto e hexadecimal combinado. Utilize dados de eventos específicos com moderação, incluindo-lo apenas se tiver a certeza de que será útil para alguém depurar o problema. Também pode utilizar os dados de eventos específicos para armazenar as informações que a aplicação pode processar independentemente o Visualizador de eventos. Por exemplo, pode escrever um visualizador especificamente para os eventos ou escrever um programa que analisa o ficheiro de registo e cria relatórios incluem informações dos dados de eventos específicos.       Para além dos dados binários, pode especificar uma categoria definido pela aplicação e um identificador de evento definido pela aplicação. O Visualizador de eventos utiliza a categoria para filtrar eventos escritos por uma origem de evento. O Visualizador de eventos pode apresentar a categoria como um valor numérico ou pode utilizar a categoria como um identificador de recurso para apresentar uma cadeia de categorias localizadas.      > [!NOTE] > O `message` cadeia não pode conter %*n*, onde *n* é um valor de número inteiro (por exemplo, %1), porque o Visualizador de eventos trata-la como uma cadeia de inserção. Porque um protocolo de Internet, a versão 6 (IPv6) endereço pode conter esta sequência de caracteres, não pode registar uma mensagem de evento que contém um endereço IPv6.      > [!NOTE] > O `category` parâmetro deve ser um valor positivo. Valores negativos categoria são apresentados como um número positivo complementares de eventos Viewer. Por exemplo, um –10 é apresentado como 65,526, um –1 como 65535.       Para apresentar as cadeias de categorias localizadas no Visualizador de eventos, tem de utilizar uma origem de evento configurado com um ficheiro de recursos de categoria e defina o `category` para um identificador de recurso no ficheiro de recursos de categoria. Se a origem do evento não tem um ficheiro de recursos de categoria configurado ou especificado `category` não indexar uma cadeia no ficheiro de recursos de categoria, em seguida, o Visualizador de eventos apresenta o valor numérico categoria para essa entrada. Configurar o ficheiro de recursos de categoria, juntamente com o número de cadeias da categoria no ficheiro de recursos, com o <xref:System.Diagnostics.EventLogInstaller>ou a <xref:System.Diagnostics.EventSourceCreationData>classe.</xref:System.Diagnostics.EventSourceCreationData> </xref:System.Diagnostics.EventLogInstaller>       Os identificadores de evento, juntamente com a origem do evento, identificam exclusivamente um evento. Cada aplicação pode definir os seus próprios eventos numerados e as cadeias de descrição para o qual efectuam o mapeamento. Visualizadores de evento apresentam estes valores de cadeia para o ajudar a compreender o que aconteceu e sugerir que ações de utilizador.       Por fim, pode especificar um <xref:System.Diagnostics.EventLogEntryType>para o evento que está a ser escrito no registo de eventos.</xref:System.Diagnostics.EventLogEntryType> O `type` indicado por um ícone e o texto da coluna de tipo no Visualizador de eventos para um registo. Este parâmetro indica se o tipo de evento é erro, aviso, informações, auditoria com êxito ou auditoria de falhas.       Tem de definir a <xref:System.Diagnostics.EventLog.Source%2A>propriedade no seu <xref:System.Diagnostics.EventLog>componente antes de poder escrever entradas no registo.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> Tem de criar e configurar a origem do evento antes de escrever a entrada primeiro com a origem.       Crie a nova origem de evento durante a instalação da aplicação. Isto permite que o tempo para o sistema operativo atualizar a lista de origens de eventos registados e a respetiva configuração. Se o sistema operativo não tem de atualizar a lista de origens de eventos e a tentativa de escrever um evento com a nova origem, que a operação de escrita irá falhar. Pode configurar uma nova origem utilizando um <xref:System.Diagnostics.EventLogInstaller>, ou utilizando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A>método.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Tem de ter direitos administrativos no computador para criar uma nova origem de evento.       Se a origem especificada no <xref:System.Diagnostics.EventLog.Source%2A>propriedade deste <xref:System.Diagnostics.EventLog>instância não está registada no computador que o componente está a escrever, <xref:System.Diagnostics.EventLog.WriteEntry%2A>chamadas <xref:System.Diagnostics.EventLog.CreateEventSource%2A>e regista a origem.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Se não especificar um <xref:System.Diagnostics.EventLog.MachineName%2A>para sua <xref:System.Diagnostics.EventLog>instância antes de chamar <xref:System.Diagnostics.EventLog.CreateEventSource%2A>ou <xref:System.Diagnostics.EventLog.WriteEntry%2A>, o computador local (&quot;.&quot;) é assumido.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       Se o sistema tem de registar <xref:System.Diagnostics.EventLog.Source%2A>através de uma chamada para <xref:System.Diagnostics.EventLog.WriteEntry%2A>e a <xref:System.Diagnostics.EventLog.Log%2A>propriedade não foi definida na sua <xref:System.Diagnostics.EventLog>instância, o registo de predefinições para o registo da aplicação.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Muitas exceções listadas acima foram geradas por erros gerados durante o processo de registo <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>       A origem tem de ser configurada para escrever entradas localizadas ou de escrita diretas cadeias. O <xref:System.Diagnostics.EventLog.WriteEntry%2A>método escreve a cadeia fornecida diretamente o registo de eventos; não utilize um ficheiro de recursos de mensagem localizável.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Utilize o <xref:System.Diagnostics.EventLog.WriteEvent%2A>método para escrever eventos utilizando um ficheiro de recursos localizados da mensagem.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Se a sua aplicação escreve entradas utilizando identificadores de recursos e valores de cadeia, tem de registar duas origens separadas. Por exemplo, configurar uma origem com ficheiros de recursos e, em seguida, utilize essa origem no <xref:System.Diagnostics.EventLog.WriteEvent%2A>método escrever entradas utilizando identificadores de recursos para o registo de eventos.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Em seguida, criar uma origem diferente sem ficheiros de recursos e utilize essa origem no <xref:System.Diagnostics.EventLog.WriteEntry%2A>método escrever cadeias diretamente o registo de eventos através dessa origem.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Se escreve uma entrada para um computador remoto, o valor da mensagem (a cadeia de texto) poderá não ser o que esperar se o computador remoto não está a executar o .NET Framework.      > [!NOTE] > Se o `message` parâmetro contém um caráter NUL, a mensagem no registo de eventos é terminada no caráter NUL."
  example:
  - >-
    [!code-cs[EventLog_WriteEntry_5#1](~/add/codesnippet/csharp/1c6518b6-dc55-4c74-9028-_1.cs)]
     [!code-vb[EventLog_WriteEntry_5#1](~/add/codesnippet/visualbasic/1c6518b6-dc55-4c74-9028-_1.vb)]
     [!code-cpp[EventLog_WriteEntry_5#1](~/add/codesnippet/cpp/1c6518b6-dc55-4c74-9028-_1.cpp)]
  syntax:
    content: public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);
    parameters:
    - id: message
      type: System.String
      description: "A cadeia a escrever o registo de eventos."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "Um do <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> valores."
    - id: eventID
      type: System.Int32
      description: "O identificador específico da aplicação para o evento."
    - id: category
      type: System.Int16
      description: "A subcategoria específicos da aplicação associada com a mensagem."
    - id: rawData
      type: System.Byte[]
      description: "Uma matriz de bytes que contém os dados binários associados a entrada."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave de registo para o registo de eventos."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>Não é um <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O sistema operativo reportou um erro ao escrever a entrada de evento no registo de eventos. Um código de erro do Windows não está disponível."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  id: WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Escreve uma entrada com o texto da mensagem fornecida, identificador de evento definido pela aplicação e categoria definido pela aplicação para o registo de eventos, utilizando a origem de evento registadas especificado. O <code> category </code> podem ser utilizados pelo Visualizador de eventos para filtrar eventos no registo."
  remarks: "Utilize este método para escrever uma entrada com um definido pela aplicação `category` para o registo de eventos, utilizando uma origem que já está registada como uma origem de evento para o registo adequado. O Visualizador de eventos utiliza a categoria para filtrar eventos escritos por uma origem de evento. O Visualizador de eventos pode apresentar a categoria como um valor numérico ou pode utilizar a categoria como um identificador de recurso para apresentar uma cadeia de categorias localizadas.      > [!NOTE] > O `category` parâmetro deve ser um valor positivo. Valores negativos categoria são apresentados como um número positivo complementares de eventos Viewer. Por exemplo, um –10 é apresentado como 65,526, um –1 como 65535.       Para apresentar as cadeias de categorias localizadas no Visualizador de eventos, tem de utilizar uma origem de evento configurado com um ficheiro de recursos de categoria e defina o `category` para um identificador de recurso no ficheiro de recursos de categoria. Se a origem do evento não tem um ficheiro de recursos de categoria configurado ou especificado `category` não indexar uma cadeia no ficheiro de recursos de categoria, em seguida, o Visualizador de eventos apresenta o valor numérico categoria para essa entrada. Configurar o ficheiro de recursos de categoria, juntamente com o número de cadeias da categoria no ficheiro de recursos, com o <xref:System.Diagnostics.EventLogInstaller>ou a <xref:System.Diagnostics.EventSourceCreationData>classe.</xref:System.Diagnostics.EventSourceCreationData> </xref:System.Diagnostics.EventLogInstaller>       Para além de categoria, pode especificar um identificador de evento para o evento que está a ser escrito no registo de eventos. Os identificadores de evento, juntamente com a origem do evento, identificam exclusivamente um evento. Cada aplicação pode definir os seus próprios eventos numerados e as cadeias de descrição para o qual efectuam o mapeamento. Visualizadores de evento apresentam estes valores de cadeia para o ajudar a compreender o que aconteceu e sugerir que ações de utilizador.       Por fim, pode especificar um <xref:System.Diagnostics.EventLogEntryType>para o evento que está a ser escrito no registo de eventos.</xref:System.Diagnostics.EventLogEntryType> O `type` indicado por um ícone e o texto da coluna de tipo no Visualizador de eventos para um registo. Este parâmetro indica se o tipo de evento é erro, aviso, informações, auditoria com êxito ou auditoria de falhas.       Tem de criar e configurar a origem do evento antes de escrever a entrada primeiro com a origem. Crie a nova origem de evento durante a instalação da aplicação. Isto permite que o tempo para o sistema operativo atualizar a lista de origens de eventos registados e a respetiva configuração. Se o sistema operativo não tem de atualizar a lista de origens de eventos e a tentativa de escrever um evento com a nova origem, que a operação de escrita irá falhar. Pode configurar uma nova origem utilizando um <xref:System.Diagnostics.EventLogInstaller>, ou utilizando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A>método.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Tem de ter direitos administrativos no computador para criar uma nova origem de evento.       A origem tem de ser configurada para escrever entradas localizadas ou de escrita diretas cadeias. O <xref:System.Diagnostics.EventLog.WriteEntry%2A>método escreve a cadeia fornecida diretamente o registo de eventos; não utilize um ficheiro de recursos de mensagem localizável.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Utilize o <xref:System.Diagnostics.EventLog.WriteEvent%2A>método para escrever eventos utilizando um ficheiro de recursos localizados da mensagem.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Se a sua aplicação escreve entradas utilizando identificadores de recursos e valores de cadeia, tem de registar duas origens separadas. Por exemplo, configurar uma origem com ficheiros de recursos e, em seguida, utilize essa origem no <xref:System.Diagnostics.EventLog.WriteEvent%2A>método escrever entradas utilizando identificadores de recursos para o registo de eventos.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Em seguida, criar uma origem diferente sem ficheiros de recursos e utilize essa origem no <xref:System.Diagnostics.EventLog.WriteEntry%2A>método escrever cadeias diretamente o registo de eventos através dessa origem.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Se o `message` parâmetro contém um caráter NUL, a mensagem no registo de eventos é terminada no caráter NUL.   >> O `message` cadeia não pode conter %*n*, onde *n* é um valor de número inteiro (por exemplo, %1), porque o Visualizador de eventos trata-la como uma cadeia de inserção. Porque um protocolo de Internet, a versão 6 (IPv6) endereço pode conter esta sequência de caracteres, não pode registar uma mensagem de evento que contém um endereço IPv6."
  example:
  - >-
    [!code-cpp[EventLog_WriteEntry_1_3#1](~/add/codesnippet/cpp/189fd615-c100-4e72-9c0b-_1.cpp)]
     [!code-cs[EventLog_WriteEntry_1_3#1](~/add/codesnippet/csharp/189fd615-c100-4e72-9c0b-_1.cs)]
     [!code-vb[EventLog_WriteEntry_1_3#1](~/add/codesnippet/visualbasic/189fd615-c100-4e72-9c0b-_1.vb)]
  syntax:
    content: public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);
    parameters:
    - id: source
      type: System.String
      description: "A origem através do qual a aplicação está registada no computador especificado."
    - id: message
      type: System.String
      description: "A cadeia a escrever o registo de eventos."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "Um do <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> valores."
    - id: eventID
      type: System.Int32
      description: "O identificador específico da aplicação para o evento."
    - id: category
      type: System.Int16
      description: "A subcategoria específicos da aplicação associada com a mensagem."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave de registo para o registo de eventos."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>Não é um <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O sistema operativo reportou um erro ao escrever a entrada de evento no registo de eventos. Um código de erro do Windows não está disponível."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  id: WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Escreve uma entrada com o texto da mensagem fornecida, identificador de evento definido pela aplicação e definidas pela aplicação categoria no registo de eventos (utilizando a origem de evento registadas especificado) e acrescenta dados binários para a mensagem."
  remarks: "Utilize este método para escrever dados de evento específicos definido pela aplicação para o registo de eventos, utilizando uma origem já registada como uma origem de evento para o registo adequado. O Visualizador de eventos não interpretar dados; Apresenta os dados não processados apenas num formato de texto e hexadecimal combinado. Utilizar dados específicos do evento com moderação; inclua apenas se tiver a certeza de que será útil. Também pode utilizar os dados de eventos específicos para armazenar as informações que a aplicação pode processar independentemente o Visualizador de eventos. Por exemplo, pode escrever um visualizador especificamente para os eventos ou escrever um programa que analisa o ficheiro de registo e cria relatórios incluem informações dos dados de eventos específicos.       Para além dos dados binários, pode especificar uma categoria definido pela aplicação e um identificador de evento definido pela aplicação. O Visualizador de eventos utiliza a categoria para filtrar eventos escritos por uma origem de evento. O Visualizador de eventos pode apresentar a categoria como um valor numérico ou pode utilizar a categoria como um identificador de recurso para apresentar uma cadeia de categorias localizadas.      > [!NOTE] > O `category` parâmetro deve ser um valor positivo. Valores negativos categoria são apresentados como um número positivo complementares de eventos Viewer. Por exemplo, um –10 aparece como 65,526, um –1 como 65535.       Para apresentar as cadeias de categorias localizadas no Visualizador de eventos, tem de utilizar uma origem de evento configurado com um ficheiro de recursos de categoria e defina o `category` para um identificador de recurso no ficheiro de recursos de categoria. Se a origem do evento não tem um ficheiro de recursos de categoria configurado ou especificado `category` não indexar uma cadeia no ficheiro de recursos de categoria, em seguida, o Visualizador de eventos apresenta o valor numérico categoria para essa entrada. Configurar o ficheiro de recursos de categoria, juntamente com o número de cadeias da categoria no ficheiro de recursos, com o <xref:System.Diagnostics.EventLogInstaller>ou a <xref:System.Diagnostics.EventSourceCreationData>classe.</xref:System.Diagnostics.EventSourceCreationData> </xref:System.Diagnostics.EventLogInstaller>       Os identificadores de evento, juntamente com a origem do evento, identificam exclusivamente um evento. Cada aplicação pode definir os seus próprios eventos numerados e as cadeias de descrição para o qual efectuam o mapeamento. Visualizadores de evento apresentam estes valores de cadeia para o ajudar a compreender o que aconteceu e sugerir que ações de utilizador.       Por fim, pode especificar um <xref:System.Diagnostics.EventLogEntryType>para o evento que está a ser escrito no registo de eventos.</xref:System.Diagnostics.EventLogEntryType> O `type` indicado por um ícone e o texto da coluna de tipo no Visualizador de eventos para um registo. Este parâmetro indica se o tipo de evento é erro, aviso, informações, auditoria com êxito ou auditoria de falhas.       Tem de criar e configurar a origem do evento antes de escrever a entrada primeiro com a origem. Crie a nova origem de evento durante a instalação da aplicação. Isto permite que o tempo para o sistema operativo atualizar a lista de origens de eventos registados e a respetiva configuração. Se o sistema operativo não tem de atualizar a lista de origens de eventos e a tentativa de escrever um evento com a nova origem, que a operação de escrita irá falhar. Pode configurar uma nova origem utilizando um <xref:System.Diagnostics.EventLogInstaller>, ou utilizando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A>método.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Tem de ter direitos administrativos no computador para criar uma nova origem de evento.       A origem tem de ser configurada para escrever entradas localizadas ou de escrita diretas cadeias. O <xref:System.Diagnostics.EventLog.WriteEntry%2A>método escreve a cadeia fornecida diretamente o registo de eventos; não utilize um ficheiro de recursos de mensagem localizável.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Utilize o <xref:System.Diagnostics.EventLog.WriteEvent%2A>método para escrever eventos utilizando um ficheiro de recursos localizados da mensagem.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Se a sua aplicação escreve entradas utilizando identificadores de recursos e valores de cadeia, tem de registar duas origens separadas. Por exemplo, configurar uma origem com ficheiros de recursos e, em seguida, utilize essa origem no <xref:System.Diagnostics.EventLog.WriteEvent%2A>método escrever entradas utilizando identificadores de recursos para o registo de eventos.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Em seguida, criar uma origem diferente sem ficheiros de recursos e utilize essa origem no <xref:System.Diagnostics.EventLog.WriteEntry%2A>método escrever cadeias diretamente o registo de eventos através dessa origem.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Se o `message` parâmetro contém um caráter NUL, a mensagem no registo de eventos é terminada no caráter NUL.   >> O `message` cadeia não pode conter %*n*, onde *n* é um valor de número inteiro (por exemplo, %1), porque o Visualizador de eventos trata-la como uma cadeia de inserção. Porque um protocolo de Internet, a versão 6 (IPv6) endereço pode conter esta sequência de caracteres, não pode registar uma mensagem de evento que contém um endereço IPv6."
  example:
  - >-
    [!code-cpp[EventLog_WriteEntry_1_3#2](~/add/codesnippet/cpp/0b90a83a-dcc8-46e6-a8db-_1.cpp)]
     [!code-cs[EventLog_WriteEntry_1_3#2](~/add/codesnippet/csharp/0b90a83a-dcc8-46e6-a8db-_1.cs)]
     [!code-vb[EventLog_WriteEntry_1_3#2](~/add/codesnippet/visualbasic/0b90a83a-dcc8-46e6-a8db-_1.vb)]
  syntax:
    content: public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);
    parameters:
    - id: source
      type: System.String
      description: "A origem através do qual a aplicação está registada no computador especificado."
    - id: message
      type: System.String
      description: "A cadeia a escrever o registo de eventos."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "Um do <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> valores."
    - id: eventID
      type: System.Int32
      description: "O identificador específico da aplicação para o evento."
    - id: category
      type: System.Int16
      description: "A subcategoria específicos da aplicação associada com a mensagem."
    - id: rawData
      type: System.Byte[]
      description: "Uma matriz de bytes que contém os dados binários associados a entrada."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>Não é um <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave de registo para o registo de eventos."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O sistema operativo reportou um erro ao escrever a entrada de evento no registo de eventos. Um código de erro do Windows não está disponível."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])
  id: WriteEvent(System.Diagnostics.EventInstance,System.Object[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEvent(EventInstance,Object[])
  nameWithType: EventLog.WriteEvent(EventInstance,Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(EventInstance,Object[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Escreve uma entrada localizada no registo de eventos."
  remarks: "Utilize este método para escrever uma entrada localizada no registo de eventos. Especifique as propriedades de evento com identificadores de recursos em vez de valores de cadeia. O Visualizador de eventos utiliza os identificadores de recursos para apresentar as cadeias correspondentes do ficheiro de recursos localizados para <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A> Tem de registar a origem com o ficheiro de recurso correspondente antes de escrever eventos utilizando identificadores de recursos.       A entrada `instance` instância Especifica a mensagem de evento e propriedades. Definir o <xref:System.Diagnostics.EventInstance.InstanceId%2A>do `instance` de entrada para a mensagem definida no ficheiro de recursos de mensagem de origem.</xref:System.Diagnostics.EventInstance.InstanceId%2A> Opcionalmente, pode definir o <xref:System.Diagnostics.EventInstance.CategoryId%2A>e <xref:System.Diagnostics.EventInstance.EntryType%2A>do `instance` entrada para definir o tipo de categoria e eventos de entrada do evento.</xref:System.Diagnostics.EventInstance.EntryType%2A> </xref:System.Diagnostics.EventInstance.CategoryId%2A> Também pode especificar uma matriz de cadeias de independente de idioma para inserir o texto da mensagem localizada. Definir `values` para `null` se a mensagem de evento não contém os marcadores de posição formatação para cadeias de substituição.       Tem de definir a <xref:System.Diagnostics.EventLog.Source%2A>propriedade no seu <xref:System.Diagnostics.EventLog>componente antes de utilizar <xref:System.Diagnostics.EventLog.WriteEvent%2A>.</xref:System.Diagnostics.EventLog.WriteEvent%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> A origem especificada tem de ser configurada para escrever localizadas entradas no registo; a origem tem, no mínimo, tem um ficheiro de recursos de mensagem definido.       Tem de criar e configurar a origem do evento antes de escrever a entrada primeiro com a origem. Crie a nova origem de evento durante a instalação da aplicação. Isto permite que o tempo para o sistema operativo atualizar a lista de origens de eventos registados e a respetiva configuração. Se o sistema operativo não tem de atualizar a lista de origens de eventos e a tentativa de escrever um evento com a nova origem, que a operação de escrita irá falhar. Pode configurar uma nova origem utilizando um <xref:System.Diagnostics.EventLogInstaller>, ou utilizando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A>método.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Tem de ter direitos administrativos no computador para criar uma nova origem de evento.       A origem tem de ser configurada para escrever entradas localizadas ou de escrita diretas cadeias. Utilize o <xref:System.Diagnostics.EventLog.WriteEntry%2A>método se a sua aplicação escreve os valores de cadeia diretamente para o registo de eventos.</xref:System.Diagnostics.EventLog.WriteEntry%2A>       Se a sua aplicação escreve entradas utilizando identificadores de recursos e valores de cadeia, tem de registar duas origens separadas. Por exemplo, configurar uma origem com ficheiros de recursos e, em seguida, utilize essa origem no <xref:System.Diagnostics.EventLog.WriteEvent%2A>método escrever entradas utilizando identificadores de recursos para o registo de eventos.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Em seguida, criar uma origem diferente sem ficheiros de recursos e utilize essa origem no <xref:System.Diagnostics.EventLog.WriteEntry%2A>método escrever cadeias diretamente o registo de eventos através dessa origem.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Se escrever uma entrada para um computador remoto, o valor da `message` cadeia não pode ser o que esperar se o computador remoto não está a executar o .NET Framework. Além disso, o `message` cadeia não pode conter %*n*, onde *n* é um valor de número inteiro (por exemplo, %1), porque o Visualizador de eventos trata-la como uma cadeia de inserção. Porque um protocolo de Internet, a versão 6 (IPv6) endereço pode conter esta sequência de caracteres, não pode registar uma mensagem de evento que contém um endereço IPv6."
  example:
  - "The following example writes two audit entries to the event log `myNewLog`. The example creates a new event source and a new event log if they do not exist on the local computer. The event message text is specified using a resource identifier in a resource file.  \n  \n [!code-cpp[EventLog_WriteEvent#7](~/add/codesnippet/cpp/6a714dbf-bcbc-4f5a-a8b4-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#7](~/add/codesnippet/visualbasic/6a714dbf-bcbc-4f5a-a8b4-_1.vb)]\n [!code-cs[EventLog_WriteEvent#7](~/add/codesnippet/csharp/6a714dbf-bcbc-4f5a-a8b4-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public void WriteEvent (System.Diagnostics.EventInstance instance, object[] values);
    parameters:
    - id: instance
      type: System.Diagnostics.EventInstance
      description: "Um <xref href=&quot;System.Diagnostics.EventInstance&quot;> </xref> instância que representa uma entrada de registo de eventos localizados."
    - id: values
      type: System.Object[]
      description: "Uma matriz de cadeias para intercalar o texto da mensagem da entrada de registo de eventos."
  overload: System.Diagnostics.EventLog.WriteEvent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>instance.InstanceId</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n <code>values</code> has more than 256 elements.  \n  \n \\- or -  \n  \n One of the <code>values</code> elements is longer than 32766 bytes.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>instance</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave de registo para o registo de eventos."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O sistema operativo reportou um erro ao escrever a entrada de evento no registo de eventos. Um código de erro do Windows não está disponível."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  id: WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEvent(EventInstance,Byte[],Object[])
  nameWithType: EventLog.WriteEvent(EventInstance,Byte[],Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(EventInstance,Byte[],Object[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Escreve uma entrada de registo de eventos com a dados de eventos fornecido, as cadeias de substituição de mensagem e os dados binários associados."
  remarks: "Utilize este método para escrever uma entrada localizada com dados adicionais do evento específico para o registo de eventos. Especifique as propriedades de evento com identificadores de recursos em vez de valores de cadeia. O Visualizador de eventos utiliza os identificadores de recursos para apresentar as cadeias correspondentes do ficheiro de recursos localizados para <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A> Tem de registar a origem com o ficheiro de recurso correspondente antes de escrever eventos utilizando identificadores de recursos.       A entrada `instance` instância Especifica a mensagem de evento e propriedades. Definir o <xref:System.Diagnostics.EventInstance.InstanceId%2A>do `instance` de entrada para a mensagem definida no ficheiro de recursos de mensagem de origem.</xref:System.Diagnostics.EventInstance.InstanceId%2A> Opcionalmente, pode definir o <xref:System.Diagnostics.EventInstance.CategoryId%2A>e <xref:System.Diagnostics.EventInstance.EntryType%2A>do `instance` entrada para definir o tipo de categoria e eventos de entrada do evento.</xref:System.Diagnostics.EventInstance.EntryType%2A> </xref:System.Diagnostics.EventInstance.CategoryId%2A> Também pode especificar uma matriz de cadeias de independente de idioma para inserir o texto da mensagem localizada. Definir `values` para `null` se a mensagem de evento não contém os marcadores de posição formatação para cadeias de substituição.       Especifique os dados binários com um evento quando é necessário fornecer detalhes adicionais para o evento. Por exemplo, utilizar o `data` parâmetro para incluir informações sobre um erro específico. O Visualizador de eventos não interpretar os dados do evento associado; Apresenta os dados num formato de texto e hexadecimal combinado. Utilizar dados específicos do evento com moderação; inclua apenas se tiver a certeza de que será útil. Também pode utilizar os dados de eventos específicos para armazenar as informações que a aplicação pode processar independentemente o Visualizador de eventos. Por exemplo, pode escrever um visualizador especificamente para os eventos ou escrever um programa que analisa o registo de eventos e cria relatórios incluem informações dos dados de eventos específicos.       Tem de definir a <xref:System.Diagnostics.EventLog.Source%2A>propriedade no seu <xref:System.Diagnostics.EventLog>componente antes de componente antes de utilizar <xref:System.Diagnostics.EventLog.WriteEvent%2A>.</xref:System.Diagnostics.EventLog.WriteEvent%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> A origem especificada tem de ser configurada para escrever localizadas entradas no registo; a origem tem, no mínimo, tem um ficheiro de recursos de mensagem definido.       Tem de criar e configurar a origem do evento antes de escrever a entrada primeiro com a origem. Crie a nova origem de evento durante a instalação da aplicação. Isto permite que o tempo para o sistema operativo atualizar a lista de origens de eventos registados e a respetiva configuração. Se o sistema operativo não tem de atualizar a lista de origens de eventos e a tentativa de escrever um evento com a nova origem, que a operação de escrita irá falhar. Pode configurar uma nova origem utilizando um <xref:System.Diagnostics.EventLogInstaller>, ou utilizando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A>método.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Tem de ter direitos administrativos no computador para criar uma nova origem de evento.      > [!NOTE] > Se não especificar um <xref:System.Diagnostics.EventLog.MachineName%2A>para sua <xref:System.Diagnostics.EventLog>instância antes de chamar <xref:System.Diagnostics.EventLog.WriteEvent%2A>, o computador local (&quot;.&quot;) é assumido.</xref:System.Diagnostics.EventLog.WriteEvent%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       A origem tem de ser configurada para escrever entradas localizadas ou de escrita diretas cadeias. Utilize o <xref:System.Diagnostics.EventLog.WriteEntry%2A>método se a sua aplicação escreve os valores de cadeia diretamente para o registo de eventos.</xref:System.Diagnostics.EventLog.WriteEntry%2A>       Se a sua aplicação escreve entradas utilizando identificadores de recursos e valores de cadeia, tem de registar duas origens separadas. Por exemplo, configurar uma origem com ficheiros de recursos e, em seguida, utilize essa origem no <xref:System.Diagnostics.EventLog.WriteEvent%2A>método escrever entradas utilizando identificadores de recursos para o registo de eventos.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Em seguida, criar uma origem diferente sem ficheiros de recursos e utilize essa origem no <xref:System.Diagnostics.EventLog.WriteEntry%2A>método escrever cadeias diretamente o registo de eventos através dessa origem.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Se escrever uma entrada para um computador remoto, o valor da `message` cadeia não pode ser o que esperar se o computador remoto não está a executar o .NET Framework. Além disso, o `message` cadeia não pode conter %*n*, onde *n* é um valor de número inteiro (por exemplo, %1), porque o Visualizador de eventos trata-la como uma cadeia de inserção. Porque um protocolo de Internet, a versão 6 (IPv6) endereço pode conter esta sequência de caracteres, não pode registar uma mensagem de evento que contém um endereço IPv6."
  example:
  - "The following example writes two audit entries to the event log `myNewLog`. The example creates a new event source and a new event log if they do not exist on the local computer. The event message text is specified using a resource identifier in a resource file.  \n  \n [!code-cpp[EventLog_WriteEvent#7](~/add/codesnippet/cpp/9c997f17-0108-4c5c-b894-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#7](~/add/codesnippet/visualbasic/9c997f17-0108-4c5c-b894-_1.vb)]\n [!code-cs[EventLog_WriteEvent#7](~/add/codesnippet/csharp/9c997f17-0108-4c5c-b894-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public void WriteEvent (System.Diagnostics.EventInstance instance, byte[] data, object[] values);
    parameters:
    - id: instance
      type: System.Diagnostics.EventInstance
      description: "Um <xref href=&quot;System.Diagnostics.EventInstance&quot;> </xref> instância que representa uma entrada de registo de eventos localizados."
    - id: data
      type: System.Byte[]
      description: "Uma matriz de bytes que contém os dados binários associados a entrada."
    - id: values
      type: System.Object[]
      description: "Uma matriz de cadeias para intercalar o texto da mensagem da entrada de registo de eventos."
  overload: System.Diagnostics.EventLog.WriteEvent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>instance.InstanceId</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n <code>values</code> has more than 256 elements.  \n  \n \\- or -  \n  \n One of the <code>values</code> elements is longer than 32766 bytes.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>instance</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave de registo para o registo de eventos."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O sistema operativo reportou um erro ao escrever a entrada de evento no registo de eventos. Um código de erro do Windows não está disponível."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])
  id: WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEvent(String,EventInstance,Object[])
  nameWithType: EventLog.WriteEvent(String,EventInstance,Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(String,EventInstance,Object[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Escreve uma entrada de registo de eventos com o evento indicado dados e a mensagem de cadeias de substituição, com a origem de evento registadas especificado."
  remarks: "Utilize este método para escrever uma entrada localizada para o registo de eventos, utilizando uma origem já registada como uma origem de evento para o registo adequado. Especifique as propriedades de evento com identificadores de recursos em vez de valores de cadeia. O Visualizador de eventos utiliza os identificadores de recursos para apresentar as cadeias correspondentes do ficheiro de recurso localizado para a origem. Tem de registar a origem com o ficheiro de recurso correspondente antes de escrever eventos utilizando identificadores de recursos.       A entrada `instance` instância Especifica a mensagem de evento e propriedades. Definir o <xref:System.Diagnostics.EventInstance.InstanceId%2A>do `instance` de entrada para a mensagem definida no ficheiro de recursos de mensagem de origem.</xref:System.Diagnostics.EventInstance.InstanceId%2A> Opcionalmente, pode definir o <xref:System.Diagnostics.EventInstance.CategoryId%2A>e <xref:System.Diagnostics.EventInstance.EntryType%2A>do `instance` entrada para definir o tipo de categoria e eventos de entrada do evento.</xref:System.Diagnostics.EventInstance.EntryType%2A> </xref:System.Diagnostics.EventInstance.CategoryId%2A> Também pode especificar uma matriz de cadeias de independente de idioma para inserir o texto da mensagem localizada. Definir `values` para `null` se a mensagem de evento não contém os marcadores de posição formatação para cadeias de substituição.       A origem especificada tem de estar registada para um registo de eventos antes de utilizar <xref:System.Diagnostics.EventLog.WriteEvent%2A>.</xref:System.Diagnostics.EventLog.WriteEvent%2A> A origem especificada tem de ser configurada para escrever localizadas entradas no registo; a origem tem, no mínimo, tem um ficheiro de recursos de mensagem definido.       Tem de criar e configurar a origem do evento antes de escrever a entrada primeiro com a origem. Crie a nova origem de evento durante a instalação da aplicação. Isto permite que o tempo para o sistema operativo atualizar a lista de origens de eventos registados e a respetiva configuração. Se o sistema operativo não tem de atualizar a lista de origens de eventos e a tentativa de escrever um evento com a nova origem, que a operação de escrita irá falhar. Pode configurar uma nova origem utilizando um <xref:System.Diagnostics.EventLogInstaller>, ou utilizando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A>método.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Tem de ter direitos administrativos no computador para criar uma nova origem de evento.       A origem tem de ser configurada para escrever entradas localizadas ou de escrita diretas cadeias. Utilize o <xref:System.Diagnostics.EventLog.WriteEntry%2A>método se a sua aplicação escreve os valores de cadeia diretamente para o registo de eventos.</xref:System.Diagnostics.EventLog.WriteEntry%2A>       Se a sua aplicação escreve entradas utilizando identificadores de recursos e valores de cadeia, tem de registar duas origens separadas. Por exemplo, configurar uma origem com ficheiros de recursos e, em seguida, utilize essa origem no <xref:System.Diagnostics.EventLog.WriteEvent%2A>método escrever entradas utilizando identificadores de recursos para o registo de eventos.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Em seguida, criar uma origem diferente sem ficheiros de recursos e utilize essa origem no <xref:System.Diagnostics.EventLog.WriteEntry%2A>método escrever cadeias diretamente o registo de eventos através dessa origem.</xref:System.Diagnostics.EventLog.WriteEntry%2A>"
  example:
  - "The following example writes an informational event entry and a warning event entry to an existing event log. The event message text is specified using a resource identifier in a resource file. The example assumes the corresponding resource file has been registered for the source.  \n  \n [!code-cpp[EventLog_WriteEvent#8](~/add/codesnippet/cpp/a57d89b3-94d2-4b9a-803c-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#8](~/add/codesnippet/visualbasic/a57d89b3-94d2-4b9a-803c-_1.vb)]\n [!code-cs[EventLog_WriteEvent#8](~/add/codesnippet/csharp/a57d89b3-94d2-4b9a-803c-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, object[] values);
    parameters:
    - id: source
      type: System.String
      description: "O nome da origem de evento registado para a aplicação no computador especificado."
    - id: instance
      type: System.Diagnostics.EventInstance
      description: "Um <xref href=&quot;System.Diagnostics.EventInstance&quot;> </xref> instância que representa uma entrada de registo de eventos localizados."
    - id: values
      type: System.Object[]
      description: "Uma matriz de cadeias para intercalar o texto da mensagem da entrada de registo de eventos."
  overload: System.Diagnostics.EventLog.WriteEvent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>instance.InstanceId</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n <code>values</code> has more than 256 elements.  \n  \n \\- or -  \n  \n One of the <code>values</code> elements is longer than 32766 bytes.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>instance</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave de registo para o registo de eventos."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O sistema operativo reportou um erro ao escrever a entrada de evento no registo de eventos. Um código de erro do Windows não está disponível."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  id: WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEvent(String,EventInstance,Byte[],Object[])
  nameWithType: EventLog.WriteEvent(String,EventInstance,Byte[],Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(String,EventInstance,Byte[],Object[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Escreve um evento de entrada do registo com os dados de eventos fornecido, as cadeias de substituição de mensagem e os dados binários associados e utilizar especificado registado a origem de evento."
  remarks: "Utilize este método para escrever uma entrada localizada com dados adicionais do evento específico para o registo de eventos, utilizando uma origem já registada como uma origem de evento para o registo adequado. Especifique as propriedades de evento com identificadores de recursos em vez de valores de cadeia. O Visualizador de eventos utiliza os identificadores de recursos para apresentar as cadeias correspondentes do ficheiro de recurso localizado para a origem. Tem de registar a origem com o ficheiro de recurso correspondente antes de escrever eventos utilizando identificadores de recursos.       A entrada `instance` instância Especifica a mensagem de evento e propriedades. Definir o <xref:System.Diagnostics.EventInstance.InstanceId%2A>do `instance` de entrada para a mensagem definida no ficheiro de recursos de mensagem de origem.</xref:System.Diagnostics.EventInstance.InstanceId%2A> Opcionalmente, pode definir o <xref:System.Diagnostics.EventInstance.CategoryId%2A>e <xref:System.Diagnostics.EventInstance.EntryType%2A>do `instance` entrada para definir o tipo de categoria e eventos de entrada do evento.</xref:System.Diagnostics.EventInstance.EntryType%2A> </xref:System.Diagnostics.EventInstance.CategoryId%2A> Também pode especificar uma matriz de cadeias de independente de idioma para inserir o texto da mensagem localizada. Definir `values` para `null` se a mensagem de evento não contém os marcadores de posição formatação para cadeias de substituição.       Especifique os dados binários com um evento quando é necessário fornecer detalhes adicionais para o evento. Por exemplo, utilizar o `data` parâmetro para incluir informações sobre um erro específico. O Visualizador de eventos não interpretar os dados do evento associado; Apresenta os dados num formato de texto e hexadecimal combinado. Utilizar dados específicos do evento com moderação; inclua apenas se tiver a certeza de que será útil. Também pode utilizar os dados de eventos específicos para armazenar as informações que a aplicação pode processar independentemente o Visualizador de eventos. Por exemplo, pode escrever um visualizador especificamente para os eventos ou escrever um programa que analisa o registo de eventos e cria relatórios incluem informações dos dados de eventos específicos.       A origem especificada tem de estar registada para um registo de eventos antes de utilizar <xref:System.Diagnostics.EventLog.WriteEvent%2A>.</xref:System.Diagnostics.EventLog.WriteEvent%2A> A origem especificada tem de ser configurada para escrever localizadas entradas no registo; a origem tem, no mínimo, tem um ficheiro de recursos de mensagem definido.       Tem de criar e configurar a origem do evento antes de escrever a entrada primeiro com a origem. Crie a nova origem de evento durante a instalação da aplicação. Isto permite que o tempo para o sistema operativo atualizar a lista de origens de eventos registados e a respetiva configuração. Se o sistema operativo não tem de atualizar a lista de origens de eventos e a tentativa de escrever um evento com a nova origem, que a operação de escrita irá falhar. Pode configurar uma nova origem utilizando um <xref:System.Diagnostics.EventLogInstaller>, ou utilizando o <xref:System.Diagnostics.EventLog.CreateEventSource%2A>método.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Tem de ter direitos administrativos no computador para criar uma nova origem de evento.       A origem tem de ser configurada para escrever entradas localizadas ou de escrita diretas cadeias. Utilize o <xref:System.Diagnostics.EventLog.WriteEntry%2A>método se a sua aplicação escreve os valores de cadeia diretamente para o registo de eventos.</xref:System.Diagnostics.EventLog.WriteEntry%2A>       Se a sua aplicação escreve entradas utilizando identificadores de recursos e valores de cadeia, tem de registar duas origens separadas. Por exemplo, configurar uma origem com ficheiros de recursos e, em seguida, utilize essa origem no <xref:System.Diagnostics.EventLog.WriteEvent%2A>método escrever entradas utilizando identificadores de recursos para o registo de eventos.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Em seguida, criar uma origem diferente sem ficheiros de recursos e utilize essa origem no <xref:System.Diagnostics.EventLog.WriteEntry%2A>método escrever cadeias diretamente o registo de eventos através dessa origem.</xref:System.Diagnostics.EventLog.WriteEntry%2A>"
  example:
  - "The following example writes an informational event entry and a warning event entry to an existing event log. The event message text is specified using a resource identifier in a resource file. The example assumes the corresponding resource file has been registered for the source.  \n  \n [!code-cpp[EventLog_WriteEvent#8](~/add/codesnippet/cpp/d4971002-e0d1-493b-96f8-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#8](~/add/codesnippet/visualbasic/d4971002-e0d1-493b-96f8-_1.vb)]\n [!code-cs[EventLog_WriteEvent#8](~/add/codesnippet/csharp/d4971002-e0d1-493b-96f8-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, byte[] data, object[] values);
    parameters:
    - id: source
      type: System.String
      description: "O nome da origem de evento registado para a aplicação no computador especificado."
    - id: instance
      type: System.Diagnostics.EventInstance
      description: "Um <xref href=&quot;System.Diagnostics.EventInstance&quot;> </xref> instância que representa uma entrada de registo de eventos localizados."
    - id: data
      type: System.Byte[]
      description: "Uma matriz de bytes que contém os dados binários associados a entrada."
    - id: values
      type: System.Object[]
      description: "Uma matriz de cadeias para intercalar o texto da mensagem da entrada de registo de eventos."
  overload: System.Diagnostics.EventLog.WriteEvent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>instance.InstanceId</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n <code>values</code> has more than 256 elements.  \n  \n \\- or -  \n  \n One of the <code>values</code> elements is longer than 32766 bytes.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>instance</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não foi possível abrir a chave de registo para o registo de eventos."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "O sistema operativo reportou um erro ao escrever a entrada de evento no registo de eventos. Um código de erro do Windows não está disponível."
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ComponentModel.Win32Exception
  parent: System.ComponentModel
  isExternal: false
  name: Win32Exception
  nameWithType: Win32Exception
  fullName: System.ComponentModel.Win32Exception
- uid: System.SystemException
  parent: System
  isExternal: false
  name: SystemException
  nameWithType: SystemException
  fullName: System.SystemException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.Diagnostics.EventLog.#ctor
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog()
  nameWithType: EventLog.EventLog()
  fullName: System.Diagnostics.EventLog.EventLog()
- uid: System.Diagnostics.EventLog.#ctor(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog(String)
  nameWithType: EventLog.EventLog(String)
  fullName: System.Diagnostics.EventLog.EventLog(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Diagnostics.EventLog.#ctor(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog(String,String)
  nameWithType: EventLog.EventLog(String,String)
  fullName: System.Diagnostics.EventLog.EventLog(String,String)
- uid: System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog(String,String,String)
  nameWithType: EventLog.EventLog(String,String,String)
  fullName: System.Diagnostics.EventLog.EventLog(String,String,String)
- uid: System.Diagnostics.EventLog.BeginInit
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: BeginInit()
  nameWithType: EventLog.BeginInit()
  fullName: System.Diagnostics.EventLog.BeginInit()
- uid: System.Diagnostics.EventLog.Clear
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Clear()
  nameWithType: EventLog.Clear()
  fullName: System.Diagnostics.EventLog.Clear()
- uid: System.Diagnostics.EventLog.Close
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Close()
  nameWithType: EventLog.Close()
  fullName: System.Diagnostics.EventLog.Close()
- uid: System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: CreateEventSource(EventSourceCreationData)
  nameWithType: EventLog.CreateEventSource(EventSourceCreationData)
  fullName: System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData)
- uid: System.Diagnostics.EventSourceCreationData
  parent: System.Diagnostics
  isExternal: false
  name: EventSourceCreationData
  nameWithType: EventSourceCreationData
  fullName: System.Diagnostics.EventSourceCreationData
- uid: System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: CreateEventSource(String,String)
  nameWithType: EventLog.CreateEventSource(String,String)
  fullName: System.Diagnostics.EventLog.CreateEventSource(String,String)
- uid: System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: CreateEventSource(String,String,String)
  nameWithType: EventLog.CreateEventSource(String,String,String)
  fullName: System.Diagnostics.EventLog.CreateEventSource(String,String,String)
- uid: System.Diagnostics.EventLog.Delete(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Delete(String)
  nameWithType: EventLog.Delete(String)
  fullName: System.Diagnostics.EventLog.Delete(String)
- uid: System.Diagnostics.EventLog.Delete(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Delete(String,String)
  nameWithType: EventLog.Delete(String,String)
  fullName: System.Diagnostics.EventLog.Delete(String,String)
- uid: System.Diagnostics.EventLog.DeleteEventSource(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: DeleteEventSource(String)
  nameWithType: EventLog.DeleteEventSource(String)
  fullName: System.Diagnostics.EventLog.DeleteEventSource(String)
- uid: System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: DeleteEventSource(String,String)
  nameWithType: EventLog.DeleteEventSource(String,String)
  fullName: System.Diagnostics.EventLog.DeleteEventSource(String,String)
- uid: System.Diagnostics.EventLog.Dispose(System.Boolean)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: EventLog.Dispose(Boolean)
  fullName: System.Diagnostics.EventLog.Dispose(Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Diagnostics.EventLog.EnableRaisingEvents
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: EventLog.EnableRaisingEvents
  fullName: System.Diagnostics.EventLog.EnableRaisingEvents
- uid: System.Diagnostics.EventLog.EndInit
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EndInit()
  nameWithType: EventLog.EndInit()
  fullName: System.Diagnostics.EventLog.EndInit()
- uid: System.Diagnostics.EventLog.Entries
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Entries
  nameWithType: EventLog.Entries
  fullName: System.Diagnostics.EventLog.Entries
- uid: System.Diagnostics.EventLogEntryCollection
  parent: System.Diagnostics
  isExternal: false
  name: EventLogEntryCollection
  nameWithType: EventLogEntryCollection
  fullName: System.Diagnostics.EventLogEntryCollection
- uid: System.Diagnostics.EventLog.EntryWritten
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EntryWritten
  nameWithType: EventLog.EntryWritten
  fullName: System.Diagnostics.EventLog.EntryWritten
- uid: System.Diagnostics.EntryWrittenEventHandler
  parent: System.Diagnostics
  isExternal: false
  name: EntryWrittenEventHandler
  nameWithType: EntryWrittenEventHandler
  fullName: System.Diagnostics.EntryWrittenEventHandler
- uid: System.Diagnostics.EventLog.Exists(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Exists(String)
  nameWithType: EventLog.Exists(String)
  fullName: System.Diagnostics.EventLog.Exists(String)
- uid: System.Diagnostics.EventLog.Exists(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Exists(String,String)
  nameWithType: EventLog.Exists(String,String)
  fullName: System.Diagnostics.EventLog.Exists(String,String)
- uid: System.Diagnostics.EventLog.GetEventLogs
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: GetEventLogs()
  nameWithType: EventLog.GetEventLogs()
  fullName: System.Diagnostics.EventLog.GetEventLogs()
- uid: System.Diagnostics.EventLog[]
  parent: System.Diagnostics
  isExternal: false
  name: EventLog
  nameWithType: EventLog
  fullName: System.Diagnostics.EventLog[]
  spec.csharp:
  - uid: System.Diagnostics.EventLog
    name: EventLog
    nameWithType: EventLog
    fullName: EventLog[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.EventLog.GetEventLogs(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: GetEventLogs(String)
  nameWithType: EventLog.GetEventLogs(String)
  fullName: System.Diagnostics.EventLog.GetEventLogs(String)
- uid: System.Diagnostics.EventLog.Log
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Log
  nameWithType: EventLog.Log
  fullName: System.Diagnostics.EventLog.Log
- uid: System.Diagnostics.EventLog.LogDisplayName
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: LogDisplayName
  nameWithType: EventLog.LogDisplayName
  fullName: System.Diagnostics.EventLog.LogDisplayName
- uid: System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: LogNameFromSourceName(String,String)
  nameWithType: EventLog.LogNameFromSourceName(String,String)
  fullName: System.Diagnostics.EventLog.LogNameFromSourceName(String,String)
- uid: System.Diagnostics.EventLog.MachineName
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MachineName
  nameWithType: EventLog.MachineName
  fullName: System.Diagnostics.EventLog.MachineName
- uid: System.Diagnostics.EventLog.MaximumKilobytes
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MaximumKilobytes
  nameWithType: EventLog.MaximumKilobytes
  fullName: System.Diagnostics.EventLog.MaximumKilobytes
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Diagnostics.EventLog.MinimumRetentionDays
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MinimumRetentionDays
  nameWithType: EventLog.MinimumRetentionDays
  fullName: System.Diagnostics.EventLog.MinimumRetentionDays
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: ModifyOverflowPolicy(OverflowAction,Int32)
  nameWithType: EventLog.ModifyOverflowPolicy(OverflowAction,Int32)
  fullName: System.Diagnostics.EventLog.ModifyOverflowPolicy(OverflowAction,Int32)
- uid: System.Diagnostics.OverflowAction
  parent: System.Diagnostics
  isExternal: false
  name: OverflowAction
  nameWithType: OverflowAction
  fullName: System.Diagnostics.OverflowAction
- uid: System.Diagnostics.EventLog.OverflowAction
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: OverflowAction
  nameWithType: EventLog.OverflowAction
  fullName: System.Diagnostics.EventLog.OverflowAction
- uid: System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: RegisterDisplayName(String,Int64)
  nameWithType: EventLog.RegisterDisplayName(String,Int64)
  fullName: System.Diagnostics.EventLog.RegisterDisplayName(String,Int64)
- uid: System.Diagnostics.EventLog.Source
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Source
  nameWithType: EventLog.Source
  fullName: System.Diagnostics.EventLog.Source
- uid: System.Diagnostics.EventLog.SourceExists(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SourceExists(String)
  nameWithType: EventLog.SourceExists(String)
  fullName: System.Diagnostics.EventLog.SourceExists(String)
- uid: System.Diagnostics.EventLog.SourceExists(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SourceExists(String,String)
  nameWithType: EventLog.SourceExists(String,String)
  fullName: System.Diagnostics.EventLog.SourceExists(String,String)
- uid: System.Diagnostics.EventLog.SynchronizingObject
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SynchronizingObject
  nameWithType: EventLog.SynchronizingObject
  fullName: System.Diagnostics.EventLog.SynchronizingObject
- uid: System.ComponentModel.ISynchronizeInvoke
  parent: System.ComponentModel
  isExternal: false
  name: ISynchronizeInvoke
  nameWithType: ISynchronizeInvoke
  fullName: System.ComponentModel.ISynchronizeInvoke
- uid: System.Diagnostics.EventLog.WriteEntry(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String)
  nameWithType: EventLog.WriteEntry(String)
  fullName: System.Diagnostics.EventLog.WriteEntry(String)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,EventLogEntryType)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType)
- uid: System.Diagnostics.EventLogEntryType
  parent: System.Diagnostics
  isExternal: false
  name: EventLogEntryType
  nameWithType: EventLogEntryType
  fullName: System.Diagnostics.EventLogEntryType
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String)
  nameWithType: EventLog.WriteEntry(String,String)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,EventLogEntryType,Int32)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String,EventLogEntryType)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,EventLogEntryType,Int32,Int16)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String,EventLogEntryType,Int32)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
- uid: System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent(EventInstance,Object[])
  nameWithType: EventLog.WriteEvent(EventInstance,Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(EventInstance,Object[])
- uid: System.Diagnostics.EventInstance
  parent: System.Diagnostics
  isExternal: false
  name: EventInstance
  nameWithType: EventInstance
  fullName: System.Diagnostics.EventInstance
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent(EventInstance,Byte[],Object[])
  nameWithType: EventLog.WriteEvent(EventInstance,Byte[],Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(EventInstance,Byte[],Object[])
- uid: System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent(String,EventInstance,Object[])
  nameWithType: EventLog.WriteEvent(String,EventInstance,Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(String,EventInstance,Object[])
- uid: System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent(String,EventInstance,Byte[],Object[])
  nameWithType: EventLog.WriteEvent(String,EventInstance,Byte[],Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(String,EventInstance,Byte[],Object[])
- uid: System.Diagnostics.EventLog.#ctor*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog
  nameWithType: EventLog.EventLog
- uid: System.Diagnostics.EventLog.BeginInit*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: BeginInit
  nameWithType: EventLog.BeginInit
- uid: System.Diagnostics.EventLog.Clear*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Clear
  nameWithType: EventLog.Clear
- uid: System.Diagnostics.EventLog.Close*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Close
  nameWithType: EventLog.Close
- uid: System.Diagnostics.EventLog.CreateEventSource*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: CreateEventSource
  nameWithType: EventLog.CreateEventSource
- uid: System.Diagnostics.EventLog.Delete*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Delete
  nameWithType: EventLog.Delete
- uid: System.Diagnostics.EventLog.DeleteEventSource*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: DeleteEventSource
  nameWithType: EventLog.DeleteEventSource
- uid: System.Diagnostics.EventLog.Dispose*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Dispose
  nameWithType: EventLog.Dispose
- uid: System.Diagnostics.EventLog.EnableRaisingEvents*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: EventLog.EnableRaisingEvents
- uid: System.Diagnostics.EventLog.EndInit*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EndInit
  nameWithType: EventLog.EndInit
- uid: System.Diagnostics.EventLog.Entries*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Entries
  nameWithType: EventLog.Entries
- uid: System.Diagnostics.EventLog.Exists*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Exists
  nameWithType: EventLog.Exists
- uid: System.Diagnostics.EventLog.GetEventLogs*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: GetEventLogs
  nameWithType: EventLog.GetEventLogs
- uid: System.Diagnostics.EventLog.Log*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Log
  nameWithType: EventLog.Log
- uid: System.Diagnostics.EventLog.LogDisplayName*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: LogDisplayName
  nameWithType: EventLog.LogDisplayName
- uid: System.Diagnostics.EventLog.LogNameFromSourceName*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: LogNameFromSourceName
  nameWithType: EventLog.LogNameFromSourceName
- uid: System.Diagnostics.EventLog.MachineName*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MachineName
  nameWithType: EventLog.MachineName
- uid: System.Diagnostics.EventLog.MaximumKilobytes*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MaximumKilobytes
  nameWithType: EventLog.MaximumKilobytes
- uid: System.Diagnostics.EventLog.MinimumRetentionDays*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MinimumRetentionDays
  nameWithType: EventLog.MinimumRetentionDays
- uid: System.Diagnostics.EventLog.ModifyOverflowPolicy*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: ModifyOverflowPolicy
  nameWithType: EventLog.ModifyOverflowPolicy
- uid: System.Diagnostics.EventLog.OverflowAction*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: OverflowAction
  nameWithType: EventLog.OverflowAction
- uid: System.Diagnostics.EventLog.RegisterDisplayName*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: RegisterDisplayName
  nameWithType: EventLog.RegisterDisplayName
- uid: System.Diagnostics.EventLog.Source*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Source
  nameWithType: EventLog.Source
- uid: System.Diagnostics.EventLog.SourceExists*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SourceExists
  nameWithType: EventLog.SourceExists
- uid: System.Diagnostics.EventLog.SynchronizingObject*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SynchronizingObject
  nameWithType: EventLog.SynchronizingObject
- uid: System.Diagnostics.EventLog.WriteEntry*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry
  nameWithType: EventLog.WriteEntry
- uid: System.Diagnostics.EventLog.WriteEvent*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent
  nameWithType: EventLog.WriteEvent
