### YamlMime:ManagedReference
items:
- uid: System.Threading.ReaderWriterLock
  id: ReaderWriterLock
  children:
  - System.Threading.ReaderWriterLock.#ctor
  - System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)
  - System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)
  - System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)
  - System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)
  - System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)
  - System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)
  - System.Threading.ReaderWriterLock.Finalize
  - System.Threading.ReaderWriterLock.IsReaderLockHeld
  - System.Threading.ReaderWriterLock.IsWriterLockHeld
  - System.Threading.ReaderWriterLock.ReleaseLock
  - System.Threading.ReaderWriterLock.ReleaseReaderLock
  - System.Threading.ReaderWriterLock.ReleaseWriterLock
  - System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)
  - System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)
  - System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)
  - System.Threading.ReaderWriterLock.WriterSeqNum
  langs:
  - csharp
  name: ReaderWriterLock
  nameWithType: ReaderWriterLock
  fullName: System.Threading.ReaderWriterLock
  type: Class
  summary: "Define um bloqueio que suporte escritores único e leitores múltiplos."
  remarks: "> [!IMPORTANT]> O [!INCLUDE[dnprdnshort](~/add/includes/dnprdnshort-md.md)] tem dois bloqueios de escritor do leitor, <xref:System.Threading.ReaderWriterLockSlim>e ReaderWriterLock.</xref:System.Threading.ReaderWriterLockSlim> <xref:System.Threading.ReaderWriterLockSlim>é recomendada para todos os novo desenvolvimento.</xref:System.Threading.ReaderWriterLockSlim> <xref:System.Threading.ReaderWriterLockSlim>é semelhante à ReaderWriterLock, mas tem simplificada regras para recursão e para atualizar e desatualização de estado de bloqueio.</xref:System.Threading.ReaderWriterLockSlim> <xref:System.Threading.ReaderWriterLockSlim>evita muitos casos de potencial impasse.</xref:System.Threading.ReaderWriterLockSlim> Além disso, o desempenho de <xref:System.Threading.ReaderWriterLockSlim>é significativamente melhor do que ReaderWriterLock.</xref:System.Threading.ReaderWriterLockSlim>       ReaderWriterLock é utilizado para sincronizar o acesso a um recurso. Em qualquer momento, permite o acesso de leitura em simultâneo para vários threads ou acesso de escrita para um único thread. Numa situação em que um recurso é alterado raramente, um `ReaderWriterLock` fornece uma melhor débito do que um bloqueio de um-em-a-time simple, tais como <xref:System.Threading.Monitor>.</xref:System.Threading.Monitor>       `ReaderWriterLock`funciona melhor quando acede a maioria das é leituras, enquanto escreve são pouco frequentes e de curta duração. Leitores de vários alternativa com escritores único, para que não os leitores nem escritores estão bloqueados durante longos períodos.      > [!NOTE] > Que contém as bloqueios de leitor ou de bloqueios de escritor para longos períodos serão prejudicar outros threads. Para melhor desempenho, considere reestruturar a sua aplicação para minimizar a duração das escritas.       Um thread pode conter um leitor de bloqueio ou um bloqueio de escritor, mas não ambos simultaneamente. Em vez de libertar um bloqueio de leitor para adquirir o bloqueio de escritor, pode utilizar <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>e <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> </xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>       Pedidos de bloqueio recursiva aumentam a contagem de bloqueio num bloqueio.       Os leitores e escritores são colocados em fila em separado. Quando um thread liberta o bloqueio de escritor, todos os threads a aguardar na fila de leitor nesse instantâneas são concedidos bloqueios de leitor; Quando todas os bloqueios de leitor tenham sido publicadas, de espera de thread seguinte no escritor de fila, se existir, é concedido o bloqueio de escritor e assim sucessivamente. Por outras palavras, `ReaderWriterLock` alternates entre uma coleção de leitores e um escritor.       Enquanto um thread na fila de escritor está à espera de bloqueios de leitor ativo ser libertado, threads Pedir novo bloqueios de leitor acumularem na fila de leitor. Os pedidos não são concedidos, apesar do pode partilhar acesso simultâneo com proprietários da existente do bloqueio de leitor; Isto ajuda a proteger os escritores contra as ultrapassagens indefinida por leitores.       A maioria dos métodos para adquirir bloqueios num `ReaderWriterLock` aceitar valores de limite de tempo. Utilize os tempos limite para evitar impasses na sua aplicação. Por exemplo, um thread poderá adquirir o bloqueio de escritor de um recurso e, em seguida, solicitam um bloqueio de leitor de um recurso segundo; Entretanto, outro thread poderá adquirir o bloqueio de escritor do recurso segundo e solicitam um bloqueio de leitor no primeiro. A menos que é utilizados os tempos limite, o bloqueio de threads.       Se o intervalo de tempo limite expira e o pedido de bloqueio não foi concedido, o método devolve controlo para o thread de chamada pelo argumentoutofrangeexception <xref:System.ApplicationException>.</xref:System.ApplicationException> Um thread pode detetar esta exceção e determinar a ação a realizar a seguir.       Tempos limite é expressas em milissegundos. Se utilizar um <xref:System.TimeSpan?displayProperty=fullName>para especificar o tempo limite, o valor utilizado é o número total de milissegundos inteiros representado pelo <xref:System.TimeSpan>.</xref:System.TimeSpan> </xref:System.TimeSpan?displayProperty=fullName> A tabela seguinte mostra os valores válidos de limite de tempo em milissegundos.      | Valor | Descrição |   |-----------|-----------------|   | -1 | O thread aguarda até que o bloqueio é obtido, independentemente de tempo que demora. Métodos de que especifique tempos limite de número inteiro, a constante <xref:System.Threading.Timeout.Infinite>pode ser utilizada. |   |&0; | O thread não aguardar para adquirir o bloqueio.</xref:System.Threading.Timeout.Infinite> Se o bloqueio não é possível adquirir imediatamente, o método devolve. |   | >&0; | O número de milissegundos a aguardar. |       À exceção de -1, não são permitidos valores negativos tempo limite. Se especificar um número inteiro negativo sem ser de -1, um valor de tempo limite de zero é utilizado em vez disso. (Ou seja, o método devolve sem espera, se o bloqueio não é possível adquirir imediatamente.) Se especificar um <xref:System.TimeSpan>que representa um número negativo de milissegundos que não sejam -1, <xref:System.ArgumentOutOfRangeException>é emitida.</xref:System.ArgumentOutOfRangeException> </xref:System.TimeSpan>"
  example:
  - "The following example demonstrates how to use a ReaderWriterLock to protect a shared resource, an integer value named `resource`, that is read concurrently and written exclusively by multiple threads. Note that the ReaderWriterLock is declared at the class level so that it is visible to all threads.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#1](~/add/codesnippet/cpp/t-system.threading.reade_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#1](~/add/codesnippet/csharp/t-system.threading.reade_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#1](~/add/codesnippet/visualbasic/t-system.threading.reade_1.vb)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class ReaderWriterLock : System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  inheritance:
  - System.Object
  - System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.#ctor
  id: '#ctor'
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: ReaderWriterLock()
  nameWithType: ReaderWriterLock.ReaderWriterLock()
  fullName: System.Threading.ReaderWriterLock.ReaderWriterLock()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Threading.ReaderWriterLock&quot;> </xref> classe."
  remarks: ''
  example:
  - "The following code example demonstrates how to create a new instance of the <xref:System.Threading.ReaderWriterLock> class.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_0_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_0_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_0_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_0_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_0_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_0_2.vb)]"
  syntax:
    content: public ReaderWriterLock ();
    parameters: []
  overload: System.Threading.ReaderWriterLock.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)
  id: AcquireReaderLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AcquireReaderLock(Int32)
  nameWithType: ReaderWriterLock.AcquireReaderLock(Int32)
  fullName: System.Threading.ReaderWriterLock.AcquireReaderLock(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Adquire um leitor de bloqueio, utilizando um <xref:System.Int32>valor para o tempo limite.</xref:System.Int32>"
  remarks: "AcquireReaderLock bloqueia se um thread diferente tem o bloqueio de escritor ou se, pelo menos, um thread está a aguardar o bloqueio de escritor.      > [!NOTE] > Se o thread atual já tem o bloqueio de escritor, sem bloqueio de leitor é adquirido. Em vez disso, a contagem de bloqueio no bloqueio de escritor é incrementada. Isto impede que um thread bloquear no seu próprio bloqueio de escritor. O resultado é exatamente igual ao chamar <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>e uma chamada adicional para <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>é necessária quando a libertação do bloqueio de escritor.</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> </xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>       `AcquireReaderLock`suporta pedidos de bloqueio de leitor recursiva. Ou seja, um thread pode chamar AcquireReaderLock várias vezes, que incrementa a contagem de bloqueios cada vez. Tem de chamar <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A>uma vez para cada vez que tem de chamar `AcquireReaderLock`.</xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> Em alternativa, pode chamar <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>para reduzir o número de bloqueio para zero imediatamente.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>       Pedidos de bloqueio recursiva sempre recebem imediatamente, sem colocar o thread de pedidos na fila de leitor. Utilize as bloqueios recursiva com cuidado, para evitar a bloquear pedidos de bloqueio de escritor por períodos longos.       Para os valores de limite de tempo válidos, consulte <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  example:
  - "The following code example shows how to acquire and release a reader lock, and how to handle the exception thrown when a request times out.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_6_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_6_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_6_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#3](~/add/codesnippet/cpp/m-system.threading.reade_6_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#3](~/add/codesnippet/csharp/m-system.threading.reade_6_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#3](~/add/codesnippet/visualbasic/m-system.threading.reade_6_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_6_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_6_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_6_3.vb)]"
  syntax:
    content: public void AcquireReaderLock (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "O limite de tempo em milissegundos."
  overload: System.Threading.ReaderWriterLock.AcquireReaderLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>millisecondsTimeout</code>expirar antes do pedido de bloqueio é concedido."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)
  id: AcquireReaderLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AcquireReaderLock(TimeSpan)
  nameWithType: ReaderWriterLock.AcquireReaderLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.AcquireReaderLock(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Adquire um leitor de bloqueio, utilizando um <xref:System.TimeSpan>valor para o tempo limite.</xref:System.TimeSpan>"
  remarks: "<xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A>bloqueia se um thread diferente tem o bloqueio de escritor ou se, pelo menos, um thread está a aguardar o bloqueio de escritor.</xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A>      > [!NOTE] > Se o thread atual já tem o bloqueio de escritor, sem bloqueio de leitor é adquirido. Em vez disso, a contagem de bloqueio no bloqueio de escritor é incrementada. Isto impede que um thread bloquear no seu próprio bloqueio de escritor. O resultado é exatamente igual ao chamar <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>e uma chamada adicional para <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>é necessária quando a libertação do bloqueio de escritor.</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> </xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>       `AcquireReaderLock`suporta pedidos de bloqueio de leitor recursiva. Ou seja, um thread pode chamar AcquireReaderLock várias vezes, que incrementa a contagem de bloqueios cada vez. Tem de chamar <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A>uma vez para cada vez que tem de chamar `AcquireReaderLock`.</xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> Em alternativa, pode chamar <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>para reduzir o número de bloqueio para zero imediatamente.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>       Pedidos de bloqueio recursiva sempre recebem imediatamente, sem colocar o thread de pedidos na fila de leitor. Utilize as bloqueios recursiva com cuidado, para evitar a bloquear pedidos de bloqueio de escritor por períodos longos.       Para os valores de limite de tempo válidos, consulte <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  syntax:
    content: public void AcquireReaderLock (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "A <xref uid=&quot;langword_csharp_TimeSpan&quot; name=&quot;TimeSpan&quot; href=&quot;&quot;> </xref> especificar o período de tempo limite."
  overload: System.Threading.ReaderWriterLock.AcquireReaderLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>timeout</code>expirar antes do pedido de bloqueio é concedido."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>timeout</code>Especifica um valor negativo diferente de-1 milissegundos."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)
  id: AcquireWriterLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AcquireWriterLock(Int32)
  nameWithType: ReaderWriterLock.AcquireWriterLock(Int32)
  fullName: System.Threading.ReaderWriterLock.AcquireWriterLock(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Adquire o escritor de bloqueio, utilizando um <xref:System.Int32>valor para o tempo limite.</xref:System.Int32>"
  remarks: "Este método bloqueia se outro thread tem um bloqueio de leitor ou o bloqueio de escritor. Para obter uma descrição da forma como alternates de bloqueio escritor com vários bloqueios de leitor em simultâneo, consulte a <xref:System.Threading.ReaderWriterLock>classe.</xref:System.Threading.ReaderWriterLock>       Um thread que já tem um bloqueio de leitor pode adquirir o bloqueio de escritor de uma das seguintes formas: pela libertação do bloqueio de leitor antes de chamar AcquireWriterLock ou chamar <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>      > [!CAUTION] > Se chama um thread `AcquireWriterLock` enquanto ainda tem um bloqueio de leitor, irá bloquear no seu próprio bloqueio de leitor; se for especificado um tempo limite infinito, irá criar um impasse o thread. Para evitar esses impasses, utilize <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>para determinar se o thread atual já tem um bloqueio de leitor.</xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>       `AcquireWriterLock`suporta pedidos de bloqueio de escritor recursiva. Ou seja, um thread pode chamar `AcquireWriterLock` várias vezes, que incrementa a contagem de bloqueios cada vez. Tem de chamar <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>uma vez para cada vez que tem de chamar `AcquireWriterLock`.</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> Em alternativa, pode chamar <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>para reduzir o número de bloqueio para zero imediatamente.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>       Pedidos de bloqueio recursiva sempre recebem imediatamente, sem colocar o thread de pedidos na fila de escritor.       Para os valores de limite de tempo válidos, consulte <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  example:
  - "The following code example shows how to acquire and release a writer lock, and how to handle the exception thrown when a request times out.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_4_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_4_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_4_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#4](~/add/codesnippet/cpp/m-system.threading.reade_4_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#4](~/add/codesnippet/csharp/m-system.threading.reade_4_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#4](~/add/codesnippet/visualbasic/m-system.threading.reade_4_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_4_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_4_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_4_3.vb)]"
  syntax:
    content: public void AcquireWriterLock (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "O limite de tempo em milissegundos."
  overload: System.Threading.ReaderWriterLock.AcquireWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>timeout</code>expirar antes do pedido de bloqueio é concedido."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)
  id: AcquireWriterLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AcquireWriterLock(TimeSpan)
  nameWithType: ReaderWriterLock.AcquireWriterLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.AcquireWriterLock(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Adquire o escritor de bloqueio, utilizando um <xref:System.TimeSpan>valor para o tempo limite.</xref:System.TimeSpan>"
  remarks: "Este método bloqueia se outro thread tem um bloqueio de leitor ou o bloqueio de escritor. Para obter uma descrição da forma como alternates de bloqueio escritor com vários bloqueios de leitor em simultâneo, consulte a <xref:System.Threading.ReaderWriterLock>classe.</xref:System.Threading.ReaderWriterLock>       Um thread que já tem um bloqueio de leitor pode adquirir o bloqueio de escritor de uma das seguintes formas: ao libertar o bloqueio de leitor antes de chamar <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, ou ao chamar <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> </xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>      > [!CAUTION] > Se chama um thread `AcquireWriterLock` enquanto ainda tem um bloqueio de leitor, irá bloquear no seu próprio bloqueio de leitor; se for especificado um tempo limite infinito, irá criar um impasse o thread. Para evitar esses impasses, utilize <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>para determinar se o thread atual já tem um bloqueio de leitor.</xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>       `AcquireWriterLock`suporta pedidos de bloqueio de escritor recursiva. Ou seja, um thread pode chamar `AcquireWriterLock` várias vezes, que incrementa a contagem de bloqueios cada vez. Tem de chamar <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>uma vez para cada vez que tem de chamar `AcquireWriterLock`.</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> Em alternativa, pode chamar <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>para reduzir o número de bloqueio para zero imediatamente.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>       Pedidos de bloqueio recursiva sempre recebem imediatamente, sem colocar o thread de pedidos na fila de escritor.       Para os valores de limite de tempo válidos, consulte <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  syntax:
    content: public void AcquireWriterLock (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "O <xref uid=&quot;langword_csharp_TimeSpan&quot; name=&quot;TimeSpan&quot; href=&quot;&quot;> </xref> especificar o período de tempo limite."
  overload: System.Threading.ReaderWriterLock.AcquireWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>timeout</code>expirar antes do pedido de bloqueio é concedido."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>timeout</code>Especifica um valor negativo diferente de-1 milissegundos."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)
  id: AnyWritersSince(System.Int32)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AnyWritersSince(Int32)
  nameWithType: ReaderWriterLock.AnyWritersSince(Int32)
  fullName: System.Threading.ReaderWriterLock.AnyWritersSince(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Indica se o bloqueio de escritor tiver sido concedido a qualquer thread desde que foi obtido o número de sequência."
  remarks: "Pode utilizar <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A>e `AnyWritersSince` para melhorar o desempenho da aplicação.</xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> Por exemplo, um thread poderá colocar em cache as informações que obtém ao que contém um bloqueio de leitor. Depois de lançamento e mais tarde reacquiring o bloqueio de, pode utilizar o thread `AnyWritersSince` para determinar se outros threads tem escrito para o recurso provisório; caso contrário, as informações em cache podem ser utilizadas. Esta técnica é útil em que a leitura das informações protegidas pelo bloqueio é dispendiosa; Por exemplo, executar uma consulta de base de dados.       O chamador tem de ser que contém um bloqueio de leitor ou um bloqueio de escritor por ordem para o número de sequência ser útil."
  example:
  - "The following code example shows how to use the AnyWritersSince method and the <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> property to determine whether another thread acquired the writer lock on the protected resource since the current thread last held the writer lock.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_8_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_8_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_8_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#6](~/add/codesnippet/cpp/m-system.threading.reade_8_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#6](~/add/codesnippet/csharp/m-system.threading.reade_8_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#6](~/add/codesnippet/visualbasic/m-system.threading.reade_8_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_8_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_8_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_8_3.vb)]"
  syntax:
    content: public bool AnyWritersSince (int seqNum);
    parameters:
    - id: seqNum
      type: System.Int32
      description: "O número de sequência."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o bloqueio de escritor tiver sido concedido a qualquer thread desde que foi obtido o número de sequência; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ReaderWriterLock.AnyWritersSince*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)
  id: DowngradeFromWriterLock(System.Threading.LockCookie@)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: DowngradeFromWriterLock(LockCookie)
  nameWithType: ReaderWriterLock.DowngradeFromWriterLock(LockCookie)
  fullName: System.Threading.ReaderWriterLock.DowngradeFromWriterLock(LockCookie)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Restaura o estado de bloqueio do thread para o qual foi antes <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*>foi chamado.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*>"
  remarks: "DowngradeFromWriterLock liberta o bloqueio de escritor, independentemente da contagem de bloqueio recursiva e restaura o bloqueio de leitor foi mantido pelo thread antes de atualizar para o bloqueio de escritor. A contagem de bloqueio no bloqueio de leitor é restaurada.      > [!NOTE]  >   `DowngradeFromWriterLock` aceita um <xref:System.Threading.LockCookie>obtida chamando <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> </xref:System.Threading.LockCookie> Não utilize um `LockCookie` devolvido pelo <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>       Um thread não bloqueia quando desatualização de bloqueio escritor, mesmo se outros threads estão a aguardar o bloqueio de escritor, porque todos os pedidos de bloqueio de leitor são concedidos quando for lançado o bloqueio de escritor."
  example:
  - "The following code example shows how to request a reader lock, upgrade the reader lock to a writer lock, and downgrade to a reader lock again.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/b2680c56-6b6f-4bd1-ba78-_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/b2680c56-6b6f-4bd1-ba78-_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/b2680c56-6b6f-4bd1-ba78-_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#5](~/add/codesnippet/cpp/b2680c56-6b6f-4bd1-ba78-_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#5](~/add/codesnippet/csharp/b2680c56-6b6f-4bd1-ba78-_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#5](~/add/codesnippet/visualbasic/b2680c56-6b6f-4bd1-ba78-_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/b2680c56-6b6f-4bd1-ba78-_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/b2680c56-6b6f-4bd1-ba78-_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/b2680c56-6b6f-4bd1-ba78-_3.vb)]"
  syntax:
    content: public void DowngradeFromWriterLock (ref System.Threading.LockCookie lockCookie);
    parameters:
    - id: lockCookie
      type: System.Threading.LockCookie
      description: "A <xref href=&quot;System.Threading.LockCookie&quot;> </xref> devolvido pelo <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*>"
  overload: System.Threading.ReaderWriterLock.DowngradeFromWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "O thread não tem o bloqueio de escritor."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "O endereço do <code> lockCookie </code> um ponteiro nulo."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.Finalize
  id: Finalize
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: Finalize()
  nameWithType: ReaderWriterLock.Finalize()
  fullName: System.Threading.ReaderWriterLock.Finalize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Garante que os recursos são libertados e outras operações de limpeza são efetuadas quando o recoletor de lixo da memória reclama o <xref href=&quot;System.Threading.ReaderWriterLock&quot;> </xref> objeto."
  remarks: "O recoletor de lixo chamadas finalizar quando atual <xref:System.Threading.ReaderWriterLock>objeto está pronto para ser finalizada.</xref:System.Threading.ReaderWriterLock>"
  syntax:
    content: ~ReaderWriterLock ();
    parameters: []
  overload: System.Threading.ReaderWriterLock.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.IsReaderLockHeld
  id: IsReaderLockHeld
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: IsReaderLockHeld
  nameWithType: ReaderWriterLock.IsReaderLockHeld
  fullName: System.Threading.ReaderWriterLock.IsReaderLockHeld
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém um valor que indica se o thread actual deter um bloqueio de leitor."
  remarks: ''
  example:
  - "The following code example demonstrates how to use `IsReaderLockHeld` to avoid deadlocks.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/cpp/p-system.threading.reade_1_1.cpp)]\n [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/visualbasic/p-system.threading.reade_1_1.vb)]\n [!code-cs[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/csharp/p-system.threading.reade_1_1.cs)]"
  syntax:
    content: public bool IsReaderLockHeld { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o thread actual deter um bloqueio de leitor; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ReaderWriterLock.IsReaderLockHeld*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.IsWriterLockHeld
  id: IsWriterLockHeld
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: IsWriterLockHeld
  nameWithType: ReaderWriterLock.IsWriterLockHeld
  fullName: System.Threading.ReaderWriterLock.IsWriterLockHeld
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém um valor que indica se o thread actual detém o bloqueio de escritor."
  remarks: ''
  example:
  - "The following code example demonstrates that when an attempt is made to acquire a reader lock on a thread that has a writer lock, `ReaderWriterLock` does not grant the reader lock but instead increments the lock count on the writer lock.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/cpp/p-system.threading.reade_0_1.cpp)]\n [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/visualbasic/p-system.threading.reade_0_1.vb)]\n [!code-cs[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/csharp/p-system.threading.reade_0_1.cs)]"
  syntax:
    content: public bool IsWriterLockHeld { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o thread actual detém o bloqueio de escritor; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ReaderWriterLock.IsWriterLockHeld*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.ReleaseLock
  id: ReleaseLock
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: ReleaseLock()
  nameWithType: ReaderWriterLock.ReleaseLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseLock()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Liberta o bloqueio, independentemente do número de vezes que o thread de adquirir o bloqueio."
  remarks: "ReleaseLock liberta o bloqueio de leitor ou o bloqueio de escritor, independentemente da contagem de bloqueios recursiva. Para restaurar o estado do bloqueio, incluindo a contagem de bloqueios, passar <xref:System.Threading.LockCookie>para <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</xref:System.Threading.ReaderWriterLock.RestoreLock%2A> </xref:System.Threading.LockCookie>"
  example:
  - "The following code example shows how to use the ReleaseLock method to release the lock, regardless of how many times it has been acquired by the thread, and how to restore the state of the lock later.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_1_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_1_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_1_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#6](~/add/codesnippet/cpp/m-system.threading.reade_1_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#6](~/add/codesnippet/csharp/m-system.threading.reade_1_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#6](~/add/codesnippet/visualbasic/m-system.threading.reade_1_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_1_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_1_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_1_3.vb)]"
  syntax:
    content: public System.Threading.LockCookie ReleaseLock ();
    parameters: []
    return:
      type: System.Threading.LockCookie
      description: "A <xref href=&quot;System.Threading.LockCookie&quot;> </xref> representando o bloqueio lançado."
  overload: System.Threading.ReaderWriterLock.ReleaseLock*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.ReleaseReaderLock
  id: ReleaseReaderLock
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: ReleaseReaderLock()
  nameWithType: ReaderWriterLock.ReleaseReaderLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseReaderLock()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "É decrementada o bloqueio de contagem."
  remarks: "É decrementada de ReleaseReaderLock o bloqueio de contagem. Quando a contagem atinge zero, o bloqueio é libertado.      > [!NOTE] > Se um thread tem o bloqueio de escritor, chamar `ReleaseReaderLock` tem o mesmo efeito que chamar <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> Se um thread tiver não existem bloqueios, chamar `ReleaseReaderLock` emite um <xref:System.ApplicationException>.</xref:System.ApplicationException>"
  example:
  - "The following code example shows how to acquire and release a reader lock, and how to handle the exception thrown when a request times out.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_5_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_5_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_5_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#3](~/add/codesnippet/cpp/m-system.threading.reade_5_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#3](~/add/codesnippet/csharp/m-system.threading.reade_5_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#3](~/add/codesnippet/visualbasic/m-system.threading.reade_5_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_5_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_5_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_5_3.vb)]"
  syntax:
    content: public void ReleaseReaderLock ();
    parameters: []
  overload: System.Threading.ReaderWriterLock.ReleaseReaderLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "O thread não tem qualquer leitor ou escritor bloqueios."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.ReleaseWriterLock
  id: ReleaseWriterLock
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: ReleaseWriterLock()
  nameWithType: ReaderWriterLock.ReleaseWriterLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseWriterLock()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "É decrementada o bloqueio contam no bloqueio de escritor."
  remarks: "É decrementada de ReleaseWriterLock o bloqueio de escritor contagem. Quando a contagem atinge zero, o bloqueio de escritor é libertado.      > [!NOTE] > Se tiver um thread um bloqueio de leitor ou não existem bloqueios, chamar `ReleaseWriterLock` emite um <xref:System.ApplicationException>.</xref:System.ApplicationException>"
  example:
  - "The following code example shows how to acquire and release a writer lock, and how to handle the exception thrown when a request times out.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_3_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_3_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_3_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#4](~/add/codesnippet/cpp/m-system.threading.reade_3_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#4](~/add/codesnippet/csharp/m-system.threading.reade_3_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#4](~/add/codesnippet/visualbasic/m-system.threading.reade_3_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_3_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_3_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_3_3.vb)]"
  syntax:
    content: public void ReleaseWriterLock ();
    parameters: []
  overload: System.Threading.ReaderWriterLock.ReleaseWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "O thread não tem o bloqueio de escritor."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)
  id: RestoreLock(System.Threading.LockCookie@)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: RestoreLock(LockCookie)
  nameWithType: ReaderWriterLock.RestoreLock(LockCookie)
  fullName: System.Threading.ReaderWriterLock.RestoreLock(LockCookie)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Restaura o estado de bloqueio do thread para o qual foi antes de chamar <xref:System.Threading.ReaderWriterLock.ReleaseLock*>.</xref:System.Threading.ReaderWriterLock.ReleaseLock*>"
  remarks: "O estado restaurado por `RestoreLock` inclui a contagem de bloqueios recursiva.       Blocos de thread se tentar restaurar um bloqueio de leitor depois de ter adquirido o bloqueio de escritor o outro thread ou se tentar restaurar o bloqueio de escritor depois de outro thread tem adquirir um bloqueio de leitor ou o bloqueio de escritor. Porque `RestoreLock` não aceita um limite de tempo, deverá demorar cuidado para evitar possíveis impasses.      > [!CAUTION] > Antes de chamar `RestoreLock`, certifique-se de que tenha publicadas todos os bloqueios adquiridos desde a chamada para <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> Por exemplo, um thread impasses se adquirir um bloqueio de leitor e, em seguida, tenta restaurar um bloqueio de escritor anterior. Utilize <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>e <xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A>para detetar esses bloqueios adicionais.</xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A> </xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>       Não utilize um <xref:System.Threading.LockCookie>devolvido de <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> </xref:System.Threading.LockCookie>"
  example:
  - "The following code example shows how to use the <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> method to release the lock, regardless of how many times it has been acquired by the thread, and how to restore the state of the lock later.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_2_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_2_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_2_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#6](~/add/codesnippet/cpp/m-system.threading.reade_2_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#6](~/add/codesnippet/csharp/m-system.threading.reade_2_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#6](~/add/codesnippet/visualbasic/m-system.threading.reade_2_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_2_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_2_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_2_3.vb)]"
  syntax:
    content: public void RestoreLock (ref System.Threading.LockCookie lockCookie);
    parameters:
    - id: lockCookie
      type: System.Threading.LockCookie
      description: "A <xref href=&quot;System.Threading.LockCookie&quot;> </xref> devolvido pelo <xref:System.Threading.ReaderWriterLock.ReleaseLock*>.</xref:System.Threading.ReaderWriterLock.ReleaseLock*>"
  overload: System.Threading.ReaderWriterLock.RestoreLock*
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "O endereço do <code> lockCookie </code> um ponteiro nulo."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)
  id: UpgradeToWriterLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: UpgradeToWriterLock(Int32)
  nameWithType: ReaderWriterLock.UpgradeToWriterLock(Int32)
  fullName: System.Threading.ReaderWriterLock.UpgradeToWriterLock(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "As atualizações de um bloqueio de leitor para o escritor de bloqueio, utilizando um <xref uid=&quot;langword_csharp_Int32&quot; name=&quot;Int32&quot; href=&quot;&quot;> </xref> valor para o limite de tempo."
  remarks: "Quando chama um thread `UpgradeToWriterLock` o bloqueio de leitor for lançado, independentemente da contagem de bloqueios, e o thread entra no fim da fila para o bloqueio de escritor. Assim, os outros threads poderão escrever para o recurso antes do thread que solicitou que a atualização é concedida o bloqueio de escritor.      > [!IMPORTANT] > A exceção de tempo limite não é acionada até que o thread que chamou o método UpgradeToWriterLock pode readquirir o bloqueio de leitor. Se não existirem não existem outros threads a aguardar que o bloqueio de escritor, isto acontece imediatamente. No entanto, se outro thread é colocada na fila para o bloqueio de escritor, o thread que chamou o método UpgradeToWriterLock não é possível readquirir o bloqueio de leitor até que todos os leitores atuais tenham publicadas os bloqueios delas e um thread tem adquirida e lançado o bloqueio de escritor. Isto acontece mesmo que o thread que o bloqueio de escritor de pedidos pedido-lo após o thread actual chamou o método de UpgradeToWriterLock.       Para restaurar o estado de bloqueio, chame <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>utilizando o <xref:System.Threading.LockCookie>devolvido pelo `UpgradeToWriterLock`.</xref:System.Threading.LockCookie> </xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> Não utilize esta opção `LockCookie` com <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</xref:System.Threading.ReaderWriterLock.RestoreLock%2A>       Quando um thread tem sem bloqueio de leitor, não utilize `UpgradeToWriterLock`. Utilize <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>em vez disso.</xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>       Para os valores de limite de tempo válidos, consulte <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  example:
  - "The following code example shows how to request a reader lock, upgrade the reader lock to a writer lock, and downgrade to a reader lock again.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_7_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_7_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_7_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#5](~/add/codesnippet/cpp/m-system.threading.reade_7_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#5](~/add/codesnippet/csharp/m-system.threading.reade_7_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#5](~/add/codesnippet/visualbasic/m-system.threading.reade_7_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_7_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_7_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_7_3.vb)]"
  syntax:
    content: public System.Threading.LockCookie UpgradeToWriterLock (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "O limite de tempo em milissegundos."
    return:
      type: System.Threading.LockCookie
      description: "A <xref href=&quot;System.Threading.LockCookie&quot;></xref> value."
  overload: System.Threading.ReaderWriterLock.UpgradeToWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>millisecondsTimeout</code>expirar antes do pedido de bloqueio é concedido."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)
  id: UpgradeToWriterLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: UpgradeToWriterLock(TimeSpan)
  nameWithType: ReaderWriterLock.UpgradeToWriterLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.UpgradeToWriterLock(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "As atualizações de um bloqueio de leitor para o escritor de bloqueio, utilizando um <xref uid=&quot;langword_csharp_TimeSpan&quot; name=&quot;TimeSpan&quot; href=&quot;&quot;> </xref> valor para o limite de tempo."
  remarks: "Quando chama um thread `UpgradeToWriterLock` o bloqueio de leitor for lançado, independentemente da contagem de bloqueios, e o thread entra no fim da fila para o bloqueio de escritor. Assim, os outros threads poderão escrever para o recurso antes do thread que solicitou que a atualização é concedida o bloqueio de escritor.      > [!IMPORTANT] > A exceção de tempo limite não é acionada até que o thread chamado o <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>método pode readquirir o bloqueio de leitor.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> Se não existirem não existem outros threads a aguardar que o bloqueio de escritor, isto acontece imediatamente. No entanto, se outro thread é colocada na fila para o bloqueio de escritor, o thread que chamado o <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>método não é possível readquirir o bloqueio de leitor até que todos os leitores atuais tenham publicadas os bloqueios delas e um thread tem adquirida e lançado o bloqueio de escritor.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> Isto acontece mesmo que o thread que o bloqueio de escritor de pedidos pedida-lo Depois do thread actual chamado o <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>método.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>       Para restaurar o estado de bloqueio, chame <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>utilizando o <xref:System.Threading.LockCookie>devolvido pelo `UpgradeToWriterLock`.</xref:System.Threading.LockCookie> </xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> Não utilize esta opção `LockCookie` com <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</xref:System.Threading.ReaderWriterLock.RestoreLock%2A>       Quando um thread tem sem bloqueio de leitor, não utilize `UpgradeToWriterLock`. Utilize <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>em vez disso.</xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>       Para os valores de limite de tempo válidos, consulte <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  syntax:
    content: public System.Threading.LockCookie UpgradeToWriterLock (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "O <xref uid=&quot;langword_csharp_TimeSpan&quot; name=&quot;TimeSpan&quot; href=&quot;&quot;> </xref> especificar o período de tempo limite."
    return:
      type: System.Threading.LockCookie
      description: "A <xref href=&quot;System.Threading.LockCookie&quot;></xref> value."
  overload: System.Threading.ReaderWriterLock.UpgradeToWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>timeout</code>expirar antes do pedido de bloqueio é concedido."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>timeout</code>Especifica um valor negativo diferente de-1 milissegundos."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.WriterSeqNum
  id: WriterSeqNum
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: WriterSeqNum
  nameWithType: ReaderWriterLock.WriterSeqNum
  fullName: System.Threading.ReaderWriterLock.WriterSeqNum
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém o número de sequência atual."
  remarks: "A sequência número aumenta sempre que um thread adquire o bloqueio de escritor. Pode guardar o número de sequência e transmiti-lo para <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A>posteriormente, se pretende determinar se outros threads tem adquirido o bloqueio de escritor entretanto.</xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A>       Pode utilizar `WriterSeqNum` para melhorar o desempenho da aplicação. Por exemplo, um thread poderá colocar em cache as informações que obtém ao que contém um bloqueio de leitor. Depois de lançamento e mais tarde reacquiring o bloqueio, o thread possa determinar se outros threads tem escrito para o recurso ao chamar `AnyWritersSince`; se não, as informações em cache podem ser utilizadas. Esta técnica é útil quando leitura das informações protegidas pelo bloqueio é dispendioso; Por exemplo, executar uma consulta de base de dados.       O chamador tem de ser que contém um bloqueio de leitor ou um bloqueio de escritor por ordem para o número de sequência ser útil."
  example:
  - "The following code example shows how to use the WriterSeqNum property and the <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> method to determine whether another thread acquired the writer lock on the protected resource since the current thread last held the writer lock.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/p-system.threading.reade_2_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/p-system.threading.reade_2_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/p-system.threading.reade_2_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#6](~/add/codesnippet/cpp/p-system.threading.reade_2_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#6](~/add/codesnippet/csharp/p-system.threading.reade_2_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#6](~/add/codesnippet/visualbasic/p-system.threading.reade_2_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/p-system.threading.reade_2_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/p-system.threading.reade_2_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/p-system.threading.reade_2_3.vb)]"
  syntax:
    content: public int WriterSeqNum { get; }
    return:
      type: System.Int32
      description: "O número de sequência atual."
  overload: System.Threading.ReaderWriterLock.WriterSeqNum*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  isExternal: false
  name: System.Runtime.ConstrainedExecution.CriticalFinalizerObject
- uid: System.ApplicationException
  parent: System
  isExternal: false
  name: ApplicationException
  nameWithType: ApplicationException
  fullName: System.ApplicationException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: System.Threading.ReaderWriterLock.#ctor
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReaderWriterLock()
  nameWithType: ReaderWriterLock.ReaderWriterLock()
  fullName: System.Threading.ReaderWriterLock.ReaderWriterLock()
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireReaderLock(Int32)
  nameWithType: ReaderWriterLock.AcquireReaderLock(Int32)
  fullName: System.Threading.ReaderWriterLock.AcquireReaderLock(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireReaderLock(TimeSpan)
  nameWithType: ReaderWriterLock.AcquireReaderLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.AcquireReaderLock(TimeSpan)
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireWriterLock(Int32)
  nameWithType: ReaderWriterLock.AcquireWriterLock(Int32)
  fullName: System.Threading.ReaderWriterLock.AcquireWriterLock(Int32)
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireWriterLock(TimeSpan)
  nameWithType: ReaderWriterLock.AcquireWriterLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.AcquireWriterLock(TimeSpan)
- uid: System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AnyWritersSince(Int32)
  nameWithType: ReaderWriterLock.AnyWritersSince(Int32)
  fullName: System.Threading.ReaderWriterLock.AnyWritersSince(Int32)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: DowngradeFromWriterLock(LockCookie)
  nameWithType: ReaderWriterLock.DowngradeFromWriterLock(LockCookie)
  fullName: System.Threading.ReaderWriterLock.DowngradeFromWriterLock(LockCookie)
- uid: System.Threading.LockCookie
  parent: System.Threading
  isExternal: false
  name: LockCookie
  nameWithType: LockCookie
  fullName: System.Threading.LockCookie
- uid: System.Threading.ReaderWriterLock.Finalize
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: Finalize()
  nameWithType: ReaderWriterLock.Finalize()
  fullName: System.Threading.ReaderWriterLock.Finalize()
- uid: System.Threading.ReaderWriterLock.IsReaderLockHeld
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: IsReaderLockHeld
  nameWithType: ReaderWriterLock.IsReaderLockHeld
  fullName: System.Threading.ReaderWriterLock.IsReaderLockHeld
- uid: System.Threading.ReaderWriterLock.IsWriterLockHeld
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: IsWriterLockHeld
  nameWithType: ReaderWriterLock.IsWriterLockHeld
  fullName: System.Threading.ReaderWriterLock.IsWriterLockHeld
- uid: System.Threading.ReaderWriterLock.ReleaseLock
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseLock()
  nameWithType: ReaderWriterLock.ReleaseLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseLock()
- uid: System.Threading.ReaderWriterLock.ReleaseReaderLock
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseReaderLock()
  nameWithType: ReaderWriterLock.ReleaseReaderLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseReaderLock()
- uid: System.Threading.ReaderWriterLock.ReleaseWriterLock
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseWriterLock()
  nameWithType: ReaderWriterLock.ReleaseWriterLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseWriterLock()
- uid: System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: RestoreLock(LockCookie)
  nameWithType: ReaderWriterLock.RestoreLock(LockCookie)
  fullName: System.Threading.ReaderWriterLock.RestoreLock(LockCookie)
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: UpgradeToWriterLock(Int32)
  nameWithType: ReaderWriterLock.UpgradeToWriterLock(Int32)
  fullName: System.Threading.ReaderWriterLock.UpgradeToWriterLock(Int32)
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: UpgradeToWriterLock(TimeSpan)
  nameWithType: ReaderWriterLock.UpgradeToWriterLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.UpgradeToWriterLock(TimeSpan)
- uid: System.Threading.ReaderWriterLock.WriterSeqNum
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: WriterSeqNum
  nameWithType: ReaderWriterLock.WriterSeqNum
  fullName: System.Threading.ReaderWriterLock.WriterSeqNum
- uid: System.Threading.ReaderWriterLock.#ctor*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReaderWriterLock
  nameWithType: ReaderWriterLock.ReaderWriterLock
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireReaderLock
  nameWithType: ReaderWriterLock.AcquireReaderLock
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireWriterLock
  nameWithType: ReaderWriterLock.AcquireWriterLock
- uid: System.Threading.ReaderWriterLock.AnyWritersSince*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AnyWritersSince
  nameWithType: ReaderWriterLock.AnyWritersSince
- uid: System.Threading.ReaderWriterLock.DowngradeFromWriterLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: DowngradeFromWriterLock
  nameWithType: ReaderWriterLock.DowngradeFromWriterLock
- uid: System.Threading.ReaderWriterLock.Finalize*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: Finalize
  nameWithType: ReaderWriterLock.Finalize
- uid: System.Threading.ReaderWriterLock.IsReaderLockHeld*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: IsReaderLockHeld
  nameWithType: ReaderWriterLock.IsReaderLockHeld
- uid: System.Threading.ReaderWriterLock.IsWriterLockHeld*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: IsWriterLockHeld
  nameWithType: ReaderWriterLock.IsWriterLockHeld
- uid: System.Threading.ReaderWriterLock.ReleaseLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseLock
  nameWithType: ReaderWriterLock.ReleaseLock
- uid: System.Threading.ReaderWriterLock.ReleaseReaderLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseReaderLock
  nameWithType: ReaderWriterLock.ReleaseReaderLock
- uid: System.Threading.ReaderWriterLock.ReleaseWriterLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseWriterLock
  nameWithType: ReaderWriterLock.ReleaseWriterLock
- uid: System.Threading.ReaderWriterLock.RestoreLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: RestoreLock
  nameWithType: ReaderWriterLock.RestoreLock
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: UpgradeToWriterLock
  nameWithType: ReaderWriterLock.UpgradeToWriterLock
- uid: System.Threading.ReaderWriterLock.WriterSeqNum*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: WriterSeqNum
  nameWithType: ReaderWriterLock.WriterSeqNum
