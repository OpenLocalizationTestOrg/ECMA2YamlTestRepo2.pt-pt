### YamlMime:ManagedReference
items:
- uid: System.IO.FileStream
  id: FileStream
  children:
  - System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode)
  - System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  - System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)
  - System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.FileStream.CanRead
  - System.IO.FileStream.CanSeek
  - System.IO.FileStream.CanWrite
  - System.IO.FileStream.Dispose(System.Boolean)
  - System.IO.FileStream.EndRead(System.IAsyncResult)
  - System.IO.FileStream.EndWrite(System.IAsyncResult)
  - System.IO.FileStream.Finalize
  - System.IO.FileStream.Flush
  - System.IO.FileStream.Flush(System.Boolean)
  - System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)
  - System.IO.FileStream.GetAccessControl
  - System.IO.FileStream.Handle
  - System.IO.FileStream.IsAsync
  - System.IO.FileStream.Length
  - System.IO.FileStream.Lock(System.Int64,System.Int64)
  - System.IO.FileStream.Name
  - System.IO.FileStream.Position
  - System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.FileStream.ReadByte
  - System.IO.FileStream.SafeFileHandle
  - System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)
  - System.IO.FileStream.SetLength(System.Int64)
  - System.IO.FileStream.Unlock(System.Int64,System.Int64)
  - System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.FileStream.WriteByte(System.Byte)
  langs:
  - csharp
  name: FileStream
  nameWithType: FileStream
  fullName: System.IO.FileStream
  type: Class
  summary: "Fornece um <xref:System.IO.Stream>para um ficheiro, que suporta operações síncronas e assíncronas ler e operações de escrita.</xref:System.IO.Stream>       Para procurar o código de origem do .NET Framework para este tipo, consulte o [referência origem](http://referencesource.microsoft.com/#mscorlib/system/io/filestream.cs#e23a38af5d11ddd3)."
  remarks: "> [!NOTE]\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/io/filestream.cs#e23a38af5d11ddd3). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \n  \n Use the FileStream class to read from, write to, open, and close files on a file system, and to manipulate other file-related operating system handles, including pipes, standard input, and standard output. You can use the [Read(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True), [Write(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True), <xref:System.IO.Stream.CopyTo%2A>, and <xref:System.IO.FileStream.Flush%2A> methods to perform synchronous operations, or the <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.FileStream.FlushAsync%2A> methods to perform asynchronous operations. Use the asynchronous methods to perform resource-intensive file operations without blocking the main thread. This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/add/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/add/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working. FileStream buffers input and output for better performance.  \n  \n> [!IMPORTANT]\n>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  \n  \n The <xref:System.IO.FileStream.IsAsync%2A> property detects whether the file handle was opened asynchronously. You specify this value when you create an instance of the FileStream class using a constructor that has an `isAsync`, `useAsync`, or `options` parameter. When the property is `true`, the stream utilizes overlapped I/O to perform file operations asynchronously. However, the <xref:System.IO.FileStream.IsAsync%2A> property does not have to be `true` to call the <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, or <xref:System.IO.Stream.CopyToAsync%2A> method. When the <xref:System.IO.FileStream.IsAsync%2A> property is `false` and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.  \n  \n The <xref:System.IO.FileStream.Seek%2A> method supports random access to files. <xref:System.IO.FileStream.Seek%2A> allows the read/write position to be moved to any position within the file. This is done with byte offset reference point parameters. The byte offset is relative to the seek reference point, which can be the beginning, the current position, or the end of the underlying file, as represented by the three members of the <xref:System.IO.SeekOrigin> enumeration.  \n  \n> [!NOTE]\n>  Disk files always support random access. At the time of construction, the <xref:System.IO.FileStream.CanSeek%2A> property value is set to `true` or `false` depending on the underlying file type.If the underlying file type is FILE_TYPE_DISK, as defined in winbase.h, the <xref:System.IO.FileStream.CanSeek%2A> property value is `true`. Otherwise, the <xref:System.IO.FileStream.CanSeek%2A> property value is `false`.  \n  \n If a process terminates with part of a file locked or closes a file that has outstanding locks, the behavior is undefined.  \n  \n For directory operations and other file operations, see the <xref:System.IO.File>, <xref:System.IO.Directory>, and <xref:System.IO.Path> classes. The <xref:System.IO.File> class is a utility class that has static methods primarily for the creation of FileStream objects based on file paths. The <xref:System.IO.MemoryStream> class creates a stream from a byte array and is similar to the FileStream class.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md).  \n  \n## Detection of Stream Position Changes  \n When a FileStream object does not have an exclusive hold on its handle, another thread could access the file handle concurrently and change the position of the operating system's file pointer that is associated with the file handle. In this case, the cached position in the FileStream object and the cached data in the buffer could be compromised. The FileStream object routinely performs checks on methods that access the cached buffer to ensure that the operating system's handle position is the same as the cached position used by the FileStream object.  \n  \n If an unexpected change in the handle position is detected in a call to the <xref:System.IO.FileStream.Read%2A> method, the .NET Framework discards the contents of the buffer and reads the stream from the file again. This can affect performance, depending on the size of the file and any other processes that could affect the position of the file stream.  \n  \n If an unexpected change in the handle position is detected in a call to the <xref:System.IO.FileStream.Write%2A> method, the contents of the buffer are discarded and an <xref:System.IO.IOException> exception is thrown.  \n  \n A FileStream object will not have an exclusive hold on its handle when either the <xref:System.IO.FileStream.SafeFileHandle%2A> property is accessed to expose the handle or the FileStream object is given the <xref:System.IO.FileStream.SafeFileHandle%2A> property in its constructor."
  example:
  - "The following example demonstrates some of the FileStream constructors.  \n  \n [!code-cs[fstream class#1](~/add/codesnippet/csharp/t-system.io.filestream_1.cs)]\n [!code-vb[fstream class#1](~/add/codesnippet/visualbasic/t-system.io.filestream_1.vb)]\n [!code-cpp[fstream class#1](~/add/codesnippet/cpp/t-system.io.filestream_1.cpp)]  \n  \n The following example shows how to write to a file asynchronously. This code runs in a WPF app that has a TextBlock named UserInput and a button hooked up to a Click event handler that is named Button_Click. The file path needs to be changed to a file than exits on the computer.  \n  \n [!code-vb[Asynchronous_File_IO_async#3](~/add/codesnippet/visualbasic/t-system.io.filestream_2.vb)]\n [!code-cs[Asynchronous_File_IO_async#3](~/add/codesnippet/csharp/t-system.io.filestream_2.cs)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public class FileStream : System.IO.Stream
  inheritance:
  - System.IO.Stream
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(SafeFileHandle,FileAccess)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.FileStream&quot;> </xref> classe para o identificador de ficheiro especificado, com a permissão de leitura/escrita especificado."
  remarks: "Quando <xref:System.IO.Stream.Close%2A>é denominado, o identificador também será fechado e contagem de identificador do ficheiro é debitada.</xref:System.IO.Stream.Close%2A>       `FileStream`parte do princípio de que tem um controlo exclusivo sobre o identificador. Ao ler, escrever ou procura a um `FileStream` é também que contém um identificador pode resultar em danos nos dados. Para segurança de dados, chamar <xref:System.IO.FileStream.Flush%2A>antes utilizando o identificador e evitar a chamar os métodos que `Close` depois de terminar com o identificador.</xref:System.IO.FileStream.Flush%2A>      > [!CAUTION] > Quando compilar um conjunto de carateres com uma definição de cultural específica e obter os mesmos carateres com uma definição de cultural diferentes, os carateres poderão não estar interpretable e pode provocar uma exceção ao ser emitida.       `FileShare.Read`é a predefinição para quem <xref:System.IO.FileStream>construtores sem um `FileShare` parâmetro.</xref:System.IO.FileStream>       Para obter uma lista de ficheiros comuns e as operações de diretório, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "Um identificador de ficheiro para o ficheiro que atual <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> irá encapsular objeto."
    - id: access
      type: System.IO.FileAccess
      description: "Uma constante que define o <> </> *> e <> </> *> propriedades do <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>access</code>Não é um campo de <xref href=&quot;System.IO.FileAccess&quot;> </xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s, tais como um erro de disco.       - ou - fluxo foi fechado."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O <code> access </code> pedida não é permitido pelo sistema operativo para o identificador de ficheiro especificado, como quando <code> access </code> é <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e o identificador de ficheiro está definido para acesso só de leitura."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)
  id: '#ctor(System.IntPtr,System.IO.FileAccess)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.FileStream&quot;> </xref> classe para o identificador de ficheiro especificado, com a permissão de leitura/escrita especificado."
  remarks: "Quando <xref:System.IO.Stream.Close%2A>é denominado, o identificador também será fechado e contagem de identificador do ficheiro é debitada.</xref:System.IO.Stream.Close%2A>       `FileStream`parte do princípio de que tem um controlo exclusivo sobre o identificador. Ao ler, escrever ou procura a um `FileStream` é também que contém um identificador pode resultar em danos nos dados. Para segurança de dados, chamar <xref:System.IO.FileStream.Flush%2A>antes utilizando o identificador e evitar a chamar os métodos que `Close` depois de terminar com o identificador.</xref:System.IO.FileStream.Flush%2A>      > [!CAUTION] > Quando compilar um conjunto de carateres com uma definição de cultural específica e obter os mesmos carateres com uma definição de cultural diferentes, os carateres poderão não estar interpretable e pode provocar uma exceção ao ser emitida.       `FileShare.Read`é a predefinição para quem <xref:System.IO.FileStream>construtores sem um `FileShare` parâmetro.</xref:System.IO.FileStream>       Para obter uma lista de ficheiros comuns e as operações de diretório, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "Um identificador de ficheiro para o ficheiro que atual <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> irá encapsular objeto."
    - id: access
      type: System.IO.FileAccess
      description: "Uma constante que define o <> </> *> e <> </> *> propriedades do <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>access</code>Não é um campo de <xref href=&quot;System.IO.FileAccess&quot;> </xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s, tais como um erro de disco.       - ou - fluxo foi fechado."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O <code> access </code> pedida não é permitido pelo sistema operativo para o identificador de ficheiro especificado, como quando <code> access </code> é <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e o identificador de ficheiro está definido para acesso só de leitura."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode)
  id: '#ctor(System.String,System.IO.FileMode)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode)
  nameWithType: FileStream.FileStream(String,FileMode)
  fullName: System.IO.FileStream.FileStream(String,FileMode)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.FileStream&quot;> </xref> classe com o modo de criação e o caminho especificado."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed).  \n  \n You cannot use this constructor to open read-only files; instead, you must use a constructor that accepts a `FileAccess` parameter with the value set to `FileAccess.Read`.  \n  \n The buffer size is set to the default size of 4096 bytes (4 KB).  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n `FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.  \n  \n For constructors without a <xref:System.IO.FileAccess> parameter, if the `mode` parameter is set to <xref:System.IO.FileMode>, <xref:System.IO.FileAccess> is the default access. Otherwise, the access is set to <xref:System.IO.FileAccess>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.s_0_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.s_0_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.s_0_1.cpp)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o ficheiro que atual <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> irá encapsular objeto."
    - id: mode
      type: System.IO.FileMode
      description: "Uma constante que determina como abrir ou criar o ficheiro."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>é uma cadeia vazia (&quot;&quot;), contém apenas espaços em branco ou contém um ou mais carateres inválidos.       - ou - <code>path</code> refere-se a um dispositivo não ficheiro, tal como &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. num ambiente NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>se refere a um dispositivo não ficheiro, tal como &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. num ambiente de NTFS."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Não é possível localizar o ficheiro, como quando <code> mode </code> é <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>e o ficheiro especificado pelo <code> path </code> não existe. O ficheiro já deve existir nestes modos."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Um erro de e/s, tais como especificar <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> quando o ficheiro especificado pelo <code> path </code> já existe, ocorreu.       - ou - fluxo foi fechado."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "O caminho especificado é inválido, tais como a ser numa unidade não mapeada."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "O caminho especificado, o nome de ficheiro ou ambos excedem o comprimento máximo definido pelo sistema. Por exemplo, em plataformas com Windows, caminhos tem de ter menos de 248 carateres e nomes de ficheiros tem de ser inferior a 260 caracteres."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>contém um valor inválido."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(SafeFileHandle,FileAccess,Int32)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.FileStream&quot;> </xref> de classe para o identificador de ficheiro especificado, com a permissão de leitura/escrita especificado e a memória intermédia de tamanho."
  remarks: "`FileStream`parte do princípio de que tem um controlo exclusivo sobre o identificador. Ao ler, escrever ou procura a um `FileStream` é também que contém um identificador pode resultar em danos nos dados. Para segurança de dados, chamar <xref:System.IO.FileStream.Flush%2A>antes utilizando o identificador e evitar a chamar os métodos que `Close` depois de terminar com o identificador.</xref:System.IO.FileStream.Flush%2A> Em alternativa, para ler e escrever o identificador antes de chamar este `FileStream` construtor.       `FileShare.Read`é a predefinição para quem <xref:System.IO.FileStream>construtores sem um `FileShare` parâmetro.</xref:System.IO.FileStream>      > [!CAUTION] > Quando compilar um conjunto de carateres com uma definição de cultural específica e obter os mesmos carateres com uma definição de cultural diferentes, os carateres poderão não estar interpretable e pode provocar uma exceção ao ser emitida.       Para obter uma lista de ficheiros comuns e as operações de diretório, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "Um identificador de ficheiro para o ficheiro que atual <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> irá encapsular objeto."
    - id: access
      type: System.IO.FileAccess
      description: "A <xref href=&quot;System.IO.FileAccess&quot;> </xref> constante que define o <> </> *> e <> </> *> propriedades do <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto."
    - id: bufferSize
      type: System.Int32
      description: "Um positivos <xref:System.Int32>um valor maior que 0 que indica o tamanho da memória intermédia.</xref:System.Int32> O tamanho de memória intermédia de predefinido é 4096."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O <code> handle </code> parâmetro é um identificador inválido.       - ou - <code> handle </code> parâmetro é um identificador de síncrono e foi utilizado no modo assíncrono."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "O <code> bufferSize </code> parâmetro é negativo."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s, tais como um erro de disco.       - ou - fluxo foi fechado."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O <code> access </code> pedida não é permitido pelo sistema operativo para o identificador de ficheiro especificado, como quando <code> access </code> é <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e o identificador de ficheiro está definido para acesso só de leitura."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)
  id: '#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.FileStream&quot;> </xref> classe para o identificador de ficheiro especificado, com a permissão de leitura/escrita especificado e <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> propriedade de instância."
  remarks: "O `FileStream` objeto é dado o acesso especificado para o ficheiro. A propriedade do identificador será conforme especificado. Se este processo é o identificador, uma chamada para o proprietário do <xref:System.IO.Stream.Close%2A>método também irá fechar o identificador e contagem de identificador do ficheiro é debitada.</xref:System.IO.Stream.Close%2A> O `FileStream` objeto é dado o tamanho de memória intermédia predefinido de 4096 bytes.       `FileStream`parte do princípio de que tem um controlo exclusivo sobre o identificador. Ao ler, escrever ou procura a um `FileStream` é também que contém um identificador pode resultar em danos nos dados. Para segurança de dados, chamar <xref:System.IO.FileStream.Flush%2A>antes utilizando o identificador e evitar a chamar os métodos que `Close` depois de terminar com o identificador.</xref:System.IO.FileStream.Flush%2A>       `FileShare.Read`é a predefinição para quem <xref:System.IO.FileStream>construtores sem um `FileShare` parâmetro.</xref:System.IO.FileStream>      > [!CAUTION] > Quando compilar um conjunto de carateres com uma definição de cultural específica e obter os mesmos carateres com uma definição de cultural diferentes, os carateres poderão não estar interpretable e pode provocar uma exceção ao ser emitida.       Para obter uma lista de ficheiros comuns e as operações de diretório, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "Um identificador de ficheiro para o ficheiro que atual <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> irá encapsular objeto."
    - id: access
      type: System.IO.FileAccess
      description: "Uma constante que define o <> </> *> e <> </> *> propriedades do <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto."
    - id: ownsHandle
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o identificador de ficheiro irá ser detido por este <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> instância; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>access</code>Não é um campo de <xref href=&quot;System.IO.FileAccess&quot;> </xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s, tais como um erro de disco.       - ou - fluxo foi fechado."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O <code> access </code> pedida não é permitido pelo sistema operativo para o identificador de ficheiro especificado, como quando <code> access </code> é <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e o identificador de ficheiro está definido para acesso só de leitura."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.FileStream&quot;> </xref> classe com o caminho especificado, o modo de criação e permissão de leitura/escrita."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed). The buffer size is set to the default size of 4096 bytes (4 KB).  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n `FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o ficheiro que atual <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> irá encapsular objeto."
    - id: mode
      type: System.IO.FileMode
      description: "Uma constante que determina como abrir ou criar o ficheiro."
    - id: access
      type: System.IO.FileAccess
      description: "Uma constante que determina a forma como o ficheiro pode ser acedido pelo <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto. Isto também determina os valores devolvidos pelo <> </> *> e <> </> *> propriedades do <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto. <xref:System.IO.FileStream.CanSeek*>é <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> se `path` Especifica um ficheiro de disco.</xref:System.IO.FileStream.CanSeek*>"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>é uma cadeia vazia (&quot;&quot;), contém apenas espaços em branco ou contém um ou mais carateres inválidos.       - ou - <code>path</code> refere-se a um dispositivo não ficheiro, tal como &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. num ambiente NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>se refere a um dispositivo não ficheiro, tal como &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. num ambiente de NTFS."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Não é possível localizar o ficheiro, como quando <code> mode </code> é <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>e o ficheiro especificado pelo <code> path </code> não existe. O ficheiro já deve existir nestes modos."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Um erro de e/s, tais como especificar <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> quando o ficheiro especificado pelo <code> path </code> já existe, ocorreu.       - ou - fluxo foi fechado."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "O caminho especificado é inválido, tais como a ser numa unidade não mapeada."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O <code> access </code> pedida não é permitido pelo sistema operativo especificado para <code> path </code>, tais como <code> access </code> é <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e o ficheiro ou diretório está definido para acesso só de leitura."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "O caminho especificado, o nome de ficheiro ou ambos excedem o comprimento máximo definido pelo sistema. Por exemplo, em plataformas com Windows, caminhos tem de ter menos de 248 carateres e nomes de ficheiros tem de ser inferior a 260 caracteres."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>contém um valor inválido."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.FileStream&quot;> </xref> classe para o identificador de ficheiro especificado, com a permissão de leitura/escrita especificado, o tamanho da memória intermédia e o estado de síncrono ou assíncrono."
  remarks: "Definir o `isAsync` parâmetro `true` para abrir o identificador de ficheiro no modo assíncrono. Quando o parâmetro é `true`, o fluxo utiliza e/s sobreposta para realizar operações de ficheiros no modo assíncrono. No entanto, o parâmetro tem de ser `true` para chamar o <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, ou <xref:System.IO.Stream.CopyToAsync%2A>método.</xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A> Quando o `isAsync` parâmetro é `false` e chamar a leitura assíncrona e operações de escrita, o thread de IU não ainda é bloqueado, mas a operação de e/s real é executada de forma síncrona.       `FileStream`parte do princípio de que tem um controlo exclusivo sobre o identificador. Ao ler, escrever ou procura a um `FileStream` é também que contém um identificador pode resultar em danos nos dados. Para segurança de dados, chamar <xref:System.IO.FileStream.Flush%2A>antes utilizando o identificador e evitar a chamar os métodos que `Close` depois de terminar com o identificador.</xref:System.IO.FileStream.Flush%2A> Em alternativa, para ler e escrever o identificador antes de chamar este `FileStream` construtor.       `FileShare.Read`é a predefinição para quem <xref:System.IO.FileStream>construtores sem um `FileShare` parâmetro.</xref:System.IO.FileStream>      > [!CAUTION] > Quando compilar um conjunto de carateres com uma definição de cultural específica e obter os mesmos carateres com uma definição de cultural diferentes, os carateres poderão não estar interpretable e pode provocar uma exceção ao ser emitida.       Para obter uma lista de ficheiros comuns e as operações de diretório, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "Identificador de um ficheiro para o ficheiro que este <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> irá encapsular objeto."
    - id: access
      type: System.IO.FileAccess
      description: "Uma constante que define o <> </> *> e <> </> *> propriedades do <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto."
    - id: bufferSize
      type: System.Int32
      description: "Um positivos <xref:System.Int32>um valor maior que 0 que indica o tamanho da memória intermédia.</xref:System.Int32> O tamanho de memória intermédia de predefinido é 4096."
    - id: isAsync
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o identificador foi aberto de forma assíncrona (ou seja, no que se sobreponham modo e/s); caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O <code> handle </code> parâmetro é um identificador inválido.       - ou - <code> handle </code> parâmetro é um identificador de síncrono e foi utilizado no modo assíncrono."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "O <code> bufferSize </code> parâmetro é negativo."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s, tais como um erro de disco.       - ou - fluxo foi fechado."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O <code> access </code> pedida não é permitido pelo sistema operativo para o identificador de ficheiro especificado, como quando <code> access </code> é <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e o identificador de ficheiro está definido para acesso só de leitura."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)
  id: '#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess,Boolean,Int32)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.FileStream&quot;> </xref> classe para o identificador de ficheiro especificado, com a permissão de leitura/escrita especificado, <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> propriedade de instância e a memória intermédia de tamanho."
  remarks: "O `FileStream` objeto é dado o acesso especificado para o ficheiro. A propriedade do identificador será conforme especificado. Se esta `FileStream` detém o identificador, uma chamada para o <xref:System.IO.Stream.Close%2A>método também irá fechar o identificador.</xref:System.IO.Stream.Close%2A> Em particular, este é debitada contagem de identificador do ficheiro. O `FileStream` objeto é dado o tamanho da memória intermédia especificado.       `FileStream`parte do princípio de que tem um controlo exclusivo sobre o identificador. Ao ler, escrever ou procura a um `FileStream` é também que contém um identificador pode resultar em danos nos dados. Para segurança de dados, chamar <xref:System.IO.FileStream.Flush%2A>antes utilizando o identificador e evitar a chamar os métodos que `Close` depois de terminar com o identificador.</xref:System.IO.FileStream.Flush%2A> Em alternativa, para ler e escrever o identificador antes de chamar este `FileStream` construtor.       `FileShare.Read`é a predefinição para quem <xref:System.IO.FileStream>construtores sem um `FileShare` parâmetro.</xref:System.IO.FileStream>      > [!CAUTION] > Quando compilar um conjunto de carateres com uma definição de cultural específica e obter os mesmos carateres com uma definição de cultural diferentes, os carateres poderão não estar interpretable e pode provocar uma exceção ao ser emitida.       Para obter uma lista de ficheiros comuns e as operações de diretório, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "Identificador de um ficheiro para o ficheiro que este <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> irá encapsular objeto."
    - id: access
      type: System.IO.FileAccess
      description: "Uma constante que define o <> </> *> e <> </> *> propriedades do <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto."
    - id: ownsHandle
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o identificador de ficheiro irá ser detido por este <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> instância; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    - id: bufferSize
      type: System.Int32
      description: "Um positivos <xref:System.Int32>um valor maior que 0 que indica o tamanho da memória intermédia.</xref:System.Int32> O tamanho de memória intermédia de predefinido é 4096."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>é negativo."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s, tais como um erro de disco.       - ou - fluxo foi fechado."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O <code> access </code> pedida não é permitido pelo sistema operativo para o identificador de ficheiro especificado, como quando <code> access </code> é <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e o identificador de ficheiro está definido para acesso só de leitura."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.FileStream&quot;> </xref> classe com o caminho especificado, o modo de criação, a permissão de leitura/escrita e a permissões de partilha."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed). The buffer size is set to the default size of 4096 bytes (4 KB).  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.  \n  \n [!code-cs[System.IO.FileStream3#2](~/add/codesnippet/csharp/904a8302-b9b6-44f1-89c4-_1.cs)]\n [!code-cpp[System.IO.FileStream3#2](~/add/codesnippet/cpp/904a8302-b9b6-44f1-89c4-_1.cpp)]\n [!code-vb[System.IO.FileStream3#2](~/add/codesnippet/visualbasic/904a8302-b9b6-44f1-89c4-_1.vb)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o ficheiro que atual <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> irá encapsular objeto."
    - id: mode
      type: System.IO.FileMode
      description: "Uma constante que determina como abrir ou criar o ficheiro."
    - id: access
      type: System.IO.FileAccess
      description: "Uma constante que determina a forma como o ficheiro pode ser acedido pelo <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto. Isto também determina os valores devolvidos pelo <> </> *> e <> </> *> propriedades do <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto. <xref:System.IO.FileStream.CanSeek*>é <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> se `path` Especifica um ficheiro de disco.</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "Uma constante que determina a forma como o ficheiro irão ser partilhado pelos processos."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>é uma cadeia vazia (&quot;&quot;), contém apenas espaços em branco ou contém um ou mais carateres inválidos.       - ou - <code>path</code> refere-se a um dispositivo não ficheiro, tal como &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. num ambiente NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>se refere a um dispositivo não ficheiro, tal como &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. num ambiente de NTFS."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Não é possível localizar o ficheiro, como quando <code> mode </code> é <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>e o ficheiro especificado pelo <code> path </code> não existe. O ficheiro já deve existir nestes modos."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Um erro de e/s, tais como especificar <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> quando o ficheiro especificado pelo <code> path </code> já existe, ocorreu.       - ou - o sistema está a executar Windows 98 ou edição do Windows 98 segundo e <code> share </code> está definido como <xref uid=&quot;langword_csharp_FileShare.Delete&quot; name=&quot;FileShare.Delete&quot; href=&quot;&quot;> </xref>.       - ou - fluxo foi fechado."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "O caminho especificado é inválido, tais como a ser numa unidade não mapeada."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O <code> access </code> pedida não é permitido pelo sistema operativo especificado para <code> path </code>, tais como <code> access </code> é <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e o ficheiro ou diretório está definido para acesso só de leitura."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "O caminho especificado, o nome de ficheiro ou ambos excedem o comprimento máximo definido pelo sistema. Por exemplo, em plataformas com Windows, caminhos tem de ter menos de 248 carateres e nomes de ficheiros tem de ser inferior a 260 caracteres."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>contém um valor inválido."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)
  id: '#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.FileStream&quot;> </xref> classe para o identificador de ficheiro especificado, com a permissão de leitura/escrita especificado, <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> instância propriedade, o tamanho da memória intermédia e o estado síncrono ou assíncrono."
  remarks: "O `FileStream` objeto é dado o acesso especificado para o ficheiro. A propriedade do identificador será conforme especificado. Se esta `FileStream` detém o identificador, uma chamada para o <xref:System.IO.Stream.Close%2A>método também irá fechar o identificador.</xref:System.IO.Stream.Close%2A> Em particular, este é debitada contagem de identificador do ficheiro. O `FileStream` objeto é dado o tamanho da memória intermédia especificado.       `FileStream`parte do princípio de que tem um controlo exclusivo sobre o identificador. Ao ler, escrever ou procura a um `FileStream` é também que contém um identificador pode resultar em danos nos dados. Para segurança de dados, chamar <xref:System.IO.FileStream.Flush%2A>antes utilizando o identificador e evitar a chamar os métodos que `Close` depois de terminar com o identificador.</xref:System.IO.FileStream.Flush%2A> Em alternativa, para ler e escrever o identificador antes de chamar este `FileStream` construtor.       `FileShare.Read`é a predefinição para quem <xref:System.IO.FileStream>construtores sem um `FileShare` parâmetro.</xref:System.IO.FileStream>      > [!CAUTION] > Quando compilar um conjunto de carateres com uma definição de cultural específica e obter os mesmos carateres com uma definição de cultural diferentes, os carateres poderão não estar interpretable e pode provocar uma exceção ao ser emitida.       Para obter uma lista de ficheiros comuns e as operações de diretório, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "Identificador de um ficheiro para o ficheiro que este <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> irá encapsular objeto."
    - id: access
      type: System.IO.FileAccess
      description: "Uma constante que define o <> </> *> e <> </> *> propriedades do <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto."
    - id: ownsHandle
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o identificador de ficheiro irá ser detido por este <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> instância; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    - id: bufferSize
      type: System.Int32
      description: "Um positivos <xref:System.Int32>um valor maior que 0 que indica o tamanho da memória intermédia.</xref:System.Int32> O tamanho de memória intermédia de predefinido é 4096."
    - id: isAsync
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o identificador foi aberto de forma assíncrona (ou seja, no que se sobreponham modo e/s); caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>access</code>é menor que <xref uid=&quot;langword_csharp_FileAccess.Read&quot; name=&quot;FileAccess.Read&quot; href=&quot;&quot;> </xref> ou superior a <xref uid=&quot;langword_csharp_FileAccess.ReadWrite&quot; name=&quot;FileAccess.ReadWrite&quot; href=&quot;&quot;> </xref> ou <code>bufferSize</code> é menor ou igual a 0."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O identificador é inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s, tais como um erro de disco.       - ou - fluxo foi fechado."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O <code> access </code> pedida não é permitido pelo sistema operativo para o identificador de ficheiro especificado, como quando <code> access </code> é <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e o identificador de ficheiro está definido para acesso só de leitura."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.FileStream&quot;> </xref> classe com o caminho especificado, o modo de criação, leitura/escrita e partilhar permissão e o tamanho da memória intermédia."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o ficheiro que atual <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> irá encapsular objeto."
    - id: mode
      type: System.IO.FileMode
      description: "Uma constante que determina como abrir ou criar o ficheiro."
    - id: access
      type: System.IO.FileAccess
      description: "Uma constante que determina a forma como o ficheiro pode ser acedido pelo <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto. Isto também determina os valores devolvidos pelo <> </> *> e <> </> *> propriedades do <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto. <xref:System.IO.FileStream.CanSeek*>é <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> se `path` Especifica um ficheiro de disco.</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "Uma constante que determina a forma como o ficheiro irão ser partilhado pelos processos."
    - id: bufferSize
      type: System.Int32
      description: "Um positivos <xref:System.Int32>um valor maior que 0 que indica o tamanho da memória intermédia.</xref:System.Int32> O tamanho de memória intermédia de predefinido é 4096."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>é uma cadeia vazia (&quot;&quot;), contém apenas espaços em branco ou contém um ou mais carateres inválidos.       - ou - <code>path</code> refere-se a um dispositivo não ficheiro, tal como &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. num ambiente NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>se refere a um dispositivo não ficheiro, tal como &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. num ambiente de NTFS."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>é negativo ou zero.       - ou - <code>mode</code>, <code>access</code>, ou <code>share</code> contém um valor inválido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Não é possível localizar o ficheiro, como quando <code> mode </code> é <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>e o ficheiro especificado pelo <code> path </code> não existe. O ficheiro já deve existir nestes modos."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Um erro de e/s, tais como especificar <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> quando o ficheiro especificado pelo <code> path </code> já existe, ocorreu.       - ou - o sistema está a executar Windows 98 ou edição do Windows 98 segundo e <code> share </code> está definido como <xref uid=&quot;langword_csharp_FileShare.Delete&quot; name=&quot;FileShare.Delete&quot; href=&quot;&quot;> </xref>.       - ou - fluxo foi fechado."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "O caminho especificado é inválido, tais como a ser numa unidade não mapeada."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O <code> access </code> pedida não é permitido pelo sistema operativo especificado para <code> path </code>, tais como <code> access </code> é <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e o ficheiro ou diretório está definido para acesso só de leitura."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "O caminho especificado, o nome de ficheiro ou ambos excedem o comprimento máximo definido pelo sistema. Por exemplo, em plataformas com Windows, caminhos tem de ter menos de 248 carateres e nomes de ficheiros tem de ser inferior a 260 caracteres."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.FileStream&quot;> </xref> classe com o caminho especificado, o modo de criação, leitura/escrita e permissão de partilha, a memória intermédia Estado tamanho e síncrono ou assíncrono."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example shows how to asynchronously write data to a file and then verify that the data was written correctly. A `State` object is created to pass information from the main thread to the `EndReadCallback` and `EndWriteCallback` methods.  \n  \n [!code-cs[System.IO.FileStream2#1](~/add/codesnippet/csharp/ff94fabb-a26d-4ac2-a74e-_1.cs)]\n [!code-vb[System.IO.FileStream2#1](~/add/codesnippet/visualbasic/ff94fabb-a26d-4ac2-a74e-_1.vb)]\n [!code-cpp[System.IO.FileStream2#1](~/add/codesnippet/cpp/ff94fabb-a26d-4ac2-a74e-_1.cpp)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o ficheiro que atual <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> irá encapsular objeto."
    - id: mode
      type: System.IO.FileMode
      description: "Uma constante que determina como abrir ou criar o ficheiro."
    - id: access
      type: System.IO.FileAccess
      description: "Uma constante que determina a forma como o ficheiro pode ser acedido pelo <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto. Isto também determina os valores devolvidos pelo <> </> *> e <> </> *> propriedades do <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto. <xref:System.IO.FileStream.CanSeek*>é <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> se `path` Especifica um ficheiro de disco.</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "Uma constante que determina a forma como o ficheiro irão ser partilhado pelos processos."
    - id: bufferSize
      type: System.Int32
      description: "Um positivos <xref:System.Int32>um valor maior que 0 que indica o tamanho da memória intermédia.</xref:System.Int32> O tamanho de memória intermédia de predefinido é 4096..."
    - id: useAsync
      type: System.Boolean
      description: "Especifica se pretende utilizar e/s assíncrona ou síncrona e/s. No entanto, tenha em atenção que o sistema operativo subjacente não suportem e/s assíncrona, pelo que, quando especificar <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, o identificador pode ser aberto de forma síncrona consoante a plataforma. Quando aberto no modo assíncrono, o <> </> *> e <> </> *> métodos melhor efetuar em grande leituras ou escritas, mas podem ser muito mais lentos para pequenas leituras ou escritas. Se a aplicação foi concebida para tirar partido das e/s assíncrona, defina o `useAsync` parâmetro <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>. Utilização de e/s assíncrona corretamente pode acelerar a aplicações, como sucederia com um fator de 10, mas a utilizá-la ao reestruturar a aplicação para e/s assíncrona pode diminuir o desempenho ao mesmo como um fator de 10."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>é uma cadeia vazia (&quot;&quot;), contém apenas espaços em branco ou contém um ou mais carateres inválidos.       - ou - <code>path</code> refere-se a um dispositivo não ficheiro, tal como &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. num ambiente NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>se refere a um dispositivo não ficheiro, tal como &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. num ambiente de NTFS."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>é negativo ou zero.       - ou - <code>mode</code>, <code>access</code>, ou <code>share</code> contém um valor inválido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Não é possível localizar o ficheiro, como quando <code> mode </code> é <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>e o ficheiro especificado pelo <code> path </code> não existe. O ficheiro já deve existir nestes modos."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Um erro de e/s, tais como especificar <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> quando o ficheiro especificado pelo <code> path </code> já existe, ocorreu.       - ou - o sistema está a executar Windows 98 ou edição do Windows 98 segundo e <code> share </code> está definido como <xref uid=&quot;langword_csharp_FileShare.Delete&quot; name=&quot;FileShare.Delete&quot; href=&quot;&quot;> </xref>.       - ou - fluxo foi fechado."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "O caminho especificado é inválido, tais como a ser numa unidade não mapeada."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O <code> access </code> pedida não é permitido pelo sistema operativo especificado para <code> path </code>, tais como <code> access </code> é <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e o ficheiro ou diretório está definido para acesso só de leitura."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "O caminho especificado, o nome de ficheiro ou ambos excedem o comprimento máximo definido pelo sistema. Por exemplo, em plataformas com Windows, caminhos tem de ter menos de 248 carateres e nomes de ficheiros tem de ser inferior a 260 caracteres."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.FileStream&quot;> </xref> classe com o caminho especificado, o modo de criação, leitura/escrita e outros FileStreams partilha permissão, o acesso pode ter o mesmo ficheiro, o tamanho da memória intermédia e opções de ficheiro adicionais."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example writes data to a file and then reads the data using the <xref:System.IO.FileStream> object.  \n  \n [!code-cpp[IO.FileStream.ctor1#1](~/add/codesnippet/cpp/53f739ba-7c4d-43ff-a387-_1.cpp)]\n [!code-vb[IO.FileStream.ctor1#1](~/add/codesnippet/visualbasic/53f739ba-7c4d-43ff-a387-_1.vb)]\n [!code-cs[IO.FileStream.ctor1#1](~/add/codesnippet/csharp/53f739ba-7c4d-43ff-a387-_1.cs)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o ficheiro que atual <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> irá encapsular objeto."
    - id: mode
      type: System.IO.FileMode
      description: "Uma constante que determina como abrir ou criar o ficheiro."
    - id: access
      type: System.IO.FileAccess
      description: "Uma constante que determina a forma como o ficheiro pode ser acedido pelo <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto. Isto também determina os valores devolvidos pelo <> </> *> e <> </> *> propriedades do <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto. <xref:System.IO.FileStream.CanSeek*>é <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> se `path` Especifica um ficheiro de disco.</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "Uma constante que determina a forma como o ficheiro irão ser partilhado pelos processos."
    - id: bufferSize
      type: System.Int32
      description: "Um positivos <xref:System.Int32>um valor maior que 0 que indica o tamanho da memória intermédia.</xref:System.Int32> O tamanho de memória intermédia de predefinido é 4096."
    - id: options
      type: System.IO.FileOptions
      description: "Um valor que especifica as opções de ficheiro adicionais."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>é uma cadeia vazia (&quot;&quot;), contém apenas espaços em branco ou contém um ou mais carateres inválidos.       - ou - <code>path</code> refere-se a um dispositivo não ficheiro, tal como &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. num ambiente NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>se refere a um dispositivo não ficheiro, tal como &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. num ambiente de NTFS."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>é negativo ou zero.       - ou - <code>mode</code>, <code>access</code>, ou <code>share</code> contém um valor inválido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Não é possível localizar o ficheiro, como quando <code> mode </code> é <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>e o ficheiro especificado pelo <code> path </code> não existe. O ficheiro já deve existir nestes modos."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Um erro de e/s, tais como especificar <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> quando o ficheiro especificado pelo <code> path </code> já existe, ocorreu.       - ou - fluxo foi fechado."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "O caminho especificado é inválido, tais como a ser numa unidade não mapeada."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O <code> access </code> pedida não é permitido pelo sistema operativo especificado para <code> path </code>, tais como <code> access </code> é <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e o ficheiro ou diretório está definido para acesso só de leitura.       - ou - <xref href=&quot;System.IO.FileOptions&quot;> </xref> especificado para <code> options </code>, mas a encriptação de ficheiros não é suportada na plataforma atual."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "O caminho especificado, o nome de ficheiro ou ambos excedem o comprimento máximo definido pelo sistema. Por exemplo, em plataformas com Windows, caminhos tem de ter menos de 248 carateres e nomes de ficheiros tem de ser inferior a 260 caracteres."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  id: '#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.FileStream&quot;> </xref> classe com o caminho especificado, o modo de criação, direitos de acesso e permissões de partilha, as opções de ficheiro de tamanho e adicionais de memória intermédia."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n Use this FileStream constructor to apply access rights at the point of creation of a file. To access or modify rights on an existing file, consider using the <xref:System.IO.File.GetAccessControl%2A> and <xref:System.IO.File.SetAccessControl%2A> methods.  \n  \n The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o ficheiro que atual <xref href=&quot;System.IO.FileStream&quot;> </xref> irá encapsular objeto."
    - id: mode
      type: System.IO.FileMode
      description: "Uma constante que determina como abrir ou criar o ficheiro."
    - id: rights
      type: System.Security.AccessControl.FileSystemRights
      description: "Uma constante que determina os direitos de acesso para utilizar quando criar regras de acesso e auditoria para o ficheiro."
    - id: share
      type: System.IO.FileShare
      description: "Uma constante que determina a forma como o ficheiro irão ser partilhado pelos processos."
    - id: bufferSize
      type: System.Int32
      description: "Um positivos <xref:System.Int32>um valor maior que 0 que indica o tamanho da memória intermédia.</xref:System.Int32> O tamanho de memória intermédia de predefinido é 4096."
    - id: options
      type: System.IO.FileOptions
      description: "Uma constante que especifica as opções de ficheiro adicionais."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>é uma cadeia vazia (&quot;&quot;), contém apenas espaços em branco ou contém um ou mais carateres inválidos.       - ou - <code>path</code> refere-se a um dispositivo não ficheiro, tal como &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. num ambiente NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>se refere a um dispositivo não ficheiro, tal como &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. num ambiente de NTFS."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>é negativo ou zero.       - ou - <code>mode</code>, <code>access</code>, ou <code>share</code> contém um valor inválido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Não é possível localizar o ficheiro, como quando <code> mode </code> é <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>e o ficheiro especificado pelo <code> path </code> não existe. O ficheiro já deve existir nestes modos."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "O sistema operativo atual não é Windows NT ou posterior."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Um erro de e/s, tais como especificar <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> quando o ficheiro especificado pelo <code> path </code> já existe, ocorreu.       - ou - fluxo foi fechado."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "O caminho especificado é inválido, tais como a ser numa unidade não mapeada."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O <code> access </code> pedida não é permitido pelo sistema operativo especificado para <code> path </code>, tais como <code> access </code> é <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e o ficheiro ou diretório está definido para acesso só de leitura.       - ou - <xref href=&quot;System.IO.FileOptions&quot;> </xref> especificado para <code> options </code>, mas a encriptação de ficheiros não é suportada na plataforma atual."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Especificado <code> path </code>, nome de ficheiro ou ambos excedem o comprimento máximo definido pelo sistema. Por exemplo, em plataformas com Windows, caminhos tem de ter menos de 248 carateres e nomes de ficheiros tem de ser inferior a 260 caracteres."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)
  id: '#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.FileStream&quot;> </xref> classe com o caminho especificado, o modo de criação, direitos de acesso e partilha permissão, o tamanho da memória intermédia, as opções de ficheiro adicionais, controlo de acesso e auditoria de segurança."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n Use this FileStream constructor to apply access rights at the point of creation of a file. To access or modify rights on an existing file, consider using the <xref:System.IO.File.GetAccessControl%2A> and <xref:System.IO.File.SetAccessControl%2A> methods.  \n  \n The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example writes data to a file and then reads the data using the <xref:System.IO.FileStream> object.  \n  \n [!code-cpp[IO.FileStream.ctor2#1](~/add/codesnippet/cpp/7f323125-1dac-495a-a4ee-_1.cpp)]\n [!code-cs[IO.FileStream.ctor2#1](~/add/codesnippet/csharp/7f323125-1dac-495a-a4ee-_1.cs)]\n [!code-vb[IO.FileStream.ctor2#1](~/add/codesnippet/visualbasic/7f323125-1dac-495a-a4ee-_1.vb)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o ficheiro que atual <xref href=&quot;System.IO.FileStream&quot;> </xref> irá encapsular objeto."
    - id: mode
      type: System.IO.FileMode
      description: "Uma constante que determina como abrir ou criar o ficheiro."
    - id: rights
      type: System.Security.AccessControl.FileSystemRights
      description: "Uma constante que determina os direitos de acesso para utilizar quando criar regras de acesso e auditoria para o ficheiro."
    - id: share
      type: System.IO.FileShare
      description: "Uma constante que determina a forma como o ficheiro irão ser partilhado pelos processos."
    - id: bufferSize
      type: System.Int32
      description: "Um positivos <xref:System.Int32>um valor maior que 0 que indica o tamanho da memória intermédia.</xref:System.Int32> O tamanho de memória intermédia de predefinido é 4096."
    - id: options
      type: System.IO.FileOptions
      description: "Uma constante que especifica as opções de ficheiro adicionais."
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "Uma constante que determina o controlo de acesso e auditoria de segurança para o ficheiro."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>é uma cadeia vazia (&quot;&quot;), contém apenas espaços em branco ou contém um ou mais carateres inválidos.       - ou - <code>path</code> refere-se a um dispositivo não ficheiro, tal como &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. num ambiente NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>se refere a um dispositivo não ficheiro, tal como &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. num ambiente de NTFS."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>é negativo ou zero.       - ou - <code>mode</code>, <code>access</code>, ou <code>share</code> contém um valor inválido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Não é possível localizar o ficheiro, como quando <code> mode </code> é <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>e o ficheiro especificado pelo <code> path </code> não existe. O ficheiro já deve existir nestes modos."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Um erro de e/s, tais como especificar <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> quando o ficheiro especificado pelo <code> path </code> já existe, ocorreu.       - ou - fluxo foi fechado."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "O caminho especificado é inválido, tais como a ser numa unidade não mapeada."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O <code> access </code> pedida não é permitido pelo sistema operativo especificado para <code> path </code>, tais como <code> access </code> é <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> e o ficheiro ou diretório está definido para acesso só de leitura.       - ou - <xref href=&quot;System.IO.FileOptions&quot;> </xref> especificado para <code> options </code>, mas a encriptação de ficheiros não é suportada na plataforma atual."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Especificado <code> path </code>, nome de ficheiro ou ambos excedem o comprimento máximo definido pelo sistema. Por exemplo, em plataformas com Windows, caminhos tem de ter menos de 248 carateres e nomes de ficheiros tem de ser inferior a 260 caracteres."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "O sistema operativo atual não é Windows NT ou posterior."
  platform:
  - net462
- uid: System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Começa uma operação de leitura assíncrona. (Considere utilizar <xref:System.IO.FileStream.ReadAsync*>em vez disso; consulte a secção observações.)</xref:System.IO.FileStream.ReadAsync*>"
  remarks: "O .NET Framework 4 e versões anteriores, é necessário usar métodos tais como BeginRead e <xref:System.IO.FileStream.EndRead%2A>para implementar as operações de ficheiros assíncronas.</xref:System.IO.FileStream.EndRead%2A> Estes métodos ainda estão disponíveis a [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] para suportar código legado; no entanto, os novos métodos assíncronos, tais como <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, e <xref:System.IO.FileStream.FlushAsync%2A>, ajuda a implementar operações assíncronas ficheiros mais facilmente.</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       <xref:System.IO.FileStream.EndRead%2A>tem de ser chamado exatamente uma vez para cada chamada BeginRead.</xref:System.IO.FileStream.EndRead%2A> Falha ao terminar um processo de leitura antes de iniciar a leitura de outra pode provocar um comportamento indesejável como impasse.       <xref:System.IO.FileStream>fornece dois modos diferentes da operação: e/s síncrona e e/s assíncrona.</xref:System.IO.FileStream> Enquanto pode ser utilizado um, os recursos de sistema operativo subjacente poderão permitir o acesso em apenas um dos modos destas. Por predefinição, <xref:System.IO.FileStream>abre o identificador de sistema operativo de forma síncrona.</xref:System.IO.FileStream> No Windows, esta atrasar métodos assíncronos. Se os métodos assíncronos são utilizados, utilize o <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>construtor.</xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>      > [!NOTE] > Utilize o <xref:System.IO.FileStream.CanRead%2A>propriedade para determinar se a instância atual suporta a leitura.</xref:System.IO.FileStream.CanRead%2A> Para obter mais informações, consulte <xref:System.IO.Stream.CanRead%2A>.</xref:System.IO.Stream.CanRead%2A>       Se um fluxo está fechado ou transmita um argumento inválido, as exceções forem emitidas imediatamente de BeginRead. Erros ocorridos durante um pedido de leitura assíncrono, tais como uma falha durante o pedido de e/s de disco ocorrerem no thread de conjunto de threads e ficam visíveis após uma chamada para <xref:System.IO.FileStream.EndRead%2A>.</xref:System.IO.FileStream.EndRead%2A>       <xref:System.IO.Stream.EndRead%2A>tem de ser chamado com esta <xref:System.IAsyncResult>para determinar o número de bytes foram lidos.</xref:System.IAsyncResult></xref:System.IO.Stream.EndRead%2A>       Vários pedidos simultâneos de assíncronos compor incerto a ordem de conclusão do pedido.       Para obter uma lista de ficheiros comuns e as operações de diretório, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#3](~/add/codesnippet/csharp/82be2bd0-0603-4287-b351-_1.cs)]\n [!code-vb[System.IO.FileStream2#3](~/add/codesnippet/visualbasic/82be2bd0-0603-4287-b351-_1.vb)]\n [!code-cpp[System.IO.FileStream2#3](~/add/codesnippet/cpp/82be2bd0-0603-4287-b351-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    parameters:
    - id: array
      type: System.Byte[]
      description: "A memória intermédia para ler os dados em."
    - id: offset
      type: System.Int32
      description: "O deslocamento de byte no `array` no qual pretende começar a ler."
    - id: numBytes
      type: System.Int32
      description: "O número máximo de bytes a ler."
    - id: userCallback
      type: System.AsyncCallback
      description: "O método chamado quando a operação de leitura a assíncrona está concluído."
    - id: stateObject
      type: System.Object
      description: "Um objeto de fornecidos pelo utilizador que distingue este pedido de leitura assíncrono específico de outros pedidos."
    return:
      type: System.IAsyncResult
      description: "Um objeto que faça referência a leitura assíncrona."
  overload: System.IO.FileStream.BeginRead*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O comprimento da matriz menos <code> offset </code> é inferior a <code> numBytes </code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>ou <code>numBytes</code> é negativo."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Foi tentada uma leitura assíncrona ultrapassou o fim do ficheiro."
  platform:
  - net462
- uid: System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Começa uma operação de escrita assíncrona. (Considere utilizar <xref:System.IO.FileStream.WriteAsync*>em vez disso; consulte a secção observações.)</xref:System.IO.FileStream.WriteAsync*>"
  remarks: "O .NET Framework 4 e versões anteriores, é necessário usar métodos tais como BeginWrite e <xref:System.IO.FileStream.EndWrite%2A>para implementar as operações de ficheiros assíncronas.</xref:System.IO.FileStream.EndWrite%2A> Estes métodos ainda estão disponíveis a [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] para suportar código legado; no entanto, os novos métodos assíncronos, tais como <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, e <xref:System.IO.FileStream.FlushAsync%2A>, ajuda a implementar operações assíncronas ficheiros mais facilmente.</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       <xref:System.IO.FileStream.EndWrite%2A>tem de ser chamado exatamente uma vez em cada <xref:System.IAsyncResult>de BeginWrite.</xref:System.IAsyncResult></xref:System.IO.FileStream.EndWrite%2A> <xref:System.IO.FileStream.EndWrite%2A>irá bloquear até que a operação de e/s foi concluída.</xref:System.IO.FileStream.EndWrite%2A>       Este método substitui <xref:System.IO.Stream.BeginWrite%2A>.</xref:System.IO.Stream.BeginWrite%2A>       <xref:System.IO.FileStream>fornece dois modos diferentes da operação: e/s síncrona e e/s assíncrona.</xref:System.IO.FileStream> Enquanto pode ser utilizado um, os recursos de sistema operativo subjacente poderão permitir o acesso em apenas um dos modos destas. Por predefinição, <xref:System.IO.FileStream>abre o identificador de sistema operativo de forma síncrona.</xref:System.IO.FileStream> No Windows, esta atrasar métodos assíncronos. Se os métodos assíncronos são utilizados, utilize o <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>construtor.</xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>       Se um fluxo está fechado ou transmita um argumento inválido, as exceções forem emitidas imediatamente de BeginWrite. Erros ocorridos durante um pedido de escrita assíncrona, tais como uma falha durante o pedido de e/s de disco ocorrerem no thread de conjunto de threads e ficam visíveis após uma chamada para <xref:System.IO.FileStream.EndWrite%2A>.</xref:System.IO.FileStream.EndWrite%2A>       Vários pedidos simultâneos de assíncronos compor incerto a ordem de conclusão do pedido.       Para obter uma lista de ficheiros comuns e as operações de diretório, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#2](~/add/codesnippet/csharp/439bdb1f-5241-4046-a4ad-_1.cs)]\n [!code-vb[System.IO.FileStream2#2](~/add/codesnippet/visualbasic/439bdb1f-5241-4046-a4ad-_1.vb)]\n [!code-cpp[System.IO.FileStream2#2](~/add/codesnippet/cpp/439bdb1f-5241-4046-a4ad-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    parameters:
    - id: array
      type: System.Byte[]
      description: "A memória intermédia que contém os dados a escrever o fluxo actual."
    - id: offset
      type: System.Int32
      description: "O deslocamento de byte baseado em zero no `array` no qual pretende começar a copiar bytes no fluxo atual."
    - id: numBytes
      type: System.Int32
      description: "O número máximo de bytes para escrita."
    - id: userCallback
      type: System.AsyncCallback
      description: "O método a ser chamado quando a operação de escrita assíncrona foi concluída."
    - id: stateObject
      type: System.Object
      description: "Um objeto de fornecidos pelo utilizador que distingue este pedido de escrita assíncrona específico de outros pedidos."
    return:
      type: System.IAsyncResult
      description: "Um objeto que faça referência a escrita assíncrona."
  overload: System.IO.FileStream.BeginWrite*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>comprimento menos <code>offset</code> é inferior a <code>numBytes</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>ou <code>numBytes</code> é negativo."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O fluxo não suporta escrita."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O fluxo está fechado."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s."
  platform:
  - net462
- uid: System.IO.FileStream.CanRead
  id: CanRead
  parent: System.IO.FileStream
  langs:
  - csharp
  name: CanRead
  nameWithType: FileStream.CanRead
  fullName: System.IO.FileStream.CanRead
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Obtém um valor que indica se o fluxo actual suporta leitura."
  remarks: "Se uma classe derivada de <xref:System.IO.Stream>não suporta leitura, as chamadas para o <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.ReadByte%2A>e <xref:System.IO.FileStream.BeginRead%2A>métodos acionar <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.FileStream.BeginRead%2A> </xref:System.IO.FileStream.ReadByte%2A> </xref:System.IO.FileStream.Read%2A> </xref:System.IO.Stream>       Se o fluxo está fechado, esta propriedade devolve `false`."
  example:
  - "The following example demonstrates a use of the `CanRead` property. The output of this code is \"MyFile.txt is not writable.\" To get the output message \"MyFile.txt can be both written to and read from.\", change the `FileAccess` parameter to `ReadWrite` in the `FileStream` constructor.  \n  \n [!code-cs[Classic FileStream.CanRead Example#1](~/add/codesnippet/csharp/p-system.io.filestream.c_1_1.cs)]\n [!code-cpp[Classic FileStream.CanRead Example#1](~/add/codesnippet/cpp/p-system.io.filestream.c_1_1.cpp)]\n [!code-vb[Classic FileStream.CanRead Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_1_1.vb)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o fluxo de suportar leitura; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> se o fluxo está fechado ou foi aberto com acesso só de escrita."
  overload: System.IO.FileStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.CanSeek
  id: CanSeek
  parent: System.IO.FileStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: FileStream.CanSeek
  fullName: System.IO.FileStream.CanSeek
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Obtém um valor que indica se o fluxo actual suporta pesquisa."
  remarks: "Se uma classe derivada de <xref:System.IO.Stream>não suporta procura, as chamadas para <xref:System.IO.FileStream.Length%2A>, <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Position%2A>e <xref:System.IO.FileStream.Seek%2A>acionar <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.FileStream.Seek%2A> </xref:System.IO.FileStream.Position%2A> </xref:System.IO.FileStream.SetLength%2A> </xref:System.IO.FileStream.Length%2A> </xref:System.IO.Stream>       Se o fluxo está fechado, esta propriedade devolve `false`."
  example:
  - "The following example uses the `CanSeek` property to check whether a stream supports seeking.  \n  \n [!code-cpp[fstream canseek#1](~/add/codesnippet/cpp/p-system.io.filestream.c_0_1.cpp)]\n [!code-vb[fstream canseek#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_0_1.vb)]\n [!code-cs[fstream canseek#1](~/add/codesnippet/csharp/p-system.io.filestream.c_0_1.cs)]"
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o fluxo de suportar a pesquisa; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> se o fluxo está fechado ou se o <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> foi construído a partir de um identificador de sistema operativo como um pipe ou saída para a consola."
  overload: System.IO.FileStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.CanWrite
  id: CanWrite
  parent: System.IO.FileStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: FileStream.CanWrite
  fullName: System.IO.FileStream.CanWrite
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Obtém um valor que indica se o fluxo actual suporta escrita."
  remarks: "Se uma classe derivada de <xref:System.IO.Stream>não suporta a escrita de uma chamada para <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.FileStream.BeginWrite%2A>, ou <xref:System.IO.FileStream.WriteByte%2A>emitir um <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.FileStream.WriteByte%2A> </xref:System.IO.FileStream.BeginWrite%2A> </xref:System.IO.FileStream.Write%2A> </xref:System.IO.FileStream.SetLength%2A> </xref:System.IO.Stream>       Se o fluxo está fechado, esta propriedade devolve `false`."
  example:
  - "The following example uses the `CanWrite` property to check whether a stream supports writing.  \n  \n [!code-cs[fstream canwrite#1](~/add/codesnippet/csharp/p-system.io.filestream.c_2_1.cs)]\n [!code-cpp[fstream canwrite#1](~/add/codesnippet/cpp/p-system.io.filestream.c_2_1.cpp)]\n [!code-vb[fstream canwrite#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_2_1.vb)]  \n  \n The following is an example using the `CanWrite` property. The output of this code is \"MyFile.txt is writable.\" To get the output message \"MyFile.txt can be both written to and read from.\", change the `FileAccess` parameter to `ReadWrite` in the `FileStream` constructor.  \n  \n [!code-cs[Classic FileStream.CanWrite Example#1](~/add/codesnippet/csharp/p-system.io.filestream.c_2_2.cs)]\n [!code-vb[Classic FileStream.CanWrite Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_2_2.vb)]\n [!code-cpp[Classic FileStream.CanWrite Example#1](~/add/codesnippet/cpp/p-system.io.filestream.c_2_2.cpp)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o fluxo de suportar escrita; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> se o fluxo está fechado ou foi aberto com acesso só de leitura."
  overload: System.IO.FileStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: FileStream.Dispose(Boolean)
  fullName: System.IO.FileStream.Dispose(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Liberta os recursos não geridos utilizados pelo <xref href=&quot;System.IO.FileStream&quot;> </xref> e opcionalmente liberta os recursos geridos."
  remarks: "Este método é denominado pelo público <xref:System.ComponentModel.Component.Dispose%2A>método e o <xref:System.Object.Finalize%2A>método.</xref:System.Object.Finalize%2A> </xref:System.ComponentModel.Component.Dispose%2A> <xref:System.ComponentModel.Component.Dispose%2A>Invoca o método de Dispose protegido com o `disposing` parâmetro definido como `true`.</xref:System.ComponentModel.Component.Dispose%2A> <xref:System.Object.Finalize%2A>invoca Dispose com `disposing` definido como `false`.</xref:System.Object.Finalize%2A>       Quando o `disposing` parâmetro é `true`, este método versões retidos por quaisquer objetos geridos de todos os recursos que este <xref:System.IO.FileStream>referências.</xref:System.IO.FileStream> Este método invoca o <xref:System.ComponentModel.Component.Dispose%2A>método de cada objeto referenciado.</xref:System.ComponentModel.Component.Dispose%2A>"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Para libertar recursos geridos e; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para libertar recursos apenas não geridos."
  overload: System.IO.FileStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.EndRead(System.IAsyncResult)
  id: EndRead(System.IAsyncResult)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: EndRead(IAsyncResult)
  nameWithType: FileStream.EndRead(IAsyncResult)
  fullName: System.IO.FileStream.EndRead(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Tem de aguardar durante a operação de leitura assíncrona pendente concluir. (Considere utilizar <xref:System.IO.FileStream.ReadAsync*>em vez disso; consulte a secção observações.)</xref:System.IO.FileStream.ReadAsync*>"
  remarks: "O .NET Framework 4 e versões anteriores, é necessário usar métodos tais como <xref:System.IO.FileStream.BeginRead%2A>e EndRead para implementar as operações de ficheiros assíncronas.</xref:System.IO.FileStream.BeginRead%2A> Estes métodos ainda estão disponíveis a [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] para suportar código legado; no entanto, os novos métodos assíncronos, tais como <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, e <xref:System.IO.FileStream.FlushAsync%2A>, ajuda a implementar operações assíncronas ficheiros mais facilmente.</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       Tem de ser chamado EndRead exatamente para cada chamada <xref:System.IO.FileStream.BeginRead%2A>.</xref:System.IO.FileStream.BeginRead%2A> Falha ao terminar um processo de leitura antes de iniciar a leitura de outra pode provocar um comportamento indesejável como impasse.       Este método substitui <xref:System.IO.Stream.EndRead%2A>.</xref:System.IO.Stream.EndRead%2A>       É possível chamar EndRead em cada <xref:System.IAsyncResult>de <xref:System.IO.FileStream.BeginRead%2A>.</xref:System.IO.FileStream.BeginRead%2A> </xref:System.IAsyncResult> Chamar EndRead indica quantos bytes foram lido do fluxo. EndRead irá bloquear até que a operação de e/s foi concluída."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#4](~/add/codesnippet/csharp/m-system.io.filestream.e_0_1.cs)]\n [!code-vb[System.IO.FileStream2#4](~/add/codesnippet/visualbasic/m-system.io.filestream.e_0_1.vb)]\n [!code-cpp[System.IO.FileStream2#4](~/add/codesnippet/cpp/m-system.io.filestream.e_0_1.cpp)]"
  syntax:
    content: public override int EndRead (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "A referência ao pedido assíncrona pendente para aguardar."
    return:
      type: System.Int32
      description: "O número de bytes lido do fluxo, entre 0 e o número de bytes que pediu. Fluxos de devolvem apenas 0 no final da transmissão em fluxo, caso contrário, deverá bloquear até, pelo menos, de 1 byte está disponível."
  overload: System.IO.FileStream.EndRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Este <xref:System.IAsyncResult>objeto não foi criado chamando <xref:System.IO.FileStream.BeginRead*>nesta classe.</xref:System.IO.FileStream.BeginRead*> </xref:System.IAsyncResult>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "EndRead é chamado várias vezes."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "O fluxo está fechado ou Ocorreu um erro interno."
  platform:
  - net462
- uid: System.IO.FileStream.EndWrite(System.IAsyncResult)
  id: EndWrite(System.IAsyncResult)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: EndWrite(IAsyncResult)
  nameWithType: FileStream.EndWrite(IAsyncResult)
  fullName: System.IO.FileStream.EndWrite(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Termina uma operação de escrita assíncrona e blocos até que a operação de e/s foi concluída. (Considere utilizar <xref:System.IO.FileStream.WriteAsync*>em vez disso; consulte a secção observações.)</xref:System.IO.FileStream.WriteAsync*>"
  remarks: "O .NET Framework 4 e versões anteriores, é necessário usar métodos tais como <xref:System.IO.FileStream.BeginWrite%2A>e EndWrite para implementar as operações de ficheiros assíncronas.</xref:System.IO.FileStream.BeginWrite%2A> Estes métodos ainda estão disponíveis a [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] para suportar código legado; no entanto, os novos métodos assíncronos, tais como <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, e <xref:System.IO.FileStream.FlushAsync%2A>, ajuda a implementar operações assíncronas ficheiros mais facilmente.</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       Este método substitui <xref:System.IO.Stream.EndWrite%2A>.</xref:System.IO.Stream.EndWrite%2A>       EndWrite tem de ser chamado exatamente uma vez em cada <xref:System.IAsyncResult>de <xref:System.IO.FileStream.BeginWrite%2A>.</xref:System.IO.FileStream.BeginWrite%2A> </xref:System.IAsyncResult> EndWrite irá bloquear até que a operação de e/s foi concluída."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#3](~/add/codesnippet/csharp/m-system.io.filestream.e_1_1.cs)]\n [!code-vb[System.IO.FileStream2#3](~/add/codesnippet/visualbasic/m-system.io.filestream.e_1_1.vb)]\n [!code-cpp[System.IO.FileStream2#3](~/add/codesnippet/cpp/m-system.io.filestream.e_1_1.cpp)]"
  syntax:
    content: public override void EndWrite (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "O pedido de e/s assíncrono pendente."
  overload: System.IO.FileStream.EndWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Este <xref:System.IAsyncResult>objeto não foi criado chamando <xref:System.IO.Stream.BeginWrite*>nesta classe.</xref:System.IO.Stream.BeginWrite*> </xref:System.IAsyncResult>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "EndWrite é chamado várias vezes."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "O fluxo está fechado ou Ocorreu um erro interno."
  platform:
  - net462
- uid: System.IO.FileStream.Finalize
  id: Finalize
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Finalize()
  nameWithType: FileStream.Finalize()
  fullName: System.IO.FileStream.Finalize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Garante que os recursos são libertados e outras operações de limpeza são efetuadas quando o recoletor de lixo da memória reclama o <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>."
  remarks: "As chamadas de recoletor de lixo `Finalize` quando o objeto atual está pronto para ser finalizada. `Finalize`Fecha o `FileStream`."
  syntax:
    content: ~FileStream ();
    parameters: []
  overload: System.IO.FileStream.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Flush
  id: Flush
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Flush()
  nameWithType: FileStream.Flush()
  fullName: System.IO.FileStream.Flush()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Limpa memórias intermédias para este fluxo e faz com que todos os dados colocados em memória intermédia para serem escritos para o ficheiro."
  remarks: "Este método substitui <xref:System.IO.Stream.Flush%2A?displayProperty=fullName>.</xref:System.IO.Stream.Flush%2A?displayProperty=fullName>       Quando chamar o método de esvaziamento, a memória intermédia do sistema operativo e/s também é descarregada.       Codificador de um fluxo não for descarregado, exceto se chamar descarregar ou eliminar o objeto explicitamente. Definição <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=fullName>para `true` significa que dados serão descarregados da memória intermédia no fluxo, mas o estado de codificador não irá ser esvaziado.</xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=fullName> Isto permite que o codificador manter o estado (parciais carateres) para que o se codificar o próximo bloco de carateres corretamente. Este cenário afeta UTF8 e UTF7 onde determinados caracteres só podem ser codificados depois do codificador recebe o caráter adjacente ou carateres.       Porque pode ser utilizada uma memória intermédia para ler ou escrever, esvaziamento efetua as seguintes duas funções: - todos os dados escritos anteriormente para a memória intermédia são copiados para o ficheiro e a memória intermédia está desmarcada, exceto para o seu estado de codificador.      -Se <xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=fullName>é `true` e dados anteriormente foi copiados do ficheiro para a memória intermédia para ler, a posição atual do ficheiro é debitada pelo número de bytes unread na memória intermédia.</xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=fullName> A memória intermédia, em seguida, está desmarcada.       Utilize o <xref:System.IO.FileStream.Flush%28System.Boolean%29>sobrecarga de método quando pretender certificar-se de que todos os colocado na memória intermédia dados das memórias intermédias de ficheiro intermédio é escrita no disco.</xref:System.IO.FileStream.Flush%28System.Boolean%29>"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.  \n  \n [!code-cs[System.IO.FileStream3#4](~/add/codesnippet/csharp/m-system.io.filestream.f_1.cs)]\n [!code-cpp[System.IO.FileStream3#4](~/add/codesnippet/cpp/m-system.io.filestream.f_1.cpp)]\n [!code-vb[System.IO.FileStream3#4](~/add/codesnippet/visualbasic/m-system.io.filestream.f_1.vb)]"
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.IO.FileStream.Flush*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O fluxo está fechado."
  platform:
  - net462
- uid: System.IO.FileStream.Flush(System.Boolean)
  id: Flush(System.Boolean)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Flush(Boolean)
  nameWithType: FileStream.Flush(Boolean)
  fullName: System.IO.FileStream.Flush(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Limpa memórias intermédias para este fluxo e faz com que todos os dados colocados em memória intermédia para serem escritos para o ficheiro e limpa todas as memórias intermédias de ficheiro intermédio."
  remarks: "Utilize esta sobrecarga quando pretender certificar-se de que todos os colocado na memória intermédia dados das memórias intermédias de ficheiro intermédio é escrita no disco.       Quando chamar o método de esvaziamento, a memória intermédia do sistema operativo e/s também é descarregada."
  syntax:
    content: public virtual void Flush (bool flushToDisk);
    parameters:
    - id: flushToDisk
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Para esvaziar todas as memórias intermédias de ficheiro intermédio; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.Flush*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)
  id: FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FlushAsync(CancellationToken)
  nameWithType: FileStream.FlushAsync(CancellationToken)
  fullName: System.IO.FileStream.FlushAsync(CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "No modo assíncrono limpa todas as memórias intermédias para este fluxo, faz com que todos os dados colocados em memória intermédia para serem escritos para o dispositivo subjacente e monitoriza os pedidos de cancelamento."
  remarks: "Quando chamar o método FlushAsync, a memória intermédia do sistema operativo e/s também é descarregada.       Se a operação é cancelada antes de concluir, a tarefa devolvida contém o <xref:System.Threading.Tasks.TaskStatus>valor para o <xref:System.Threading.Tasks.Task.Status%2A>propriedade.</xref:System.Threading.Tasks.Task.Status%2A> </xref:System.Threading.Tasks.TaskStatus> Se o identificador do ficheiro for eliminado, a tarefa devolvida contém o <xref:System.ObjectDisposedException>exceção no <xref:System.Threading.Tasks.Task.Exception%2A>propriedade.</xref:System.Threading.Tasks.Task.Exception%2A> </xref:System.ObjectDisposedException>"
  syntax:
    content: public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "O token para monitorizar os pedidos de cancelamento."
    return:
      type: System.Threading.Tasks.Task
      description: "Uma tarefa que representa a operação assíncrona."
  overload: System.IO.FileStream.FlushAsync*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O fluxo foi eliminado."
  platform:
  - net462
- uid: System.IO.FileStream.GetAccessControl
  id: GetAccessControl
  parent: System.IO.FileStream
  langs:
  - csharp
  name: GetAccessControl()
  nameWithType: FileStream.GetAccessControl()
  fullName: System.IO.FileStream.GetAccessControl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Obtém um <xref href=&quot;System.Security.AccessControl.FileSecurity&quot;> </xref> objecto que encapsula as entradas de lista (ACL) de controlo de acesso para o ficheiro descrita através de atual <xref href=&quot;System.IO.FileStream&quot;> </xref> objeto."
  remarks: "Enquanto o <xref:System.IO.FileStream>podem ser utilizados para obter as entradas de lista (ACL) de controlo de acesso de um ficheiro existente, considere a utilização de classe e GetAccessControl <xref:System.IO.File.GetAccessControl%2A?displayProperty=fullName>método, dado que é mais fáceis de utilizar.</xref:System.IO.File.GetAccessControl%2A?displayProperty=fullName> </xref:System.IO.FileStream>       Utilize o método GetAccessControl para obter as entradas de ACL de um ficheiro.       Uma ACL descreve indivíduos e/ou grupos de utilizadores que tenham ou não tem, direitos para as ações específicas sobre o ficheiro. Para obter mais informações, consulte [como: Adicionar ou remover entradas de lista de controlo de acesso](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public System.Security.AccessControl.FileSecurity GetAccessControl ();
    parameters: []
    return:
      type: System.Security.AccessControl.FileSecurity
      description: "Um objeto que contém as definições de controlo de acesso para o ficheiro descrita através de atual <xref href=&quot;System.IO.FileStream&quot;> </xref> objeto."
  overload: System.IO.FileStream.GetAccessControl*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O ficheiro está fechado."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao abrir o ficheiro."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Não foi possível encontrar o ficheiro."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Esta operação não é suportada na plataforma atual.       - ou - o chamador não tem a permissão necessária."
  platform:
  - net462
- uid: System.IO.FileStream.Handle
  id: Handle
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Handle
  nameWithType: FileStream.Handle
  fullName: System.IO.FileStream.Handle
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Obtém um identificador de ficheiro de sistema operativo para o ficheiro atual <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> encapsula do objeto."
  remarks: "Esta propriedade é um identificador de sistema operativo para utilização com as chamadas de sistema operativo-fornecidos pelo sistema (tais como `ReadFile` no Windows). Não irá funcionar com as funções de biblioteca de C esperam um descritor de ficheiros, tais como `fread`.       O identificador de sistema operativo poderá tenham sido aberto forma síncrona ou assíncrona, dependendo `FileStream` construtor foi chamado. Utilize o <xref:System.IO.FileStream.IsAsync%2A>propriedade para detetar se este identificador foi aberto de forma assíncrona.</xref:System.IO.FileStream.IsAsync%2A> O Win32, significa o identificador foi aberto para e/s sobreposta e requer parâmetros diferentes para `ReadFile` e `WriteFile`.      > [!CAUTION] > Danos nos dados poderão ocorrer se um `FileStream` é criada, é passado o respetivo identificador, algumas operações move o ponteiro o identificador de ficheiro e, em seguida, o `FileStream` é utilizado novamente. Vários threads em segurança não é possível escrever no mesmo ficheiro em simultâneo, e `FileStream` memória intermédia de código parte do princípio de que controla exclusivamente o identificador. `FileStream`Pode acionar um <xref:System.IO.IOException>se `FileStream` Deteta que outro processo tem de mover o ponteiro de ficheiro.</xref:System.IO.IOException> Para evitar isto, não escrever todos os dados para uma parte do ficheiro que `FileStream` poderá ter colocado na memória intermédia e restaurar o ponteiro de ficheiro para a localização tinha quando métodos foram chamados pela última vez em `FileStream`."
  syntax:
    content: public virtual IntPtr Handle { get; }
    return:
      type: System.IntPtr
      description: "O identificador de ficheiro de sistema operativo para o ficheiro encapsulado por este <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> objeto ou -1 se o <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> foi fechada."
  overload: System.IO.FileStream.Handle*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  platform:
  - net462
- uid: System.IO.FileStream.IsAsync
  id: IsAsync
  parent: System.IO.FileStream
  langs:
  - csharp
  name: IsAsync
  nameWithType: FileStream.IsAsync
  fullName: System.IO.FileStream.IsAsync
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Obtém um valor que indica se o <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> foi aberto de forma assíncrona ou síncrona."
  remarks: "O `IsAsync` propriedade Deteta se o `FileStream` identificador foi aberto de forma assíncrona, ativar o seu código utilizar o <xref:System.IO.FileStream.Handle%2A>propriedade corretamente.</xref:System.IO.FileStream.Handle%2A> No Win32, `IsAsync` a ser true significa que o identificador foi aberto para e/s sobreposta e, por conseguinte, requer que parâmetros diferentes `ReadFile` e `WriteFile`.       Especificar este valor quando criar uma instância do <xref:System.IO.FileStream>classe utilizando um construtor que tenha um `isAsync`, `useAsync`, ou `options` parâmetro.</xref:System.IO.FileStream> Quando a propriedade é `true`, o fluxo utiliza e/s sobreposta para realizar operações de ficheiros no modo assíncrono. No entanto, a propriedade IsAsync tem de ser `true` para chamar o <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, ou <xref:System.IO.Stream.CopyToAsync%2A>método.</xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A> Quando a propriedade de IsAsync é `false` e chamar a leitura assíncrona e operações de escrita, o thread de IU não ainda é bloqueado, mas a operação de e/s real é executada de forma síncrona."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#2](~/add/codesnippet/csharp/p-system.io.filestream.i_1.cs)]\n [!code-vb[System.IO.FileStream2#2](~/add/codesnippet/visualbasic/p-system.io.filestream.i_1.vb)]\n [!code-cpp[System.IO.FileStream2#2](~/add/codesnippet/cpp/p-system.io.filestream.i_1.cpp)]"
  syntax:
    content: public virtual bool IsAsync { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> foi aberto no modo assíncrono; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.IsAsync*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Length
  id: Length
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Length
  nameWithType: FileStream.Length
  fullName: System.IO.FileStream.Length
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Obtém o comprimento em bytes da sequência."
  remarks: "Para obter uma lista de ficheiros comuns e as operações de diretório, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example uses the `Length` and `Position` properties to check for an end-of-file condition.  \n  \n [!code-cpp[Classic FileStream.Length Example#1](~/add/codesnippet/cpp/p-system.io.filestream.l_1.cpp)]\n [!code-cs[Classic FileStream.Length Example#1](~/add/codesnippet/csharp/p-system.io.filestream.l_1.cs)]\n [!code-vb[Classic FileStream.Length Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.l_1.vb)]"
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "Um valor de tempo que representa o comprimento do fluxo de bytes."
  overload: System.IO.FileStream.Length*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref:System.IO.FileStream.CanSeek*>para este fluxo é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.IO.FileStream.CanSeek*>"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s, tal como o ficheiro ser fechado."
  platform:
  - net462
- uid: System.IO.FileStream.Lock(System.Int64,System.Int64)
  id: Lock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Lock(Int64,Int64)
  nameWithType: FileStream.Lock(Int64,Int64)
  fullName: System.IO.FileStream.Lock(Int64,Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Impede que outros processos de ler a partir de ou escrever o <xref href=&quot;System.IO.FileStream&quot;> </xref>."
  remarks: "Bloqueio de um intervalo de uma sequência de ficheiros fornece os threads do bloqueio acesso exclusivo do processo para esse intervalo do fluxo de ficheiros.       Para obter uma lista de ficheiros comuns e as operações de diretório, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example demonstrates how to lock part of a file so another process cannot access that part of the file even though it has read/write access to the file. Run the program simultaneously in different command windows and investigate using the different console input options.  \n  \n [!code-cs[System.IO.FileStream3#1](~/add/codesnippet/csharp/m-system.io.filestream.l_1.cs)]\n [!code-cpp[System.IO.FileStream3#1](~/add/codesnippet/cpp/m-system.io.filestream.l_1.cpp)]\n [!code-vb[System.IO.FileStream3#1](~/add/codesnippet/visualbasic/m-system.io.filestream.l_1.vb)]"
  syntax:
    content: public virtual void Lock (long position, long length);
    parameters:
    - id: position
      type: System.Int64
      description: "O início do intervalo para bloquear. O valor deste parâmetro tem de ser igual ou maior que zero (0)."
    - id: length
      type: System.Int64
      description: "O intervalo para ser bloqueado."
  overload: System.IO.FileStream.Lock*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>position</code>ou <code>length</code> é negativo."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O ficheiro está fechado."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "O processo não é possível aceder ao ficheiro porque outro processo bloqueou uma parte do ficheiro."
  platform:
  - net462
- uid: System.IO.FileStream.Name
  id: Name
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Name
  nameWithType: FileStream.Name
  fullName: System.IO.FileStream.Name
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Obtém o nome do <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> transmitido a este construtor."
  remarks: "Para obter uma lista de ficheiros comuns e as operações de diretório, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#4](~/add/codesnippet/csharp/p-system.io.filestream.n_1.cs)]\n [!code-vb[System.IO.FileStream2#4](~/add/codesnippet/visualbasic/p-system.io.filestream.n_1.vb)]\n [!code-cpp[System.IO.FileStream2#4](~/add/codesnippet/cpp/p-system.io.filestream.n_1.cpp)]"
  syntax:
    content: public string Name { get; }
    return:
      type: System.String
      description: "A cadeia que é o nome do <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.Name*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Position
  id: Position
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Position
  nameWithType: FileStream.Position
  fullName: System.IO.FileStream.Position
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Obtém ou define a posição actual desta sequência."
  remarks: "Pesquisa para qualquer localização, para além do comprimento do fluxo é suportada.  Quando a procura para além do comprimento do ficheiro, aumenta o tamanho do ficheiro.  No Microsoft Windows NT e mais recente, os dados adicionados ao final do ficheiro estão definidos como zero.  No Microsoft Windows 98 ou anterior, os dados adicionados ao final do ficheiro não estão definidos para zero, o que significa que anteriormente eliminados dados está visível no fluxo. Definir a posição do fluxo de para um valor grande para além do fim do fluxo de Windows 98 ou anterior poderá resultar numa exceção que está a ser gerada.       Para obter uma lista de ficheiros comuns e as operações de diretório, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example uses the `Length` and `Position` properties to check for an end-of-file condition.  \n  \n [!code-cpp[Classic FileStream.Length Example#1](~/add/codesnippet/cpp/p-system.io.filestream.p_1.cpp)]\n [!code-cs[Classic FileStream.Length Example#1](~/add/codesnippet/csharp/p-system.io.filestream.p_1.cs)]\n [!code-vb[Classic FileStream.Length Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.p_1.vb)]"
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "A posição actual desta sequência."
  overload: System.IO.FileStream.Position*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O fluxo não suporta pesquisa."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "An I/O error occurred.  \n  \n \\- or -  \n  \n The position was set to a very large value beyond the end of the stream in Windows 98 or earlier."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Tentativa de definir a posição para um valor negativo."
  - type: System.IO.EndOfStreamException
    commentId: T:System.IO.EndOfStreamException
    description: "Tentativa de procura depois do fim de um fluxo que não suporta esta."
  platform:
  - net462
- uid: System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: FileStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Lê um bloco de bytes do fluxo de e escreve os dados numa memória intermédia fornecida."
  remarks: "Este método substitui <xref:System.IO.Stream.Read%2A>.</xref:System.IO.Stream.Read%2A>       O `offset` parâmetro fornece o deslocamento de byte no `array` (o índice de memória intermédia) no qual pretende começar a ler e o `count` parâmetro indica o número máximo de bytes a ler a partir desta sequência. O valor devolvido é o número real de bytes lidos, ou zero se for atingido o fim da sequência. Se a operação de leitura for bem sucedida, a posição atual do fluxo de avançado pelo número de bytes lidos. Se ocorrer uma exceção, a posição atual do fluxo de permanece inalterada.       O método de leitura devolve zero apenas depois de atingir o fim da sequência. Caso contrário, leitura sempre lê, pelo menos, um bytes da sequência antes de regressar. Se não estão disponíveis dados do fluxo após uma chamada de leitura, o método irá bloquear até, pelo menos, um byte de dados pode ser devolvido. Uma implementação é gratuita devolver menos bytes que o pedido mesmo que não foi atingido o fim do fluxo.       Utilize <xref:System.IO.BinaryReader>para ler os tipos de dados primitivos.</xref:System.IO.BinaryReader>       Não interrompem o thread que está a efetuar uma operação de leitura. Apesar da aplicação pode ser apresentado ser executada com êxito após o thread está desbloqueado, a interrupção pode diminuir o desempenho e a fiabilidade da aplicação.       Para obter uma lista de ficheiros comuns e as operações de diretório, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example reads the contents from a <xref:System.IO.FileStream> and writes it into another <xref:System.IO.FileStream>.  \n  \n [!code-vb[FSRead#1](~/add/codesnippet/visualbasic/m-system.io.filestream.r_1_1.vb)]\n [!code-cs[FSRead#1](~/add/codesnippet/csharp/m-system.io.filestream.r_1_1.cs)]"
  syntax:
    content: public override int Read (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "Quando este método devolve, contém a matriz de bytes especificado com os valores entre `offset` e (`offset`  +  `count` - 1`)` substituído pelos bytes de leitura de origem atual."
    - id: offset
      type: System.Int32
      description: "O deslocamento de byte no `array` em que os bytes de leitura devem ser colocados."
    - id: count
      type: System.Int32
      description: "O número máximo de bytes a ler."
    return:
      type: System.Int32
      description: "O número total de bytes na memória intermédia de leitura. Isto pode ser inferior ao número de bytes se esse número de bytes não está atualmente disponível ou zero se for atingido o fim do fluxo de pedido."
  overload: System.IO.FileStream.Read*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>ou <code>count</code> é negativo."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O fluxo não suporta leitura."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>offset</code>e <code>count</code> descrevem um intervalo inválido no <code>array</code>."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Métodos foram chamados depois do fluxo foi fechado."
  platform:
  - net462
- uid: System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "No modo assíncrono lê uma sequência de bytes do fluxo atual, avança a posição dentro do fluxo de pelo número de bytes lidos e monitoriza os pedidos de cancelamento."
  remarks: "O método ReadAsync permite-lhe efetuar operações de ficheiros de recurso intensivas sem bloquear o thread principal. Este consideração de desempenho é particularmente importante num [!INCLUDE[win8_appname_long](~/add/includes/win8-appname-long-md.md)] aplicação ou [!INCLUDE[desktop_appname](~/add/includes/desktop-appname-md.md)] aplicação onde uma operação morosa fluxo pode bloquear o thread de IU e tornar a sua aplicação são apresentadas como se não está a funcionar. Os métodos assíncronos são utilizados em conjunto com o `async` e `await` palavras-chave no Visual Basic e c#.       Utilize o <xref:System.IO.FileStream.CanRead%2A>propriedade para determinar se a instância atual suporta a leitura.</xref:System.IO.FileStream.CanRead%2A>       Se a operação é cancelada antes de concluir, a tarefa devolvida contém o <xref:System.Threading.Tasks.TaskStatus>valor para o <xref:System.Threading.Tasks.Task.Status%2A>propriedade.</xref:System.Threading.Tasks.Task.Status%2A> </xref:System.Threading.Tasks.TaskStatus> Se o identificador do ficheiro for eliminado, a tarefa devolvida contém o <xref:System.ObjectDisposedException>exceção no <xref:System.Threading.Tasks.Task.Exception%2A>propriedade.</xref:System.Threading.Tasks.Task.Exception%2A> </xref:System.ObjectDisposedException>"
  example:
  - "The following example shows how to read from a file asynchronously.  \n  \n [!code-vb[Asynchronous_File_IO_async#4](~/add/codesnippet/visualbasic/9c5ba435-5f90-4f89-b415-_1.vb)]\n [!code-cs[Asynchronous_File_IO_async#4](~/add/codesnippet/csharp/9c5ba435-5f90-4f89-b415-_1.cs)]"
  syntax:
    content: public override System.Threading.Tasks.Task<int> ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "A memória intermédia para escrever dados no."
    - id: offset
      type: System.Int32
      description: "O deslocamento de byte no `buffer` no qual pretende iniciar a escrita de dados da sequência."
    - id: count
      type: System.Int32
      description: "O número máximo de bytes a ler."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "O token para monitorizar os pedidos de cancelamento."
    return:
      type: System.Threading.Tasks.Task{System.Int32}
      description: "Operação de leitura de uma tarefa que representa o assíncrona. O valor da <code> TResult </code> parâmetro contém o número total de bytes na memória intermédia de leitura. O valor de resultados pode ser inferior ao número de bytes se o número de bytes atualmente disponíveis é inferior ao número pedido ou pode ser 0 (zero) se foi atingido o fim do fluxo de pedido."
  overload: System.IO.FileStream.ReadAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>ou <code>count</code> é negativo."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "A soma de <code> offset </code> e <code> count </code> é maior do que o comprimento da memória intermédia."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O fluxo não suporta leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O fluxo foi eliminado."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O fluxo está a ser utilizado por uma operação de leitura anterior."
  platform:
  - net462
- uid: System.IO.FileStream.ReadByte
  id: ReadByte
  parent: System.IO.FileStream
  langs:
  - csharp
  name: ReadByte()
  nameWithType: FileStream.ReadByte()
  fullName: System.IO.FileStream.ReadByte()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Lê um byte do ficheiro e avança o uma byte posição de leitura."
  remarks: "Este método substitui <xref:System.IO.Stream.ReadByte%2A>.</xref:System.IO.Stream.ReadByte%2A>      > [!NOTE] > Utilize o <xref:System.IO.FileStream.CanRead%2A>propriedade para determinar se a instância atual suporta a leitura.</xref:System.IO.FileStream.CanRead%2A> Para obter mais informações, consulte <xref:System.IO.Stream.CanRead%2A>.</xref:System.IO.Stream.CanRead%2A>"
  example:
  - "The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.r_0_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.r_0_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.r_0_1.cpp)]"
  syntax:
    content: public override int ReadByte ();
    parameters: []
    return:
      type: System.Int32
      description: "O byte, converter para um <xref:System.Int32>, ou -1 se foi atingido o fim do fluxo.</xref:System.Int32>"
  overload: System.IO.FileStream.ReadByte*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O fluxo actual não suporta leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O fluxo actual foi fechado."
  platform:
  - net462
- uid: System.IO.FileStream.SafeFileHandle
  id: SafeFileHandle
  parent: System.IO.FileStream
  langs:
  - csharp
  name: SafeFileHandle
  nameWithType: FileStream.SafeFileHandle
  fullName: System.IO.FileStream.SafeFileHandle
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Obtém um <xref href=&quot;Microsoft.Win32.SafeHandles.SafeFileHandle&quot;> </xref> objeto que representa o identificador de ficheiro de sistema operativo para o ficheiro que atual <xref href=&quot;System.IO.FileStream&quot;> </xref> encapsula do objeto."
  remarks: "A propriedade SafeFileHandle automaticamente esvaziamentos da sequência e define a posição de fluxo actual para 0.  Isto permite que o ficheiro ser movidos ou a posição de fluxo a reposição por outro fluxo utilizando o SafeFileHandle devolvido por esta propriedade."
  syntax:
    content: public virtual Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }
    return:
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "Um objecto que representa o identificador de ficheiro de sistema operativo para o ficheiro que atual <xref href=&quot;System.IO.FileStream&quot;> </xref> encapsula do objeto."
  overload: System.IO.FileStream.SafeFileHandle*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: FileStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.FileStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Define a posição actual desta sequência para o valor indicado."
  remarks: "Este método substitui <xref:System.IO.Stream.Seek%2A?displayProperty=fullName>.</xref:System.IO.Stream.Seek%2A?displayProperty=fullName>      > [!NOTE] > Utilize o <xref:System.IO.FileStream.CanSeek%2A?displayProperty=fullName>propriedade para determinar se a instância atual suporta a pesquisa.</xref:System.IO.FileStream.CanSeek%2A?displayProperty=fullName> Para obter mais informações, consulte <xref:System.IO.Stream.CanSeek%2A?displayProperty=fullName>.</xref:System.IO.Stream.CanSeek%2A?displayProperty=fullName>       Pode procurar em qualquer localização, para além do comprimento do fluxo. Quando a procura para além do comprimento do ficheiro, aumenta o tamanho do ficheiro. No Windows NT e versões posteriores, os dados adicionados ao fim do ficheiro estão definidos como zero. No Windows 98 ou versões anteriores, os dados adicionados ao fim do ficheiro de mensagens em fila não estão definidos como zero, o que significa que anteriormente eliminados dados está visível no fluxo.       Para obter uma lista de ficheiros comuns e as operações de diretório, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.s_1_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.s_1_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.s_1_1.cpp)]  \n  \n The following example reads text in the reverse direction, from the end of file to the beginning of the file, by using the various <xref:System.IO.SeekOrigin> values with the Seek method.  \n  \n [!code-vb[System.IO.FileStream.Seek#1](~/add/codesnippet/visualbasic/m-system.io.filestream.s_1_2.vb)]\n [!code-cs[System.IO.FileStream.Seek#1](~/add/codesnippet/csharp/m-system.io.filestream.s_1_2.cs)]"
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin origin);
    parameters:
    - id: offset
      type: System.Int64
      description: "O ponto de relativa `origin` partir do qual iniciar a pesquisa."
    - id: origin
      type: System.IO.SeekOrigin
      description: "Especifica o início, final ou a posição atual como um ponto de referência para `offset`, utilizando um valor de tipo <xref:System.IO.SeekOrigin>.</xref:System.IO.SeekOrigin>"
    return:
      type: System.Int64
      description: "Nova posição na sequência."
  overload: System.IO.FileStream.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O fluxo não suporta a pesquisa, por exemplo, se o <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> construídas a partir de uma saída de pipe ou a consola."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Pesquisa é tentada antes do início da sequência."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Métodos foram chamados depois do fluxo foi fechado."
  platform:
  - net462
- uid: System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)
  id: SetAccessControl(System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: SetAccessControl(FileSecurity)
  nameWithType: FileStream.SetAccessControl(FileSecurity)
  fullName: System.IO.FileStream.SetAccessControl(FileSecurity)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Aplica-se entradas de lista (ACL) de controlo de acesso descritas através de um <xref href=&quot;System.Security.AccessControl.FileSecurity&quot;> </xref> objeto para o ficheiro descrito através de atual <xref href=&quot;System.IO.FileStream&quot;> </xref> objeto."
  remarks: "Enquanto o <xref:System.IO.FileStream>classe e SetAccessControl pode ser utilizado num ficheiro existente, considere utilizar o <xref:System.IO.File.SetAccessControl%2A?displayProperty=fullName>método dado que é mais fáceis de utilizar.</xref:System.IO.File.SetAccessControl%2A?displayProperty=fullName> </xref:System.IO.FileStream>       O método SetAccessControl aplica-se entradas de lista (ACL) de controlo de acesso a um ficheiro que representa a lista ACL noninherited.      > [!CAUTION] > A ACL especificado para o `fileSecurity` parâmetro substitui a ACL existente para o ficheiro. Para adicionar permissões para um novo utilizador, utilize o <xref:System.IO.FileStream.GetAccessControl%2A>método para obter a ACL existente, modificá-lo e, em seguida, utilize SetAccessControl para aplicá-la novamente para o ficheiro.</xref:System.IO.FileStream.GetAccessControl%2A>       Uma ACL descreve indivíduos e/ou grupos de utilizadores que tenham ou não tem, direitos para as ações específicas sobre o ficheiro. Para obter mais informações, consulte [como: Adicionar ou remover entradas de lista de controlo de acesso](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "Um objeto que descreve uma entrada ACL para aplicar o ficheiro atual."
  overload: System.IO.FileStream.SetAccessControl*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O ficheiro está fechado."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>fileSecurity</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "O ficheiro não foi encontrado ou modificado."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "O processo atual não tem acesso para abrir o ficheiro."
  platform:
  - net462
- uid: System.IO.FileStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: FileStream.SetLength(Int64)
  fullName: System.IO.FileStream.SetLength(Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Define o comprimento desta sequência para o valor indicado."
  remarks: "Este método substitui <xref:System.IO.Stream.SetLength%2A>.</xref:System.IO.Stream.SetLength%2A>       Se o valor indicado é inferior ao comprimento atual da transmissão em fluxo, o fluxo é truncado. Neste cenário, se a posição atual é superior ao comprimento novo, é movida a posição atual até ao último byte da transmissão em fluxo. Se o valor especificado é maior do que o comprimento do fluxo de atual, o fluxo é expandido e a posição actual permanece igual. Se o fluxo está expandido, o conteúdo da transmissão em fluxo entre o antigo e o comprimento do novo é indefinido.       Tem de suportar uma sequência de escrita e pesquisa para `SetLength` funcione.      > [!NOTE] > Utilize o <xref:System.IO.FileStream.CanWrite%2A>propriedade para determinar se a instância atual suporta a escrita e o <xref:System.IO.FileStream.CanSeek%2A>propriedade para determinar se a pesquisa é suportada.</xref:System.IO.FileStream.CanSeek%2A> </xref:System.IO.FileStream.CanWrite%2A> Para obter mais informações, consulte <xref:System.IO.Stream.CanWrite%2A>e <xref:System.IO.Stream.CanSeek%2A>.</xref:System.IO.Stream.CanSeek%2A> </xref:System.IO.Stream.CanWrite%2A>       Para obter uma lista de ficheiros comuns e as operações de diretório, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "O comprimento do novo da transmissão em fluxo."
  overload: System.IO.FileStream.SetLength*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O fluxo não suporta o escrita e pesquisa."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Tentou definir o <code> value </code> parâmetro inferior a 0."
  platform:
  - net462
- uid: System.IO.FileStream.Unlock(System.Int64,System.Int64)
  id: Unlock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Unlock(Int64,Int64)
  nameWithType: FileStream.Unlock(Int64,Int64)
  fullName: System.IO.FileStream.Unlock(Int64,Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Permite o acesso por outros processos a totalidade ou parte de um ficheiro que anteriormente estava bloqueado."
  remarks: "Para obter uma lista de ficheiros comuns e as operações de diretório, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example demonstrates how to lock part of a file so another process cannot access that part of the file even though it has read/write access to the file, and then unlock the specified part of the file . Run the program simultaneously in different command windows and investigate using the different console input options.  \n  \n [!code-cs[System.IO.FileStream3#1](~/add/codesnippet/csharp/m-system.io.filestream.u_1.cs)]\n [!code-cpp[System.IO.FileStream3#1](~/add/codesnippet/cpp/m-system.io.filestream.u_1.cpp)]\n [!code-vb[System.IO.FileStream3#1](~/add/codesnippet/visualbasic/m-system.io.filestream.u_1.vb)]"
  syntax:
    content: public virtual void Unlock (long position, long length);
    parameters:
    - id: position
      type: System.Int64
      description: "O início do intervalo para o desbloquear."
    - id: length
      type: System.Int64
      description: "O intervalo para ser desbloqueada."
  overload: System.IO.FileStream.Unlock*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>position</code>ou <code>length</code> é negativo."
  platform:
  - net462
- uid: System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: FileStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Escreve um bloco de bytes no fluxo de ficheiros."
  remarks: "Este método substitui <xref:System.IO.Stream.Write%2A>.</xref:System.IO.Stream.Write%2A>       O `offset` parâmetro fornece o deslocamento de byte no `array` (o índice de memória intermédia) no qual pretende começar a copiar e o `count` parâmetro indica o número de bytes que serão escritos no fluxo. Se a operação de escrita for bem sucedida, a posição atual do fluxo de avançado pelo número de bytes escritos. Se ocorrer uma exceção, a posição atual do fluxo de permanece inalterada.      > [!NOTE] > Utilize o <xref:System.IO.FileStream.CanWrite%2A>propriedade para determinar se a instância atual suporta escrita.</xref:System.IO.FileStream.CanWrite%2A> Para obter mais informações, consulte <xref:System.IO.Stream.CanWrite%2A>.</xref:System.IO.Stream.CanWrite%2A>       Não interrompem o thread que está a efetuar uma operação de escrita. Apesar da aplicação pode ser apresentado ser executada com êxito após o thread está desbloqueado, a interrupção pode diminuir o desempenho e a fiabilidade da aplicação.       Para obter uma lista de ficheiros comuns e as operações de diretório, consulte [tarefas comuns de e/s](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.  \n  \n [!code-cs[System.IO.FileStream3#3](~/add/codesnippet/csharp/m-system.io.filestream.w_1_1.cs)]\n [!code-cpp[System.IO.FileStream3#3](~/add/codesnippet/cpp/m-system.io.filestream.w_1_1.cpp)]\n [!code-vb[System.IO.FileStream3#3](~/add/codesnippet/visualbasic/m-system.io.filestream.w_1_1.vb)]"
  syntax:
    content: public override void Write (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "A memória intermédia que contém os dados para escrever no fluxo."
    - id: offset
      type: System.Int32
      description: "O deslocamento de byte baseado em zero no `array` partir do qual iniciar copiar bytes no fluxo."
    - id: count
      type: System.Int32
      description: "O número máximo de bytes para escrita."
  overload: System.IO.FileStream.Write*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>offset</code>e <code>count</code> descrevem um intervalo inválido no <code>array</code>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>ou <code>count</code> é negativo."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "An I/O error occurred.  \n  \n \\- or -  \n  \n Another thread may have caused an unexpected change in the position of the operating system's file handle."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O fluxo está fechado."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A instância de fluxo actual não suporta escrita."
  platform:
  - net462
- uid: System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "No modo assíncrono escreve uma sequência de bytes no fluxo atual, avança a posição atual neste fluxo pelo número de bytes escritos e monitoriza os pedidos de cancelamento."
  remarks: "O método WriteAsync permite-lhe efetuar operações de ficheiros de recurso intensivas sem bloquear o thread principal. Este consideração de desempenho é particularmente importante num [!INCLUDE[win8_appname_long](~/add/includes/win8-appname-long-md.md)] aplicação ou [!INCLUDE[desktop_appname](~/add/includes/desktop-appname-md.md)] aplicação onde uma operação morosa fluxo pode bloquear o thread de IU e tornar a sua aplicação são apresentadas como se não está a funcionar. Os métodos assíncronos são utilizados em conjunto com o `async` e `await` palavras-chave no Visual Basic e c#.       Utilize o <xref:System.IO.FileStream.CanWrite%2A>propriedade para determinar se a instância atual suporta a leitura.</xref:System.IO.FileStream.CanWrite%2A>       Se a operação é cancelada antes de concluir, a tarefa devolvida contém o <xref:System.Threading.Tasks.TaskStatus>valor para o <xref:System.Threading.Tasks.Task.Status%2A>propriedade.</xref:System.Threading.Tasks.Task.Status%2A> </xref:System.Threading.Tasks.TaskStatus> Se o identificador do ficheiro for eliminado, a tarefa devolvida contém o <xref:System.ObjectDisposedException>exceção no <xref:System.Threading.Tasks.Task.Exception%2A>propriedade.</xref:System.Threading.Tasks.Task.Exception%2A> </xref:System.ObjectDisposedException>"
  example:
  - "The following example shows how to write asynchronously to a file.  \n  \n [!code-vb[Asynchronous_File_IO_async#3](~/add/codesnippet/visualbasic/7726d527-d678-42ba-9864-_1.vb)]\n [!code-cs[Asynchronous_File_IO_async#3](~/add/codesnippet/csharp/7726d527-d678-42ba-9864-_1.cs)]"
  syntax:
    content: public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "A memória intermédia para escrever dados a partir de."
    - id: offset
      type: System.Int32
      description: "O deslocamento de byte baseado em zero no `buffer` partir do qual iniciar copiar bytes no fluxo."
    - id: count
      type: System.Int32
      description: "O número máximo de bytes para escrita."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "O token para monitorizar os pedidos de cancelamento."
    return:
      type: System.Threading.Tasks.Task
      description: "Uma tarefa que representa a operação de escrita assíncrona."
  overload: System.IO.FileStream.WriteAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>ou <code>count</code> é negativo."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "A soma de <code> offset </code> e <code> count </code> é maior do que o comprimento da memória intermédia."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O fluxo não suporta escrita."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O fluxo foi eliminado."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O fluxo está a ser utilizado por uma operação de escrita anterior."
  platform:
  - net462
- uid: System.IO.FileStream.WriteByte(System.Byte)
  id: WriteByte(System.Byte)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: WriteByte(Byte)
  nameWithType: FileStream.WriteByte(Byte)
  fullName: System.IO.FileStream.WriteByte(Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Escreve um byte a posição atual no fluxo de ficheiros."
  remarks: "Este método substitui <xref:System.IO.Stream.WriteByte%2A>.</xref:System.IO.Stream.WriteByte%2A>       Utilize `WriteByte` para escrever um byte para um `FileStream` forma eficiente. Se o fluxo está fechado ou não gravável, será emitida uma exceção.      > [!NOTE] > Utilize o <xref:System.IO.FileStream.CanWrite%2A>propriedade para determinar se a instância atual suporta escrita.</xref:System.IO.FileStream.CanWrite%2A> Para obter mais informações, consulte <xref:System.IO.Stream.CanWrite%2A>.</xref:System.IO.Stream.CanWrite%2A>"
  example:
  - "The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.w_0_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.w_0_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.w_0_1.cpp)]"
  syntax:
    content: public override void WriteByte (byte value);
    parameters:
    - id: value
      type: System.Byte
      description: "Um byte para escrever no fluxo."
  overload: System.IO.FileStream.WriteByte*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O fluxo está fechado."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O fluxo não suporta escrita."
  platform:
  - net462
references:
- uid: System.IO.Stream
  isExternal: false
  name: System.IO.Stream
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.DirectoryNotFoundException
  isExternal: true
  name: System.IO.DirectoryNotFoundException
- uid: System.IO.PathTooLongException
  isExternal: true
  name: System.IO.PathTooLongException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.SystemException
  parent: System
  isExternal: false
  name: SystemException
  nameWithType: SystemException
  fullName: System.SystemException
- uid: System.IO.EndOfStreamException
  isExternal: true
  name: System.IO.EndOfStreamException
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(SafeFileHandle,FileAccess)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess)
- uid: Microsoft.Win32.SafeHandles.SafeFileHandle
  parent: Microsoft.Win32.SafeHandles
  isExternal: false
  name: SafeFileHandle
  nameWithType: SafeFileHandle
  fullName: Microsoft.Win32.SafeHandles.SafeFileHandle
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess)
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode)
  nameWithType: FileStream.FileStream(String,FileMode)
  fullName: System.IO.FileStream.FileStream(String,FileMode)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.IO.FileMode
  parent: System.IO
  isExternal: false
  name: FileMode
  nameWithType: FileMode
  fullName: System.IO.FileMode
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(SafeFileHandle,FileAccess,Int32)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess)
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess,Boolean,Int32)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare)
- uid: System.IO.FileShare
  parent: System.IO
  isExternal: false
  name: FileShare
  nameWithType: FileShare
  fullName: System.IO.FileShare
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
- uid: System.IO.FileOptions
  parent: System.IO
  isExternal: false
  name: FileOptions
  nameWithType: FileOptions
  fullName: System.IO.FileOptions
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
- uid: System.Security.AccessControl.FileSystemRights
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSystemRights
  nameWithType: FileSystemRights
  fullName: System.Security.AccessControl.FileSystemRights
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
- uid: System.Security.AccessControl.FileSecurity
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSecurity
  nameWithType: FileSecurity
  fullName: System.Security.AccessControl.FileSecurity
- uid: System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  isExternal: false
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  isExternal: false
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IO.FileStream.CanRead
  parent: System.IO.FileStream
  isExternal: false
  name: CanRead
  nameWithType: FileStream.CanRead
  fullName: System.IO.FileStream.CanRead
- uid: System.IO.FileStream.CanSeek
  parent: System.IO.FileStream
  isExternal: false
  name: CanSeek
  nameWithType: FileStream.CanSeek
  fullName: System.IO.FileStream.CanSeek
- uid: System.IO.FileStream.CanWrite
  parent: System.IO.FileStream
  isExternal: false
  name: CanWrite
  nameWithType: FileStream.CanWrite
  fullName: System.IO.FileStream.CanWrite
- uid: System.IO.FileStream.Dispose(System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: FileStream.Dispose(Boolean)
  fullName: System.IO.FileStream.Dispose(Boolean)
- uid: System.IO.FileStream.EndRead(System.IAsyncResult)
  parent: System.IO.FileStream
  isExternal: false
  name: EndRead(IAsyncResult)
  nameWithType: FileStream.EndRead(IAsyncResult)
  fullName: System.IO.FileStream.EndRead(IAsyncResult)
- uid: System.IO.FileStream.EndWrite(System.IAsyncResult)
  parent: System.IO.FileStream
  isExternal: false
  name: EndWrite(IAsyncResult)
  nameWithType: FileStream.EndWrite(IAsyncResult)
  fullName: System.IO.FileStream.EndWrite(IAsyncResult)
- uid: System.IO.FileStream.Finalize
  parent: System.IO.FileStream
  isExternal: false
  name: Finalize()
  nameWithType: FileStream.Finalize()
  fullName: System.IO.FileStream.Finalize()
- uid: System.IO.FileStream.Flush
  parent: System.IO.FileStream
  isExternal: false
  name: Flush()
  nameWithType: FileStream.Flush()
  fullName: System.IO.FileStream.Flush()
- uid: System.IO.FileStream.Flush(System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: Flush(Boolean)
  nameWithType: FileStream.Flush(Boolean)
  fullName: System.IO.FileStream.Flush(Boolean)
- uid: System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.FileStream
  isExternal: false
  name: FlushAsync(CancellationToken)
  nameWithType: FileStream.FlushAsync(CancellationToken)
  fullName: System.IO.FileStream.FlushAsync(CancellationToken)
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.IO.FileStream.GetAccessControl
  parent: System.IO.FileStream
  isExternal: false
  name: GetAccessControl()
  nameWithType: FileStream.GetAccessControl()
  fullName: System.IO.FileStream.GetAccessControl()
- uid: System.IO.FileStream.Handle
  parent: System.IO.FileStream
  isExternal: false
  name: Handle
  nameWithType: FileStream.Handle
  fullName: System.IO.FileStream.Handle
- uid: System.IO.FileStream.IsAsync
  parent: System.IO.FileStream
  isExternal: false
  name: IsAsync
  nameWithType: FileStream.IsAsync
  fullName: System.IO.FileStream.IsAsync
- uid: System.IO.FileStream.Length
  parent: System.IO.FileStream
  isExternal: false
  name: Length
  nameWithType: FileStream.Length
  fullName: System.IO.FileStream.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.FileStream.Lock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  isExternal: false
  name: Lock(Int64,Int64)
  nameWithType: FileStream.Lock(Int64,Int64)
  fullName: System.IO.FileStream.Lock(Int64,Int64)
- uid: System.IO.FileStream.Name
  parent: System.IO.FileStream
  isExternal: false
  name: Name
  nameWithType: FileStream.Name
  fullName: System.IO.FileStream.Name
- uid: System.IO.FileStream.Position
  parent: System.IO.FileStream
  isExternal: false
  name: Position
  nameWithType: FileStream.Position
  fullName: System.IO.FileStream.Position
- uid: System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: FileStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Read(Byte[],Int32,Int32)
- uid: System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  isExternal: false
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.Threading.Tasks.Task{System.Int32}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<Int32>
  nameWithType: Task<Int32>
  fullName: System.Threading.Tasks.Task<System.Int32>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Int32>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.FileStream.ReadByte
  parent: System.IO.FileStream
  isExternal: false
  name: ReadByte()
  nameWithType: FileStream.ReadByte()
  fullName: System.IO.FileStream.ReadByte()
- uid: System.IO.FileStream.SafeFileHandle
  parent: System.IO.FileStream
  isExternal: false
  name: SafeFileHandle
  nameWithType: FileStream.SafeFileHandle
  fullName: System.IO.FileStream.SafeFileHandle
- uid: System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.FileStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: FileStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.FileStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileStream
  isExternal: false
  name: SetAccessControl(FileSecurity)
  nameWithType: FileStream.SetAccessControl(FileSecurity)
  fullName: System.IO.FileStream.SetAccessControl(FileSecurity)
- uid: System.IO.FileStream.SetLength(System.Int64)
  parent: System.IO.FileStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: FileStream.SetLength(Int64)
  fullName: System.IO.FileStream.SetLength(Int64)
- uid: System.IO.FileStream.Unlock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  isExternal: false
  name: Unlock(Int64,Int64)
  nameWithType: FileStream.Unlock(Int64,Int64)
  fullName: System.IO.FileStream.Unlock(Int64,Int64)
- uid: System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: FileStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Write(Byte[],Int32,Int32)
- uid: System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  isExternal: false
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.IO.FileStream.WriteByte(System.Byte)
  parent: System.IO.FileStream
  isExternal: false
  name: WriteByte(Byte)
  nameWithType: FileStream.WriteByte(Byte)
  fullName: System.IO.FileStream.WriteByte(Byte)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.IO.FileStream.#ctor*
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream
  nameWithType: FileStream.FileStream
- uid: System.IO.FileStream.BeginRead*
  parent: System.IO.FileStream
  isExternal: false
  name: BeginRead
  nameWithType: FileStream.BeginRead
- uid: System.IO.FileStream.BeginWrite*
  parent: System.IO.FileStream
  isExternal: false
  name: BeginWrite
  nameWithType: FileStream.BeginWrite
- uid: System.IO.FileStream.CanRead*
  parent: System.IO.FileStream
  isExternal: false
  name: CanRead
  nameWithType: FileStream.CanRead
- uid: System.IO.FileStream.CanSeek*
  parent: System.IO.FileStream
  isExternal: false
  name: CanSeek
  nameWithType: FileStream.CanSeek
- uid: System.IO.FileStream.CanWrite*
  parent: System.IO.FileStream
  isExternal: false
  name: CanWrite
  nameWithType: FileStream.CanWrite
- uid: System.IO.FileStream.Dispose*
  parent: System.IO.FileStream
  isExternal: false
  name: Dispose
  nameWithType: FileStream.Dispose
- uid: System.IO.FileStream.EndRead*
  parent: System.IO.FileStream
  isExternal: false
  name: EndRead
  nameWithType: FileStream.EndRead
- uid: System.IO.FileStream.EndWrite*
  parent: System.IO.FileStream
  isExternal: false
  name: EndWrite
  nameWithType: FileStream.EndWrite
- uid: System.IO.FileStream.Finalize*
  parent: System.IO.FileStream
  isExternal: false
  name: Finalize
  nameWithType: FileStream.Finalize
- uid: System.IO.FileStream.Flush*
  parent: System.IO.FileStream
  isExternal: false
  name: Flush
  nameWithType: FileStream.Flush
- uid: System.IO.FileStream.FlushAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: FlushAsync
  nameWithType: FileStream.FlushAsync
- uid: System.IO.FileStream.GetAccessControl*
  parent: System.IO.FileStream
  isExternal: false
  name: GetAccessControl
  nameWithType: FileStream.GetAccessControl
- uid: System.IO.FileStream.Handle*
  parent: System.IO.FileStream
  isExternal: false
  name: Handle
  nameWithType: FileStream.Handle
- uid: System.IO.FileStream.IsAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: IsAsync
  nameWithType: FileStream.IsAsync
- uid: System.IO.FileStream.Length*
  parent: System.IO.FileStream
  isExternal: false
  name: Length
  nameWithType: FileStream.Length
- uid: System.IO.FileStream.Lock*
  parent: System.IO.FileStream
  isExternal: false
  name: Lock
  nameWithType: FileStream.Lock
- uid: System.IO.FileStream.Name*
  parent: System.IO.FileStream
  isExternal: false
  name: Name
  nameWithType: FileStream.Name
- uid: System.IO.FileStream.Position*
  parent: System.IO.FileStream
  isExternal: false
  name: Position
  nameWithType: FileStream.Position
- uid: System.IO.FileStream.Read*
  parent: System.IO.FileStream
  isExternal: false
  name: Read
  nameWithType: FileStream.Read
- uid: System.IO.FileStream.ReadAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: ReadAsync
  nameWithType: FileStream.ReadAsync
- uid: System.IO.FileStream.ReadByte*
  parent: System.IO.FileStream
  isExternal: false
  name: ReadByte
  nameWithType: FileStream.ReadByte
- uid: System.IO.FileStream.SafeFileHandle*
  parent: System.IO.FileStream
  isExternal: false
  name: SafeFileHandle
  nameWithType: FileStream.SafeFileHandle
- uid: System.IO.FileStream.Seek*
  parent: System.IO.FileStream
  isExternal: false
  name: Seek
  nameWithType: FileStream.Seek
- uid: System.IO.FileStream.SetAccessControl*
  parent: System.IO.FileStream
  isExternal: false
  name: SetAccessControl
  nameWithType: FileStream.SetAccessControl
- uid: System.IO.FileStream.SetLength*
  parent: System.IO.FileStream
  isExternal: false
  name: SetLength
  nameWithType: FileStream.SetLength
- uid: System.IO.FileStream.Unlock*
  parent: System.IO.FileStream
  isExternal: false
  name: Unlock
  nameWithType: FileStream.Unlock
- uid: System.IO.FileStream.Write*
  parent: System.IO.FileStream
  isExternal: false
  name: Write
  nameWithType: FileStream.Write
- uid: System.IO.FileStream.WriteAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: WriteAsync
  nameWithType: FileStream.WriteAsync
- uid: System.IO.FileStream.WriteByte*
  parent: System.IO.FileStream
  isExternal: false
  name: WriteByte
  nameWithType: FileStream.WriteByte
