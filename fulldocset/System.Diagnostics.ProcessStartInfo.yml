### YamlMime:ManagedReference
items:
- uid: System.Diagnostics.ProcessStartInfo
  id: ProcessStartInfo
  children:
  - System.Diagnostics.ProcessStartInfo.#ctor
  - System.Diagnostics.ProcessStartInfo.#ctor(System.String)
  - System.Diagnostics.ProcessStartInfo.#ctor(System.String,System.String)
  - System.Diagnostics.ProcessStartInfo.Arguments
  - System.Diagnostics.ProcessStartInfo.CreateNoWindow
  - System.Diagnostics.ProcessStartInfo.Domain
  - System.Diagnostics.ProcessStartInfo.Environment
  - System.Diagnostics.ProcessStartInfo.EnvironmentVariables
  - System.Diagnostics.ProcessStartInfo.ErrorDialog
  - System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle
  - System.Diagnostics.ProcessStartInfo.FileName
  - System.Diagnostics.ProcessStartInfo.LoadUserProfile
  - System.Diagnostics.ProcessStartInfo.Password
  - System.Diagnostics.ProcessStartInfo.PasswordInClearText
  - System.Diagnostics.ProcessStartInfo.RedirectStandardError
  - System.Diagnostics.ProcessStartInfo.RedirectStandardInput
  - System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
  - System.Diagnostics.ProcessStartInfo.StandardErrorEncoding
  - System.Diagnostics.ProcessStartInfo.StandardOutputEncoding
  - System.Diagnostics.ProcessStartInfo.UserName
  - System.Diagnostics.ProcessStartInfo.UseShellExecute
  - System.Diagnostics.ProcessStartInfo.Verb
  - System.Diagnostics.ProcessStartInfo.Verbs
  - System.Diagnostics.ProcessStartInfo.WindowStyle
  - System.Diagnostics.ProcessStartInfo.WorkingDirectory
  langs:
  - csharp
  name: ProcessStartInfo
  nameWithType: ProcessStartInfo
  fullName: System.Diagnostics.ProcessStartInfo
  type: Class
  summary: "Especifica um conjunto de valores que são utilizadas ao iniciar um processo."
  remarks: "ProcessStartInfo é utilizado em conjunto com o <xref:System.Diagnostics.Process>componente.</xref:System.Diagnostics.Process> Quando inicia um processo utilizando o <xref:System.Diagnostics.Process>classe, tem acesso ao processar as informações disponíveis disso que, ao anexar a um processo em execução.</xref:System.Diagnostics.Process>       Pode utilizar a classe de ProcessStartInfo para melhorar o controlo sobre o processo de que iniciar. Tem de definir, pelo menos, o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>propriedade, manualmente ou utilizar o construtor.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> O nome de ficheiro é qualquer aplicação ou documento. Aqui um documento está definido para ser de qualquer tipo de ficheiro que tenha um open ou default ação associada. Pode ver os tipos de ficheiros registada e as respetivas aplicações associadas para o seu computador através de **opções de pastas** caixa de diálogo, que está disponível através do sistema operativo. O **avançadas** botão conduz a uma caixa de diálogo que mostra se houver uma ação aberta associada um tipo específico de ficheiros registada.       Além disso, pode definir outras propriedades que definem as ações a fazer com que o ficheiro. Pode especificar um valor específico para o tipo do <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>propriedade para o <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>propriedade.</xref:System.Diagnostics.ProcessStartInfo.Verb%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Por exemplo, pode especificar &quot;imprimir&quot; para um tipo de documento. Além disso, pode especificar <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>valores de propriedade para ser argumentos da linha de comandos transmitidos para o procedimento de abrir o ficheiro.</xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> Por exemplo, se especificar uma aplicação do editor de texto no <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>propriedade, pode utilizar o <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>propriedade para especificar um ficheiro de texto para ser aberto pelo editor.</xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A>       Entrada padrão é normalmente o teclado e saída padrão e o erro padrão são, normalmente, o ecrã do monitor. No entanto, pode utilizar o <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A>, <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A>, e <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A>Propriedades para fazer com que o processo para obter a entrada de ou voltar a saída para um ficheiro ou outro dispositivo.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> </xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> </xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A> Se utilizar o <xref:System.Diagnostics.Process.StandardInput%2A>, <xref:System.Diagnostics.Process.StandardOutput%2A>, ou <xref:System.Diagnostics.Process.StandardError%2A>Propriedades no <xref:System.Diagnostics.Process>componente, tem primeiro de definir o valor correspondente na propriedade ProcessStartInfo.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardError%2A> </xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process.StandardInput%2A> Caso contrário, o sistema emite uma exceção ao ler ou escrever no fluxo.       Definir <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>para especificar se pretende iniciar o processo utilizando a shell do sistema operativo.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>       Pode alterar o valor da propriedade qualquer ProcessStartInfo até à hora que o processo é iniciado. Depois de iniciar o processo, alterar estes valores não tem qualquer efeito.      > [!NOTE] > Esta classe contém um pedido de ligação ao nível da classe que se aplica a todos os membros. A <xref:System.Security.SecurityException>é acionada quando o chamador imediato não tem permissão de fidedignidade total.</xref:System.Security.SecurityException> Para obter detalhes sobre as exigências de segurança, consulte [exigências de ligação](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example demonstrates how to use the ProcessStartInfo class to start Internet Explorer, providing the destination URLs as ProcessStartInfo arguments.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/t-system.diagnostics.pro_2_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/t-system.diagnostics.pro_2_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/t-system.diagnostics.pro_2_1.cpp)]"
  syntax:
    content: >-
      [System.ComponentModel.TypeConverter(typeof(System.ComponentModel.ExpandableObjectConverter))]

      public sealed class ProcessStartInfo
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.#ctor
  id: '#ctor'
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: ProcessStartInfo()
  nameWithType: ProcessStartInfo.ProcessStartInfo()
  fullName: System.Diagnostics.ProcessStartInfo.ProcessStartInfo()
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;> </xref> classe sem especificar um nome de ficheiro com a qual pretende iniciar o processo."
  remarks: "Tem de definir, pelo menos, o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>propriedade antes de iniciar o processo.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> O nome de ficheiro é qualquer aplicação ou documento. Neste caso, um documento está definido para ser de qualquer tipo de ficheiro que tenha um open ou default ação associada. Pode ver os tipos de ficheiros registada e as respetivas aplicações associadas para o seu computador através de **opções de pastas** caixa de diálogo, que está disponível através do sistema operativo. O **avançadas** botão conduz a uma caixa de diálogo que mostra se houver uma ação aberta associada um tipo específico de ficheiros registada.       Opcionalmente, também pode definir outras propriedades antes de iniciar o processo. O <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>propriedade fornece ações, como &quot;print&quot;, com o ficheiro indicado a <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>propriedade.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.ProcessStartInfo.Verb%2A> A <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>propriedade fornece uma forma para passar os argumentos da linha de comandos para o ficheiro quando o sistema abre o mesmo.</xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>"
  syntax:
    content: public ProcessStartInfo ();
    parameters: []
  overload: System.Diagnostics.ProcessStartInfo.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.#ctor(System.String)
  id: '#ctor(System.String)'
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: ProcessStartInfo(String)
  nameWithType: ProcessStartInfo.ProcessStartInfo(String)
  fullName: System.Diagnostics.ProcessStartInfo.ProcessStartInfo(String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;> </xref> classe e especifica um nome de ficheiro, como uma aplicação ou documento com a qual pretende iniciar o processo."
  remarks: "O nome de ficheiro é qualquer aplicação ou documento. Neste caso, um documento está definido para ser de qualquer tipo de ficheiro que tenha um open ou default ação associada. Pode ver os tipos de ficheiros registada e as respetivas aplicações associadas para o seu computador através de **opções de pastas** caixa de diálogo, que está disponível através do sistema operativo. O **avançadas** botão conduz a uma caixa de diálogo que mostra se houver uma ação aberta associada um tipo específico de ficheiros registada.       Pode alterar o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>propriedade depois de chamar este construtor, até à hora que o processo é iniciado.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Depois de iniciar o processo, alterar estes valores não tem qualquer efeito."
  syntax:
    content: public ProcessStartInfo (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "Uma aplicação ou documento com a qual pretende iniciar um processo."
  overload: System.Diagnostics.ProcessStartInfo.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.#ctor(System.String,System.String)
  id: '#ctor(System.String,System.String)'
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: ProcessStartInfo(String,String)
  nameWithType: ProcessStartInfo.ProcessStartInfo(String,String)
  fullName: System.Diagnostics.ProcessStartInfo.ProcessStartInfo(String,String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;> </xref> classe, especifica um nome de ficheiro de aplicação com a qual pretende iniciar o processo e especifica um conjunto de argumentos da linha de comandos transmitidos à aplicação."
  remarks: "O nome de ficheiro é qualquer aplicação ou documento. Neste caso, um documento está definido para ser de qualquer tipo de ficheiro que tenha um open ou default ação associada. Pode ver os tipos de ficheiros registada e as respetivas aplicações associadas para o seu computador através de **opções de pastas** caixa de diálogo, que está disponível através do sistema operativo. O **avançadas** botão conduz a uma caixa de diálogo que mostra se houver uma ação aberta associada um tipo específico de ficheiros registada.       Pode alterar o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>ou <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>Propriedades depois de chamar este construtor, até à hora que o processo é iniciado.</xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Depois de iniciar o processo, alterar estes valores não tem qualquer efeito."
  syntax:
    content: public ProcessStartInfo (string fileName, string arguments);
    parameters:
    - id: fileName
      type: System.String
      description: "Uma aplicação com a qual pretende iniciar um processo."
    - id: arguments
      type: System.String
      description: "Argumentos da linha de comandos transmitidos à aplicação quando inicia o processo."
  overload: System.Diagnostics.ProcessStartInfo.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.Arguments
  id: Arguments
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: Arguments
  nameWithType: ProcessStartInfo.Arguments
  fullName: System.Diagnostics.ProcessStartInfo.Arguments
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define o conjunto de argumentos da linha de comandos a utilizar quando iniciar a aplicação."
  remarks: ''
  example:
  - "The first example below creates a small application (argsecho.exe) that echos its arguments to the console. The second example creates an application that invokes argsecho.exe to demonstrate different variations for the Arguments property.  \n  \n [!code-vb[Process.Start_static#3](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_2_1.vb)]\n [!code-cs[Process.Start_static#3](~/add/codesnippet/csharp/p-system.diagnostics.pro_2_1.cs)]\n [!code-cpp[Process.Start_static#3](~/add/codesnippet/cpp/p-system.diagnostics.pro_2_1.cpp)]  \n  \n [!code-vb[Process.Start_static#2](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_2_2.vb)]\n [!code-cs[Process.Start_static#2](~/add/codesnippet/csharp/p-system.diagnostics.pro_2_2.cs)]\n [!code-cpp[Process.Start_static#2](~/add/codesnippet/cpp/p-system.diagnostics.pro_2_2.cpp)]"
  syntax:
    content: public string Arguments { get; set; }
    return:
      type: System.String
      description: "Uma cadeia único que contém os argumentos transmitidos para a aplicação de destino especificada no <xref:System.Diagnostics.ProcessStartInfo.FileName*>propriedade.</xref:System.Diagnostics.ProcessStartInfo.FileName*> A predefinição é uma cadeia vazia (&quot;&quot;). No Windows Vista e versões anteriores do sistema operativo Windows, o comprimento dos argumentos adicionadas para o comprimento do caminho completo para o processo deve ser inferior a 2080. No Windows 7 e versões posteriores, o comprimento deve ser inferior a 32699.       Os argumentos são analisados e interpretados pela aplicação de destino, pelo que tem de alinhar com as expectativas dessa aplicação. Aplicações For.NET, conforme demonstrado nos exemplos abaixo, os espaços são interpretados como um separador entre vários argumentos. Um argumento único, que inclui espaços tem de estar entre aspas, mas essas aspas não são transportadas da aplicação de destino. Incluir na aspas no final analisar argumento, triple-escape cada marca."
  overload: System.Diagnostics.ProcessStartInfo.Arguments*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.CreateNoWindow
  id: CreateNoWindow
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: CreateNoWindow
  nameWithType: ProcessStartInfo.CreateNoWindow
  fullName: System.Diagnostics.ProcessStartInfo.CreateNoWindow
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define um valor que indica se pretende iniciar o processo numa nova janela."
  remarks: "Se o <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>propriedade é `true` ou <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>e <xref:System.Diagnostics.ProcessStartInfo.Password%2A>Propriedades não são `null`, o valor da propriedade CreateNoWindow é ignorado e é criada uma nova janela.</xref:System.Diagnostics.ProcessStartInfo.Password%2A> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>"
  example:
  - >-
    [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_19_1.cpp)]
     [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_19_1.vb)]
     [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_19_1.cs)]
  syntax:
    content: public bool CreateNoWindow { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o processo deve ser iniciado sem criar uma nova janela que contêm; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. A predefinição é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.CreateNoWindow*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.Domain
  id: Domain
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: Domain
  nameWithType: ProcessStartInfo.Domain
  fullName: System.Diagnostics.ProcessStartInfo.Domain
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define um valor que identifica o domínio a utilizar quando iniciar o processo."
  syntax:
    content: public string Domain { get; set; }
    return:
      type: System.String
      description: "Domínio do Active Directory a utilizar quando iniciar o processo. A propriedade de domínio é principalmente de interesse para os utilizadores dentro de ambientes de enterprise que utilizam o Active Directory."
  overload: System.Diagnostics.ProcessStartInfo.Domain*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.Environment
  id: Environment
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: Environment
  nameWithType: ProcessStartInfo.Environment
  fullName: System.Diagnostics.ProcessStartInfo.Environment
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém as variáveis de ambiente que se aplicam a este processo e dos processos subordinados."
  remarks: "The environment variables contain search paths for files, directories for temporary files, application-specific options, and other similar information. Although you cannot directly set the Environment property, you can modify the generic dictionary returned by the property. For example, the following code adds a TempPath environment variable: `myProcess.StartInfo.Environment.Add(\"TempPath\", \"C:\\\\Temp\")`.  You must set the <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> property to `false` to start the process after changing the Environment property. If <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true`, an <xref:System.InvalidOperationException> is thrown when the <xref:System.Diagnostics.Process.Start%2A> method is called.  \n  \n On .NET Framework applications, using the Environment property is the same as using the <xref:System.Diagnostics.ProcessStartInfo.EnvironmentVariables%2A> property."
  syntax:
    content: public System.Collections.Generic.IDictionary<string,string> Environment { get; }
    return:
      type: System.Collections.Generic.IDictionary{System.String,System.String}
      description: "Um dicionário genérico que contém as variáveis de ambiente que se aplicam a este processo e dos processos subordinados. A predefinição é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.Environment*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.EnvironmentVariables
  id: EnvironmentVariables
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: EnvironmentVariables
  nameWithType: ProcessStartInfo.EnvironmentVariables
  fullName: System.Diagnostics.ProcessStartInfo.EnvironmentVariables
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Pesquisa obtém os caminhos de ficheiros, os diretórios para ficheiros temporários, opções específicas da aplicação e outras informações semelhantes."
  remarks: 'Apesar de não é possível definir a propriedade EnvironmentVariables, pode modificar o <xref:System.Collections.Specialized.StringDictionary>devolvido pela propriedade.</xref:System.Collections.Specialized.StringDictionary> Por exemplo, o seguinte código adiciona uma variável de ambiente de TempPath: `myProcess.StartInfo.EnvironmentVariables.Add(&quot;TempPath&quot;, &quot;C:\\Temp&quot;)`.  Tem de definir o <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>propriedade `false` para iniciar o processo depois de alterar a propriedade EnvironmentVariables.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> Se <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>é `true`, um <xref:System.InvalidOperationException>é acionada quando o <xref:System.Diagnostics.Process.Start%2A>método é chamado.</xref:System.Diagnostics.Process.Start%2A> </xref:System.InvalidOperationException> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>'
  syntax:
    content: public System.Collections.Specialized.StringDictionary EnvironmentVariables { get; }
    return:
      type: System.Collections.Specialized.StringDictionary
      description: "Um dicionário de cadeia que fornece as variáveis de ambiente que se aplicam a este processo e processos subordinados. A predefinição é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.EnvironmentVariables*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.ErrorDialog
  id: ErrorDialog
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: ErrorDialog
  nameWithType: ProcessStartInfo.ErrorDialog
  fullName: System.Diagnostics.ProcessStartInfo.ErrorDialog
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define um valor que indica se uma caixa de diálogo de erro é apresentada ao utilizador se não é possível iniciar o processo."
  remarks: >-
    > [!NOTE]

    >  <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> must be `true` if you want to set ErrorDialog to `true`.
  syntax:
    content: public bool ErrorDialog { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se uma caixa de diálogo de erro deverá ser apresentada no ecrã, se o processo não pode ser iniciado; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. A predefinição é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.ErrorDialog*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle
  id: ErrorDialogParentHandle
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: ErrorDialogParentHandle
  nameWithType: ProcessStartInfo.ErrorDialogParentHandle
  fullName: System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define o identificador de janela a utilizar quando é apresentada uma caixa de diálogo de erro para um processo que não pode ser iniciado."
  remarks: "Se <xref:System.Diagnostics.ProcessStartInfo.ErrorDialog%2A>é `true`, a propriedade ErrorDialogParentHandle Especifica a janela principal para a caixa de diálogo que é apresentada.</xref:System.Diagnostics.ProcessStartInfo.ErrorDialog%2A> É útil especificar um elemento principal para manter a caixa de diálogo à frente da aplicação."
  syntax:
    content: public IntPtr ErrorDialogParentHandle { get; set; }
    return:
      type: System.IntPtr
      description: "Um ponteiro para o identificador da caixa de diálogo de erro que os resultados de um processo iniciam falha."
  overload: System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.FileName
  id: FileName
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: FileName
  nameWithType: ProcessStartInfo.FileName
  fullName: System.Diagnostics.ProcessStartInfo.FileName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define a aplicação ou documento para iniciar."
  remarks: "Tem de definir, pelo menos, a propriedade de nome de ficheiro antes de iniciar o processo. O nome de ficheiro é qualquer aplicação ou documento. Um documento não está definido para ser de qualquer tipo de ficheiro que tenha um open ou default ação associada. Pode ver os tipos de ficheiros registada e as respetivas aplicações associadas para o seu computador através de **opções de pastas** caixa de diálogo, que está disponível através do sistema operativo. O **avançadas** botão conduz a uma caixa de diálogo que mostra se houver uma ação aberta associada um tipo específico de ficheiros registada.       O conjunto de tipos de ficheiros disponíveis para si depende em parte do valor da <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>propriedade.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> Se <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>é `true`, pode iniciar de qualquer documento e executar operações no ficheiro, como a impressão, com o <xref:System.Diagnostics.Process>componente.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>é `false`, pode iniciar apenas executáveis com o <xref:System.Diagnostics.Process>componente.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>       Pode iniciar uma aplicação ClickOnce definindo a propriedade de nome de ficheiro para a localização (por exemplo, um endereço de Web) a partir do qual instalado originalmente a aplicação. Não inicie uma aplicação ClickOnce especificando a localização instalada no disco rígido."
  example:
  - >-
    [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_27_1.cpp)]
     [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_27_1.vb)]
     [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_27_1.cs)]
  syntax:
    content: public string FileName { get; set; }
    return:
      type: System.String
      description: "O nome da aplicação para iniciar ou o nome de um documento de um tipo de ficheiro que está associado uma aplicação e que tem uma predefinição abrir ação disponível. A predefinição é uma cadeia vazia (&quot;&quot;)."
  overload: System.Diagnostics.ProcessStartInfo.FileName*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.LoadUserProfile
  id: LoadUserProfile
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: LoadUserProfile
  nameWithType: ProcessStartInfo.LoadUserProfile
  fullName: System.Diagnostics.ProcessStartInfo.LoadUserProfile
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define um valor que indica se o perfil de utilizador do Windows está a ser carregado a partir do registo."
  remarks: "Esta propriedade é referenciada se estiver a ser iniciado o processo utilizando o nome de utilizador, palavra-passe e domínio.       Se o valor for `true`, o perfil do utilizador no `HKEY_USERS` chave de registo é carregada. Carregar o perfil pode ser morosa. Por conseguinte, é melhor utilizar este valor apenas se precisa de aceder as informações de `HKEY_CURRENT_USER` chave de registo.       No Windows Server 2003 e no Windows 2000, o perfil é descarregado depois do novo processo foi terminado, independentemente se o processo foi criado subordinado processos.       No Windows XP, o perfil é descarregado após o novo processo e todos os processos subordinados que ter criado foram terminados."
  syntax:
    content: public bool LoadUserProfile { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o perfil de utilizador do Windows deve ser carregado; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. A predefinição é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.LoadUserProfile*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.Password
  id: Password
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: Password
  nameWithType: ProcessStartInfo.Password
  fullName: System.Diagnostics.ProcessStartInfo.Password
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define uma cadeia segura que contenha a palavra-passe do utilizador a utilizar quando iniciar o processo."
  remarks: "> [!IMPORTANT]\n>  The <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> property must be set if <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> and Password are provided. If the property is not set, the default working directory is %SYSTEMROOT%\\system32.  \n  \n> [!NOTE]\n>  Setting the <xref:System.Diagnostics.ProcessStartInfo.Domain%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, and the Password properties in a <xref:System.Diagnostics.ProcessStartInfo> object is the recommended practice for starting a process with user credentials.  \n  \n A <xref:System.Security.SecureString> object is like a <xref:System.String> object in that it has a text value. However, the value of a <xref:System.Security.SecureString> object is automatically encrypted, it can be modified until your application marks it as read-only, and it can be deleted from computer memory by either your application or the .NET Framework garbage collector.  \n  \n For more information about secure strings and an example of how to obtain a password to set this property, see the <xref:System.Security.SecureString> class.  \n  \n> [!NOTE]\n>  If you provide a value for the Password property, the <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> property must be `false`, or an <xref:System.InvalidOperationException> will be thrown when the <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=fullName> method is called."
  syntax:
    content: public System.Security.SecureString Password { get; set; }
    return:
      type: System.Security.SecureString
      description: "A palavra-passe do utilizador a utilizar quando iniciar o processo."
  overload: System.Diagnostics.ProcessStartInfo.Password*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.PasswordInClearText
  id: PasswordInClearText
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: PasswordInClearText
  nameWithType: ProcessStartInfo.PasswordInClearText
  fullName: System.Diagnostics.ProcessStartInfo.PasswordInClearText
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define a palavra-passe do utilizador em texto não encriptado para utilizar quando iniciar o processo."
  syntax:
    content: public string PasswordInClearText { get; set; }
    return:
      type: System.String
      description: "A palavra-passe do utilizador em texto não encriptado."
  overload: System.Diagnostics.ProcessStartInfo.PasswordInClearText*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardError
  id: RedirectStandardError
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: RedirectStandardError
  nameWithType: ProcessStartInfo.RedirectStandardError
  fullName: System.Diagnostics.ProcessStartInfo.RedirectStandardError
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define um valor que indica se a saída de erro de uma aplicação é escrita para o &lt;xref:System.Diagnostics.Process.StandardError%2A?displayProperty=fullName&gt; fluxo."
  remarks: "Quando um <xref:System.Diagnostics.Process>escreve o texto a respetiva sequência de erro padrão, que o texto, normalmente, é apresentado na consola.</xref:System.Diagnostics.Process> Redirecionar o <xref:System.Diagnostics.Process.StandardError%2A>fluxo, pode manipular ou suprimir a saída de erro de um processo.</xref:System.Diagnostics.Process.StandardError%2A> Por exemplo, pode filtrar o texto, formate-o de forma diferente ou escrever a saída para a consola e um ficheiro de registo designado.      > [!NOTE] > Tem de definir <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>para `false` se pretende definir RedirectStandardError `true`.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> Caso contrário, a ler a partir de <xref:System.Diagnostics.Process.StandardError%2A>fluxo emite uma exceção.</xref:System.Diagnostics.Process.StandardError%2A>       O redirecionada <xref:System.Diagnostics.Process.StandardError%2A>fluxo pode ser lidos de forma síncrona ou assíncrona.</xref:System.Diagnostics.Process.StandardError%2A> Métodos, tais como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>e <xref:System.IO.StreamReader.ReadToEnd%2A>efetuar operações de leitura síncronas no fluxo de saída de erro do processo.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Estes síncrona ler operações não concluída até associada <xref:System.Diagnostics.Process>escreve o <xref:System.Diagnostics.Process.StandardError%2A>transmitir ou fecha o fluxo.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.Diagnostics.Process>       Em contrapartida, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>operações de leitura assíncrona inicia no <xref:System.Diagnostics.Process.StandardError%2A>stream.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.Diagnostics.Process.BeginErrorReadLine%2A> Este método permite que um processador de eventos designado para a saída de fluxo e devolve imediatamente para o emissor, o que pode efetuar outras tarefas enquanto a saída de fluxo é direcionada para o processador de eventos.      > [!NOTE] > A aplicação que está a processar o resultado assíncrono deverá chamar o <xref:System.Diagnostics.Process.WaitForExit%2A>método para se certificar de que a memória intermédia de saída foram descarregada.</xref:System.Diagnostics.Process.WaitForExit%2A>       Síncrono ler operações introduzem uma dependência entre o autor da chamada ler a partir de <xref:System.Diagnostics.Process.StandardError%2A>fluxo e o subordinado processam escrita a esse fluxo.</xref:System.Diagnostics.Process.StandardError%2A> Estas dependências podem fazer com que as condições de impasse. Quando o autor da chamada lê do fluxo de um processo subordinado redirecionado, está dependente da subordinada. O autor da chamada aguarda que a operação de leitura até o subordinado escreve no fluxo ou fecha o fluxo. Quando o processo subordinado escreve dados suficientes para preencher o fluxo redirecionado, está dependente de principal. O processo subordinado aguarda que a próxima operação de escrita até que o elemento principal lê a partir da sequência de completa ou fecha o fluxo. A condição de impasse resulta quando o processo de subordinados e autor da chamada de espera para si concluir uma operação e não pode continuar. Pode evitar impasses através da avaliação de dependências entre o emissor e o processo subordinado.       Por exemplo, o seguinte código c# mostra como ler a partir de um fluxo redirecionado e aguarde que o processo de subordinados sair.      ```   // Start the child process.    Process p = new Process();    // Redirect the error stream of the child process.    p.StartInfo.UseShellExecute = false;    p.StartInfo.RedirectStandardError = true;    p.StartInfo.FileName = &quot;Write500Lines.exe&quot;;    p.Start();    // Do not wait for the child process to exit before    // reading to the end of its redirected error stream.    // p.WaitForExit();    // Read the error stream first and then wait.    string error = p.StandardError.ReadToEnd();    p.WaitForExit();   ```O exemplo de código evita uma condição de impasse ao chamar `p.StandardError.ReadToEnd` antes `p.WaitForExit`. Uma condição de impasse pode resultar se principal processar chamadas `p.WaitForExit` antes `p.StandardError.ReadToEnd` e o processo subordinado escreve suficiente texto para preencher o fluxo redirecionado. O processo de principal seria aguardar indefinidamente o processo de subordinados sair. O processo subordinado seria aguardar indefinidamente principal ler a partir de completo <xref:System.Diagnostics.Process.StandardError%2A>stream.</xref:System.Diagnostics.Process.StandardError%2A>       Não há um problema semelhante quando Leia todo o texto do resultado padrão e fluxos de erro padrão. Por exemplo, o seguinte código c# efetua uma operação de leitura em ambos os fluxos.      ```   // Do not perform a synchronous read to the end of both   // redirected streams.   // string output = p.StandardOutput.ReadToEnd();   // string error = p.StandardError.ReadToEnd();   // p.WaitForExit();   // Use asynchronous read operations on at least one of the streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```O exemplo de código evita a condição de impasse efetuando assíncrona operações de leitura no <xref:System.Diagnostics.Process.StandardOutput%2A>stream.</xref:System.Diagnostics.Process.StandardOutput%2A> Uma condição de impasse resulta se principal processar chamadas `p.StandardOutput.ReadToEnd` seguido `p.StandardError.ReadToEnd` e o processo subordinado escreve suficiente texto para preencher a sequência de erro. O processo de principal seria aguardar indefinidamente o processo de subordinados fechar o <xref:System.Diagnostics.Process.StandardOutput%2A>stream.</xref:System.Diagnostics.Process.StandardOutput%2A> O processo subordinado seria aguardar indefinidamente principal ler a partir de completo <xref:System.Diagnostics.Process.StandardError%2A>stream.</xref:System.Diagnostics.Process.StandardError%2A>       Pode utilizar operações de leitura assíncrona para evitar estas dependências e as respetivas impasse potencial. Em alternativa, pode evitar a condição de impasse ao criar dois threads e ao ler a saída de cada fluxo num thread separado."
  example:
  - "The following example uses the `net use` command together with a user-supplied argument to map a network resource. It then reads the standard error stream of the net command and writes it to console.  \n  \n [!code-cs[Process_StandardError#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_31_1.cs)]\n [!code-cpp[Process_StandardError#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_31_1.cpp)]\n [!code-vb[Process_StandardError#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_31_1.vb)]"
  syntax:
    content: public bool RedirectStandardError { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a saída de erro deve ser escrita para &lt;xref:System.Diagnostics.Process.StandardError%2A?displayProperty=fullName&gt;; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. A predefinição é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.RedirectStandardError*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardInput
  id: RedirectStandardInput
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: RedirectStandardInput
  nameWithType: ProcessStartInfo.RedirectStandardInput
  fullName: System.Diagnostics.ProcessStartInfo.RedirectStandardInput
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define um valor que indica se a entrada para uma aplicação é lida a &lt;xref:System.Diagnostics.Process.StandardInput%2A?displayProperty=fullName&gt; fluxo."
  remarks: "A <xref:System.Diagnostics.Process>pode ler o texto de entrada do seu fluxo de entrada padrão, normalmente, o teclado.</xref:System.Diagnostics.Process> Redirecionar o <xref:System.Diagnostics.Process.StandardInput%2A>fluxo, pode especificar a entrada de um processo através de programação.</xref:System.Diagnostics.Process.StandardInput%2A> Por exemplo, em vez de utilizar introdução por teclado, pode fornecer texto o conteúdo de um ficheiro designado ou um resultado de outra aplicação.      > [!NOTE] > Tem de definir <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>para `false` se pretende definir RedirectStandardInput `true`.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> Caso contrário, ao escrever o <xref:System.Diagnostics.Process.StandardInput%2A>fluxo emite uma exceção.</xref:System.Diagnostics.Process.StandardInput%2A>"
  example:
  - "The following example illustrates how to redirect the <xref:System.Diagnostics.Process.StandardInput%2A> stream of a process. The `sort` command is a console application that reads and sorts text input.  \n  \n The example starts the `sort` command with redirected input. It then prompts the user for text, and passes the text to the `sort` process through the redirected <xref:System.Diagnostics.Process.StandardInput%2A> stream. The `sort` results are displayed to the user on the console.  \n  \n [!code-cs[Process_StandardInput#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_43_1.cs)]\n [!code-cpp[Process_StandardInput#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_43_1.cpp)]\n [!code-vb[Process_StandardInput#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_43_1.vb)]"
  syntax:
    content: public bool RedirectStandardInput { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a entrada deve ser lida &lt;xref:System.Diagnostics.Process.StandardInput%2A?displayProperty=fullName&gt;; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. A predefinição é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.RedirectStandardInput*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
  id: RedirectStandardOutput
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: RedirectStandardOutput
  nameWithType: ProcessStartInfo.RedirectStandardOutput
  fullName: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define um valor que indica se o resultado de uma aplicação textual é escrito para o &lt;xref:System.Diagnostics.Process.StandardOutput%2A?displayProperty=fullName&gt; fluxo."
  remarks: "Quando um <xref:System.Diagnostics.Process>escreve o texto para o padrão de transmissão, texto é geralmente apresentado na consola.</xref:System.Diagnostics.Process> Definindo RedirectStandardOutput `true` para redirecionar o <xref:System.Diagnostics.Process.StandardOutput%2A>fluxo, pode manipular ou suprimir a saída de um processo.</xref:System.Diagnostics.Process.StandardOutput%2A> Por exemplo, pode filtrar o texto, formate-o de forma diferente ou escrever a saída para a consola e um ficheiro de registo designado.      > [!NOTE] > Tem de definir <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>para `false` se pretende definir RedirectStandardOutput `true`.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> Caso contrário, a ler a partir de <xref:System.Diagnostics.Process.StandardOutput%2A>fluxo emite uma exceção.</xref:System.Diagnostics.Process.StandardOutput%2A>       O redirecionada <xref:System.Diagnostics.Process.StandardOutput%2A>fluxo pode ser lidos de forma síncrona ou assíncrona.</xref:System.Diagnostics.Process.StandardOutput%2A> Métodos, tais como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A>efetuar operações de leitura síncronas no fluxo de saída do processo.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Estes síncrona ler operações não concluída até associada <xref:System.Diagnostics.Process>escreve o <xref:System.Diagnostics.Process.StandardOutput%2A>transmitir ou fecha o fluxo.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process>       Em contrapartida, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>operações de leitura assíncrona inicia no <xref:System.Diagnostics.Process.StandardOutput%2A>stream.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process.BeginOutputReadLine%2A> Este método permite que um processador de eventos designado (consulte <xref:System.Diagnostics.Process.OutputDataReceived>) para a saída de fluxo e imediatamente devolve para o autor da chamada, que pode efetuar outras tarefas enquanto a saída de fluxo é direcionada para o processador de eventos.</xref:System.Diagnostics.Process.OutputDataReceived>      > [!NOTE] > A aplicação que está a processar o resultado assíncrono deverá chamar o <xref:System.Diagnostics.Process.WaitForExit%2A>método para se certificar de que a memória intermédia de saída foram descarregada.</xref:System.Diagnostics.Process.WaitForExit%2A>       Síncrono ler operações introduzem uma dependência entre o autor da chamada ler a partir de <xref:System.Diagnostics.Process.StandardOutput%2A>fluxo e o subordinado processam escrita a esse fluxo.</xref:System.Diagnostics.Process.StandardOutput%2A> Estas dependências podem fazer com que as condições de impasse. Quando o autor da chamada lê do fluxo de um processo subordinado redirecionado, está dependente da subordinada. O autor da chamada aguarda que a operação de leitura até o subordinado escreve no fluxo ou fecha o fluxo. Quando o processo subordinado escreve dados suficientes para preencher o fluxo redirecionado, está dependente de principal. O processo subordinado aguarda que a próxima operação de escrita até que o elemento principal lê a partir da sequência de completa ou fecha o fluxo. A condição de impasse resulta quando o processo de subordinados e autor da chamada de espera para si concluir uma operação e não pode continuar. Pode evitar impasses através da avaliação de dependências entre o emissor e o processo subordinado.       Por exemplo, o seguinte código c# mostra como ler a partir de um fluxo redirecionado e aguarde que o processo de subordinados sair.      ```   Process p = new Process();   p.StartInfo.UseShellExecute = false;   p.StartInfo.RedirectStandardOutput = true;   p.StartInfo.FileName = &quot;Write500Lines.exe&quot;;   p.Start();      // To avoid deadlocks, always read the output stream first and then wait.   string output = p.StandardOutput.ReadToEnd();   p.WaitForExit();   ```O exemplo de código evita uma condição de impasse ao chamar `p.StandardOutput.ReadToEnd` antes `p.WaitForExit`. Uma condição de impasse pode resultar se principal processar chamadas `p.WaitForExit` antes `p.StandardOutput.ReadToEnd` e o processo subordinado escreve suficiente texto para preencher o fluxo redirecionado. O processo de principal seria aguardar indefinidamente o processo de subordinados sair. O processo subordinado seria aguardar indefinidamente principal ler a partir de completo <xref:System.Diagnostics.Process.StandardOutput%2A>stream.</xref:System.Diagnostics.Process.StandardOutput%2A>       Não há um problema semelhante quando Leia todo o texto do resultado padrão e fluxos de erro padrão. Por exemplo, o seguinte código c# efetua uma operação de leitura em ambos os fluxos.      ```   // To avoid deadlocks, use asynchronous read operations on at least one of the streams.   // Do not perform a synchronous read to the end of both redirected streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```O exemplo de código evita a condição de impasse efetuando assíncrona operações de leitura no <xref:System.Diagnostics.Process.StandardOutput%2A>stream.</xref:System.Diagnostics.Process.StandardOutput%2A> Uma condição de impasse resulta se principal processar chamadas `p.StandardOutput.ReadToEnd` seguido `p.StandardError.ReadToEnd` e o processo subordinado escreve suficiente texto para preencher a sequência de erro. O processo de principal seria aguardar indefinidamente o processo de subordinados fechar o <xref:System.Diagnostics.Process.StandardOutput%2A>stream.</xref:System.Diagnostics.Process.StandardOutput%2A> O processo subordinado seria aguardar indefinidamente principal ler a partir de completo <xref:System.Diagnostics.Process.StandardError%2A>stream.</xref:System.Diagnostics.Process.StandardError%2A>       Pode utilizar operações de leitura assíncrona para evitar estas dependências e as respetivas impasse potencial. Em alternativa, pode evitar a condição de impasse ao criar dois threads e ao ler a saída de cada fluxo num thread separado."
  example:
  - >-
    [!code-cpp[ProcessOneStream#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_20_1.cpp)]
     [!code-cs[ProcessOneStream#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_20_1.cs)]
     [!code-vb[ProcessOneStream#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_20_1.vb)]
  syntax:
    content: public bool RedirectStandardOutput { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a saída deve ser escrita &lt;xref:System.Diagnostics.Process.StandardOutput%2A?displayProperty=fullName&gt;; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. A predefinição é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.StandardErrorEncoding
  id: StandardErrorEncoding
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: StandardErrorEncoding
  nameWithType: ProcessStartInfo.StandardErrorEncoding
  fullName: System.Diagnostics.ProcessStartInfo.StandardErrorEncoding
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define a codificação preferido para a saída de erro."
  remarks: "Se o valor da propriedade StandardErrorEncoding for `null`, o processo utiliza a codificação de erro padrão de predefinida para a saída de erro. A propriedade StandardErrorEncoding tem de ser definida antes de iniciar o processo. Definir esta propriedade não garante que o processo irá utilizar à codificação especificada; o processo irá utilizar apenas as codificações que suporta. A aplicação deve ser testada para determinar as codificações são suportadas."
  syntax:
    content: public System.Text.Encoding StandardErrorEncoding { get; set; }
    return:
      type: System.Text.Encoding
      description: "Um objeto que representa a codificação preferida para a saída de erro. A predefinição é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.StandardErrorEncoding*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.StandardOutputEncoding
  id: StandardOutputEncoding
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: StandardOutputEncoding
  nameWithType: ProcessStartInfo.StandardOutputEncoding
  fullName: System.Diagnostics.ProcessStartInfo.StandardOutputEncoding
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define a codificação preferido para a saída padrão."
  remarks: "Se o valor da propriedade StandardOutputEncoding for `null`, o processo utiliza a codificação de saída padrão de predefinida para a saída padrão. A propriedade StandardOutputEncoding tem de ser definida antes de iniciar o processo. Definir esta propriedade não garante que o processo irá utilizar à codificação especificada. A aplicação deve ser testada para determinar as codificações do processo de suporte."
  syntax:
    content: public System.Text.Encoding StandardOutputEncoding { get; set; }
    return:
      type: System.Text.Encoding
      description: "Um objeto que representa a codificação preferida para a saída padrão. A predefinição é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.StandardOutputEncoding*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.UserName
  id: UserName
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: UserName
  nameWithType: ProcessStartInfo.UserName
  fullName: System.Diagnostics.ProcessStartInfo.UserName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define o nome de utilizador a utilizar quando iniciar o processo."
  remarks: "> [!IMPORTANT]\n>  The <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> property must be set if UserName and <xref:System.Diagnostics.ProcessStartInfo.Password%2A> are provided. If the property is not set, the default working directory is %SYSTEMROOT%\\system32.  \n  \n If the UserName property is not `null` or an empty string, the <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> property must be `false`, or an <xref:System.InvalidOperationException> will be thrown when the <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=fullName> method is called."
  syntax:
    content: public string UserName { get; set; }
    return:
      type: System.String
      description: "O nome de utilizador a utilizar quando iniciar o processo."
  overload: System.Diagnostics.ProcessStartInfo.UserName*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.UseShellExecute
  id: UseShellExecute
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: UseShellExecute
  nameWithType: ProcessStartInfo.UseShellExecute
  fullName: System.Diagnostics.ProcessStartInfo.UseShellExecute
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define um valor que indica se deve utilizar a shell do sistema operativo para iniciar o processo."
  remarks: "Definição desta propriedade como `false` permite-lhe redirecionar os fluxos de entrada, saída e o erro.      > [!NOTE] > UseShellExecute tem de ser `false` se o <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>propriedade não é `null` ou uma cadeia vazia, ou um <xref:System.InvalidOperationException>será acionada quando o <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=fullName>método é chamado.</xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=fullName> </xref:System.InvalidOperationException> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A>       Quando utiliza a shell do sistema operativo para iniciar processos, pode iniciar de qualquer documento (que é qualquer tipo de ficheiro registado associado um ficheiro executável que tem uma ação de abrir predefinido) e executar operações no ficheiro, como a impressão, utilizando o <xref:System.Diagnostics.Process>objeto.</xref:System.Diagnostics.Process> Quando é UseShellExecute `false`, pode iniciar apenas executáveis utilizando o <xref:System.Diagnostics.Process>objeto.</xref:System.Diagnostics.Process>      > [!NOTE] > UseShellExecute tem de ser `true` se definir o <xref:System.Diagnostics.ProcessStartInfo.ErrorDialog%2A>propriedade `true`.</xref:System.Diagnostics.ProcessStartInfo.ErrorDialog%2A>       O <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>propriedade comporta-se de forma diferente consoante o valor da propriedade UseShellExecute.</xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> Quando é UseShellExecute `true`, a <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>propriedade especifica a localização do executável.</xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> Se <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>é uma cadeia vazia, presume-se que o diretório atual contém o executável.</xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>       Quando é UseShellExecute `false`, a <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>propriedade não é utilizada para localizar o ficheiro executável.</xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> Em vez disso, é utilizado apenas pelo processo que é iniciado e tem significado apenas dentro do contexto do processo de novo. Quando é UseShellExecute `false`, a <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>propriedade pode ser o um caminho totalmente qualificado para o executável ou um nome de executável simple que o sistema irá tentar localizar dentro de pastas especificadas pela variável de ambiente PATH.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A>"
  example:
  - >-
    [!code-cpp[ProcessOneStream#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_44_1.cpp)]
     [!code-cs[ProcessOneStream#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_44_1.cs)]
     [!code-vb[ProcessOneStream#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_44_1.vb)]
  syntax:
    content: public bool UseShellExecute { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o shell deve ser utilizada ao iniciar o processo de; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> se o processo deve ser criado diretamente a partir do ficheiro executável. A predefinição é <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.UseShellExecute*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.Verb
  id: Verb
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: Verb
  nameWithType: ProcessStartInfo.Verb
  fullName: System.Diagnostics.ProcessStartInfo.Verb
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define o verbo a utilizar ao abrir a aplicação ou documento especificado pelo <xref:System.Diagnostics.ProcessStartInfo.FileName*>propriedade.</xref:System.Diagnostics.ProcessStartInfo.FileName*>"
  remarks: "Cada extensão de nome de ficheiro tem o seu próprio conjunto de verbos, que podem ser obtidas usando o <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>propriedade.</xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> Por exemplo, o &quot;`print`&quot; verbo irá imprimir um documento especificado utilizando <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> O verbo predefinido pode ser especificado utilizando uma cadeia vazia (&quot;&quot;). Exemplos de verbos são &quot;Editar&quot;, &quot;Abrir&quot;, &quot;OpenAsReadOnly&quot;, &quot;Print&quot; e &quot;Printto&quot;. Deve utilizar apenas os verbos que aparecem no conjunto de verbos devolvido pelo <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>propriedade.</xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>       Quando utiliza a propriedade do verbo, tem de incluir a extensão de nome de ficheiro quando definir o valor da <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>propriedade.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> O nome de ficheiro não precisa de ter uma extensão, se introduzir manualmente um valor para a propriedade de verbo."
  example:
  - "The following code example starts a new process by using the specified verb and file name. This code example is part of a larger example provided for the <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> property.  \n  \n [!code-vb[ProcessVerbs_Diagnostics#4](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_9_1.vb)]\n [!code-cs[ProcessVerbs_Diagnostics#4](~/add/codesnippet/csharp/p-system.diagnostics.pro_9_1.cs)]"
  syntax:
    content: public string Verb { get; set; }
    return:
      type: System.String
      description: "A ação a tomar com o ficheiro que o processo abre. A predefinição é uma cadeia vazia (&quot;&quot;), não significa que nenhuma ação."
  overload: System.Diagnostics.ProcessStartInfo.Verb*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.Verbs
  id: Verbs
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: Verbs
  nameWithType: ProcessStartInfo.Verbs
  fullName: System.Diagnostics.ProcessStartInfo.Verbs
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o conjunto de verbos associados com o tipo de ficheiro especificado pelo <xref:System.Diagnostics.ProcessStartInfo.FileName*>propriedade.</xref:System.Diagnostics.ProcessStartInfo.FileName*>"
  remarks: "A propriedade de verbos permite-lhe determinar os verbos que podem ser utilizados com o ficheiro especificado pelo <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>propriedade.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Pode definir o <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>propriedade para o valor de qualquer verbo no conjunto.</xref:System.Diagnostics.ProcessStartInfo.Verb%2A> Exemplos de verbos são &quot;Editar&quot;, &quot;Abrir&quot;, &quot;OpenAsReadOnly&quot;, &quot;Print&quot; e &quot;Printto&quot;.       Quando utiliza a propriedade de verbos, tem de incluir a extensão de nome de ficheiro quando definir o valor da <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>propriedade.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> A extensão de nome de ficheiro determina o conjunto de verbos possíveis."
  example:
  - "The following code example displays the defined verbs for the chosen file name. If the user selects one of the defined verbs, the example starts a new process using the selected verb and the input file name.  \n  \n [!code-vb[ProcessVerbs_Diagnostics#3](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_7_1.vb)]\n [!code-cs[ProcessVerbs_Diagnostics#3](~/add/codesnippet/csharp/p-system.diagnostics.pro_7_1.cs)]"
  syntax:
    content: public string[] Verbs { get; }
    return:
      type: System.String[]
      description: "As ações que pode aplicar o sistema para o ficheiro indicaram pelo <xref:System.Diagnostics.ProcessStartInfo.FileName*>propriedade.</xref:System.Diagnostics.ProcessStartInfo.FileName*>"
  overload: System.Diagnostics.ProcessStartInfo.Verbs*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.WindowStyle
  id: WindowStyle
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: WindowStyle
  nameWithType: ProcessStartInfo.WindowStyle
  fullName: System.Diagnostics.ProcessStartInfo.WindowStyle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define o estado de janela a utilizar quando iniciar o processo."
  remarks: ''
  example:
  - >-
    [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_42_1.vb)]
     [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_42_1.cs)]
     [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_42_1.cpp)]
  syntax:
    content: public System.Diagnostics.ProcessWindowStyle WindowStyle { get; set; }
    return:
      type: System.Diagnostics.ProcessWindowStyle
      description: "Um dos valores de enumeração que indica se o processo é iniciado numa janela que é maximizada, minimizado, normal (nenhum maximizado nem minimizado), ou não visível. A predefinição é <xref uid=&quot;langword_csharp_Normal&quot; name=&quot;Normal&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.WindowStyle*
  exceptions:
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "O estilo de janela não é um do <xref href=&quot;System.Diagnostics.ProcessWindowStyle&quot;> </xref> membros de enumeração."
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.WorkingDirectory
  id: WorkingDirectory
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: WorkingDirectory
  nameWithType: ProcessStartInfo.WorkingDirectory
  fullName: System.Diagnostics.ProcessStartInfo.WorkingDirectory
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Quando o <> </> *> propriedade é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>, obtém ou define o diretório de trabalho para o processo de ser iniciadas. Quando <> </> *> é <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, obtém ou define o diretório que contém o processo de ser iniciadas."
  remarks: "> [!IMPORTANT]\n>  The WorkingDirectory property must be set if <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> and <xref:System.Diagnostics.ProcessStartInfo.Password%2A> are provided. If the property is not set, the default working directory is %SYSTEMROOT%\\system32.  \n  \n If the directory is already part of the system path variable, you do not have to repeat the directory's location in this property.  \n  \n The WorkingDirectory property behaves differently when <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` than when <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `false`. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true`, the WorkingDirectory property specifies the location of the executable. If WorkingDirectory is an empty string, the current directory is understood to contain the executable.  \n  \n> [!NOTE]\n>  When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true`, the working directory of the application that starts the executable is also the working directory of the executable.  \n  \n When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `false`, the WorkingDirectory property is not used to find the executable. Instead, its value applies to the process that is started and only has meaning within the context of the new process."
  syntax:
    content: public string WorkingDirectory { get; set; }
    return:
      type: System.String
      description: "Quando <> </> *> é <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, o nome completamente qualificado do diretório que contém o processo de ser iniciadas. Quando o <> </> *> propriedade é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>, o diretório de trabalho para o processo de ser iniciadas. A predefinição é uma cadeia vazia (&quot;&quot;)."
  overload: System.Diagnostics.ProcessStartInfo.WorkingDirectory*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.Diagnostics.ProcessStartInfo.#ctor
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ProcessStartInfo()
  nameWithType: ProcessStartInfo.ProcessStartInfo()
  fullName: System.Diagnostics.ProcessStartInfo.ProcessStartInfo()
- uid: System.Diagnostics.ProcessStartInfo.#ctor(System.String)
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ProcessStartInfo(String)
  nameWithType: ProcessStartInfo.ProcessStartInfo(String)
  fullName: System.Diagnostics.ProcessStartInfo.ProcessStartInfo(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Diagnostics.ProcessStartInfo.#ctor(System.String,System.String)
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ProcessStartInfo(String,String)
  nameWithType: ProcessStartInfo.ProcessStartInfo(String,String)
  fullName: System.Diagnostics.ProcessStartInfo.ProcessStartInfo(String,String)
- uid: System.Diagnostics.ProcessStartInfo.Arguments
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Arguments
  nameWithType: ProcessStartInfo.Arguments
  fullName: System.Diagnostics.ProcessStartInfo.Arguments
- uid: System.Diagnostics.ProcessStartInfo.CreateNoWindow
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: CreateNoWindow
  nameWithType: ProcessStartInfo.CreateNoWindow
  fullName: System.Diagnostics.ProcessStartInfo.CreateNoWindow
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Diagnostics.ProcessStartInfo.Domain
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Domain
  nameWithType: ProcessStartInfo.Domain
  fullName: System.Diagnostics.ProcessStartInfo.Domain
- uid: System.Diagnostics.ProcessStartInfo.Environment
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Environment
  nameWithType: ProcessStartInfo.Environment
  fullName: System.Diagnostics.ProcessStartInfo.Environment
- uid: System.Collections.Generic.IDictionary{System.String,System.String}
  parent: System.Collections.Generic
  isExternal: true
  name: IDictionary<String,String>
  nameWithType: IDictionary<String,String>
  fullName: System.Collections.Generic.IDictionary<System.String,System.String>
  spec.csharp:
  - uid: System.Collections.Generic.IDictionary`2
    name: IDictionary
    nameWithType: IDictionary
    fullName: IDictionary<System.String,System.String>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Diagnostics.ProcessStartInfo.EnvironmentVariables
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: EnvironmentVariables
  nameWithType: ProcessStartInfo.EnvironmentVariables
  fullName: System.Diagnostics.ProcessStartInfo.EnvironmentVariables
- uid: System.Collections.Specialized.StringDictionary
  parent: System.Collections.Specialized
  isExternal: false
  name: StringDictionary
  nameWithType: StringDictionary
  fullName: System.Collections.Specialized.StringDictionary
- uid: System.Diagnostics.ProcessStartInfo.ErrorDialog
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ErrorDialog
  nameWithType: ProcessStartInfo.ErrorDialog
  fullName: System.Diagnostics.ProcessStartInfo.ErrorDialog
- uid: System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ErrorDialogParentHandle
  nameWithType: ProcessStartInfo.ErrorDialogParentHandle
  fullName: System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Diagnostics.ProcessStartInfo.FileName
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: FileName
  nameWithType: ProcessStartInfo.FileName
  fullName: System.Diagnostics.ProcessStartInfo.FileName
- uid: System.Diagnostics.ProcessStartInfo.LoadUserProfile
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: LoadUserProfile
  nameWithType: ProcessStartInfo.LoadUserProfile
  fullName: System.Diagnostics.ProcessStartInfo.LoadUserProfile
- uid: System.Diagnostics.ProcessStartInfo.Password
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Password
  nameWithType: ProcessStartInfo.Password
  fullName: System.Diagnostics.ProcessStartInfo.Password
- uid: System.Security.SecureString
  parent: System.Security
  isExternal: false
  name: SecureString
  nameWithType: SecureString
  fullName: System.Security.SecureString
- uid: System.Diagnostics.ProcessStartInfo.PasswordInClearText
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: PasswordInClearText
  nameWithType: ProcessStartInfo.PasswordInClearText
  fullName: System.Diagnostics.ProcessStartInfo.PasswordInClearText
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardError
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: RedirectStandardError
  nameWithType: ProcessStartInfo.RedirectStandardError
  fullName: System.Diagnostics.ProcessStartInfo.RedirectStandardError
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardInput
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: RedirectStandardInput
  nameWithType: ProcessStartInfo.RedirectStandardInput
  fullName: System.Diagnostics.ProcessStartInfo.RedirectStandardInput
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: RedirectStandardOutput
  nameWithType: ProcessStartInfo.RedirectStandardOutput
  fullName: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
- uid: System.Diagnostics.ProcessStartInfo.StandardErrorEncoding
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: StandardErrorEncoding
  nameWithType: ProcessStartInfo.StandardErrorEncoding
  fullName: System.Diagnostics.ProcessStartInfo.StandardErrorEncoding
- uid: System.Text.Encoding
  parent: System.Text
  isExternal: true
  name: Encoding
  nameWithType: Encoding
  fullName: System.Text.Encoding
- uid: System.Diagnostics.ProcessStartInfo.StandardOutputEncoding
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: StandardOutputEncoding
  nameWithType: ProcessStartInfo.StandardOutputEncoding
  fullName: System.Diagnostics.ProcessStartInfo.StandardOutputEncoding
- uid: System.Diagnostics.ProcessStartInfo.UserName
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: UserName
  nameWithType: ProcessStartInfo.UserName
  fullName: System.Diagnostics.ProcessStartInfo.UserName
- uid: System.Diagnostics.ProcessStartInfo.UseShellExecute
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: UseShellExecute
  nameWithType: ProcessStartInfo.UseShellExecute
  fullName: System.Diagnostics.ProcessStartInfo.UseShellExecute
- uid: System.Diagnostics.ProcessStartInfo.Verb
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Verb
  nameWithType: ProcessStartInfo.Verb
  fullName: System.Diagnostics.ProcessStartInfo.Verb
- uid: System.Diagnostics.ProcessStartInfo.Verbs
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Verbs
  nameWithType: ProcessStartInfo.Verbs
  fullName: System.Diagnostics.ProcessStartInfo.Verbs
- uid: System.String[]
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.ProcessStartInfo.WindowStyle
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: WindowStyle
  nameWithType: ProcessStartInfo.WindowStyle
  fullName: System.Diagnostics.ProcessStartInfo.WindowStyle
- uid: System.Diagnostics.ProcessWindowStyle
  parent: System.Diagnostics
  isExternal: false
  name: ProcessWindowStyle
  nameWithType: ProcessWindowStyle
  fullName: System.Diagnostics.ProcessWindowStyle
- uid: System.Diagnostics.ProcessStartInfo.WorkingDirectory
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: WorkingDirectory
  nameWithType: ProcessStartInfo.WorkingDirectory
  fullName: System.Diagnostics.ProcessStartInfo.WorkingDirectory
- uid: System.Diagnostics.ProcessStartInfo.#ctor*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ProcessStartInfo
  nameWithType: ProcessStartInfo.ProcessStartInfo
- uid: System.Diagnostics.ProcessStartInfo.Arguments*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Arguments
  nameWithType: ProcessStartInfo.Arguments
- uid: System.Diagnostics.ProcessStartInfo.CreateNoWindow*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: CreateNoWindow
  nameWithType: ProcessStartInfo.CreateNoWindow
- uid: System.Diagnostics.ProcessStartInfo.Domain*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Domain
  nameWithType: ProcessStartInfo.Domain
- uid: System.Diagnostics.ProcessStartInfo.Environment*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Environment
  nameWithType: ProcessStartInfo.Environment
- uid: System.Diagnostics.ProcessStartInfo.EnvironmentVariables*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: EnvironmentVariables
  nameWithType: ProcessStartInfo.EnvironmentVariables
- uid: System.Diagnostics.ProcessStartInfo.ErrorDialog*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ErrorDialog
  nameWithType: ProcessStartInfo.ErrorDialog
- uid: System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ErrorDialogParentHandle
  nameWithType: ProcessStartInfo.ErrorDialogParentHandle
- uid: System.Diagnostics.ProcessStartInfo.FileName*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: FileName
  nameWithType: ProcessStartInfo.FileName
- uid: System.Diagnostics.ProcessStartInfo.LoadUserProfile*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: LoadUserProfile
  nameWithType: ProcessStartInfo.LoadUserProfile
- uid: System.Diagnostics.ProcessStartInfo.Password*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Password
  nameWithType: ProcessStartInfo.Password
- uid: System.Diagnostics.ProcessStartInfo.PasswordInClearText*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: PasswordInClearText
  nameWithType: ProcessStartInfo.PasswordInClearText
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardError*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: RedirectStandardError
  nameWithType: ProcessStartInfo.RedirectStandardError
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardInput*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: RedirectStandardInput
  nameWithType: ProcessStartInfo.RedirectStandardInput
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: RedirectStandardOutput
  nameWithType: ProcessStartInfo.RedirectStandardOutput
- uid: System.Diagnostics.ProcessStartInfo.StandardErrorEncoding*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: StandardErrorEncoding
  nameWithType: ProcessStartInfo.StandardErrorEncoding
- uid: System.Diagnostics.ProcessStartInfo.StandardOutputEncoding*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: StandardOutputEncoding
  nameWithType: ProcessStartInfo.StandardOutputEncoding
- uid: System.Diagnostics.ProcessStartInfo.UserName*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: UserName
  nameWithType: ProcessStartInfo.UserName
- uid: System.Diagnostics.ProcessStartInfo.UseShellExecute*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: UseShellExecute
  nameWithType: ProcessStartInfo.UseShellExecute
- uid: System.Diagnostics.ProcessStartInfo.Verb*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Verb
  nameWithType: ProcessStartInfo.Verb
- uid: System.Diagnostics.ProcessStartInfo.Verbs*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Verbs
  nameWithType: ProcessStartInfo.Verbs
- uid: System.Diagnostics.ProcessStartInfo.WindowStyle*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: WindowStyle
  nameWithType: ProcessStartInfo.WindowStyle
- uid: System.Diagnostics.ProcessStartInfo.WorkingDirectory*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: WorkingDirectory
  nameWithType: ProcessStartInfo.WorkingDirectory
