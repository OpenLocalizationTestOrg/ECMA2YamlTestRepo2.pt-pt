### YamlMime:ManagedReference
items:
- uid: Microsoft.VisualBasic.FileSystem
  id: FileSystem
  children:
  - Microsoft.VisualBasic.FileSystem.ChDir(System.String)
  - Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)
  - Microsoft.VisualBasic.FileSystem.ChDrive(System.String)
  - Microsoft.VisualBasic.FileSystem.CurDir
  - Microsoft.VisualBasic.FileSystem.CurDir(System.Char)
  - Microsoft.VisualBasic.FileSystem.Dir
  - Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  - Microsoft.VisualBasic.FileSystem.EOF(System.Int32)
  - Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)
  - Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])
  - Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)
  - Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileLen(System.String)
  - Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)
  - Microsoft.VisualBasic.FileSystem.FreeFile
  - Microsoft.VisualBasic.FileSystem.GetAttr(System.String)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)
  - Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)
  - Microsoft.VisualBasic.FileSystem.Kill(System.String)
  - Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Loc(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)
  - Microsoft.VisualBasic.FileSystem.LOF(System.Int32)
  - Microsoft.VisualBasic.FileSystem.MkDir(System.String)
  - Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])
  - Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])
  - Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)
  - Microsoft.VisualBasic.FileSystem.Reset
  - Microsoft.VisualBasic.FileSystem.RmDir(System.String)
  - Microsoft.VisualBasic.FileSystem.Seek(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  - Microsoft.VisualBasic.FileSystem.SPC(System.Int16)
  - Microsoft.VisualBasic.FileSystem.TAB
  - Microsoft.VisualBasic.FileSystem.TAB(System.Int16)
  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)
  - Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])
  - Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])
  langs:
  - csharp
  name: FileSystem
  nameWithType: FileSystem
  fullName: Microsoft.VisualBasic.FileSystem
  type: Class
  summary: "O <xref uid=&quot;langword_csharp_FileSystem&quot; name=&quot;FileSystem&quot; href=&quot;&quot;> </xref> módulo contém procedimentos que são utilizados para efetuar operações de ficheiro, diretório ou pasta e do sistema. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe maior produtividade e desempenho em operações de e/s de ficheiro ao utilizar o <xref uid=&quot;langword_csharp_FileSystem&quot; name=&quot;FileSystem&quot; href=&quot;&quot;> </xref> módulo. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Este módulo suporta as palavras-chave de linguagem do Visual Basic e membros de biblioteca de tempo de execução que acedam a ficheiros e pastas."
  example:
  - "This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.  \n  \n [!code-vb[VbVbalrCatRef#25](~/add/codesnippet/visualbasic/t-microsoft.visualbasic._17_1.vb)]"
  syntax:
    content: >-
      [Microsoft.VisualBasic.CompilerServices.StandardModule]

      [System.Security.SecurityCritical]

      public sealed class FileSystem
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.ChDir(System.String)
  id: ChDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: ChDir(String)
  nameWithType: FileSystem.ChDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDir(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Altera o diretório atual ou a pasta. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe maior produtividade e desempenho em operações de e/s de ficheiro que o <xref uid=&quot;langword_csharp_ChDir &quot; name=&quot;ChDir &quot; href=&quot;&quot;> </xref>função. Para obter mais informações, consulte <xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>"
  remarks: "O `ChDir` função altera o diretório predefinido, mas não a unidade de predefinição. Por exemplo, se a unidade de predefinição está C, a seguinte instrução altera o diretório predefinido na unidade D, mas C permanece unidade predefinida: [!code-vb [VbVbalrCatRef&#39;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._177_1.vb) ] pode efetuar relativo é alterado de diretório, escrevendo dois períodos, da seguinte forma: [!code-vb [VbVbalrCatRef&#40;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._177_2.vb) ]       >  [!IMPORTANT] > o `ChDir` função necessita de permissão de código não gerido, pode afetar a respetiva execução em situações de fidedignidade parcial. Para obter mais informações, consulte <xref:System.Security.Permissions.SecurityPermission>e.</xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "This example uses the `ChDir` function to change the current directory or folder.  \n  \n [!code-vb[VbVbalrCatRef#41](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._177_3.vb)]"
  syntax:
    content: public static void ChDir (string Path);
    parameters:
    - id: Path
      type: System.String
      description: "Necessário. A <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> expressão que identifica o diretório ou uma pasta torna-se o novo diretório predefinido ou pasta. `Path`Pode incluir a unidade. Não se for especificada nenhuma unidade, <xref uid=&quot;langword_csharp_ChDir&quot; name=&quot;ChDir&quot; href=&quot;&quot;> </xref> altera o diretório predefinido ou uma pasta no disco atual."
  overload: Microsoft.VisualBasic.FileSystem.ChDir*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Path</code>está vazio."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Unidade inválida foi especificada ou unidade não está disponível."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)
  id: ChDrive(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: ChDrive(Char)
  nameWithType: FileSystem.ChDrive(Char)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(Char)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Altera a unidade atual."
  remarks: "O `ChDrive` função necessita de permissão de código não gerido, pode afetar a respetiva execução em situações de fidedignidade parcial. Para obter mais informações, consulte <xref:System.Security.Permissions.SecurityPermission>e [permissões de acesso de código](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).</xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "This example uses the `ChDrive` function to change the current drive. The function throws an exception if the drive does not exist.  \n  \n [!code-vb[VbVbalrCatRef#32](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._181_1.vb)]"
  syntax:
    content: public static void ChDrive (char Drive);
    parameters:
    - id: Drive
      type: System.Char
      description: "Necessário. Expressão de cadeia que especifica uma unidade existente. Se fornecer uma cadeia de comprimento zero (&quot;&quot;), a unidade atual não é alterado. Se o `Drive` argumento é uma cadeia de carateres de múltiplos, <xref uid=&quot;langword_csharp_ChDrive&quot; name=&quot;ChDrive&quot; href=&quot;&quot;> </xref> utiliza apenas a primeira letra."
  overload: Microsoft.VisualBasic.FileSystem.ChDrive*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Unidade inválida foi especificada ou unidade não está disponível."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.String)
  id: ChDrive(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: ChDrive(String)
  nameWithType: FileSystem.ChDrive(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Altera a unidade atual."
  remarks: "O `ChDrive` função necessita de permissão de código não gerido, pode afetar a respetiva execução em situações de fidedignidade parcial. Para obter mais informações, consulte <xref:System.Security.Permissions.SecurityPermission>e [permissões de acesso de código](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).</xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "This example uses the `ChDrive` function to change the current drive. The function throws an exception if the drive does not exist.  \n  \n [!code-vb[VbVbalrCatRef#32](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._225_1.vb)]"
  syntax:
    content: public static void ChDrive (string Drive);
    parameters:
    - id: Drive
      type: System.String
      description: "Necessário. Expressão de cadeia que especifica uma unidade existente. Se fornecer uma cadeia de comprimento zero (&quot;&quot;), a unidade atual não é alterado. Se o `Drive` argumento é uma cadeia de carateres de múltiplos, <xref uid=&quot;langword_csharp_ChDrive&quot; name=&quot;ChDrive&quot; href=&quot;&quot;> </xref> utiliza apenas a primeira letra."
  overload: Microsoft.VisualBasic.FileSystem.ChDrive*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Unidade inválida foi especificada ou unidade não está disponível."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.CurDir
  id: CurDir
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: CurDir()
  nameWithType: FileSystem.CurDir()
  fullName: Microsoft.VisualBasic.FileSystem.CurDir()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Devolve uma cadeia que representa o caminho atual. O <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_CurDir&quot; name=&quot;CurDir&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>"
  remarks: ''
  example:
  - "This example uses the `CurDir` function to return the current path.  \n  \n [!code-vb[VbVbalrCatRef#65](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._123_1.vb)]"
  syntax:
    content: public static string CurDir ();
    parameters: []
    return:
      type: System.String
      description: "Uma cadeia que representa o caminho atual."
  overload: Microsoft.VisualBasic.FileSystem.CurDir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.CurDir(System.Char)
  id: CurDir(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: CurDir(Char)
  nameWithType: FileSystem.CurDir(Char)
  fullName: Microsoft.VisualBasic.FileSystem.CurDir(Char)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Devolve uma cadeia que representa o caminho atual. O <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_CurDir&quot; name=&quot;CurDir&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>"
  remarks: ''
  example:
  - "This example uses the `CurDir` function to return the current path.  \n  \n [!code-vb[VbVbalrCatRef#65](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._203_1.vb)]"
  syntax:
    content: public static string CurDir (char Drive);
    parameters:
    - id: Drive
      type: System.Char
      description: "Opcional. <xref uid=&quot;langword_csharp_Char&quot; name=&quot;Char&quot; href=&quot;&quot;></xref>expressão que especifica uma unidade existente. Se não for especificada nenhuma unidade ou se `Drive` é uma cadeia de comprimento zero (&quot;&quot;), <xref uid=&quot;langword_csharp_CurDir&quot; name=&quot;CurDir&quot; href=&quot;&quot;> </xref> devolve o caminho para a unidade atual."
    return:
      type: System.String
      description: "Uma cadeia que representa o caminho atual."
  overload: Microsoft.VisualBasic.FileSystem.CurDir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Dir
  id: Dir
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Dir()
  nameWithType: FileSystem.Dir()
  fullName: Microsoft.VisualBasic.FileSystem.Dir()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Devolve uma cadeia que representa o nome de um diretório, ficheiro ou pasta que corresponde ao padrão especificado ou o atributo de ficheiro ou a etiqueta do volume de uma unidade. O <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> dá-lhe maior produtividade e desempenho em operações de e/s de ficheiro que o <xref uid=&quot;langword_csharp_Dir&quot; name=&quot;Dir&quot; href=&quot;&quot;> </xref> função. Consulte <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>para obter mais informações.</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>"
  remarks: "O `Dir` função suporta a utilização de carateres de múltiplos (`*`) e caráter (`?`) carateres universais para especificar vários ficheiros.       `VbVolume`Devolve a etiqueta de volume para a unidade em vez do nome de ficheiro específico.       Tem de fornecer um `PathName` na primeira vez que tem de chamar o `Dir` função. Para obter o item seguinte, pode efetuar as chamadas subsequentes para o `Dir` função sem parâmetros.      > [!IMPORTANT] > Funcione corretamente, o `Dir` função requer o <xref:System.Security.Permissions.FileIOPermissionAccess>e <xref:System.Security.Permissions.FileIOPermissionAccess>sinalizadores de <xref:System.Security.Permissions.FileIOPermission>para ser concedida para o código em execução.</xref:System.Security.Permissions.FileIOPermission> </xref:System.Security.Permissions.FileIOPermissionAccess> </xref:System.Security.Permissions.FileIOPermissionAccess> Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, e [permissões de acesso de código](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).</xref:System.Security.SecurityException> </xref:System.Security.Permissions.FileIOPermission>       O `Attributes` valores de enumeração de argumento são os seguintes: |||   |-|-|-|   | Valor | Constante | Descrição |   | `Normal`|`vbnormal`| A predefinição. Especifica os ficheiros sem atributos. |   | `ReadOnly`|`vbReadOnly`| Especifica os ficheiros só de leitura bem como ficheiros sem atributos. |   | `Hidden`|`vbHidden`| Especifica oculto e também ficheiros sem atributos. |   | `System`|`vbSystem`| Especifica os ficheiros de sistema bem como ficheiros sem atributos. |   | `Volume`|`vbVolume`| Especifica a etiqueta de volume Se não for especificado qualquer outro atributo, `vbVolume` é ignorada. |   | `Directory`|`vbDirectory`| Especifica os diretórios ou de pastas e ficheiros também sem atributos. |   | `Archive`|`vbArchive`| O ficheiro foi alterado desde a última cópia de segurança. |   | `Alias`|`vbAlias`| O ficheiro tem um nome diferente. |      > [!NOTE] > Estes enumerações são especificadas pela linguagem Visual Basic e pode ser utilizadas em qualquer lugar no seu código em vez dos valores reais."
  example:
  - "This example uses the `Dir` function to check if certain files and directories exist.  \n  \n [!code-vb[VbVbalrCatRef#3](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._44_1.vb)]"
  syntax:
    content: public static string Dir ();
    parameters: []
    return:
      type: System.String
      description: "Uma cadeia que representa o nome de um diretório, ficheiro ou pasta que corresponde ao padrão especificado ou o atributo de ficheiro ou a etiqueta do volume de uma unidade."
  overload: Microsoft.VisualBasic.FileSystem.Dir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  id: Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Dir(String,FileAttribute)
  nameWithType: FileSystem.Dir(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.Dir(String,FileAttribute)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Devolve uma cadeia que representa o nome de um diretório, ficheiro ou pasta que corresponde ao padrão especificado ou o atributo de ficheiro ou a etiqueta do volume de uma unidade. O <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> dá-lhe maior produtividade e desempenho em operações de e/s de ficheiro que o <xref uid=&quot;langword_csharp_Dir&quot; name=&quot;Dir&quot; href=&quot;&quot;> </xref> função. Consulte <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>para obter mais informações.</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>"
  remarks: "O `Dir` função suporta a utilização de carateres de múltiplos (`*`) e caráter (`?`) carateres universais para especificar vários ficheiros.       `VbVolume`Devolve a etiqueta de volume para a unidade em vez do nome de ficheiro específico.       Tem de fornecer um `PathName` na primeira vez que tem de chamar o `Dir` função. Para obter o item seguinte, pode efetuar as chamadas subsequentes para o `Dir` função sem parâmetros.      > [!IMPORTANT] > Funcione corretamente, o `Dir` função requer o <xref:System.Security.Permissions.FileIOPermissionAccess>e <xref:System.Security.Permissions.FileIOPermissionAccess>sinalizadores de <xref:System.Security.Permissions.FileIOPermission>para ser concedida para o código em execução.</xref:System.Security.Permissions.FileIOPermission> </xref:System.Security.Permissions.FileIOPermissionAccess> </xref:System.Security.Permissions.FileIOPermissionAccess> Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, e [permissões de acesso de código](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).</xref:System.Security.SecurityException> </xref:System.Security.Permissions.FileIOPermission>       O `Attributes` valores de enumeração de argumento são os seguintes: |||   |-|-|-|   | Valor | Constante | Descrição |   | `Normal`|`vbnormal`| A predefinição. Especifica os ficheiros que tenham sem atributos. |   | `ReadOnly`|`vbReadOnly`| Especifica os ficheiros só de leitura para além dos ficheiros que tenham sem atributos. |   | `Hidden`|`vbHidden`| Especifica os ficheiros ocultos, para além dos ficheiros que tenham sem atributos. |   | `System`|`vbSystem`| Especifica os ficheiros de sistema, para além dos ficheiros que tenham sem atributos. |   | `Volume`|`vbVolume`| Especifica a etiqueta de volume Se não for especificado qualquer outro atributo, `vbVolume` é ignorada. |   | `Directory`|`vbDirectory`| Especifica o diretórios ou de pastas, além disso, para os ficheiros que tenham sem atributos. |   | `Archive`|`vbArchive`| O ficheiro foi alterado desde a última cópia de segurança. |   | `Alias`|`vbAlias`| O ficheiro tem um nome diferente. |      > [!NOTE] > Estes enumerações são especificadas pela linguagem Visual Basic e pode ser utilizadas em qualquer lugar no seu código em vez dos valores reais."
  example:
  - "This example uses the `Dir` function to check if certain files and directories exist.  \n  \n [!code-vb[VbVbalrCatRef#3](~/add/codesnippet/visualbasic/0bb37160-d621-482a-af3b-_1.vb)]"
  syntax:
    content: public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);
    parameters:
    - id: PathName
      type: System.String
      description: "Opcional. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>expressão que especifica um nome de ficheiro, nome de diretório ou uma pasta ou etiqueta do volume de unidade. Uma cadeia de comprimento zero (<xref uid=&quot;langword_csharp_&quot;&quot;&quot; name=&quot;&quot;&quot;&quot; href=&quot;&quot;></xref>) é devolvido se `PathName` não foi encontrado."
    - id: Attributes
      type: Microsoft.VisualBasic.FileAttribute
      description: "Opcional. Enumeração ou expressão numérica cujo valor Especifica atributos de ficheiro. Se for omitido, <xref uid=&quot;langword_csharp_Dir&quot; name=&quot;Dir&quot; href=&quot;&quot;> </xref> devolve os ficheiros que correspondam `PathName` mas ter sem atributos."
    return:
      type: System.String
      description: "Uma cadeia que representa o nome de um diretório, ficheiro ou pasta que corresponde ao padrão especificado ou o atributo de ficheiro ou a etiqueta do volume de uma unidade."
  overload: Microsoft.VisualBasic.FileSystem.Dir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.EOF(System.Int32)
  id: EOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: EOF(Int32)
  nameWithType: FileSystem.EOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.EOF(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Devolve um valor booleano <xref uid=&quot;langword_csharp_True&quot; name=&quot;True&quot; href=&quot;&quot;> </xref> quando o fim de um ficheiro aberto para <xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> ou sequenciais <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref> foi atingido."
  remarks: "Utilize `EOF` para evitar erros gerados ao tentar obter foi ultrapassado o fim de um ficheiro.       O `EOF` funcionar devolve `False` até foi atingido o fim do ficheiro. Com ficheiros abertos para `Random` ou `Binary` acesso, `EOF` devolve `False` até que o último executado `FileGet` função não é possível ler um registo de todo.       Com ficheiros abertos para `Binary` aceder a uma tentativa de leitura de ficheiros com o `Input` funcionar até que `EOF` devolve `True` gera um erro. Utilize o `LOF` e `Loc` funciona em vez de `EOF` ao ler os ficheiros binários com `Input`, ou utilize `Get` ao utilizar o `EOF` função. Com ficheiros abertos para `Output`, `EOF` sempre devolve `True`."
  example:
  - "This example uses the `EOF` function to detect the end of a file. This example assumes that `Testfile` is a text file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#62](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._184_1.vb)]"
  syntax:
    content: public static bool EOF (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Um <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> que contém a qualquer número de ficheiro válido."
    return:
      type: System.Boolean
      description: "Devolve um valor booleano <xref uid=&quot;langword_csharp_True&quot; name=&quot;True&quot; href=&quot;&quot;> </xref> quando o fim de um ficheiro aberto para <xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> ou sequenciais <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref> foi atingido."
  overload: Microsoft.VisualBasic.FileSystem.EOF*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)
  id: FileAttr(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileAttr(Int32)
  nameWithType: FileSystem.FileAttr(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileAttr(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Devolve uma enumeração que representa o modo de ficheiros para ficheiros abertos com o <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> função. O <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> dá-lhe maior produtividade e desempenho em operações de e/s de ficheiro que o <xref uid=&quot;langword_csharp_FileAttr &quot; name=&quot;FileAttr &quot; href=&quot;&quot;> </xref>função. Consulte <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>para obter mais informações.</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>"
  remarks: "Esta função devolve uma enumeração que representa o modo de ficheiros para ficheiros abertos com o `FileOpen` função."
  example:
  - "This example uses the `FileAttr` function to return the file mode of an open file.  \n  \n [!code-vb[VbVbalrCatRef#46](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._147_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;></xref>. Qualquer número de ficheiro válido."
    return:
      type: Microsoft.VisualBasic.OpenMode
      description: "Os seguintes valores de enumeração indicam o modo de acesso do ficheiro:       <table><tbody><tr><td> Valor       </td><td> Modo       </td></tr><tr><td> 1       </td><td><xref uid=&quot;langword_csharp_OpenMode.Input&quot; name=&quot;OpenMode.Input&quot; href=&quot;&quot;></xref></td></tr><tr><td> 2       </td><td><xref uid=&quot;langword_csharp_OpenMode.Output&quot; name=&quot;OpenMode.Output&quot; href=&quot;&quot;></xref></td></tr><tr><td> 4       </td><td><xref uid=&quot;langword_csharp_OpenMode.Random&quot; name=&quot;OpenMode.Random&quot; href=&quot;&quot;></xref></td></tr><tr><td> 8       </td><td><xref uid=&quot;langword_csharp_OpenMode.Append&quot; name=&quot;OpenMode.Append&quot; href=&quot;&quot;></xref></td></tr><tr><td> 32       </td><td><xref uid=&quot;langword_csharp_OpenMode.Binary&quot; name=&quot;OpenMode.Binary&quot; href=&quot;&quot;></xref></td></tr></tbody></table>"
  overload: Microsoft.VisualBasic.FileSystem.FileAttr*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])
  id: FileClose(System.Int32[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileClose(Int32[])
  nameWithType: FileSystem.FileClose(Int32[])
  fullName: Microsoft.VisualBasic.FileSystem.FileClose(Int32[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Conclui a entrada/saída (e/s) para um ficheiro aberto utilizando o <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> função. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;></xref>dá-lhe maior produtividade e desempenho em operações de e/s de ficheiro. Consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> para obter mais informações."
  remarks: "O `FileClose` função é fornecida para compatibilidade com versões anteriores e poderá afetar o desempenho. Para aplicações não legado, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [como: texto de leitura de ficheiros com um StreamReader](~/add/includes/ajax-current-ext-md.md),[como: escrever texto para os ficheiros com um StreamWriter](~/add/includes/ajax-current-ext-md.md), e [explicação passo a passo: manipulação de ficheiros e diretórios em Visual Basic](~/add/includes/ajax-current-ext-md.md).       Se omitir `FileNumbers`, todos os ficheiros de Active Directory aberto pelo `FileOpen` função estão fechadas.       Quando fechar ficheiros que foram abertos para `Output` ou `Append`, a memória intermédia do final de saída é escrita na memória intermédia de sistema operativo para esse ficheiro. Todos os a memória intermédia espaço associado a fechado ficheiro é lançado.       Quando o `FileClose` função for executada, a associação de um ficheiro com o respetivo ficheiro number termina."
  example:
  - "This example uses the `FileClose`function to close a file opened for `Input`.  \n  \n [!code-vb[VbVbalrCatRef#69](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._41_1.vb)]"
  syntax:
    content: public static void FileClose (int[] FileNumbers);
    parameters:
    - id: FileNumbers
      type: System.Int32[]
      description: "Opcional. Matriz dos parâmetros de 0 ou mais canais a ser fechado."
  overload: Microsoft.VisualBasic.FileSystem.FileClose*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileNumber</code>não existe."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)
  id: FileCopy(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileCopy(String,String)
  nameWithType: FileSystem.FileCopy(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.FileCopy(String,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Copia um ficheiro. O <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FileCopy&quot; name=&quot;FileCopy&quot; href=&quot;&quot;> </xref>. Consulte <xref:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile*>para obter mais informações.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile*>"
  remarks: "Se tentar utilizar o `FileCopy` funcionar num ficheiro atualmente aberto, ocorre um erro.       `FileCopy`requer uma fidedignidade total para funcionar no disco local."
  example:
  - "This example uses the `FileCopy` function to copy one file to another. For purposes of this example, assume that `SrcFile` is a file that contains data.  \n  \n [!code-vb[VbVbalrCatRef#2](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._96_1.vb)]"
  syntax:
    content: public static void FileCopy (string Source, string Destination);
    parameters:
    - id: Source
      type: System.String
      description: "Necessário. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>expressão que especifica o nome do ficheiro a ser copiado. `Source`Pode incluir o diretório ou pasta e unidade, o ficheiro de origem."
    - id: Destination
      type: System.String
      description: "Necessário. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>expressão que especifica o nome de ficheiro de destino. `Destination`Pode incluir o diretório ou pasta e unidade, o ficheiro de destino."
  overload: Microsoft.VisualBasic.FileSystem.FileCopy*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Source</code>ou <code>Destination</code> é inválido ou não foi especificado."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ficheiro já está aberto."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "O ficheiro não existe."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)
  id: FileDateTime(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileDateTime(String)
  nameWithType: FileSystem.FileDateTime(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileDateTime(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Devolve um <xref uid=&quot;langword_csharp_Date&quot; name=&quot;Date&quot; href=&quot;&quot;> </xref> valor que indica a data e hora de um ficheiro foi escrito. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FileDateTime&quot; name=&quot;FileDateTime&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte<xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*></xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>"
  remarks: ''
  example:
  - "This example uses the `FileDateTime` function to determine the date and time a file was created or last modified. The format of the date and time displayed is based on the locale settings of the system.  \n  \n [!code-vb[VbVbalrCatRef#34](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._22_1.vb)]"
  syntax:
    content: public static DateTime FileDateTime (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "Necessário. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>expressão que especifica um nome de ficheiro. `PathName`Pode incluir o diretório ou pasta e unidade."
    return:
      type: System.DateTime
      description: "<xref uid=&quot;langword_csharp_Date&quot; name=&quot;Date&quot; href=&quot;&quot;></xref>valor que indica a data e hora de um ficheiro foi criado ou modificado pela última vez."
  overload: Microsoft.VisualBasic.FileSystem.FileDateTime*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>PathName</code>é inválido ou contiver carateres universais."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Ficheiro de destino não existe."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)
  id: FileGet(System.Int32,System.Boolean@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Boolean,Int64)
  nameWithType: FileSystem.FileGet(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Boolean,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê os dados de um ficheiro de disco aberto numa variável. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/ad6628f8-6ae5-47af-a394-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.Boolean
      description: "Necessário. Nome de variável válido para o qual é lido dados."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registos (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> ficheiros do modo) ou um número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> ficheiros do modo) em que a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 e não igual a -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)
  id: FileGet(System.Int32,System.Byte@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Byte,Int64)
  nameWithType: FileSystem.FileGet(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Byte,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê os dados de um ficheiro de disco aberto numa variável. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic`parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used. Then the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/9daa1fad-0f67-40af-bac0-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.Byte
      description: "Necessário. Nome de variável válido para o qual é lido dados."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registos (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> ficheiros do modo) ou um número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> ficheiros do modo) em que a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 e não igual a -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)
  id: FileGet(System.Int32,System.Char@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Char,Int64)
  nameWithType: FileSystem.FileGet(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Char,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê os dados de um ficheiro de disco aberto numa variável. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic`parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/31a532e9-297f-48c8-a186-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.Char
      description: "Necessário. Nome de variável válido para o qual é lido dados."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registos (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> ficheiros do modo) ou um número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> ficheiros do modo) em que a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 e não igual a -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)
  id: FileGet(System.Int32,System.DateTime@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,DateTime,Int64)
  nameWithType: FileSystem.FileGet(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,DateTime,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê os dados de um ficheiro de disco aberto numa variável. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function,`FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/d9877ddb-692f-47fe-8c26-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.DateTime
      description: "Necessário. Nome de variável válido para o qual é lido dados."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registos (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> ficheiros do modo) ou um número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> ficheiros do modo) em que a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 e não igual a -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)
  id: FileGet(System.Int32,System.Decimal@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Decimal,Int64)
  nameWithType: FileSystem.FileGet(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Decimal,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê os dados de um ficheiro de disco aberto numa variável. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/3d9f416d-1287-4566-b3fa-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.Decimal
      description: "Necessário. Nome de variável válido para o qual é lido dados."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registos (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> ficheiros do modo) ou um número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> ficheiros do modo) em que a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 e não igual a -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)
  id: FileGet(System.Int32,System.Double@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Double,Int64)
  nameWithType: FileSystem.FileGet(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Double,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê os dados de um ficheiro de disco aberto numa variável. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/184fee0e-b744-4669-8fdf-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.Double
      description: "Necessário. Nome de variável válido para o qual é lido dados."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registos (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> ficheiros do modo) ou um número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> ficheiros do modo) em que a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 e não igual a -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)
  id: FileGet(System.Int32,System.Int16@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Int16,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int16,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê os dados de um ficheiro de disco aberto numa variável. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic`parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/45e0fdff-455b-4fd4-a7c2-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.Int16
      description: "Necessário. Nome de variável válido para o qual é lido dados."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registos (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> ficheiros do modo) ou um número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> ficheiros do modo) em que a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 e não igual a -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)
  id: FileGet(System.Int32,System.Int32@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Int32,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê os dados de um ficheiro de disco aberto numa variável. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/7db3ee1c-ee17-457b-bd2d-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.Int32
      description: "Necessário. Nome de variável válido para o qual é lido dados."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registos (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> ficheiros do modo) ou um número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> ficheiros do modo) em que a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 e não igual a -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)
  id: FileGet(System.Int32,System.Int64@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Int64,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê os dados de um ficheiro de disco aberto numa variável. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/bd48d1ef-82ea-4239-8c9b-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.Int64
      description: "Necessário. Nome de variável válido para o qual é lido dados."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registos (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> ficheiros do modo) ou um número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> ficheiros do modo) em que a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 e não igual a -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)
  id: FileGet(System.Int32,System.Single@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Single,Int64)
  nameWithType: FileSystem.FileGet(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Single,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê os dados de um ficheiro de disco aberto numa variável. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/79f9948f-e0d0-41fe-a7b5-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.Single
      description: "Necessário. Nome de variável válido para o qual é lido dados."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registos (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> ficheiros do modo) ou um número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> ficheiros do modo) em que a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 e não igual a -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)
  id: FileGet(System.Int32,System.ValueType@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,ValueType,Int64)
  nameWithType: FileSystem.FileGet(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,ValueType,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê os dados de um ficheiro de disco aberto numa variável. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/f351f02c-d919-4d73-938f-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.ValueType
      description: "Necessário. Nome de variável válido para o qual é lido dados."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registos (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> ficheiros do modo) ou um número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> ficheiros do modo) em que a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 e não igual a -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  id: FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FileGet(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,String,Int64,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê os dados de um ficheiro de disco aberto numa variável. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/cefffea4-17eb-455d-be3e-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.String
      description: "Necessário. Nome de variável válido para o qual é lido dados."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registos (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> ficheiros do modo) ou um número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> ficheiros do modo) em que a leitura começa."
    - id: StringIsFixedLength
      type: System.Boolean
      description: "Opcional. Aplica-se apenas ao escrever uma cadeia. Especifica se pretende um descritor de dois bytes para a cadeia que descreve o comprimento de escrita. A predefinição é <xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 e não igual a -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  id: FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê os dados de um ficheiro de disco aberto numa variável. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the starting of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/c053ec00-d593-49bf-a3cb-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.Array
      description: "Necessário. Nome de variável válido para o qual é lido dados."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registos (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> ficheiros do modo) ou um número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> ficheiros do modo) em que a leitura começa."
    - id: ArrayIsDynamic
      type: System.Boolean
      description: "Opcional. Aplica-se apenas ao escrever uma matriz. Especifica se a matriz é deve ser tratado como dinâmico e se é necessário um descritor de matriz que descrevem o tamanho e limites da matriz."
    - id: StringIsFixedLength
      type: System.Boolean
      description: "Opcional. Aplica-se apenas ao escrever uma cadeia. Especifica se pretende um descritor de dois bytes para a cadeia que descreve o comprimento de escrita. A predefinição é <xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 e não igual a -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)
  id: FileGetObject(System.Int32,System.Object@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGetObject(Int32,Object,Int64)
  nameWithType: FileSystem.FileGetObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGetObject(Int32,Object,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê os dados de um ficheiro de disco aberto numa variável.  O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FileGetObject&quot; name=&quot;FileGetObject&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "The `FileGetObject` function is used instead of `FileGet` to avoid ambiguities at compile time if type `Object` is returned instead of another type, such as `Integer`, `Long`, `Short`, and so forth.  \n  \n If you intend to write out the `Variant` type, `FileGetObject` is required. When in doubt, if you are using an object for the second parameter, it is always suggested that you use `FilePutObject` and `FileGetObject`.  \n  \n `FileGetObject` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGetObject` is usually written with `FilePutObject`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, `FileGetObject` reads the record or byte after the last `FileGetObject` or `FilePutObject` function (or pointed to by the last `Seek` function).  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGetObject` reads subsequent records on record-length boundaries. The space between the end of one record and the beginning of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be precisely determined, it is a good idea to have the record length match the length of the data being read.  \n  \n-   If the variable being read into is a string, by default `FileGetObject` reads a two-byte descriptor containing the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings and when read to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, then the record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: 2 + 8 * NumberOfDimensions.  \n  \n     For example, the following array declaration requires 218 bytes when the array is written to disk:  \n  \n     [!code-vb[VbVbalrCatRef#27](~/add/codesnippet/visualbasic/16450c3e-87c4-4606-9e31-_1.vb)]  \n  \n     The 218 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2), and 100 bytes for the data (5 \\* 10 \\* 4).  \n  \n-   `FileGetObject` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePutObject`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: 2 + 8 * NumberOfDimensions. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements, including any arrays and their descriptors. The <xref:Microsoft.VisualBasic.VBFixedStringAttribute> class can be applied to string fields in the structures to indicate the size of string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, all of the `Random` rules apply, with these exceptions:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGetObject`reads all variables from disk contiguously, that is, with no padding between records.  \n  \n-   For any array other than an array in a structure, `FileGetObject` reads only the data. No descriptor is read.  \n  \n `FileGetObject` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file named Form1.vb may not be a Visual Basic source file."
  example:
  - "The following example reads a record into a test file and then retrieves it.  \n  \n [!code-vb[VbVbalrCatRef#26](~/add/codesnippet/visualbasic/16450c3e-87c4-4606-9e31-_2.vb)]"
  syntax:
    content: public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.Object
      description: "Necessário. Nome de variável válido para o qual é lido dados."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registos (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> ficheiros do modo) ou um número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> ficheiros do modo) em que a leitura começa."
  overload: Microsoft.VisualBasic.FileSystem.FileGetObject*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileLen(System.String)
  id: FileLen(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileLen(String)
  nameWithType: FileSystem.FileLen(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileLen(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Devolve um <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> valor que especifica o comprimento de um ficheiro em bytes. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FileLen&quot; name=&quot;FileLen&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>"
  remarks: "Se o ficheiro especificado é aberta quando a `FileLen` denomina-se a função, o valor devolvido representa o tamanho do ficheiro no momento foi aberto.      > [!NOTE] > Para obter o comprimento de um ficheiro aberto atual, utilize o `LOF` função."
  example:
  - "This example uses the `FileLen` function to return the length of a file in bytes. For purposes of this example, assume that `TestFile` is a file that contains some data.  \n  \n [!code-vb[VbVbalrCatRef#1](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._122_1.vb)]"
  syntax:
    content: public static long FileLen (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "Necessário. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>expressão que especifica um ficheiro. `PathName`Pode incluir o diretório ou pasta e unidade."
    return:
      type: System.Int64
      description: "<xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;></xref>valor que especifica o comprimento de um ficheiro em bytes."
  overload: Microsoft.VisualBasic.FileSystem.FileLen*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "O ficheiro não existe."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  id: FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  nameWithType: FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Abre um ficheiro de entrada ou saída. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "O `FileOpen` função é fornecida para compatibilidade com versões anteriores e poderá afetar o desempenho. Para aplicações não legado, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a ficheiros com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Tem de abrir um ficheiro antes de qualquer operação de e/s pode ser efetuada no mesmo. `FileOpen`atribui uma memória intermédia para e/s para o ficheiro e determina o modo de acesso para utilizar com a memória intermédia.      > [!IMPORTANT] > Quando são escritos num ficheiro, uma aplicação poderá ter de criar um ficheiro, se o ficheiro ao qual está a tentar escrever não existe. Para tal, tem permissão para o diretório no qual o ficheiro está a ser criado. No entanto, se o ficheiro especificado pelo `FileName` existir, a aplicação deverá `Write` permissão apenas para o próprio ficheiro. Onde quer que possível, para ajudar a melhorar a segurança, criar o ficheiro durante a implementação e conceder `Write` permissão para esse ficheiro único, em vez de para o diretório de todo. Para ajudar a melhorar a segurança, escreva dados diretórios de utilizador em vez de para o diretório de raiz ou o diretório de ficheiros de programa.       O canal para abrir pode ser encontrado utilizando o `FreeFile()` função.      > [!IMPORTANT] > O `FileOpen` função requer `Read` aceder a partir de `FileIOPermissionAccess` enumeração, que pode afetar a respetiva execução em situações de fidedignidade parcial. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>enumeração.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example illustrates various uses of the `FileOpen` function to enable input and output to a file.  \n  \n The following code opens the file `TestFile` in `Input` mode.  \n  \n [!code-vb[VbVbalrCatRef#5](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_1.vb)]  \n  \n This example opens the file in `Binary` mode for writing operations only.  \n  \n [!code-vb[VbVbalrCatRef#6](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_2.vb)]  \n  \n The following example opens the file in `Random` mode. The file contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#7](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_3.vb)]  \n  \n This code example opens the file in `Output` mode; any process can read or write to file.  \n  \n [!code-vb[VbVbalrCatRef#8](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_4.vb)]  \n  \n This code example opens the file in `Binary` mode for reading; other processes cannot read file.  \n  \n [!code-vb[VbVbalrCatRef#9](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_5.vb)]"
  syntax:
    content: public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido. Utilize o <xref uid=&quot;langword_csharp_FreeFile&quot; name=&quot;FreeFile&quot; href=&quot;&quot;> </xref> função para obter o número de ficheiros disponível seguinte."
    - id: FileName
      type: System.String
      description: "Necessário. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>expressão que especifica um nome de ficheiro — pode incluir diretórios ou de pasta e unidade."
    - id: Mode
      type: Microsoft.VisualBasic.OpenMode
      description: 'Necessário. Enumeration specifying the file mode: <xref uid=&quot;langword_csharp_Append&quot; name=&quot;Append&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Output&quot; name=&quot;Output&quot; href=&quot;&quot;></xref>, or <xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;></xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.OpenMode&quot;> </xref> .'
    - id: Access
      type: Microsoft.VisualBasic.OpenAccess
      description: 'Opcional. Especificar as operações de enumeração permitidas no ficheiro aberto: <xref uid=&quot;langword_csharp_Read&quot; name=&quot;Read&quot; href=&quot;&quot;> </xref>, <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref>, ou <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref>. Por predefinição <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.OpenAccess&quot;> </xref> .'
    - id: Share
      type: Microsoft.VisualBasic.OpenShare
      description: 'Opcional. Especificar as operações não permitidas no ficheiro aberto por outros processos de enumeração: <xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref>, <xref uid=&quot;langword_csharp_Lock Read&quot; name=&quot;Lock Read&quot; href=&quot;&quot;> </xref>, <xref uid=&quot;langword_csharp_Lock Write&quot; name=&quot;Lock Write&quot; href=&quot;&quot;> </xref>, e <xref uid=&quot;langword_csharp_Lock Read Write&quot; name=&quot;Lock Read Write&quot; href=&quot;&quot;> </xref>. Por predefinição <xref uid=&quot;langword_csharp_Lock Read Write&quot; name=&quot;Lock Read Write&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.OpenShare&quot;> </xref> .'
    - id: RecordLength
      type: System.Int32
      description: "Opcional. Número menor ou igual a 32,767 (bytes). Para ficheiros abertos para acesso aleatório, este valor é o período de registo. Para ficheiros sequenciais, este valor é o número de carateres em memória intermédia."
  overload: Microsoft.VisualBasic.FileSystem.FileOpen*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Comprimento do registo é negativo (e não igual a -1)."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileName</code>já está aberto, ou <code>FileName</code> é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)
  id: FilePut(System.Int32,System.Boolean,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Boolean,Int64)
  nameWithType: FileSystem.FilePut(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Boolean,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Escreve dados de uma variável de um ficheiro de disco. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`só é válido em `Random` e `Binary` modo.       Os dados escritos com `FilePut` normalmente é de leitura de um ficheiro ao utilizar `FileGet`.       O primeiro registo ou byte num ficheiro está na posição 1, o segundo registo ou um byte na posição 2 e assim sucessivamente. Se omitir `RecordNumber`, o seguinte registo ou byte após a última `FileGet` ou `FilePut` funcionar ou indicada pelo último `Seek` função é escrita.       O `StringIsFixedLength` argumento controla se a função interpreta cadeias como comprimento variável ou fixo. `FilePut`não escrever o descritor de comprimento quando o argumento é `True`. Se utilizar `StringIsFixedLength`  =  `True` com `FilePut`, terá de fazer o mesmo com `FileGet`, e tem de certificar-se de que a cadeia é inicializada para o comprimento esperado.      ## Aleatórios para o modo ficheiros abertos no `Random` modo, as seguintes regras aplicam-se: - se o comprimento dos dados que está a ser escritos é inferior ao comprimento especificado no `RecordLength` cláusula o `FileOpen` função, `FilePut` escreve subsequentes registos nos limites de comprimento do registo. O espaço entre o fim de um registo e o início do registo seguinte será preenchido com os conteúdos da memória intermédia ficheiros existentes. Porque não é possível determinar a quantidade de dados de preenchimento com qualquer certainty, normalmente, é boa ideia ter o comprimento de registo coincide com o comprimento dos dados que está a ser escritos. Se o comprimento dos dados que está a ser escritos é superior ao comprimento especificado no `RecordLength` cláusula o `FileOpen`função, irá ser emitida uma exceção.      -Se a variável que está a ser escrita é uma cadeia, `FilePut` escreve um descritor de dois bytes que contém o comprimento da cadeia e, em seguida, escreve os dados que vai para a variável. Por conseguinte, o comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que o comprimento real da cadeia de, pelo menos, dois bytes.      -Se a variável que está a ser escrita é um objeto que contém um tipo numérico, `FilePut` escreve dois bytes identificar o `VarType` do objeto e, em seguida, escreve a variável. Por exemplo, quando escrever um objeto que contém um número inteiro, `FilePut` escreve bytes seis: dois bytes que identificam o objeto como `VarType(`3`)` (`Integer`) e quatro bytes que contém os dados. O comprimento de registo especificado pelo `RecordLength` parâmetro o `FileOpen` função tem de ser maior que o número real de bytes necessário para armazenar a variável, pelo menos, dois bytes.      -Se a variável que está a ser escrita é um objeto que contém uma cadeia, `FilePut` escreve um descritor de dois bytes identificar o `VarType(`8`)` do objeto, um descritor de dois bytes que indica que o comprimento da cadeia e, em seguida, escreve os dados de cadeia. O comprimento de registo especificado pelo `RecordLength` parâmetro o `FileOpen` função tem de ser maior que o comprimento real da cadeia de, pelo menos, quatro bytes. Se pretender colocar uma cadeia sem o descritor, deverá passar `True` para o `StringIsFixedLength` parâmetro e a cadeia lido no deve ser igual ao período correto.      -Se a variável que está a ser escrita é uma matriz, tem uma opção para escrever um descritor de tamanho e dimensões da matriz ou não. O descritor de ficheiros para uma matriz dinâmica mas não para uma matriz de tamanho fixo de escrita Visual Basic 6.0 e versões anteriores. Visual Basic 2005 será assumida a não escrever o descritor. Para escrever o descritor, defina o `ArrayIsDynamic` parâmetro `True`. Ao escrever a matriz, tem de corresponder a forma como serão lidos a matriz; se será possível lê-lo com o descritor, terá de escrever o descritor. O descritor de Especifica a posição da matriz, o tamanho e os limites inferiores para cada classificação. O for igual ao comprimento 2 plus 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que ou igual à soma de todos os bytes necessários para escrever os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz necessita de 218 bytes quando a matriz é escrita no disco.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/b684b977-357d-4475-a2d0-_1.vb) ] - se a variável que está a ser escrita é qualquer outro tipo de variável (não uma cadeia de comprimento variável ou um objeto), `FilePut` escreve apenas os dados da variável. O comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que ou igual ao comprimento dos dados que está a ser escritos.      - `FilePut` escreve os elementos de estruturas como se cada foram escrita individualmente, mas não há nenhum preenchimento entre elementos. O `VBFixedString` atributo pode ser aplicado aos campos de cadeia em estruturas para indicar o tamanho da cadeia quando escrito no disco.          > [!NOTE] > Cadeia campos que tenham mais de bytes que o especificado pelo `VBFixedString` atributo estão truncados ao escrito no disco, # # modo binário para ficheiros abertos no `Binary` modo, a maioria do `Random` modo regras aplicam-se, com algumas exceções. As seguintes regras para ficheiros abertos no `Binary` modo diferem das regras para `Random` modo: - `RecordLength` cláusula no `FileOpen` função não tem qualquer efeito. `FilePut`escreve todas as variáveis para o disco contiguamente, ou seja, sem o preenchimento entre registos.      -Para nenhuma matriz de que não seja uma matriz de uma estrutura, `FilePut` escreve apenas os dados. Não existem descritor é escrito.      - `FilePut` escreve cadeias de comprimento variável que não são elementos de estruturas sem o descritor de dois bytes de comprimento. O número de bytes escritos iguala o número de carateres da cadeia. Por exemplo, as seguintes declarações de escrever 11 bytes para o número de ficheiros 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/b684b977-357d-4475-a2d0-_2.vb) ] - escrever um ficheiro ao utilizar o `FilePut` função requer `Write` aceder a partir do <xref:System.Security.Permissions.FileIOPermissionAccess>enumeração.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/b684b977-357d-4475-a2d0-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.Boolean
      description: "Necessário. Nome de variável válido que contenha os dados escritos no disco."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registos (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> ficheiros do modo) ou um número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> ficheiros do modo) em que escrever é iniciado."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 e não igual a -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)
  id: FilePut(System.Int32,System.Byte,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Byte,Int64)
  nameWithType: FileSystem.FilePut(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Byte,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Escreve dados de uma variável de um ficheiro de disco. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`só é válido em `Random` e `Binary` modo.       Os dados escritos com `FilePut` normalmente é de leitura de um ficheiro ao utilizar `FileGet`.       O primeiro registo ou byte num ficheiro está na posição 1, o segundo registo ou um byte na posição 2 e assim sucessivamente. Se omitir `RecordNumber`, o seguinte registo ou byte após a última `FileGet` ou `FilePut` funcionar ou indicada pelo último `Seek` função é escrita.       O `StringIsFixedLength` argumento controla se a função interpreta cadeias como comprimento variável ou fixo. `FilePut`não escrever o descritor de comprimento quando o argumento é `True`. Se utilizar `StringIsFixedLength`  =  `True` com `FilePut`, terá de fazer o mesmo com `FileGet`, e tem de certificar-se de que a cadeia é inicializada para o comprimento esperado.      ## Aleatórios para o modo ficheiros abertos no `Random` modo, as seguintes regras aplicam-se: - se o comprimento dos dados que está a ser escritos é inferior ao comprimento especificado no `RecordLength` cláusula o `FileOpen` função, `FilePut` escreve subsequentes registos nos limites de comprimento do registo. O espaço entre o fim de um registo e o início do registo seguinte será preenchido com os conteúdos da memória intermédia ficheiros existentes. Porque não é possível determinar a quantidade de dados de preenchimento com qualquer certainty, normalmente, é boa ideia ter o comprimento de registo coincide com o comprimento dos dados que está a ser escritos. Se o comprimento dos dados que está a ser escritos é superior ao comprimento especificado no `RecordLength` cláusula o `FileOpen` função, irá ser emitida uma exceção.      -Se a variável que está a ser escrita é uma cadeia, `FilePut` escreve um descritor de dois bytes que contém o comprimento da cadeia e, em seguida, escreve os dados que vai para a variável. Por conseguinte, o comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que o comprimento real da cadeia de, pelo menos, dois bytes.      -Se a variável que está a ser escrita é um objeto que contém um tipo numérico, `FilePut` escreve dois bytes identificar o `VarType` do objeto e, em seguida, escreve a variável. Por exemplo, quando escrever um objeto que contém um número inteiro, `FilePut` escreve bytes seis: dois bytes que identificam o objeto como `VarType(`3`)` (`Integer`) e quatro bytes que contém os dados. O comprimento de registo especificado pelo `RecordLength` parâmetro o `FileOpen` função tem de ser maior que o número real de bytes necessário para armazenar a variável, pelo menos, dois bytes.      -Se a variável que está a ser escrita é um objeto que contém uma cadeia, `FilePut` escreve um descritor de dois bytes identificar o `VarType(`8`)` do objeto, um descritor de dois bytes que indica que o comprimento da cadeia e, em seguida, escreve os dados de cadeia. O comprimento de registo especificado pelo `RecordLength` parâmetro o `FileOpen` função tem de ser maior que o comprimento real da cadeia de, pelo menos, quatro bytes. Se pretender colocar uma cadeia sem o descritor, deverá passar `True` para o `StringIsFixedLength` parâmetro e a cadeia lido no deve ser igual ao período correto.      -Se a variável que está a ser escrita é uma matriz, tem uma opção para escrever um descritor de tamanho e dimensões da matriz ou não. O descritor de ficheiros para uma matriz dinâmica mas não para uma matriz de tamanho fixo de escrita Visual Basic 6.0 e versões anteriores. Visual Basic 2005 será assumida a não escrever o descritor. Para escrever o descritor, defina o `ArrayIsDynamic` parâmetro `True`. Ao escrever a matriz, tem de corresponder a forma como serão lidos a matriz; se será possível lê-lo com o descritor, terá de escrever o descritor. O descritor de Especifica a posição da matriz, o tamanho e os limites inferiores para cada classificação. O for igual ao comprimento 2 plus 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que ou igual à soma de todos os bytes necessários para escrever os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz necessita de 218 bytes quando a matriz é escrita no disco.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/2a393bee-4ca7-4317-bbe9-_1.vb) ] - se a variável que está a ser escrita é qualquer outro tipo de variável (não uma cadeia de comprimento variável ou um objeto), `FilePut` escreve apenas os dados da variável. O comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que ou igual ao comprimento dos dados que está a ser escritos.      - `FilePut` escreve os elementos de estruturas como se cada foram escrita individualmente, mas não há nenhum preenchimento entre elementos. O `VBFixedString` atributo pode ser aplicado aos campos de cadeia em estruturas para indicar o tamanho da cadeia quando escrito no disco.          > [!NOTE] > Cadeia campos que tenham mais de bytes que o especificado pelo `VBFixedString` atributo estão truncados ao escrito no disco, # # modo binário para ficheiros abertos no `Binary` modo, a maioria do `Random` modo regras aplicam-se, com algumas exceções. As seguintes regras para ficheiros abertos no `Binary` modo diferem das regras para `Random` modo: - `RecordLength` cláusula no `FileOpen` função não tem qualquer efeito. `FilePut`escreve todas as variáveis para o disco contiguamente, ou seja, sem o preenchimento entre registos.      -Para nenhuma matriz de que não seja uma matriz de uma estrutura, `FilePut` escreve apenas os dados. Não existem descritor é escrito.      - `FilePut` escreve cadeias de comprimento variável que não são elementos de estruturas sem o descritor de dois bytes de comprimento. O número de bytes escritos iguala o número de carateres da cadeia. Por exemplo, as seguintes declarações de escrever 11 bytes para o número de ficheiros 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/2a393bee-4ca7-4317-bbe9-_2.vb) ] - escrever um ficheiro ao utilizar o `FilePut` função requer `Write` aceder a partir do <xref:System.Security.Permissions.FileIOPermissionAccess>enumeração.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/2a393bee-4ca7-4317-bbe9-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.Byte
      description: "Necessário. Nome de variável válido que contenha os dados escritos no disco."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registos (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> ficheiros do modo) ou um número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> ficheiros do modo) em que escrever é iniciado."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 e não igual a -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)
  id: FilePut(System.Int32,System.Char,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Char,Int64)
  nameWithType: FileSystem.FilePut(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Char,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Escreve dados de uma variável de um ficheiro de disco. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`só é válido em `Random` e `Binary` modo.       Os dados escritos com `FilePut` normalmente é de leitura de um ficheiro ao utilizar `FileGet`.       O primeiro registo ou byte num ficheiro está na posição 1, o segundo registo ou um byte na posição 2 e assim sucessivamente. Se omitir `RecordNumber`, o seguinte registo ou byte após a última `FileGet` ou `FilePut` funcionar ou indicada pelo último `Seek` função é escrita.       O `StringIsFixedLength` argumento controla se a função interpreta cadeias como comprimento variável ou fixo. `FilePut`não escrever o descritor de comprimento quando o argumento é `True`. Se utilizar `StringIsFixedLength`  =  `True` com `FilePut`, terá de fazer o mesmo com `FileGet`, e tem de certificar-se de que a cadeia é inicializada para o comprimento esperado.      ## Aleatórios para o modo ficheiros abertos no `Random` modo, as seguintes regras aplicam-se: - se o comprimento dos dados que está a ser escritos é inferior ao comprimento especificado no `RecordLength` cláusula o `FileOpen` função, `FilePut` escreve subsequentes registos nos limites de comprimento do registo. O espaço entre o fim de um registo e o início do registo seguinte será preenchido com os conteúdos da memória intermédia ficheiros existentes. Porque não é possível determinar a quantidade de dados de preenchimento com qualquer certainty, normalmente, é boa ideia ter o comprimento de registo coincide com o comprimento dos dados que está a ser escritos. Se o comprimento dos dados que está a ser escritos é superior ao comprimento especificado no `RecordLength` cláusula o `FileOpen` função, irá ser emitida uma exceção.      -Se a variável que está a ser escrita é uma cadeia, `FilePut` escreve um descritor de dois bytes que contém o comprimento da cadeia e, em seguida, escreve os dados que vai para a variável. Por conseguinte, o comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que o comprimento real da cadeia de, pelo menos, dois bytes.      -Se a variável que está a ser escrita é um objeto que contém um tipo numérico, `FilePut` escreve dois bytes identificar o `VarType` do objeto e, em seguida, escreve a variável. Por exemplo, quando escrever um objeto que contém um número inteiro, `FilePut` escreve bytes seis: dois bytes que identificam o objeto como `VarType(`3`)` (`Integer`) e quatro bytes que contém os dados. O comprimento de registo especificado pelo `RecordLength` parâmetro o `FileOpen` função tem de ser maior que o número real de bytes necessário para armazenar a variável, pelo menos, dois bytes.      -Se a variável que está a ser escrita é um objeto que contém uma cadeia, `FilePut` escreve um descritor de dois bytes identificar o `VarType(`8`)` do objeto, um descritor de dois bytes que indica que o comprimento da cadeia e, em seguida, escreve os dados de cadeia. O comprimento de registo especificado pelo `RecordLength` parâmetro o `FileOpen` função tem de ser maior que o comprimento real da cadeia de, pelo menos, quatro bytes. Se pretender colocar uma cadeia sem o descritor, deverá passar `True` para o `StringIsFixedLength` parâmetro e a cadeia lido no deve ser igual ao período correto.      -Se a variável que está a ser escrita é uma matriz, tem uma opção para escrever um descritor de tamanho e dimensões da matriz ou não. O descritor de ficheiros para uma matriz dinâmica mas não para uma matriz de tamanho fixo de escrita Visual Basic 6.0 e versões anteriores. Visual Basic 2005 será assumida a não escrever o descritor. Para escrever o descritor, defina o `ArrayIsDynamic` parâmetro `True`. Ao escrever a matriz, tem de corresponder a forma como serão lidos a matriz; se será possível lê-lo com o descritor, terá de escrever o descritor. O descritor de Especifica a posição da matriz, o tamanho e os limites inferiores para cada classificação. O for igual ao comprimento 2 plus 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que ou igual à soma de todos os bytes necessários para escrever os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz necessita de 218 bytes quando a matriz é escrita no disco.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/f7dbd668-3841-4860-9fe2-_1.vb) ] - se a variável que está a ser escrita é qualquer outro tipo de variável (não uma cadeia de comprimento variável ou um objeto), `FilePut` escreve apenas os dados da variável. O comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que ou igual ao comprimento dos dados que está a ser escritos.      - `FilePut` escreve os elementos de estruturas como se cada foram escrita individualmente, mas não há nenhum preenchimento entre elementos. O `VBFixedString` atributo pode ser aplicado aos campos de cadeia em estruturas para indicar o tamanho da cadeia quando escrito no disco.          > [!NOTE] > Cadeia campos que tenham mais de bytes que o especificado pelo `VBFixedString` atributo estão truncados ao escrito no disco, # # modo binário para ficheiros abertos no `Binary` modo, a maioria do `Random` modo regras aplicam-se, com algumas exceções. As seguintes regras para ficheiros abertos no `Binary` modo diferem das regras para `Random` modo: - `RecordLength` cláusula no `FileOpen` função não tem qualquer efeito. `FilePut`escreve todas as variáveis para o disco contiguamente, ou seja, sem o preenchimento entre registos.      -Para nenhuma matriz de que não seja uma matriz de uma estrutura, `FilePut` escreve apenas os dados. Não existem descritor é escrito.      - `FilePut` escreve cadeias de comprimento variável que não são elementos de estruturas sem o descritor de dois bytes de comprimento. O número de bytes escritos iguala o número de carateres da cadeia. Por exemplo, as seguintes declarações de escrever 11 bytes para o número de ficheiros 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/f7dbd668-3841-4860-9fe2-_2.vb) ] - escrever um ficheiro ao utilizar o `FilePut` função requer `Write` aceder a partir do <xref:System.Security.Permissions.FileIOPermissionAccess>enumeração.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/f7dbd668-3841-4860-9fe2-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.Char
      description: "Necessário. Nome de variável válido que contenha os dados escritos no disco."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registos (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> ficheiros do modo) ou um número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> ficheiros do modo) em que escrever é iniciado."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 e não igual a -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)
  id: FilePut(System.Int32,System.DateTime,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,DateTime,Int64)
  nameWithType: FileSystem.FilePut(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,DateTime,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Escreve dados de uma variável de um ficheiro de disco. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`só é válido em `Random` e `Binary` modo.       Os dados escritos com `FilePut` normalmente é de leitura de um ficheiro ao utilizar `FileGet`.       O primeiro registo ou byte num ficheiro está na posição 1, o segundo registo ou um byte na posição 2 e assim sucessivamente. Se omitir `RecordNumber`, o seguinte registo ou byte após a última `FileGet` ou `FilePut` funcionar ou indicada pelo último `Seek` função é escrita.       O `StringIsFixedLength` argumento controla se a função interpreta cadeias como comprimento variável ou fixo. `FilePut`não escrever o descritor de comprimento quando o argumento é `True`. Se utilizar `StringIsFixedLength`  =  `True` com `FilePut`, terá de fazer o mesmo com `FileGet`, e tem de certificar-se de que a cadeia é inicializada para o comprimento esperado.      ## Aleatórios para o modo ficheiros abertos no `Random` modo, as seguintes regras aplicam-se: - se o comprimento dos dados que está a ser escritos é inferior ao comprimento especificado no `RecordLength` cláusula o `FileOpen` função, `FilePut` escreve subsequentes registos nos limites de comprimento do registo. O espaço entre o fim de um registo e o início do registo seguinte será preenchido com os conteúdos da memória intermédia ficheiros existentes. Porque não é possível determinar a quantidade de dados de preenchimento com qualquer certainty, normalmente, é boa ideia ter o comprimento de registo coincide com o comprimento dos dados que está a ser escritos. Se o comprimento dos dados que está a ser escritos é superior ao comprimento especificado no `RecordLength` cláusula o `FileOpen` função, irá ser emitida uma exceção.      -Se a variável que está a ser escrita é uma cadeia, `FilePut` escreve um descritor de dois bytes que contém o comprimento da cadeia e, em seguida, escreve os dados que vai para a variável. Por conseguinte, o comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que o comprimento real da cadeia de, pelo menos, dois bytes.      -Se a variável que está a ser escrita é um objeto que contém um tipo numérico, `FilePut` escreve dois bytes identificar o `VarType` do objeto e, em seguida, escreve a variável. Por exemplo, quando escrever um objeto que contém um número inteiro, `FilePut` escreve bytes seis: dois bytes que identificam o objeto como `VarType(`3`)` (`Integer`) e quatro bytes que contém os dados. O comprimento de registo especificado pelo `RecordLength` parâmetro o `FileOpen` função tem de ser maior que o número real de bytes necessário para armazenar a variável, pelo menos, dois bytes.      -Se a variável que está a ser escrita é um objeto que contém uma cadeia, `FilePut` escreve um descritor de dois bytes identificar o `VarType(`8`)` do objeto, um descritor de dois bytes que indica que o comprimento da cadeia e, em seguida, escreve os dados de cadeia. O comprimento de registo especificado pelo `RecordLength` parâmetro o `FileOpen` função tem de ser maior que o comprimento real da cadeia de, pelo menos, quatro bytes. Se pretender colocar uma cadeia sem o descritor, deverá passar `True` para o `StringIsFixedLength` parâmetro e a cadeia lido no deve ser igual ao período correto.      -Se a variável que está a ser escrita é uma matriz, tem uma opção para escrever um descritor de tamanho e dimensões da matriz ou não. O descritor de ficheiros para uma matriz dinâmica mas não para uma matriz de tamanho fixo de escrita Visual Basic 6.0 e versões anteriores. Visual Basic 2005 será assumida a não escrever o descritor. Para escrever o descritor, defina o `ArrayIsDynamic` parâmetro `True`. Ao escrever a matriz, tem de corresponder a forma como serão lidos a matriz; se será possível lê-lo com o descritor, terá de escrever o descritor. O descritor de Especifica a posição da matriz, o tamanho e os limites inferiores para cada classificação. O for igual ao comprimento 2 plus 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que ou igual à soma de todos os bytes necessários para escrever os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz necessita de 218 bytes quando a matriz é escrita no disco.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/30fdf8e5-a84c-499e-8f20-_1.vb) ] - se a variável que está a ser escrita é qualquer outro tipo de variável (não uma cadeia de comprimento variável ou um objeto), `FilePut` escreve apenas os dados da variável. O comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que ou igual ao comprimento dos dados que está a ser escritos.      - `FilePut` escreve os elementos de estruturas como se cada foram escrita individualmente, mas não há nenhum preenchimento entre elementos. O `VBFixedString` atributo pode ser aplicado aos campos de cadeia em estruturas para indicar o tamanho da cadeia quando escrito no disco.          > [!NOTE] > Cadeia campos que tenham mais de bytes que o especificado pelo `VBFixedString` atributo estão truncados ao escrito no disco, # # modo binário para ficheiros abertos no `Binary` modo, a maioria do `Random` modo regras aplicam-se, com algumas exceções. As seguintes regras para ficheiros abertos no `Binary` modo diferem das regras para `Random` modo: - `RecordLength` cláusula no `FileOpen` função não tem qualquer efeito. `FilePut`escreve todas as variáveis para o disco contiguamente, ou seja, sem o preenchimento entre registos.      -Para nenhuma matriz de que não seja uma matriz de uma estrutura, `FilePut` escreve apenas os dados. Não existem descritor é escrito.      - `FilePut` escreve cadeias de comprimento variável que não são elementos de estruturas sem o descritor de dois bytes de comprimento. O número de bytes escritos iguala o número de carateres da cadeia. Por exemplo, as seguintes declarações de escrever 11 bytes para o número de ficheiros 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/30fdf8e5-a84c-499e-8f20-_2.vb) ] - escrever um ficheiro ao utilizar o `FilePut` função requer `Write` aceder a partir do <xref:System.Security.Permissions.FileIOPermissionAccess>enumeração.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/30fdf8e5-a84c-499e-8f20-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.DateTime
      description: "Necessário. Nome de variável válido que contenha os dados escritos no disco."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registos (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> ficheiros do modo) ou um número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> ficheiros do modo) em que escrever é iniciado."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 e não igual a -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)
  id: FilePut(System.Int32,System.Decimal,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Decimal,Int64)
  nameWithType: FileSystem.FilePut(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Decimal,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Escreve dados de uma variável de um ficheiro de disco. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`só é válido em `Random` e `Binary` modo.       Os dados escritos com `FilePut` normalmente é de leitura de um ficheiro ao utilizar `FileGet`.       O primeiro registo ou byte num ficheiro está na posição 1, o segundo registo ou um byte na posição 2 e assim sucessivamente. Se omitir `RecordNumber`, o seguinte registo ou byte após a última `FileGet` ou `FilePut` funcionar ou indicada pelo último `Seek` função é escrita.       O `StringIsFixedLength` argumento controla se a função interpreta cadeias como comprimento variável ou fixo. `FilePut`não escrever o descritor de comprimento quando o argumento é `True`. Se utilizar `StringIsFixedLength`  =  `True` com `FilePut`, terá de fazer o mesmo com `FileGet`, e tem de certificar-se de que a cadeia é inicializada para o comprimento esperado.      ## Aleatórios para o modo ficheiros abertos no `Random` modo, as seguintes regras aplicam-se: - se o comprimento dos dados que está a ser escritos é inferior ao comprimento especificado no `RecordLength` cláusula o `FileOpen` função, `FilePut` escreve subsequentes registos nos limites de comprimento do registo. O espaço entre o fim de um registo e o início do registo seguinte será preenchido com os conteúdos da memória intermédia ficheiros existentes. Porque não é possível determinar a quantidade de dados de preenchimento com qualquer certainty, normalmente, é boa ideia ter o comprimento de registo coincide com o comprimento dos dados que está a ser escritos. Se o comprimento dos dados que está a ser escritos é superior ao comprimento especificado no `RecordLength` cláusula o `FileOpen` função, irá ser emitida uma exceção.      -Se a variável que está a ser escrita é uma cadeia, `FilePut` escreve um descritor de dois bytes que contém o comprimento da cadeia e, em seguida, escreve os dados que vai para a variável. Por conseguinte, o comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que o comprimento real da cadeia de, pelo menos, dois bytes.      -Se a variável que está a ser escrita é um objeto que contém um tipo numérico, `FilePut` escreve dois bytes identificar o `VarType` do objeto e, em seguida, escreve a variável. Por exemplo, quando escrever um objeto que contém um número inteiro, `FilePut` escreve bytes seis: dois bytes que identificam o objeto como `VarType(`3`)` (`Integer`) e quatro bytes que contém os dados. O comprimento de registo especificado pelo `RecordLength` parâmetro o `FileOpen` função tem de ser maior que o número real de bytes necessário para armazenar a variável, pelo menos, dois bytes.      -Se a variável que está a ser escrita é um objeto que contém uma cadeia, `FilePut` escreve um descritor de dois bytes identificar o `VarType(`8`)` do objeto, um descritor de dois bytes que indica que o comprimento da cadeia e, em seguida, escreve os dados de cadeia. O comprimento de registo especificado pelo `RecordLength` parâmetro o `FileOpen` função tem de ser maior que o comprimento real da cadeia de, pelo menos, quatro bytes. Se pretender colocar uma cadeia sem o descritor, deverá passar `True` para o `StringIsFixedLength` parâmetro e a cadeia lido no deve ser igual ao período correto.      -Se a variável que está a ser escrita é uma matriz, tem uma opção para escrever um descritor de tamanho e dimensões da matriz ou não. O descritor de ficheiros para uma matriz dinâmica mas não para uma matriz de tamanho fixo de escrita Visual Basic 6.0 e versões anteriores. Visual Basic 2005 será assumida a não escrever o descritor. Para escrever o descritor, defina o `ArrayIsDynamic` parâmetro `True`. Ao escrever a matriz, tem de corresponder a forma como serão lidos a matriz; se será possível lê-lo com o descritor, terá de escrever o descritor. O descritor de Especifica a posição da matriz, o tamanho e os limites inferiores para cada classificação. O for igual ao comprimento 2 plus 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que ou igual à soma de todos os bytes necessários para escrever os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz necessita de 218 bytes quando a matriz é escrita no disco.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/9cb41843-0b02-4bad-b757-_1.vb) ] - se a variável que está a ser escrita é qualquer outro tipo de variável (não uma cadeia de comprimento variável ou um objeto), `FilePut` escreve apenas os dados da variável. O comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que ou igual ao comprimento dos dados que está a ser escritos.      - `FilePut` escreve os elementos de estruturas como se cada foram escrita individualmente, mas não há nenhum preenchimento entre elementos. O `VBFixedString` atributo pode ser aplicado aos campos de cadeia em estruturas para indicar o tamanho da cadeia quando escrito no disco.          > [!NOTE] > Cadeia campos que tenham mais de bytes que o especificado pelo `VBFixedString` atributo estão truncados ao escrito no disco, # # modo binário para ficheiros abertos no `Binary` modo, a maioria do `Random` modo regras aplicam-se, com algumas exceções. As seguintes regras para ficheiros abertos no `Binary` modo diferem das regras para `Random` modo: - `RecordLength` cláusula no `FileOpen` função não tem qualquer efeito. `FilePut`escreve todas as variáveis para o disco contiguamente, ou seja, sem o preenchimento entre registos.      -Para nenhuma matriz de que não seja uma matriz de uma estrutura, `FilePut` escreve apenas os dados. Não existem descritor é escrito.      - `FilePut` escreve cadeias de comprimento variável que não são elementos de estruturas sem o descritor de dois bytes de comprimento. O número de bytes escritos iguala o número de carateres da cadeia. Por exemplo, as seguintes declarações de escrever 11 bytes para o número de ficheiros 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/9cb41843-0b02-4bad-b757-_2.vb) ] - escrever um ficheiro ao utilizar o `FilePut` função requer `Write` aceder a partir do <xref:System.Security.Permissions.FileIOPermissionAccess>enumeração.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/9cb41843-0b02-4bad-b757-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.Decimal
      description: "Necessário. Nome de variável válido que contenha os dados escritos no disco."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registos (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> ficheiros do modo) ou um número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> ficheiros do modo) em que escrever é iniciado."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 e não igual a -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)
  id: FilePut(System.Int32,System.Double,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Double,Int64)
  nameWithType: FileSystem.FilePut(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Double,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Escreve dados de uma variável de um ficheiro de disco. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`só é válido em `Random` e `Binary` modo.       Os dados escritos com `FilePut` normalmente é de leitura de um ficheiro ao utilizar `FileGet`.       O primeiro registo ou byte num ficheiro está na posição 1, o segundo registo ou um byte na posição 2 e assim sucessivamente. Se omitir `RecordNumber`, o seguinte registo ou byte após a última `FileGet` ou `FilePut` funcionar ou indicada pelo último `Seek` função é escrita.       O `StringIsFixedLength` argumento controla se a função interpreta cadeias como comprimento variável ou fixo. `FilePut`não escrever o descritor de comprimento quando o argumento é `True`. Se utilizar `StringIsFixedLength`  =  `True` com `FilePut`, terá de fazer o mesmo com `FileGet`, e tem de certificar-se de que a cadeia é inicializada para o comprimento esperado.      ## Aleatórios para o modo ficheiros abertos no `Random` modo, as seguintes regras aplicam-se: - se o comprimento dos dados que está a ser escritos é inferior ao comprimento especificado no `RecordLength` cláusula o `FileOpen` função, `FilePut` escreve subsequentes registos nos limites de comprimento do registo. O espaço entre o fim de um registo e o início do registo seguinte será preenchido com os conteúdos da memória intermédia ficheiros existentes. Porque não é possível determinar a quantidade de dados de preenchimento com qualquer certainty, normalmente, é boa ideia ter o comprimento de registo coincide com o comprimento dos dados que está a ser escritos. Se o comprimento dos dados que está a ser escritos é superior ao comprimento especificado no `RecordLength` cláusula o `FileOpen` função, irá ser emitida uma exceção.      -Se a variável que está a ser escrita é uma cadeia, `FilePut` escreve um descritor de dois bytes que contém o comprimento da cadeia e, em seguida, escreve os dados que vai para a variável. Por conseguinte, o comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que o comprimento real da cadeia de, pelo menos, dois bytes.      -Se a variável que está a ser escrita é um objeto que contém um tipo numérico, `FilePut` escreve dois bytes identificar o `VarType` do objeto e, em seguida, escreve a variável. Por exemplo, quando escrever um objeto que contém um número inteiro, `FilePut` escreve bytes seis: dois bytes que identificam o objeto como `VarType(`3`)` (`Integer`) e quatro bytes que contém os dados. O comprimento de registo especificado pelo `RecordLength` parâmetro o `FileOpen` função tem de ser maior que o número real de bytes necessário para armazenar a variável, pelo menos, dois bytes.      -Se a variável que está a ser escrita é um objeto que contém uma cadeia, `FilePut` escreve um descritor de dois bytes identificar o `VarType(`8`)` do objeto, um descritor de dois bytes que indica que o comprimento da cadeia e, em seguida, escreve os dados de cadeia. O comprimento de registo especificado pelo `RecordLength` parâmetro o `FileOpen` função tem de ser maior que o comprimento real da cadeia de, pelo menos, quatro bytes. Se pretender colocar uma cadeia sem o descritor, deverá passar `True` para o `StringIsFixedLength` parâmetro e a cadeia lido no deve ser igual ao período correto.      -Se a variável que está a ser escrita é uma matriz, tem uma opção para escrever um descritor de tamanho e dimensões da matriz ou não. O descritor de ficheiros para uma matriz dinâmica mas não para uma matriz de tamanho fixo de escrita Visual Basic 6.0 e versões anteriores. Visual Basic 2005 será assumida a não escrever o descritor. Para escrever o descritor, defina o `ArrayIsDynamic` parâmetro `True`. Ao escrever a matriz, tem de corresponder a forma como serão lidos a matriz; se será possível lê-lo com o descritor, terá de escrever o descritor. O descritor de Especifica a posição da matriz, o tamanho e os limites inferiores para cada classificação. O for igual ao comprimento 2 plus 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que ou igual à soma de todos os bytes necessários para escrever os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz necessita de 218 bytes quando a matriz é escrita no disco.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/59c5b768-6732-40e5-a205-_1.vb) ] - se a variável que está a ser escrita é qualquer outro tipo de variável (não uma cadeia de comprimento variável ou um objeto), `FilePut` escreve apenas os dados da variável. O comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que ou igual ao comprimento dos dados que está a ser escritos.      - `FilePut` escreve os elementos de estruturas como se cada foram escrita individualmente, mas não há nenhum preenchimento entre elementos. O `VBFixedString` atributo pode ser aplicado aos campos de cadeia em estruturas para indicar o tamanho da cadeia quando escrito no disco.          > [!NOTE] > Cadeia campos que tenham mais de bytes que o especificado pelo `VBFixedString` atributo estão truncados ao escrito no disco, # # modo binário para ficheiros abertos no `Binary` modo, a maioria do `Random` modo regras aplicam-se, com algumas exceções. As seguintes regras para ficheiros abertos no `Binary` modo diferem das regras para `Random` modo: - `RecordLength` cláusula no `FileOpen` função não tem qualquer efeito. `FilePut`escreve todas as variáveis para o disco contiguamente, ou seja, sem o preenchimento entre registos.      -Para nenhuma matriz de que não seja uma matriz de uma estrutura, `FilePut` escreve apenas os dados. Não existem descritor é escrito.      - `FilePut` escreve cadeias de comprimento variável que não são elementos de estruturas sem o descritor de dois bytes de comprimento. O número de bytes escritos iguala o número de carateres da cadeia. Por exemplo, as seguintes declarações de escrever 11 bytes para o número de ficheiros 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/59c5b768-6732-40e5-a205-_2.vb) ] - escrever um ficheiro ao utilizar o `FilePut` função requer `Write` aceder a partir do <xref:System.Security.Permissions.FileIOPermissionAccess>enumeração.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/59c5b768-6732-40e5-a205-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.Double
      description: "Necessário. Nome de variável válido que contenha os dados escritos no disco."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registos (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> ficheiros do modo) ou um número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> ficheiros do modo) em que escrever é iniciado."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 e não igual a -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)
  id: FilePut(System.Int32,System.Int16,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Int16,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int16,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Escreve dados de uma variável de um ficheiro de disco. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`só é válido em `Random` e `Binary` modo.       Os dados escritos com `FilePut` normalmente é de leitura de um ficheiro ao utilizar `FileGet`.       O primeiro registo ou byte num ficheiro está na posição 1, o segundo registo ou um byte na posição 2 e assim sucessivamente. Se omitir `RecordNumber`, o seguinte registo ou byte após a última `FileGet` ou `FilePut` funcionar ou indicada pelo último `Seek` função é escrita.       O `StringIsFixedLength` argumento controla se a função interpreta cadeias como comprimento variável ou fixo. `FilePut`não escrever o descritor de comprimento quando o argumento é `True`. Se utilizar `StringIsFixedLength`  =  `True` com `FilePut`, terá de fazer o mesmo com `FileGet`, e tem de certificar-se de que a cadeia é inicializada para o comprimento esperado.      ## Aleatórios para o modo ficheiros abertos no `Random` modo, as seguintes regras aplicam-se: - se o comprimento dos dados que está a ser escritos é inferior ao comprimento especificado no `RecordLength` cláusula o `FileOpen` função, `FilePut` escreve subsequentes registos nos limites de comprimento do registo. O espaço entre o fim de um registo e o início do registo seguinte será preenchido com os conteúdos da memória intermédia ficheiros existentes. Porque não é possível determinar a quantidade de dados de preenchimento com qualquer certainty, normalmente, é boa ideia ter o comprimento de registo coincide com o comprimento dos dados que está a ser escritos. Se o comprimento dos dados que está a ser escritos é superior ao comprimento especificado no `RecordLength` cláusula o `FileOpen` função, irá ser emitida uma exceção.      -Se a variável que está a ser escrita é uma cadeia, `FilePut` escreve um descritor de dois bytes que contém o comprimento da cadeia e, em seguida, escreve os dados que vai para a variável. Por conseguinte, o comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que o comprimento real da cadeia de, pelo menos, dois bytes.      -Se a variável que está a ser escrita é um objeto que contém um tipo numérico, `FilePut` escreve dois bytes identificar o `VarType` do objeto e, em seguida, escreve a variável. Por exemplo, quando escrever um objeto que contém um número inteiro, `FilePut` escreve bytes seis: dois bytes que identificam o objeto como `VarType(`3`)` (`Integer`) e quatro bytes que contém os dados. O comprimento de registo especificado pelo `RecordLength` parâmetro o `FileOpen` função tem de ser maior que o número real de bytes necessário para armazenar a variável, pelo menos, dois bytes.      -Se a variável que está a ser escrita é um objeto que contém uma cadeia, `FilePut` escreve um descritor de dois bytes identificar o`VarType(`8`)` do objeto, um descritor de dois bytes que indica que o comprimento da cadeia e, em seguida, escreve os dados de cadeia. O comprimento de registo especificado pelo `RecordLength` parâmetro o `FileOpen` função tem de ser maior que o comprimento real da cadeia de, pelo menos, quatro bytes. Se pretender colocar uma cadeia sem o descritor, deverá passar `True` para o `StringIsFixedLength` parâmetro e a cadeia lido no deve ser igual ao período correto.      -Se a variável que está a ser escrita é uma matriz, tem uma opção para escrever um descritor de tamanho e dimensões da matriz ou não. O descritor de ficheiros para uma matriz dinâmica mas não para uma matriz de tamanho fixo de escrita Visual Basic 6.0 e versões anteriores. Visual Basic 2005 será assumida a não escrever o descritor. Para escrever o descritor, defina o `ArrayIsDynamic` parâmetro `True`. Ao escrever a matriz, tem de corresponder a forma como serão lidos a matriz; se será possível lê-lo com o descritor, terá de escrever o descritor. O descritor de Especifica a posição da matriz, o tamanho e os limites inferiores para cada classificação. O for igual ao comprimento 2 plus 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que ou igual à soma de todos os bytes necessários para escrever os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz necessita de 218 bytes quando a matriz é escrita no disco.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/835229db-b7e7-4e50-86a7-_1.vb) ] - se a variável que está a ser escrita é qualquer outro tipo de variável (não uma cadeia de comprimento variável ou um objeto), `FilePut` escreve apenas os dados da variável. O comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que ou igual ao comprimento dos dados que está a ser escritos.      - `FilePut` escreve os elementos de estruturas como se cada foram escrita individualmente, mas não há nenhum preenchimento entre elementos. O `VBFixedString` atributo pode ser aplicado aos campos de cadeia em estruturas para indicar o tamanho da cadeia quando escrito no disco.          > [!NOTE] > Cadeia campos que tenham mais de bytes que o especificado pelo `VBFixedString` atributo estão truncados ao escrito no disco, # # modo binário para ficheiros abertos no `Binary` modo, a maioria do `Random` modo regras aplicam-se, com algumas exceções. As seguintes regras para ficheiros abertos no `Binary` modo diferem das regras para `Random` modo: - `RecordLength` cláusula no `FileOpen` função não tem qualquer efeito. `FilePut`escreve todas as variáveis para o disco contiguamente, ou seja, sem o preenchimento entre registos.      -Para nenhuma matriz de que não seja uma matriz de uma estrutura, `FilePut` escreve apenas os dados. Não existem descritor é escrito.      - `FilePut` escreve cadeias de comprimento variável que não são elementos de estruturas sem o descritor de dois bytes de comprimento. O número de bytes escritos iguala o número de carateres da cadeia. Por exemplo, as seguintes declarações de escrever 11 bytes para o número de ficheiros 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/835229db-b7e7-4e50-86a7-_2.vb) ] - escrever um ficheiro ao utilizar o `FilePut` função requer `Write` aceder a partir do <xref:System.Security.Permissions.FileIOPermissionAccess>enumeração.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/835229db-b7e7-4e50-86a7-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.Int16
      description: "Necessário. Nome de variável válido que contenha os dados escritos no disco."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registos (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> ficheiros do modo) ou um número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> ficheiros do modo) em que escrever é iniciado."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 e não igual a -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)
  id: FilePut(System.Int32,System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Int32,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Escreve dados de uma variável de um ficheiro de disco. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`só é válido em `Random` e `Binary` modo.       Os dados escritos com `FilePut` normalmente é de leitura de um ficheiro ao utilizar `FileGet`.       O primeiro registo ou byte num ficheiro está na posição 1, o segundo registo ou um byte na posição 2 e assim sucessivamente. Se omitir `RecordNumber`, o seguinte registo ou byte após a última `FileGet` ou `FilePut` funcionar ou indicada pelo último `Seek` função é escrita.       O `StringIsFixedLength` argumento controla se a função interpreta cadeias como comprimento variável ou fixo. `FilePut`não escrever o descritor de comprimento quando o argumento é `True`. Se utilizar `StringIsFixedLength`  =  `True` com `FilePut`, terá de fazer o mesmo com `FileGet`, e tem de certificar-se de que a cadeia é inicializada para o comprimento esperado.      ## Aleatórios para o modo ficheiros abertos no `Random` modo, as seguintes regras aplicam-se: - se o comprimento dos dados que está a ser escritos é inferior ao comprimento especificado no `RecordLength` cláusula o `FileOpen` função, `FilePut` escreve subsequentes registos nos limites de comprimento do registo. O espaço entre o fim de um registo e o início do registo seguinte será preenchido com os conteúdos da memória intermédia ficheiros existentes. Porque não é possível determinar a quantidade de dados de preenchimento com qualquer certainty, normalmente, é boa ideia ter o comprimento de registo coincide com o comprimento dos dados que está a ser escritos. Se o comprimento dos dados que está a ser escritos é superior ao comprimento especificado no `RecordLength` cláusula o `FileOpen` função, irá ser emitida uma exceção.      -Se a variável que está a ser escrita é uma cadeia, `FilePut` escreve um descritor de dois bytes que contém o comprimento da cadeia e, em seguida, escreve os dados que vai para a variável. Por conseguinte, o comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que o comprimento real da cadeia de, pelo menos, dois bytes.      -Se a variável que está a ser escrita é um objeto que contém um tipo numérico, `FilePut` escreve dois bytes identificar o `VarType` do objeto e, em seguida, escreve a variável. Por exemplo, quando escrever um objeto que contém um número inteiro, `FilePut` escreve bytes seis: dois bytes que identificam o objeto como `VarType(`3`)` (`Integer`) e quatro bytes que contém os dados. O comprimento de registo especificado pelo `RecordLength` parâmetro o `FileOpen` função tem de ser maior que o número real de bytes necessário para armazenar a variável, pelo menos, dois bytes.      -Se a variável que está a ser escrita é um objeto que contém uma cadeia, `FilePut` escreve um descritor de dois bytes identificar o `VarType(`8`)` do objeto, um descritor de dois bytes que indica que o comprimento da cadeia e, em seguida, escreve os dados de cadeia. O comprimento de registo especificado pelo `RecordLength` parâmetro o `FileOpen` função tem de ser maior que o comprimento real da cadeia de, pelo menos, quatro bytes. Se pretender colocar uma cadeia sem o descritor, deverá passar `True` para o `StringIsFixedLength` parâmetro e a cadeia lido no deve ser igual ao período correto.      -Se a variável que está a ser escrita é uma matriz, tem uma opção para escrever um descritor de tamanho e dimensões da matriz ou não. O descritor de ficheiros para uma matriz dinâmica mas não para uma matriz de tamanho fixo de escrita Visual Basic 6.0 e versões anteriores. Visual Basic 2005 será assumida a não escrever o descritor. Para escrever o descritor, defina o `ArrayIsDynamic` parâmetro `True`. Ao escrever a matriz, tem de corresponder a forma como serão lidos a matriz; se será possível lê-lo com o descritor, terá de escrever o descritor. O descritor de Especifica a posição da matriz, o tamanho e os limites inferiores para cada classificação. O for igual ao comprimento 2 plus 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que ou igual à soma de todos os bytes necessários para escrever os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz necessita de 218 bytes quando a matriz é escrita no disco.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/6a50d289-6d85-4fc1-99f7-_1.vb) ] - se a variável que está a ser escrita é qualquer outro tipo de variável (não uma cadeia de comprimento variável ou um objeto), `FilePut` escreve apenas os dados da variável. O comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que ou igual ao comprimento dos dados que está a ser escritos.      - `FilePut` escreve os elementos de estruturas como se cada foram escrita individualmente, mas não há nenhum preenchimento entre elementos. O `VBFixedString` atributo pode ser aplicado aos campos de cadeia em estruturas para indicar o tamanho da cadeia quando escrito no disco.          > [!NOTE] > Cadeia campos que tenham mais de bytes que o especificado pelo `VBFixedString` atributo estão truncados ao escrito no disco, # # modo binário para ficheiros abertos no `Binary` modo, a maioria do `Random` modo regras aplicam-se, com algumas exceções. As seguintes regras para ficheiros abertos no `Binary` modo diferem das regras para `Random` modo: - `RecordLength` cláusula no `FileOpen` função não tem qualquer efeito. `FilePut`escreve todas as variáveis para o disco contiguamente, ou seja, sem o preenchimento entre registos.      -Para nenhuma matriz de que não seja uma matriz de uma estrutura, `FilePut` escreve apenas os dados. Não existem descritor é escrito.      - `FilePut` escreve cadeias de comprimento variável que não são elementos de estruturas sem o descritor de dois bytes de comprimento. O número de bytes escritos iguala o número de carateres da cadeia. Por exemplo, as seguintes declarações de escrever 11 bytes para o número de ficheiros 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/6a50d289-6d85-4fc1-99f7-_2.vb) ] - escrever um ficheiro ao utilizar o `FilePut` função requer `Write` aceder a partir do <xref:System.Security.Permissions.FileIOPermissionAccess>enumeração.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/6a50d289-6d85-4fc1-99f7-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.Int32
      description: "Necessário. Nome de variável válido que contenha os dados escritos no disco."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registos (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> ficheiros do modo) ou um número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> ficheiros do modo) em que escrever é iniciado."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 e não igual a -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)
  id: FilePut(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Int64,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Escreve dados de uma variável de um ficheiro de disco. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`só é válido em `Random` e `Binary` modo.       Os dados escritos com `FilePut` normalmente é de leitura de um ficheiro ao utilizar `FileGet`.       O primeiro registo ou byte num ficheiro está na posição 1, o segundo registo ou um byte na posição 2 e assim sucessivamente. Se omitir `RecordNumber`, o seguinte registo ou byte após a última `FileGet` ou `FilePut` funcionar ou indicada pelo último `Seek` função é escrita.       O `StringIsFixedLength` argumento controla se a função interpreta cadeias como comprimento variável ou fixo. `FilePut`não escrever o descritor de comprimento quando o argumento é `True`. Se utilizar `StringIsFixedLength`  =  `True` com `FilePut`, terá de fazer o mesmo com `FileGet`, e tem de certificar-se de que a cadeia é inicializada para o comprimento esperado.      ## Aleatórios para o modo ficheiros abertos no `Random` modo, as seguintes regras aplicam-se: - se o comprimento dos dados que está a ser escritos é inferior ao comprimento especificado no `RecordLength` cláusula o `FileOpen` função, `FilePut` escreve subsequentes registos nos limites de comprimento do registo. O espaço entre o fim de um registo e o início do registo seguinte será preenchido com os conteúdos da memória intermédia ficheiros existentes. Porque não é possível determinar a quantidade de dados de preenchimento com qualquer certainty, normalmente, é boa ideia ter o comprimento de registo coincide com o comprimento dos dados que está a ser escritos. Se o comprimento dos dados que está a ser escritos é superior ao comprimento especificado no `RecordLength` cláusula o `FileOpen` função, irá ser emitida uma exceção.      -Se a variável que está a ser escrita é uma cadeia, `FilePut` escreve um descritor de dois bytes que contém o comprimento da cadeia e, em seguida, escreve os dados que vai para a variável. Por conseguinte, o comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que o comprimento real da cadeia de, pelo menos, dois bytes.      -Se a variável que está a ser escrita é um objeto que contém um tipo numérico, `FilePut` escreve dois bytes identificar o `VarType` do objeto e, em seguida, escreve a variável. Por exemplo, quando escrever um objeto que contém um número inteiro, `FilePut` escreve bytes seis: dois bytes que identificam o objeto como `VarType(`3`)` (`Integer`) e quatro bytes que contém os dados. O comprimento de registo especificado pelo `RecordLength` parâmetro o `FileOpen` função tem de ser maior que o número real de bytes necessário para armazenar a variável, pelo menos, dois bytes.      -Se a variável que está a ser escrita é um objeto que contém uma cadeia, `FilePut` escreve um descritor de dois bytes identificar o `VarType(`8`)` do objeto, um descritor de dois bytes que indica que o comprimento da cadeia e, em seguida, escreve os dados de cadeia. O comprimento de registo especificado pelo `RecordLength` parâmetro o `FileOpen` função tem de ser maior que o comprimento real da cadeia de, pelo menos, quatro bytes. Se pretender colocar uma cadeia sem o descritor, deverá passar `True` para o `StringIsFixedLength` parâmetro e a cadeia lido no deve ser igual ao período correto.      -Se a variável que está a ser escrita é uma matriz, tem uma opção para escrever um descritor de tamanho e dimensões da matriz ou não. O descritor de ficheiros para uma matriz dinâmica mas não para uma matriz de tamanho fixo de escrita Visual Basic 6.0 e versões anteriores. Visual Basic 2005 será assumida a não escrever o descritor. Para escrever o descritor, defina o `ArrayIsDynamic` parâmetro `True`. Ao escrever a matriz, tem de corresponder a forma como serão lidos a matriz; se será possível lê-lo com o descritor, terá de escrever o descritor. O descritor de Especifica a posição da matriz, o tamanho e os limites inferiores para cada classificação. O for igual ao comprimento 2 plus 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que ou igual à soma de todos os bytes necessários para escrever os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz necessita de 218 bytes quando a matriz é escrita no disco.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/90087c6f-a92b-4ccb-88f5-_1.vb) ] - se a variável que está a ser escrita é qualquer outro tipo de variável (não uma cadeia de comprimento variável ou um objeto), `FilePut` escreve apenas os dados da variável. O comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que ou igual ao comprimento dos dados que está a ser escritos.      - `FilePut` escreve os elementos de estruturas como se cada foram escrita individualmente, mas não há nenhum preenchimento entre elementos. O `VBFixedString` atributo pode ser aplicado aos campos de cadeia em estruturas para indicar o tamanho da cadeia quando escrito no disco.          > [!NOTE] > Cadeia campos que tenham mais de bytes que o especificado pelo `VBFixedString` atributo estão truncados ao escrito no disco, # # modo binário para ficheiros abertos no `Binary` modo, a maioria do `Random` modo regras aplicam-se, com algumas exceções. As seguintes regras para ficheiros abertos no `Binary` modo diferem das regras para `Random` modo: - `RecordLength` cláusula no `FileOpen` função não tem qualquer efeito. `FilePut`escreve todas as variáveis para o disco contiguamente, ou seja, sem o preenchimento entre registos.      -Para nenhuma matriz de que não seja uma matriz de uma estrutura, `FilePut` escreve apenas os dados. Não existem descritor é escrito.      - `FilePut` escreve cadeias de comprimento variável que não são elementos de estruturas sem o descritor de dois bytes de comprimento. O número de bytes escritos iguala o número de carateres da cadeia. Por exemplo, as seguintes declarações de escrever 11 bytes para o número de ficheiros 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/90087c6f-a92b-4ccb-88f5-_2.vb) ] - escrever um ficheiro ao utilizar o `FilePut` função requer `Write` aceder a partir do <xref:System.Security.Permissions.FileIOPermissionAccess>enumeração.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/90087c6f-a92b-4ccb-88f5-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.Int64
      description: "Necessário. Nome de variável válido que contenha os dados escritos no disco."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registos (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> ficheiros do modo) ou um número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> ficheiros do modo) em que escrever é iniciado."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 e não igual a -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)
  id: FilePut(System.Int32,System.Single,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Single,Int64)
  nameWithType: FileSystem.FilePut(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Single,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Escreve dados de uma variável de um ficheiro de disco. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`só é válido em `Random` e `Binary` modo.       Os dados escritos com `FilePut` normalmente é de leitura de um ficheiro ao utilizar `FileGet`.       O primeiro registo ou byte num ficheiro está na posição 1, o segundo registo ou um byte na posição 2 e assim sucessivamente. Se omitir `RecordNumber`, o seguinte registo ou byte após a última `FileGet` ou `FilePut` funcionar ou indicada pelo último `Seek` função é escrita.       O `StringIsFixedLength` argumento controla se a função interpreta cadeias como comprimento variável ou fixo. `FilePut`não escrever o descritor de comprimento quando o argumento é `True`. Se utilizar `StringIsFixedLength`  =  `True` com `FilePut`, terá de fazer o mesmo com `FileGet`, e tem de certificar-se de que a cadeia é inicializada para o comprimento esperado.      ## Aleatórios para o modo ficheiros abertos no `Random` modo, as seguintes regras aplicam-se: - se o comprimento dos dados que está a ser escritos é inferior ao comprimento especificado no `RecordLength` cláusula o `FileOpen` função, `FilePut` escreve subsequentes registos nos limites de comprimento do registo. O espaço entre o fim de um registo e o início do registo seguinte será preenchido com os conteúdos da memória intermédia ficheiros existentes. Porque não é possível determinar a quantidade de dados de preenchimento com qualquer certainty, normalmente, é boa ideia ter o comprimento de registo coincide com o comprimento dos dados que está a ser escritos. Se o comprimento dos dados que está a ser escritos é superior ao comprimento especificado no `RecordLength` cláusula o `FileOpen`função, irá ser emitida uma exceção.      -Se a variável que está a ser escrita é uma cadeia, `FilePut` escreve um descritor de dois bytes que contém o comprimento da cadeia e, em seguida, escreve os dados que vai para a variável. Por conseguinte, o comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que o comprimento real da cadeia de, pelo menos, dois bytes.      -Se a variável que está a ser escrita é um objeto que contém um tipo numérico, `FilePut` escreve dois bytes identificar o `VarType` do objeto e, em seguida, escreve a variável. Por exemplo, quando escrever um objeto que contém um número inteiro, `FilePut` escreve bytes seis: dois bytes que identificam o objeto como `VarType(`3`)` (`Integer`) e quatro bytes que contém os dados. O comprimento de registo especificado pelo `RecordLength` parâmetro o `FileOpen` função tem de ser maior que o número real de bytes necessário para armazenar a variável, pelo menos, dois bytes.      -Se a variável que está a ser escrita é um objeto que contém uma cadeia, `FilePut` escreve um descritor de dois bytes identificar o `VarType(`8`)` do objeto, um descritor de dois bytes que indica que o comprimento da cadeia e, em seguida, escreve os dados de cadeia. O comprimento de registo especificado pelo `RecordLength` parâmetro o `FileOpen` função tem de ser maior que o comprimento real da cadeia de, pelo menos, quatro bytes. Se pretender colocar uma cadeia sem o descritor, deverá passar `True` para o `StringIsFixedLength` parâmetro e a cadeia lido no deve ser igual ao período correto.      -Se a variável que está a ser escrita é uma matriz, tem uma opção para escrever um descritor de tamanho e dimensões da matriz ou não. O descritor de ficheiros para uma matriz dinâmica mas não para uma matriz de tamanho fixo de escrita Visual Basic 6.0 e versões anteriores. Visual Basic 2005 será assumida a não escrever o descritor. Para escrever o descritor, defina o `ArrayIsDynamic` parâmetro `True`. Ao escrever a matriz, tem de corresponder a forma como serão lidos a matriz; se será possível lê-lo com o descritor, terá de escrever o descritor. O descritor de Especifica a posição da matriz, o tamanho e os limites inferiores para cada classificação. O for igual ao comprimento 2 plus 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que ou igual à soma de todos os bytes necessários para escrever os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz necessita de 218 bytes quando a matriz é escrita no disco.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/67fd8601-6772-45be-87ee-_1.vb) ] - se a variável que está a ser escrita é qualquer outro tipo de variável (não uma cadeia de comprimento variável ou um objeto), `FilePut` escreve apenas os dados da variável. O comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que ou igual ao comprimento dos dados que está a ser escritos.      - `FilePut` escreve os elementos de estruturas como se cada foram escrita individualmente, mas não há nenhum preenchimento entre elementos. O `VBFixedString` atributo pode ser aplicado aos campos de cadeia em estruturas para indicar o tamanho da cadeia quando escrito no disco.          > [!NOTE] > Cadeia campos que tenham mais de bytes que o especificado pelo `VBFixedString` atributo estão truncados ao escrito no disco, # # modo binário para ficheiros abertos no `Binary` modo, a maioria do `Random` modo regras aplicam-se, com algumas exceções. As seguintes regras para ficheiros abertos no `Binary` modo diferem das regras para `Random` modo: - `RecordLength` cláusula no `FileOpen` função não tem qualquer efeito. `FilePut`escreve todas as variáveis para o disco contiguamente, ou seja, sem o preenchimento entre registos.      -Para nenhuma matriz de que não seja uma matriz de uma estrutura, `FilePut` escreve apenas os dados. Não existem descritor é escrito.      - `FilePut` escreve cadeias de comprimento variável que não são elementos de estruturas sem o descritor de dois bytes de comprimento. O número de bytes escritos iguala o número de carateres da cadeia. Por exemplo, as seguintes declarações de escrever 11 bytes para o número de ficheiros 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/67fd8601-6772-45be-87ee-_2.vb) ] - escrever um ficheiro ao utilizar o `FilePut` função requer `Write` aceder a partir do <xref:System.Security.Permissions.FileIOPermissionAccess>enumeração.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/67fd8601-6772-45be-87ee-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.Single
      description: "Necessário. Nome de variável válido que contenha os dados escritos no disco."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registos (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> ficheiros do modo) ou um número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> ficheiros do modo) em que escrever é iniciado."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 e não igual a -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)
  id: FilePut(System.Int32,System.ValueType,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,ValueType,Int64)
  nameWithType: FileSystem.FilePut(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,ValueType,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Escreve dados de uma variável de um ficheiro de disco. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`só é válido em `Random` e `Binary` modo.       Os dados escritos com `FilePut` normalmente é de leitura de um ficheiro ao utilizar `FileGet`.       O primeiro registo ou byte num ficheiro está na posição 1, o segundo registo ou um byte na posição 2 e assim sucessivamente. Se omitir `RecordNumber`, o seguinte registo ou byte após a última `FileGet` ou `FilePut` funcionar ou indicada pelo último `Seek` função é escrita.       O `StringIsFixedLength` argumento controla se a função interpreta cadeias como comprimento variável ou fixo. `FilePut`não escrever o descritor de comprimento quando o argumento é `True`. Se utilizar `StringIsFixedLength`  =  `True` com `FilePut`, terá de fazer o mesmo com `FileGet`, e tem de certificar-se de que a cadeia é inicializada para o comprimento esperado.      ## Aleatórios para o modo ficheiros abertos no `Random` modo, as seguintes regras aplicam-se: - se o comprimento dos dados que está a ser escritos é inferior ao comprimento especificado no`RecordLength` cláusula o `FileOpen` função, `FilePut` escreve subsequentes registos nos limites de comprimento do registo. O espaço entre o fim de um registo e o início do registo seguinte será preenchido com os conteúdos da memória intermédia ficheiros existentes. Porque não é possível determinar a quantidade de dados de preenchimento com qualquer certainty, normalmente, é boa ideia ter o comprimento de registo coincide com o comprimento dos dados que está a ser escritos. Se o comprimento dos dados que está a ser escritos é superior ao comprimento especificado no `RecordLength` cláusula o `FileOpen` função, irá ser emitida uma exceção.      -Se a variável que está a ser escrita é uma cadeia, `FilePut` escreve um descritor de dois bytes que contém o comprimento da cadeia e, em seguida, escreve os dados que vai para a variável. Por conseguinte, o comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que o comprimento real da cadeia de, pelo menos, dois bytes.      -Se a variável que está a ser escrita é um objeto que contém um tipo numérico, `FilePut` escreve dois bytes identificar o `VarType` do objeto e, em seguida, escreve a variável. Por exemplo, quando escrever um objeto que contém um número inteiro, `FilePut` escreve bytes seis: dois bytes que identificam o objeto como `VarType(`3`)` (`Integer`) e quatro bytes que contém os dados. O comprimento de registo especificado pelo `RecordLength` parâmetro o `FileOpen` função tem de ser maior que o número real de bytes necessário para armazenar a variável, pelo menos, dois bytes.      -Se a variável que está a ser escrita é um objeto que contém uma cadeia, `FilePut` escreve um descritor de dois bytes identificar o `VarType(`8`)` do objeto, um descritor de dois bytes que indica que o comprimento da cadeia e, em seguida, escreve os dados de cadeia. O comprimento de registo especificado pelo `RecordLength` parâmetro o `FileOpen` função tem de ser maior que o comprimento real da cadeia de, pelo menos, quatro bytes. Se pretender colocar uma cadeia sem o descritor, deverá passar `True` para o `StringIsFixedLength` parâmetro e a cadeia lido no deve ser igual ao período correto.      -Se a variável que está a ser escrita é uma matriz, tem uma opção para escrever um descritor de tamanho e dimensões da matriz ou não. O descritor de ficheiros para uma matriz dinâmica mas não para uma matriz de tamanho fixo de escrita Visual Basic 6.0 e versões anteriores. Visual Basic 2005 será assumida a não escrever o descritor. Para escrever o descritor, defina o `ArrayIsDynamic` parâmetro `True`. Ao escrever a matriz, tem de corresponder a forma como serão lidos a matriz; se será possível lê-lo com o descritor, terá de escrever o descritor. O descritor de Especifica a posição da matriz, o tamanho e os limites inferiores para cada classificação. O for igual ao comprimento 2 plus 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que ou igual à soma de todos os bytes necessários para escrever os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz necessita de 218 bytes quando a matriz é escrita no disco.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/814bf35d-de00-4bf6-9dca-_1.vb) ] - se a variável que está a ser escrita é qualquer outro tipo de variável (não uma cadeia de comprimento variável ou um objeto), `FilePut` escreve apenas os dados da variável. O comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que ou igual ao comprimento dos dados que está a ser escritos.      - `FilePut` escreve os elementos de estruturas como se cada foram escrita individualmente, mas não há nenhum preenchimento entre elementos. O `VBFixedString` atributo pode ser aplicado aos campos de cadeia em estruturas para indicar o tamanho da cadeia quando escrito no disco.          > [!NOTE] > Cadeia campos que tenham mais de bytes que o especificado pelo `VBFixedString` atributo estão truncados ao escrito no disco, # # modo binário para ficheiros abertos no `Binary` modo, a maioria do `Random` modo regras aplicam-se, com algumas exceções. As seguintes regras para ficheiros abertos no `Binary` modo diferem das regras para `Random` modo: - `RecordLength` cláusula no `FileOpen` função não tem qualquer efeito. `FilePut`escreve todas as variáveis para o disco contiguamente, ou seja, sem o preenchimento entre registos.      -Para nenhuma matriz de que não seja uma matriz de uma estrutura, `FilePut` escreve apenas os dados. Não existem descritor é escrito.      - `FilePut` escreve cadeias de comprimento variável que não são elementos de estruturas sem o descritor de dois bytes de comprimento. O número de bytes escritos iguala o número de carateres da cadeia. Por exemplo, as seguintes declarações de escrever 11 bytes para o número de ficheiros 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/814bf35d-de00-4bf6-9dca-_2.vb) ] - escrever um ficheiro ao utilizar o `FilePut` função requer `Write` aceder a partir do <xref:System.Security.Permissions.FileIOPermissionAccess>enumeração.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/814bf35d-de00-4bf6-9dca-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.ValueType
      description: "Necessário. Nome de variável válido que contenha os dados escritos no disco."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registos (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> ficheiros do modo) ou um número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> ficheiros do modo) em que escrever é iniciado."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 e não igual a -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)
  id: FilePut(System.Object,System.Object,System.Object)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Object,Object,Object)
  nameWithType: FileSystem.FilePut(Object,Object,Object)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Object,Object,Object)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Escreve dados de uma variável de um ficheiro de disco. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`só é válido em `Random` e `Binary` modo.       Os dados escritos com `FilePut` normalmente é de leitura de um ficheiro ao utilizar `FileGet`.       O primeiro registo ou byte num ficheiro está na posição 1, o segundo registo ou um byte na posição 2 e assim sucessivamente. Se omitir `RecordNumber`, o seguinte registo ou byte após a última `FileGet` ou `FilePut` funcionar ou indicada pelo último `Seek` função é escrita.       O `StringIsFixedLength` argumento controla se a função interpreta cadeias como comprimento variável ou fixo. `FilePut`não escrever o descritor de comprimento quando o argumento é `True`. Se utilizar `StringIsFixedLength`  =  `True` com `FilePut`, terá de fazer o mesmo com `FileGet`, e tem de certificar-se de que a cadeia é inicializada para o comprimento esperado.      ## Aleatórios para o modo ficheiros abertos no `Random` modo, as seguintes regras aplicam-se: - se o comprimento dos dados que está a ser escritos é inferior ao comprimento especificado no `RecordLength` cláusula o `FileOpen` função, `FilePut` escreve subsequentes registos nos limites de comprimento do registo. O espaço entre o fim de um registo e o início do registo seguinte será preenchido com os conteúdos da memória intermédia ficheiros existentes. Porque não é possível determinar a quantidade de dados de preenchimento com qualquer certainty, normalmente, é boa ideia ter o comprimento de registo coincide com o comprimento dos dados que está a ser escritos. Se o comprimento dos dados que está a ser escritos é superior ao comprimento especificado no `RecordLength` cláusula o `FileOpen` função, irá ser emitida uma exceção.      -Se a variável que está a ser escrita é uma cadeia, `FilePut` escreve um descritor de dois bytes que contém o comprimento da cadeia e, em seguida, escreve os dados que vai para a variável. Por conseguinte, o comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que o comprimento real da cadeia de, pelo menos, dois bytes.      -Se a variável que está a ser escrita é um objeto que contém um tipo numérico, `FilePut` escreve dois bytes identificar o `VarType` do objeto e, em seguida, escreve a variável. Por exemplo, quando escrever um objeto que contém um número inteiro, `FilePut` escreve bytes seis: dois bytes que identificam o objeto como `VarType(`3`)` (`Integer`) e quatro bytes que contém os dados. O comprimento de registo especificado pelo `RecordLength` parâmetro o `FileOpen` função tem de ser maior que o número real de bytes necessário para armazenar a variável, pelo menos, dois bytes.      -Se a variável que está a ser escrita é um objeto que contém uma cadeia, `FilePut` escreve um descritor de dois bytes identificar o `VarType(`8`)` do objeto, um descritor de dois bytes que indica que o comprimento da cadeia e, em seguida, escreve os dados de cadeia. O comprimento de registo especificado pelo `RecordLength` parâmetro o `FileOpen` função tem de ser maior que o comprimento real da cadeia de, pelo menos, quatro bytes. Se pretender colocar uma cadeia sem o descritor, deverá passar `True` para o `StringIsFixedLength` parâmetro e a cadeia lido no deve ser igual ao período correto.      -Se a variável que está a ser escrita é uma matriz, tem uma opção para escrever um descritor de tamanho e dimensões da matriz ou não. O descritor de ficheiros para uma matriz dinâmica mas não para uma matriz de tamanho fixo de escrita Visual Basic 6.0 e versões anteriores. Visual Basic 2005 será assumida a não escrever o descritor. Para escrever o descritor, defina o `ArrayIsDynamic` parâmetro `True`. Ao escrever a matriz, tem de corresponder a forma como serão lidos a matriz; se será possível lê-lo com o descritor, terá de escrever o descritor. O descritor de Especifica a posição da matriz, o tamanho e os limites inferiores para cada classificação. O for igual ao comprimento 2 plus 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que ou igual à soma de todos os bytes necessários para escrever os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz necessita de 218 bytes quando a matriz é escrita no disco.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/b8a1d844-c860-47f2-9311-_1.vb) ] - se a variável que está a ser escrita é qualquer outro tipo de variável (não uma cadeia de comprimento variável ou um objeto), `FilePut` escreve apenas os dados da variável. O comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que ou igual ao comprimento dos dados que está a ser escritos.      - `FilePut` escreve os elementos de estruturas como se cada foram escrita individualmente, mas não há nenhum preenchimento entre elementos. O `VBFixedString` atributo pode ser aplicado aos campos de cadeia em estruturas para indicar o tamanho da cadeia quando escrito no disco.          > [!NOTE] > Cadeia campos que tenham mais de bytes que o especificado pelo `VBFixedString` atributo estão truncados ao escrito no disco, # # modo binário para ficheiros abertos no `Binary` modo, a maioria do `Random` modo regras aplicam-se, com algumas exceções. As seguintes regras para ficheiros abertos no `Binary` modo diferem das regras para `Random` modo: - `RecordLength` cláusula no `FileOpen` função não tem qualquer efeito. `FilePut`escreve todas as variáveis para o disco contiguamente, ou seja, sem o preenchimento entre registos.      -Para nenhuma matriz de que não seja uma matriz de uma estrutura, `FilePut` escreve apenas os dados. Não existem descritor é escrito.      - `FilePut` escreve cadeias de comprimento variável que não são elementos de estruturas sem o descritor de dois bytes de comprimento. O número de bytes escritos iguala o número de carateres da cadeia. Por exemplo, as seguintes declarações de escrever 11 bytes para o número de ficheiros 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/b8a1d844-c860-47f2-9311-_2.vb) ] - escrever um ficheiro ao utilizar o `FilePut` função requer `Write` aceder a partir do <xref:System.Security.Permissions.FileIOPermissionAccess>enumeração.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/b8a1d844-c860-47f2-9311-_3.vb)]"
  syntax:
    content: public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Object
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.Object
      description: "Necessário. Nome de variável válido que contenha os dados escritos no disco."
    - id: RecordNumber
      type: System.Object
      description: "Opcional. Número de registos (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> ficheiros do modo) ou um número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> ficheiros do modo) em que escrever é iniciado."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 e não igual a -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  id: FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FilePut(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,String,Int64,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Escreve dados de uma variável de um ficheiro de disco. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>..."
  remarks: "`FilePut`só é válido em `Random` e `Binary` modo.       Os dados escritos com `FilePut` normalmente é de leitura de um ficheiro ao utilizar `FileGet`.       O primeiro registo ou byte num ficheiro está na posição 1, o segundo registo ou um byte na posição 2 e assim sucessivamente. Se omitir `RecordNumber`, o seguinte registo ou byte após a última `FileGet` ou `FilePut` funcionar ou indicada pelo último `Seek` função é escrita.       O `StringIsFixedLength` argumento controla se a função interpreta cadeias como comprimento variável ou fixo. `FilePut`não escrever o descritor de comprimento quando o argumento é `True`. Se utilizar `StringIsFixedLength`  =  `True` com `FilePut`, terá de fazer o mesmo com `FileGet`, e tem de certificar-se de que a cadeia é inicializada para o comprimento esperado.      ## Aleatórios para o modo ficheiros abertos no `Random` modo, as seguintes regras aplicam-se: - se o comprimento dos dados que está a ser escritos é inferior ao comprimento especificado no `RecordLength` cláusula o `FileOpen` função, `FilePut` escreve subsequentes registos nos limites de comprimento do registo. O espaço entre o fim de um registo e o início do registo seguinte será preenchido com os conteúdos da memória intermédia ficheiros existentes. Porque não é possível determinar a quantidade de dados de preenchimento com qualquer certainty, normalmente, é boa ideia ter o comprimento de registo coincide com o comprimento dos dados que está a ser escritos. Se o comprimento dos dados que está a ser escritos é superior ao comprimento especificado no `RecordLength` cláusula o `FileOpen` função, irá ser emitida uma exceção.      -Se a variável que está a ser escrita é uma cadeia, `FilePut` escreve um descritor de dois bytes que contém o comprimento da cadeia e, em seguida, escreve os dados que vai para a variável. Por conseguinte, o comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que o comprimento real da cadeia de, pelo menos, dois bytes.      -Se a variável que está a ser escrita é um objeto que contém um tipo numérico, `FilePut` escreve dois bytes identificar o `VarType` do objeto e, em seguida, escreve a variável. Por exemplo, quando escrever um objeto que contém um número inteiro, `FilePut` escreve bytes seis: dois bytes que identificam o objeto como `VarType(`3`)` (`Integer`) e quatro bytes que contém os dados. O comprimento de registo especificado pelo `RecordLength` parâmetro o `FileOpen` função tem de ser maior que o número real de bytes necessário para armazenar a variável, pelo menos, dois bytes.      -Se a variável que está a ser escrita é um objeto que contém uma cadeia, `FilePut` escreve um descritor de dois bytes identificar o `VarType(`8`)` do objeto, um descritor de dois bytes que indica que o comprimento da cadeia e, em seguida, escreve os dados de cadeia. O comprimento de registo especificado pelo `RecordLength` parâmetro o `FileOpen` função tem de ser maior que o comprimento real da cadeia de, pelo menos, quatro bytes. Se pretender colocar uma cadeia sem o descritor, deverá passar `True` para o `StringIsFixedLength` parâmetro e a cadeia lido no deve ser igual ao período correto.      -Se a variável que está a ser escrita é uma matriz, tem uma opção para escrever um descritor de tamanho e dimensões da matriz ou não. O descritor de ficheiros para uma matriz dinâmica mas não para uma matriz de tamanho fixo de escrita Visual Basic 6.0 e versões anteriores. Visual Basic 2005 será assumida a não escrever o descritor. Para escrever o descritor, defina o `ArrayIsDynamic` parâmetro `True`. Ao escrever a matriz, tem de corresponder a forma como serão lidos a matriz; se será possível lê-lo com o descritor, terá de escrever o descritor. O descritor de Especifica a posição da matriz, o tamanho e os limites inferiores para cada classificação. O for igual ao comprimento 2 plus 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que ou igual à soma de todos os bytes necessários para escrever os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz necessita de 218 bytes quando a matriz é escrita no disco.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/6bdd614c-e459-4fef-9c10-_1.vb) ] - se a variável que está a ser escrita é qualquer outro tipo de variável (não uma cadeia de comprimento variável ou um objeto), `FilePut` escreve apenas os dados da variável. O comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que ou igual ao comprimento dos dados que está a ser escritos.      - `FilePut` escreve os elementos de estruturas como se cada foram escrita individualmente, mas não há nenhum preenchimento entre elementos. O `VBFixedString` atributo pode ser aplicado aos campos de cadeia em estruturas para indicar o tamanho da cadeia quando escrito no disco.          > [!NOTE] > Cadeia campos que tenham mais de bytes que o especificado pelo `VBFixedString` atributo estão truncados ao escrito no disco, # # modo binário para ficheiros abertos no `Binary` modo, a maioria do `Random` modo regras aplicam-se, com algumas exceções. As seguintes regras para ficheiros abertos no `Binary` modo diferem das regras para `Random` modo: - `RecordLength` cláusula no `FileOpen` função não tem qualquer efeito. `FilePut`escreve todas as variáveis para o disco contiguamente, ou seja, sem o preenchimento entre registos.      -Para nenhuma matriz de que não seja uma matriz de uma estrutura, `FilePut` escreve apenas os dados. Não existem descritor é escrito.      - `FilePut` escreve cadeias de comprimento variável que não são elementos de estruturas sem o descritor de dois bytes de comprimento. O número de bytes escritos iguala o número de carateres da cadeia. Por exemplo, as seguintes declarações de escrever 11 bytes para o número de ficheiros 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/6bdd614c-e459-4fef-9c10-_2.vb) ] - escrever um ficheiro ao utilizar o `FilePut` função requer `Write` aceder a partir do <xref:System.Security.Permissions.FileIOPermissionAccess>enumeração.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/6bdd614c-e459-4fef-9c10-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.String
      description: "Necessário. Nome de variável válido que contenha os dados escritos no disco."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registos (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> ficheiros do modo) ou um número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> ficheiros do modo) em que escrever é iniciado."
    - id: StringIsFixedLength
      type: System.Boolean
      description: "Opcional. Aplica-se apenas ao escrever uma cadeia. Especifica se escrever um descritor de comprimento de cadeia de dois bytes para a cadeia para o ficheiro. A predefinição é <xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 e não igual a -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  id: FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Escreve dados de uma variável de um ficheiro de disco. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`só é válido em `Random` e `Binary` modo.       Os dados escritos com `FilePut` normalmente é de leitura de um ficheiro ao utilizar `FileGet`.       O primeiro registo ou byte num ficheiro está na posição 1, o segundo registo ou um byte na posição 2 e assim sucessivamente. Se omitir `RecordNumber`, o seguinte registo ou byte após a última `FileGet` ou `FilePut` funcionar ou indicada pelo último `Seek` função é escrita.       O `StringIsFixedLength` argumento controla se a função interpreta cadeias como comprimento variável ou fixo. `FilePut`não escrever o descritor de comprimento quando o argumento é `True`. Se utilizar `StringIsFixedLength`  =  `True` com `FilePut`, terá de fazer o mesmo com `FileGet`, e tem de certificar-se de que a cadeia é inicializada para o comprimento esperado.      ## Aleatórios para o modo ficheiros abertos no `Random` modo, as seguintes regras aplicam-se: - se o comprimento dos dados que está a ser escritos é inferior ao comprimento especificado no `RecordLength` cláusula o `FileOpen` função, `FilePut` escreve subsequentes registos nos limites de comprimento do registo. O espaço entre o fim de um registo e o início do registo seguinte será preenchido com os conteúdos da memória intermédia ficheiros existentes. Porque não é possível determinar a quantidade de dados de preenchimento com qualquer certainty, normalmente, é boa ideia ter o comprimento de registo coincide com o comprimento dos dados que está a ser escritos. Se o comprimento dos dados que está a ser escritos é superior ao comprimento especificado no `RecordLength` cláusula o `FileOpen` função, irá ser emitida uma exceção.      -Se a variável que está a ser escrita é uma cadeia, `FilePut` escreve um descritor de dois bytes que contém o comprimento da cadeia e, em seguida, escreve os dados que vai para a variável. Por conseguinte, o comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que o comprimento real da cadeia de, pelo menos, dois bytes.      -Se a variável que está a ser escrita é um objeto que contém um tipo numérico, `FilePut` escreve dois bytes identificar o `VarType` do objeto e, em seguida, escreve a variável. Por exemplo, quando escrever um objeto que contém um número inteiro, `FilePut` escreve bytes seis: dois bytes que identificam o objeto como `VarType(`3`)` (`Integer`) e quatro bytes que contém os dados. O comprimento de registo especificado pelo `RecordLength` parâmetro o `FileOpen` função tem de ser maior que o número real de bytes necessário para armazenar a variável, pelo menos, dois bytes.      -Se a variável que está a ser escrita é um objeto que contém uma cadeia, `FilePut` escreve um descritor de dois bytes identificar o `VarType(`8`)` do objeto, um descritor de dois bytes que indica que o comprimento da cadeia e, em seguida, escreve os dados de cadeia. O comprimento de registo especificado pelo `RecordLength` parâmetro o `FileOpen` função tem de ser maior que o comprimento real da cadeia de, pelo menos, quatro bytes. Se pretender colocar uma cadeia sem o descritor, deverá passar `True` para o `StringIsFixedLength` parâmetro e a cadeia lido no deve ser igual ao período correto.      -Se a variável que está a ser escrita é uma matriz, tem uma opção para escrever um descritor de tamanho e dimensões da matriz ou não. O descritor de ficheiros para uma matriz dinâmica mas não para uma matriz de tamanho fixo de escrita Visual Basic 6.0 e versões anteriores. Visual Basic 2005 será assumida a não escrever o descritor. Para escrever o descritor, defina o `ArrayIsDynamic` parâmetro `True`. Ao escrever a matriz, tem de corresponder a forma como serão lidos a matriz; se será possível lê-lo com o descritor, terá de escrever o descritor. O descritor de Especifica a posição da matriz, o tamanho e os limites inferiores para cada classificação. O for igual ao comprimento 2 plus 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que ou igual à soma de todos os bytes necessários para escrever os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz necessita de 218 bytes quando a matriz é escrita no disco.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/34008b69-543f-4e9e-add6-_1.vb) ] - se a variável que está a ser escrita é qualquer outro tipo de variável (não uma cadeia de comprimento variável ou um objeto), `FilePut` escreve apenas os dados da variável. O comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que ou igual ao comprimento dos dados que está a ser escritos.      - `FilePut` escreve os elementos de estruturas como se cada foram escrita individualmente, mas não há nenhum preenchimento entre elementos. O `VBFixedString` atributo pode ser aplicado aos campos de cadeia em estruturas para indicar o tamanho da cadeia quando escrito no disco.          > [!NOTE] > Cadeia campos que tenham mais de bytes que o especificado pelo `VBFixedString` atributo estão truncados ao escrito no disco, # # modo binário para ficheiros abertos no `Binary` modo, a maioria do `Random` modo regras aplicam-se, com algumas exceções. As seguintes regras para ficheiros abertos no `Binary` modo diferem das regras para `Random` modo: - `RecordLength` cláusula no `FileOpen` função não tem qualquer efeito. `FilePut`escreve todas as variáveis para o disco contiguamente, ou seja, sem o preenchimento entre registos.      -Para nenhuma matriz de que não seja uma matriz de uma estrutura, `FilePut` escreve apenas os dados. Não existem descritor é escrito.      - `FilePut` escreve cadeias de comprimento variável que não são elementos de estruturas sem o descritor de dois bytes de comprimento. O número de bytes escritos iguala o número de carateres da cadeia. Por exemplo, as seguintes declarações de escrever 11 bytes para o número de ficheiros 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/34008b69-543f-4e9e-add6-_2.vb) ] - escrever um ficheiro ao utilizar o `FilePut` função requer `Write` aceder a partir do <xref:System.Security.Permissions.FileIOPermissionAccess>enumeração.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/34008b69-543f-4e9e-add6-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.Array
      description: "Necessário. Nome de variável válido que contenha os dados escritos no disco."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registos (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> ficheiros do modo) ou um número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> ficheiros do modo) em que escrever é iniciado."
    - id: ArrayIsDynamic
      type: System.Boolean
      description: "Opcional. Aplica-se apenas ao escrever uma matriz. Especifica se a matriz é deve ser tratado como dinâmico e, se escrever um descritor de matriz para a cadeia que descreve o comprimento."
    - id: StringIsFixedLength
      type: System.Boolean
      description: "Opcional. Aplica-se apenas ao escrever uma cadeia. Especifica se escrever um descritor de comprimento de cadeia de dois bytes para a cadeia para o ficheiro. A predefinição é <xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 e não igual a -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)
  id: FilePutObject(System.Int32,System.Object,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePutObject(Int32,Object,Int64)
  nameWithType: FileSystem.FilePutObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePutObject(Int32,Object,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Escreve dados de uma variável de um ficheiro de disco.  O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FilePutObject&quot; name=&quot;FilePutObject&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "O `FilePutObject` função é utilizada em vez de `FilePut` para evitar ambiguities no momento da compilação se tipo `Object` é transmitida em vez de outro tipo, tais como `Integer`, `Long`, `Short`, etc.       `FilePutObject`escritas e leituras descritores que descrevem o objeto. Se pretender escrever o `Variant` tipo, `FilePutObject` é necessária. Quando em dúvida, se estiver a utilizar um objeto para o segundo parâmetro, recomendamos que utilize sempre `FilePutObject` e `FileGetObject`.       `FilePutObject`só é válido em `Random` e `Binary` modo.       Os dados escritos com `FilePutObject` normalmente é de leitura de um ficheiro ao utilizar `FileGetObject`.       O primeiro registo ou byte num ficheiro está na posição 1, o segundo registo ou um byte na posição 2 e assim sucessivamente. Se omitir `RecordNumber`, `FilePutObject` escreve o seguinte registo ou byte após a última `FileGetObject` ou `FilePutObject` função (ou o registo ou um byte indicada pelo último `Seek` função).       O `StringIsFixedLength` argumento controla se a função interpreta cadeias como comprimento variável ou fixo. `FilePutObject`não escrever o descritor de comprimento quando o argumento é `True`. Se utilizar `StringIsFixedLength`  =  `True` com `FilePutObject`, terá de fazer o mesmo com `FileGetObject`, e também tem de se certificar de que a cadeia é inicializada para o comprimento esperado.      ## Aleatórios para o modo ficheiros abertos no `Random` modo, as seguintes regras aplicam-se: - se o comprimento dos dados que está a ser escritos é inferior ao comprimento especificado no `RecordLength` cláusula o `FileOpen` função, `FilePutObject` escreve subsequentes registos nos limites de comprimento do registo. O espaço entre o fim de um registo e o início do registo seguinte será preenchido com os conteúdos da memória intermédia ficheiros existentes. Porque a quantidade de preenchimento dados não é possível determinar precisamente, normalmente, é boa ideia ter o comprimento de registo coincide com o comprimento dos dados que está a ser escritos. Se o comprimento dos dados que está a ser escritos é superior ao comprimento especificado no `RecordLength` cláusula o `FileOpen` função, é emitida uma exceção.      -Se a variável que está a ser escrita é um objeto que contém um tipo numérico, `FilePutObject` escreve dois bytes identificar o `VarType` do objeto e, em seguida, escreve a variável. Por exemplo, quando escrever um objeto que contém um número inteiro, `FilePutObject` escreve bytes seis: dois bytes que identificam o objeto como `VarType(`3`)` (`Integer`) e quatro bytes que contém os dados. O comprimento de registo especificado pelo `RecordLength` parâmetro o `FileOpen` função tem de ser maior que o número real de bytes necessário para armazenar a variável, pelo menos, dois bytes.      -Se a variável que está a ser escrita é um objeto que contém uma cadeia, `FilePutObject` escreve um descritor de dois bytes que identifica o `VarType(`8`)` do objeto, um descritor de dois bytes que indica que o comprimento da cadeia e, em seguida, escreve os dados de cadeia. O comprimento de registo especificado pelo `RecordLength` parâmetro o `FileOpen` função tem de ser maior que o comprimento real da cadeia de, pelo menos, quatro bytes. Se pretender colocar uma cadeia sem o descritor, deverá passar `True` para o `StringIsFixedLength` parâmetro e a cadeia lido no deve ser igual ao período correto.      -Se a variável que está a ser escrita é uma matriz, em seguida, o comprimento de registo especificado pelo `RecordLength` cláusula no `FileOpen` função tem de ser maior que ou igual à soma de todos os bytes necessários para escrever os dados de matriz e o descritor de matriz. O descritor de Especifica a posição da matriz, o tamanho e os limites inferiores para cada classificação. O for igual ao comprimento 2 plus 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions).      ## Modo para os ficheiros binários aberto em `Binary` modo, todos os o `Random` aplicam regras de modo, exceto: - `RecordLength` cláusula FROM no `FileOpen` função não tem qualquer efeito. `FilePutObject`escreve todas as variáveis para o disco contiguamente, ou seja, sem o preenchimento entre registos."
  example:
  - "This example uses the `FilePutObject` function to write a string to a file.  \n  \n [!code-vb[VbVbalrCatRef#54](~/add/codesnippet/visualbasic/69f8d8bb-169c-4dec-b805-_1.vb)]"
  syntax:
    content: public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.Object
      description: "Necessário. Nome de variável válido que contenha os dados escritos no disco."
    - id: RecordNumber
      type: System.Int64
      description: "Opcional. Número de registos (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> ficheiros do modo) ou um número de bytes (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> ficheiros do modo) em que escrever é iniciado."
  overload: Microsoft.VisualBasic.FileSystem.FilePutObject*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)
  id: FileWidth(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileWidth(Int32,Int32)
  nameWithType: FileSystem.FileWidth(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileWidth(Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Atribui uma largura de linha de saída para um ficheiro aberto utilizando o <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> função."
  remarks: ''
  example:
  - "This example uses the `FileWidth` function to set the output line width for a file.  \n  \n [!code-vb[VbVbalrCatRef#10](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._187_1.vb)]"
  syntax:
    content: public static void FileWidth (int FileNumber, int RecordWidth);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: RecordWidth
      type: System.Int32
      description: "Necessário. Expressão numérica no intervalo 0-255, inclusive, que indica o número de carateres são apresentados numa linha antes de uma nova linha é iniciada. Se `RecordWidth` é igual a 0, não existe nenhum limite para o comprimento de uma linha. O valor predefinido para `RecordWidth` é 0."
  overload: Microsoft.VisualBasic.FileSystem.FileWidth*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FreeFile
  id: FreeFile
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FreeFile()
  nameWithType: FileSystem.FreeFile()
  fullName: Microsoft.VisualBasic.FileSystem.FreeFile()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Devolve um <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> valor que representa o número seguinte de ficheiros disponível para utilização pelo <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> função."
  remarks: "Utilize `FreeFile` para fornecer um número de ficheiros que já não está a ser utilizado."
  example:
  - "This example uses the `FreeFile` function to return the next available file number. Five files are opened for output within the loop, and some sample data is written to each.  \n  \n [!code-vb[VbVbalrCatRef#55](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._104_1.vb)]"
  syntax:
    content: public static int FreeFile ();
    parameters: []
    return:
      type: System.Int32
      description: "Devolve um <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> valor que representa o número seguinte de ficheiros disponível para utilização pelo <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> função."
  overload: Microsoft.VisualBasic.FileSystem.FreeFile*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Mais de 255 ficheiros estão em utilização."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.GetAttr(System.String)
  id: GetAttr(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: GetAttr(String)
  nameWithType: FileSystem.GetAttr(String)
  fullName: Microsoft.VisualBasic.FileSystem.GetAttr(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Devolve um <xref uid=&quot;langword_csharp_FileAttribute&quot; name=&quot;FileAttribute&quot; href=&quot;&quot;> </xref> valor que representa os atributos de uma pasta, ficheiro ou diretório. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_FileAttribute&quot; name=&quot;FileAttribute&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Para determinar quais os atributos que estão definidos, utilize o `And` operador para executar uma comparação bit a bit entre o valor devolvido pelo `GetAttr` função e o valor do atributo de ficheiro individuais que pretende. Se o resultado não for zero, esse atributo está definido para o ficheiro com nome. Por exemplo, o valor de retorno dos seguintes `And` expressão é zero se o `Archive` atributo não está definido: ```vb#   Result = GetAttr(FName) And vbArchive   ``` um valor diferente de zero é devolvido se o `Archive` atributo está definido."
  example:
  - "This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.  \n  \n [!code-vb[VbVbalrCatRef#25](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._13_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "Necessário. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>expressão que especifica um nome de pasta, ficheiro ou diretório. `PathName`Pode incluir o diretório ou pasta e unidade."
    return:
      type: Microsoft.VisualBasic.FileAttribute
      description: "O valor devolvido pelo <xref uid=&quot;langword_csharp_GetAttr&quot; name=&quot;GetAttr&quot; href=&quot;&quot;> </xref> é a soma dos seguintes valores de enumeração:       <table><tbody><tr><td> Valor       </td><td> Descrição constante       </td></tr><tr><td><xref uid=&quot;langword_csharp_Normal&quot; name=&quot;Normal&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbNormal&quot; name=&quot;vbNormal&quot; href=&quot;&quot;></xref>Normal.       </td></tr><tr><td><xref uid=&quot;langword_csharp_ReadOnly&quot; name=&quot;ReadOnly&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbReadOnly&quot; name=&quot;vbReadOnly&quot; href=&quot;&quot;></xref>Só de leitura.       </td></tr><tr><td><xref uid=&quot;langword_csharp_Hidden&quot; name=&quot;Hidden&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbHidden&quot; name=&quot;vbHidden&quot; href=&quot;&quot;></xref>Oculto.       </td></tr><tr><td><xref uid=&quot;langword_csharp_System&quot; name=&quot;System&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbSystem&quot; name=&quot;vbSystem&quot; href=&quot;&quot;></xref>Ficheiro de sistema.       </td></tr><tr><td><xref uid=&quot;langword_csharp_Directory&quot; name=&quot;Directory&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbDirectory&quot; name=&quot;vbDirectory&quot; href=&quot;&quot;></xref>Diretório ou uma pasta.       </td></tr><tr><td><xref uid=&quot;langword_csharp_Archive&quot; name=&quot;Archive&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbArchive&quot; name=&quot;vbArchive&quot; href=&quot;&quot;></xref>Ficheiro foi alterada desde a última cópia de segurança.       </td></tr><tr><td><xref uid=&quot;langword_csharp_Alias&quot; name=&quot;Alias&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbAlias&quot; name=&quot;vbAlias&quot; href=&quot;&quot;></xref>O ficheiro tem um nome diferente.       </td></tr></tbody></table><div class=&quot;alert NOTE&quot;>    Estes enumerações são especificadas pela linguagem Visual Basic. Os nomes podem ser utilizados em qualquer lugar no seu código em vez dos valores reais.      </div>"
  overload: Microsoft.VisualBasic.FileSystem.GetAttr*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>Pathname</code>é inválido ou contiver carateres universais."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Ficheiro de destino não existe."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)
  id: Input(System.Int32,System.Boolean@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Boolean)
  nameWithType: FileSystem.Input(Int32,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados a partir de um ficheiro aberto sequencial e atribui os dados de variáveis."
  remarks: "O `Input` função é fornecida para compatibilidade com versões anteriores e poderá afetar o desempenho. Para aplicações não legado, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a ficheiros com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Dados lidos com `Input` , normalmente, é escrito num ficheiro utilizando `Write`. Utilize esta função apenas com ficheiros abertos em `Input` ou `Binary` modo.      > [!IMPORTANT] > Durante a leitura de ficheiros, não decisões sobre o conteúdo do ficheiro com base na extensão de nome de ficheiro. Por exemplo, um ficheiro denominado Form1.vb não pode ser um ficheiro de origem do Visual Basic 2005.       Cadeia padrão ou dados numéricos quando ler, são atribuídos a variáveis sem modificação. A tabela seguinte ilustra como outros dados de entrada são processados.      |||   |-|-|   | Dados | Valor atribuído à variável |   | Delimitador vírgula ou por linha em branco | Vazio |   | NULL # #| `DBNull`|   | #TRUE # ou FALSE # #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A data e/ou hora representados pela expressão de |   |#ERROR `errornumber` #| `errornumber` (variável é um objeto marcado como um erro) |       Se chegar ao fim do ficheiro enquanto são inputting um item de dados, a entrada está parada e ocorre um erro.      > [!NOTE] > O `Input` função não está localizada. Por exemplo, na versão em alemão, se for entrada 3,14159, devolve apenas 3, porque a vírgula é tratada como um separador de variável em vez de como um ponto decimal.      > [!IMPORTANT] > Ler a partir de um ficheiro ao utilizar o `Input` função requer `Read` aceder a partir do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._237_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref bool Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.Boolean
      description: "Necessário. Variável que é atribuído os valores de leitura do ficheiro — não pode ser uma variável de matriz nem um objeto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)
  id: Input(System.Int32,System.Byte@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Byte)
  nameWithType: FileSystem.Input(Int32,Byte)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Byte)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados a partir de um ficheiro aberto sequencial e atribui os dados de variáveis."
  remarks: "O `Input` função é fornecida para compatibilidade com versões anteriores e poderá afetar o desempenho. Para aplicações não legado, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a ficheiros com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Dados lidos com `Input` , normalmente, é escrito num ficheiro utilizando `Write`. Utilize esta função apenas com ficheiros abertos em `Input` ou `Binary` modo.      > [!IMPORTANT] > Durante a leitura de ficheiros, não decisões sobre o conteúdo do ficheiro com base na extensão de nome de ficheiro. Por exemplo, um ficheiro denominado Form1.vb não pode ser um ficheiro de origem do Visual Basic 2005.       Cadeia padrão ou dados numéricos quando ler, são atribuídos a variáveis sem modificação. A tabela seguinte ilustra como outros dados de entrada são processados.      |||   |-|-|   | Dados | Valor atribuído à variável |   | Delimitador vírgula ou por linha em branco | Vazio |   | NULL # #| `DBNull`|   | #TRUE # ou FALSE # #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A data e/ou hora representados pela expressão de |   |#ERROR `errornumber` #| `errornumber` (variável é um objeto marcado como um erro) |       Se chegar ao fim do ficheiro enquanto são inputting um item de dados, a entrada está parada e ocorre um erro.      > [!NOTE] > O `Input` função não está localizada. Por exemplo, na versão em alemão, se for entrada 3,14159, devolve apenas 3, porque a vírgula é tratada como um separador de variável em vez de como um ponto decimal.      > [!IMPORTANT] > Ler a partir de um ficheiro ao utilizar o `Input` função requer `Read` aceder a partir do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._73_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref byte Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.Byte
      description: "Necessário. Variável que é atribuído os valores de leitura do ficheiro — não pode ser uma variável de matriz nem um objeto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)
  id: Input(System.Int32,System.Char@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Char)
  nameWithType: FileSystem.Input(Int32,Char)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Char)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados a partir de um ficheiro aberto sequencial e atribui os dados de variáveis."
  remarks: "O `Input` função é fornecida para compatibilidade com versões anteriores e poderá afetar o desempenho. Para aplicações não legado, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a ficheiros com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Dados lidos com `Input` , normalmente, é escrito num ficheiro utilizando `Write`. Utilize esta função apenas com ficheiros abertos em `Input` ou `Binary` modo.      > [!IMPORTANT] > Durante a leitura de ficheiros, não decisões sobre o conteúdo do ficheiro com base na extensão de nome de ficheiro. Por exemplo, um ficheiro denominado Form1.vb não pode ser um ficheiro de origem do Visual Basic 2005.       Cadeia padrão ou dados numéricos quando ler, são atribuídos a variáveis sem modificação. A tabela seguinte ilustra como outros dados de entrada são processados.      |||   |-|-|   | Dados | Valor atribuído à variável |   | Delimitador vírgula ou por linha em branco | Vazio |   | NULL # #| `DBNull`|   | #TRUE # ou FALSE # #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A data e/ou hora representados pela expressão de |   |#ERROR `errornumber` #| `errornumber` (variável é um objeto marcado como um erro) |       Se chegar ao fim do ficheiro enquanto são inputting um item de dados, a entrada está parada e ocorre um erro.      > [!NOTE] > O `Input` função não está localizada. Por exemplo, na versão em alemão, se for entrada 3,14159, devolve apenas 3, porque a vírgula é tratada como um separador de variável em vez de como um ponto decimal.      > [!IMPORTANT] > Ler a partir de um ficheiro ao utilizar o `Input` função requer `Read` aceder a partir do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._91_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref char Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.Char
      description: "Necessário. Variável que é atribuído os valores de leitura do ficheiro — não pode ser uma variável de matriz nem um objeto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)
  id: Input(System.Int32,System.DateTime@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,DateTime)
  nameWithType: FileSystem.Input(Int32,DateTime)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,DateTime)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados a partir de um ficheiro aberto sequencial e atribui os dados de variáveis."
  remarks: "O `Input` função é fornecida para compatibilidade com versões anteriores e poderá afetar o desempenho. Para aplicações não legado, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a ficheiros com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Dados lidos com `Input` , normalmente, é escrito num ficheiro utilizando `Write`. Utilize esta função apenas com ficheiros abertos em `Input` ou `Binary` modo.      > [!IMPORTANT] > Durante a leitura de ficheiros, não decisões sobre o conteúdo do ficheiro com base na extensão de nome de ficheiro. Por exemplo, um ficheiro denominado Form1.vb não pode ser um ficheiro de origem do Visual Basic 2005.       Cadeia padrão ou dados numéricos quando ler, são atribuídos a variáveis sem modificação. A tabela seguinte ilustra como outros dados de entrada são processados.      |||   |-|-|   | Dados | Valor atribuído à variável |   | Delimitador vírgula ou por linha em branco | Vazio |   | NULL # #| `DBNull`|   | #TRUE # ou FALSE # #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A data e/ou hora representados pela expressão de |   |#ERROR `errornumber` #| `errornumber` (variável é um objeto marcado como um erro) |       Se chegar ao fim do ficheiro enquanto são inputting um item de dados, a entrada está parada e ocorre um erro.      > [!NOTE] > O `Input` função não está localizada. Por exemplo, na versão em alemão, se for entrada 3,14159, devolve apenas 3, porque a vírgula é tratada como um separador de variável em vez de como um ponto decimal.      > [!IMPORTANT] > Ler a partir de um ficheiro ao utilizar o `Input` função requer `Read` aceder a partir do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._169_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref DateTime Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.DateTime
      description: "Necessário. Variável que é atribuído os valores de leitura do ficheiro — não pode ser uma variável de matriz nem um objeto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)
  id: Input(System.Int32,System.Decimal@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Decimal)
  nameWithType: FileSystem.Input(Int32,Decimal)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Decimal)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados a partir de um ficheiro aberto sequencial e atribui os dados de variáveis."
  remarks: "O `Input` função é fornecida para compatibilidade com versões anteriores e poderá afetar o desempenho. Para aplicações não legado, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a ficheiros com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Dados lidos com `Input` , normalmente, é escrito num ficheiro utilizando `Write`. Utilize esta função apenas com ficheiros abertos em `Input` ou `Binary` modo.      > [!IMPORTANT] > Durante a leitura de ficheiros, não decisões sobre o conteúdo do ficheiro com base na extensão de nome de ficheiro. Por exemplo, um ficheiro denominado Form1.vb não pode ser um ficheiro de origem do Visual Basic 2005.       Cadeia padrão ou dados numéricos quando ler, são atribuídos a variáveis sem modificação. A tabela seguinte ilustra como outros dados de entrada são processados.      |||   |-|-|   | Dados | Valor atribuído à variável |   | Delimitador vírgula ou por linha em branco | Vazio |   | NULL # #| `DBNull`|   | #TRUE # ou FALSE # #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A data e/ou hora representados pela expressão de |   |#ERROR `errornumber` #| `errornumber` (variável é um objeto marcado como um erro) |       Se chegar ao fim do ficheiro enquanto são inputting um item de dados, a entrada está parada e ocorre um erro.      > [!NOTE] > O `Input` função não está localizada. Por exemplo, na versão em alemão, se for entrada 3,14159, devolve apenas 3, porque a vírgula é tratada como um separador de variável em vez de como um ponto decimal.      > [!IMPORTANT] > Ler a partir de um ficheiro ao utilizar o `Input` função requer `Read` aceder a partir do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._46_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref decimal Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.Decimal
      description: "Necessário. Variável que é atribuído os valores de leitura do ficheiro — não pode ser uma variável de matriz nem um objeto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)
  id: Input(System.Int32,System.Double@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Double)
  nameWithType: FileSystem.Input(Int32,Double)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Double)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados a partir de um ficheiro aberto sequencial e atribui os dados de variáveis."
  remarks: "O `Input` função é fornecida para compatibilidade com versões anteriores e poderá afetar o desempenho. Para aplicações não legado, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a ficheiros com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Dados lidos com `Input` , normalmente, é escrito num ficheiro utilizando `Write`. Utilize esta função apenas com ficheiros abertos em `Input` ou `Binary` modo.      > [!IMPORTANT] > Durante a leitura de ficheiros, não decisões sobre o conteúdo do ficheiro com base na extensão de nome de ficheiro. Por exemplo, um ficheiro denominado Form1.vb não pode ser um ficheiro de origem do Visual Basic 2005.       Cadeia padrão ou dados numéricos quando ler, são atribuídos a variáveis sem modificação. A tabela seguinte ilustra como outros dados de entrada são processados.      |||   |-|-|   | Dados | Valor atribuído à variável |   | Delimitador vírgula ou por linha em branco | Vazio |   | NULL # #| `DBNull`|   | #TRUE # ou FALSE # #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A data e/ou hora representados pela expressão de |   |#ERROR `errornumber` #| `errornumber` (variável é um objeto marcado como um erro) |       Se chegar ao fim do ficheiro enquanto são inputting um item de dados, a entrada está parada e ocorre um erro.      > [!NOTE] > O `Input` função não está localizada. Por exemplo, na versão em alemão, se for entrada 3,14159, devolve apenas 3, porque a vírgula é tratada como um separador de variável em vez de como um ponto decimal.      > [!IMPORTANT] > Ler a partir de um ficheiro ao utilizar o `Input` função requer `Read` aceder a partir do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._204_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref double Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.Double
      description: "Necessário. Variável que é atribuído os valores de leitura do ficheiro — não pode ser uma variável de matriz nem um objeto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)
  id: Input(System.Int32,System.Int16@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Int16)
  nameWithType: FileSystem.Input(Int32,Int16)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int16)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados a partir de um ficheiro aberto sequencial e atribui os dados de variáveis."
  remarks: "O `Input` função é fornecida para compatibilidade com versões anteriores e poderá afetar o desempenho. Para aplicações não legado, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a ficheiros com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Dados lidos com `Input` , normalmente, é escrito num ficheiro utilizando `Write`. Utilize esta função apenas com ficheiros abertos em `Input` ou `Binary` modo.      > [!IMPORTANT] > Durante a leitura de ficheiros, não decisões sobre o conteúdo do ficheiro com base na extensão de nome de ficheiro. Por exemplo, um ficheiro denominado Form1.vb não pode ser um ficheiro de origem do Visual Basic 2005.       Cadeia padrão ou dados numéricos quando ler, são atribuídos a variáveis sem modificação. A tabela seguinte ilustra como outros dados de entrada são processados.      |||   |-|-|   | Dados | Valor atribuído à variável |   | Delimitador vírgula ou por linha em branco | Vazio |   | NULL # #| `DBNull`|   | #TRUE # ou FALSE # #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A data e/ou hora representados pela expressão de |   |#ERROR `errornumber` #| `errornumber` (variável é um objeto marcado como um erro) |       Se chegar ao fim do ficheiro enquanto são inputting um item de dados, a entrada está parada e ocorre um erro.      > [!NOTE] > O `Input` função não está localizada. Por exemplo, na versão em alemão, se for entrada 3,14159, devolve apenas 3, porque a vírgula é tratada como um separador de variável em vez de como um ponto decimal.      > [!IMPORTANT] > Ler a partir de um ficheiro ao utilizar o `Input` função requer `Read` aceder a partir do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._81_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref short Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.Int16
      description: "Necessário. Variável que é atribuído os valores de leitura do ficheiro — não pode ser uma variável de matriz nem um objeto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)
  id: Input(System.Int32,System.Int32@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Int32)
  nameWithType: FileSystem.Input(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados a partir de um ficheiro aberto sequencial e atribui os dados de variáveis."
  remarks: "O `Input` função é fornecida para compatibilidade com versões anteriores e poderá afetar o desempenho. Para aplicações não legado, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a ficheiros com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Dados lidos com `Input` , normalmente, é escrito num ficheiro utilizando `Write`. Utilize esta função apenas com ficheiros abertos em `Input` ou `Binary` modo.      > [!IMPORTANT] > Durante a leitura de ficheiros, não decisões sobre o conteúdo do ficheiro com base na extensão de nome de ficheiro. Por exemplo, um ficheiro denominado Form1.vb não pode ser um ficheiro de origem do Visual Basic 2005.       Cadeia padrão ou dados numéricos quando ler, são atribuídos a variáveis sem modificação. A tabela seguinte ilustra como outros dados de entrada são processados.      |||   |-|-|   | Dados | Valor atribuído à variável |   | Delimitador vírgula ou por linha em branco | Vazio |   | NULL # #| `DBNull`|   | #TRUE # ou FALSE # #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A data e/ou hora representados pela expressão de |   |#ERROR `errornumber` #| `errornumber` (variável é um objeto marcado como um erro) |       Se chegar ao fim do ficheiro enquanto são inputting um item de dados, a entrada está parada e ocorre um erro.      > [!NOTE] > O `Input` função não está localizada. Por exemplo, na versão em alemão, se for entrada 3,14159, devolve apenas 3, uma vez que a vírgula é tratada como um separador de variável em vez de como um ponto decimal.      > [!IMPORTANT] > Ler a partir de um ficheiro ao utilizar o `Input` função requer `Read` aceder a partir do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._207_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref int Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.Int32
      description: "Necessário. Variável que é atribuído os valores de leitura do ficheiro — não pode ser uma variável de matriz nem um objeto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)
  id: Input(System.Int32,System.Int64@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Int64)
  nameWithType: FileSystem.Input(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados a partir de um ficheiro aberto sequencial e atribui os dados de variáveis."
  remarks: "O `Input` função é fornecida para compatibilidade com versões anteriores e poderá afetar o desempenho. Para aplicações não legado, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a ficheiros com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Dados lidos com `Input` , normalmente, é escrito num ficheiro utilizando `Write`. Utilize esta função apenas com ficheiros abertos em `Input` ou `Binary` modo.      > [!IMPORTANT] > Durante a leitura de ficheiros, não decisões sobre o conteúdo do ficheiro com base na extensão de nome de ficheiro. Por exemplo, um ficheiro denominado Form1.vb não pode ser um ficheiro de origem do Visual Basic 2005.       Cadeia padrão ou dados numéricos quando ler, são atribuídos a variáveis sem modificação. A tabela seguinte ilustra como outros dados de entrada são processados.      |||   |-|-|   | Dados | Valor atribuído à variável |   | Delimitador vírgula ou por linha em branco | Vazio |   | NULL # #| `DBNull`|   | #TRUE # ou FALSE # #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A data e/ou hora representados pela expressão de |   |#ERROR `errornumber` #| `errornumber` (variável é um objeto marcado como um erro) |       Se chegar ao fim do ficheiro enquanto são inputting um item de dados, a entrada está parada e ocorre um erro.      > [!NOTE] > O `Input` função não está localizada. Por exemplo, na versão em alemão, se for entrada 3,14159, devolve apenas 3, porque a vírgula é tratada como um separador de variável em vez de como um ponto decimal.      > [!IMPORTANT] > Ler a partir de um ficheiro ao utilizar o `Input` função requer `Read` aceder a partir do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._31_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref long Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.Int64
      description: "Necessário. Variável que é atribuído os valores de leitura do ficheiro — não pode ser uma variável de matriz nem um objeto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)
  id: Input(System.Int32,System.Object@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Object)
  nameWithType: FileSystem.Input(Int32,Object)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Object)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados a partir de um ficheiro aberto sequencial e atribui os dados de variáveis."
  remarks: "O `Input` função é fornecida para compatibilidade com versões anteriores e poderá afetar o desempenho. Para aplicações não legado, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a ficheiros com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Dados lidos com `Input` , normalmente, é escrito num ficheiro utilizando `Write`. Utilize esta função apenas com ficheiros abertos em `Input` ou `Binary` modo.      > [!IMPORTANT] > Durante a leitura de ficheiros, não decisões sobre o conteúdo do ficheiro com base na extensão de nome de ficheiro. Por exemplo, um ficheiro denominado Form1.vb não pode ser um ficheiro de origem do Visual Basic 2005.       Cadeia padrão ou dados numéricos quando ler, são atribuídos a variáveis sem modificação. A tabela seguinte ilustra como outros dados de entrada são processados.      |||   |-|-|   | Dados | Valor atribuído à variável |   | Delimitador vírgula ou por linha em branco | Vazio |   | NULL # #| `DBNull`|   | #TRUE # ou FALSE # #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A data e/ou hora representados pela expressão de |   |#ERROR `errornumber` #| `errornumber` (variável é um objeto marcado como um erro) |       Se chegar ao fim do ficheiro enquanto são inputting um item de dados, a entrada está parada e ocorre um erro.      > [!NOTE] > O `Input` função não está localizada. Por exemplo, na versão em alemão, se for entrada 3,14159, devolve apenas 3, porque a vírgula é tratada como um separador de variável em vez de como um ponto decimal.      > [!IMPORTANT] > Ler a partir de um ficheiro ao utilizar o `Input` função requer `Read` aceder a partir do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._244_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref object Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.Object
      description: "Necessário. Variável que é atribuído os valores de leitura do ficheiro — não pode ser uma variável de matriz nem um objeto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)
  id: Input(System.Int32,System.Single@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Single)
  nameWithType: FileSystem.Input(Int32,Single)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Single)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados a partir de um ficheiro aberto sequencial e atribui os dados de variáveis."
  remarks: "O `Input` função é fornecida para compatibilidade com versões anteriores e poderá afetar o desempenho. Para aplicações não legado, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a ficheiros com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Dados lidos com `Input` , normalmente, é escrito num ficheiro utilizando `Write`. Utilize esta função apenas com ficheiros abertos em `Input` ou `Binary` modo.      > [!IMPORTANT] > Durante a leitura de ficheiros, não decisões sobre o conteúdo do ficheiro com base na extensão de nome de ficheiro. Por exemplo, um ficheiro denominado Form1.vb não pode ser um ficheiro de origem do Visual Basic 2005.       Cadeia padrão ou dados numéricos quando ler, são atribuídos a variáveis sem modificação. A tabela seguinte ilustra como outros dados de entrada são processados.      |||   |-|-|   | Dados | Valor atribuído à variável |   | Delimitador vírgula ou por linha em branco | Vazio |   | NULL # #| `DBNull`|   | #TRUE # ou FALSE # #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A data e/ou hora representados pela expressão de |   |#ERROR `errornumber` #| `errornumber` (variável é um objeto marcado como um erro) |       Se chegar ao fim do ficheiro enquanto são inputting um item de dados, a entrada está parada e ocorre um erro.      > [!NOTE] > O `Input` função não está localizada. Por exemplo, na versão em alemão, se for entrada 3,14159, devolve apenas 3, porque a vírgula é tratada como um separador de variável em vez de como um ponto decimal.      > [!IMPORTANT] > Ler a partir de um ficheiro ao utilizar o `Input` função requer `Read` aceder a partir do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._115_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref float Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.Single
      description: "Necessário. Variável que é atribuído os valores de leitura do ficheiro — não pode ser uma variável de matriz nem um objeto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)
  id: Input(System.Int32,System.String@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,String)
  nameWithType: FileSystem.Input(Int32,String)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê dados a partir de um ficheiro aberto sequencial e atribui os dados de variáveis."
  remarks: "O `Input` função é fornecida para compatibilidade com versões anteriores e poderá afetar o desempenho. Para aplicações não legado, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a ficheiros com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Dados lidos com `Input` , normalmente, é escrito num ficheiro utilizando `Write`. Utilize esta função apenas com ficheiros abertos em `Input` ou `Binary` modo.      > [!IMPORTANT] > Durante a leitura de ficheiros, não decisões sobre o conteúdo do ficheiro com base na extensão de nome de ficheiro. Por exemplo, um ficheiro denominado Form1.vb não pode ser um ficheiro de origem do Visual Basic 2005.       Cadeia padrão ou dados numéricos quando ler, são atribuídos a variáveis sem modificação. A tabela seguinte ilustra como outros dados de entrada são processados.      |||   |-|-|   | Dados | Valor atribuído à variável |   | Delimitador vírgula ou por linha em branco | Vazio |   | NULL # #| `DBNull`|   | #TRUE # ou FALSE # #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| A data e/ou hora representados pela expressão de |   |#ERROR `errornumber` #| `errornumber` (variável é um objeto marcado como um erro) |       Se chegar ao fim do ficheiro enquanto são inputting um item de dados, a entrada está parada e ocorre um erro.      > [!NOTE] > O `Input` função não está localizada. Por exemplo, na versão em alemão, se for entrada 3,14159, devolve apenas 3, porque a vírgula é tratada como um separador de variável em vez de como um ponto decimal.      > [!IMPORTANT] > Ler a partir de um ficheiro ao utilizar o `Input` função requer `Read` aceder a partir do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._140_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref string Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Value
      type: System.String
      description: "Necessário. Variável que é atribuído os valores de leitura do ficheiro — não pode ser uma variável de matriz nem um objeto."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)
  id: InputString(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: InputString(Int32,Int32)
  nameWithType: FileSystem.InputString(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.InputString(Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Devolve <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> valor que contenha carateres de um ficheiro aberto em <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modo. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_InputString&quot; name=&quot;InputString&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "O `InputString` função é fornecida para compatibilidade com versões anteriores e poderá afetar o desempenho. Para aplicações não legado, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a ficheiros com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Dados lidos com o `InputString` função, normalmente, é escrita num ficheiro utilizando `Print` ou `FilePut`. Utilize esta função apenas com ficheiros abertos em `Input` ou `Binary` modo.       Ao contrário do `Input` função, o `InputString` função devolve todos os carateres lê-lo. Isto inclui vírgulas, mudanças, avanços de linha, aspas e espaços à esquerda.       Com ficheiros abertos para `Binary` aceder a uma tentativa de ler o ficheiro utilizando o `InputString` funcionar até que `EOF` devolve `True` gera um erro. Utilize o `LOF` e `Loc` funciona em vez de `EOF` ao ler os ficheiros binários utilizando `InputString`, ou utilize `FileGet` quando utiliza o `EOF` função.      > [!NOTE] > Durante a leitura de ficheiros, não decisões segurança sobre o conteúdo do ficheiro com base na extensão de nome de ficheiro. Por exemplo, um ficheiro denominado Form1.vb não pode ser um ficheiro de origem do Visual Basic."
  example:
  - "This example uses the `InputString` function to read one character at a time from a file and print it to the `Output` window. This example assumes that `MyFile` is a text file that has several lines of sample data.  \n  \n [!code-vb[VbVbalrCatRef#33](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._220_1.vb)]"
  syntax:
    content: public static string InputString (int FileNumber, int CharCount);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: CharCount
      type: System.Int32
      description: "Necessário. Uma expressão numérica válida especificando o número de carateres a ler."
    return:
      type: System.String
      description: "Devolve <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> valor que contenha carateres de um ficheiro aberto em <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modo. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_InputString&quot; name=&quot;InputString&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.InputString*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileNumber</code>não existe."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>CharCount</code>&lt; 0 or &gt; 214."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Kill(System.String)
  id: Kill(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Kill(String)
  nameWithType: FileSystem.Kill(String)
  fullName: Microsoft.VisualBasic.FileSystem.Kill(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Elimina os ficheiros a partir de um disco. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_Kill&quot; name=&quot;Kill&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> ."
  remarks: "`Kill`suporta a utilização de carateres de múltiplos (`*`) e caráter (`?`) carateres universais para especificar vários ficheiros.       **Nota de segurança** para executar, o `Kill` função requer `Read` e `PathDiscovery` sinalizadores de <xref:System.Security.Permissions.FileIOPermission>para ser concedida para o código em execução.</xref:System.Security.Permissions.FileIOPermission> Para obter mais informações, consulte <xref:System.Security.SecurityException> [permissões de acesso de código](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)</xref:System.Security.SecurityException>"
  example:
  - "This example uses the `Kill` function to delete a file from a disk.  \n  \n [!code-vb[VbVbalrCatRef#60](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._250_1.vb)]"
  syntax:
    content: public static void Kill (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "Necessário. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>expressão que especifica um ou mais nomes de ficheiro a eliminar. `PathName`Pode incluir o diretório ou pasta e unidade."
  overload: Microsoft.VisualBasic.FileSystem.Kill*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Abra o ficheiro de destino."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Ficheiro de destino não foi encontrado."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Permissão negada."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)
  id: LineInput(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: LineInput(Int32)
  nameWithType: FileSystem.LineInput(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LineInput(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lê uma única linha a partir de um ficheiro aberto sequencial e atribui-o para um <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> variável."
  remarks: "O `LineInput` função é fornecida para compatibilidade com versões anteriores e poderá afetar o desempenho. Para aplicações não legado, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a ficheiros com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Dados lidos com `LineInput` , normalmente, é escrito num ficheiro utilizando `Print`.      > [!IMPORTANT] > Durante a leitura de ficheiros, não decisões sobre o conteúdo de um ficheiro com base na extensão de nome de ficheiro. Por exemplo, um ficheiro denominado Form1.vb não pode ser um ficheiro de origem do Visual Basic.       O `LineInput` função lê a partir de um caráter de um ficheiro de cada vez até encontrar um avanço retorno (`Chr(`13`)`) ou de avanço de retorno/linha feed (`Chr(`13`)` + `Chr(`10`)`) sequência. Sequências de feed de linha de retorno/avanço são ignoradas em vez de anexado a cadeia de carateres.      > [!IMPORTANT] > Ler a partir de um ficheiro ao utilizar o `LineInput` função requer `Read` aceder a partir do <xref:System.Security.Permissions.FileIOPermissionAccess>enumeração.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `LineInput` function to read a line from a sequential file and assign it to a variable. This example assumes that `TestFile` is a text file that has several lines of sample data.  \n  \n [!code-vb[VbVbalrCatRef#19](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._158_1.vb)]"
  syntax:
    content: public static string LineInput (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    return:
      type: System.String
      description: "Lê uma única linha a partir de um ficheiro aberto sequencial e atribui-o para um <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> variável."
  overload: Microsoft.VisualBasic.FileSystem.LineInput*
  exceptions:
  - type: System.IO.EndOfStreamException
    commentId: T:System.IO.EndOfStreamException
    description: "Foi atingido o fim do ficheiro."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileNumber</code>não existe."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Loc(System.Int32)
  id: Loc(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Loc(Int32)
  nameWithType: FileSystem.Loc(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Loc(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Devolve um <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> valor que especifica a posição actual de leitura/escrita num ficheiro aberto."
  remarks: "O `Loc` função é baseado em zero; utilizá-lo a obter o primeiro byte num ficheiro irá devolver 0.       O `Loc` função é fornecida para compatibilidade com versões anteriores e poderá afetar o desempenho. Para aplicações não legado, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a ficheiros com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       O seguinte descreve o valor de retorno para cada modo de acesso do ficheiro: |||   |-|-|   | Modo | Devolver valor |   | `Random`| Número do último registo lidas ou escritas para o ficheiro. |   | `Sequential`| Posição actual de bytes no ficheiro dividido pelo 128. No entanto, as informações devolvidas pelo `Loc` para ficheiros sequenciais é utilizada nem necessária. |   | `Binary`| Posição do último byte lidas ou escritas. |"
  example:
  - "This example uses the `Loc` function to return the current read/write position in an open file. This example assumes that `MyFile` is a text file that has several lines of sample data.  \n  \n [!code-vb[VbVbalrCatRef#17](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._178_1.vb)]"
  syntax:
    content: public static long Loc (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer válido <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> número de ficheiros."
    return:
      type: System.Int64
      description: "Devolve um <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> valor que especifica a posição actual de leitura/escrita num ficheiro aberto."
  overload: Microsoft.VisualBasic.FileSystem.Loc*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32)
  id: Lock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Lock(Int32)
  nameWithType: FileSystem.Lock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Controla o acesso por outros processos a totalidade ou parte de um ficheiro aberto utilizando o <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> função. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> e <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "O `Lock` e `Unlock` as funções são utilizadas em ambientes onde vários processos poderão ter acesso ao mesmo ficheiro.       `Lock`e `Unlock` funções são sempre utilizadas pares. Os argumentos `Lock` e `Unlock` têm de ser idênticos.       Se `Record`, ou `FromRecord` e `ToRecord` não são foi fornecido, o bloqueio será para o ficheiro de todo. Se `Record` sozinho especificado único registo será bloqueado/desbloqueado.       Se o ficheiro tiver sido aberto para sequencial entrada ou saída, `Lock` e `Unlock` afetam o ficheiro de todo, independentemente do intervalo especificado pelas `FromRecord` e`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._243_1.vb)]"
  syntax:
    content: public static void Lock (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
  overload: Microsoft.VisualBasic.FileSystem.Lock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)
  id: Lock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Lock(Int32,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Controla o acesso por outros processos a totalidade ou parte de um ficheiro aberto utilizando o <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> função. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> e <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "O `Lock` e `Unlock` as funções são utilizadas em ambientes onde vários processos poderão ter acesso ao mesmo ficheiro.       `Lock`e `Unlock` funções são sempre utilizadas pares. Os argumentos `Lock` e `Unlock` têm de ser idênticos.       Se `Record`, ou `FromRecord` e `ToRecord` não são foi fornecido, o bloqueio será para o ficheiro de todo. Se `Record` sozinho especificado único registo será bloqueado/desbloqueado.       Se o ficheiro tiver sido aberto para sequencial entrada ou saída, `Lock` e `Unlock` afetam o ficheiro de todo, independentemente do intervalo especificado pelas `FromRecord` e`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._38_1.vb)]"
  syntax:
    content: public static void Lock (int FileNumber, long Record);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Record
      type: System.Int64
      description: "Opcional. Número do único registo ou um byte para bloquear ou desbloquear"
  overload: Microsoft.VisualBasic.FileSystem.Lock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)
  id: Lock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Lock(Int32,Int64,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Controla o acesso por outros processos a totalidade ou parte de um ficheiro aberto utilizando o <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> função. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> e <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "O `Lock` e `Unlock` as funções são utilizadas em ambientes onde vários processos poderão ter acesso ao mesmo ficheiro.       `Lock`e `Unlock` funções são sempre utilizadas pares. Os argumentos `Lock` e `Unlock` têm de ser idênticos.       Se `Record`, ou `FromRecord` e `ToRecord` não são foi fornecido, o bloqueio será para o ficheiro de todo. Se `Record` sozinho especificado único registo será bloqueado/desbloqueado.       Se o ficheiro tiver sido aberto para sequencial entrada ou saída, `Lock` e `Unlock` afetam o ficheiro de todo, independentemente do intervalo especificado pelas `FromRecord` e`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._116_1.vb)]"
  syntax:
    content: public static void Lock (int FileNumber, long FromRecord, long ToRecord);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: FromRecord
      type: System.Int64
      description: "Opcional. Número do primeiro registo ou byte para bloquear ou desbloquear."
    - id: ToRecord
      type: System.Int64
      description: "Opcional. Número do último registo ou byte para bloquear ou desbloquear."
  overload: Microsoft.VisualBasic.FileSystem.Lock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.LOF(System.Int32)
  id: LOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: LOF(Int32)
  nameWithType: FileSystem.LOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LOF(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Devolve um <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> que representa o tamanho, em bytes, de um ficheiro aberto utilizando o <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> função. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_LOF&quot; name=&quot;LOF&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Utilize o `FileLen` função para obter o comprimento de um ficheiro que não está aberto."
  example:
  - "This example uses the `LOF` function to determine the size of an open file. This example assumes that `TestFile` is a text file that contains sample data.  \n  \n [!code-vb[VbVbalrCatRef#23](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._83_1.vb)]"
  syntax:
    content: public static long LOF (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Um <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> que contém um número de ficheiro válido."
    return:
      type: System.Int64
      description: "Devolve um <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> que representa o tamanho, em bytes, de um ficheiro aberto utilizando o <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> função. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_LOF&quot; name=&quot;LOF&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.LOF*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.MkDir(System.String)
  id: MkDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: MkDir(String)
  nameWithType: FileSystem.MkDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.MkDir(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Cria um novo diretório. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_MkDir&quot; name=&quot;MkDir&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory*>"
  remarks: "Esta função cria um novo diretório."
  example:
  - "This example uses the `MkDir` function to create a directory. If the drive is not specified, the new directory is created on the current drive.  \n  \n [!code-vb[VbVbalrCatRef#38](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._246_1.vb)]"
  syntax:
    content: public static void MkDir (string Path);
    parameters:
    - id: Path
      type: System.String
      description: "Necessário. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>expressão que identifica o diretório a ser criado. O `Path` podem incluir a unidade. Não se for especificada nenhuma unidade, <xref uid=&quot;langword_csharp_MkDir&quot; name=&quot;MkDir&quot; href=&quot;&quot;> </xref> cria o novo diretório na unidade atual."
  overload: Microsoft.VisualBasic.FileSystem.MkDir*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Path</code>Não foi especificado ou está vazio."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Permissão negada."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Já existe um diretório."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])
  id: Print(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Print(Int32,Object[])
  nameWithType: FileSystem.Print(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Print(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Escritas formatado para apresentar os dados para um ficheiro sequencial."
  remarks: "O `Print` e `PrintLine` funções são fornecidas para retro-compatibilidade e poderá afetar o desempenho. Para aplicações não legado, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a ficheiros com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       `Print`não inclui uma linha no final de uma linha; No entanto, `PrintLine` incluem uma linha.       Os dados escritos com `Print` normalmente é de leitura de um ficheiro ao utilizar `LineInput` ou `Input`.       Se omitir `Output` para `PrintLine`, uma linha em branco está impresso; para o ficheiro `Print`, nada é de saída. Várias expressões separadas por uma vírgula irão ser alinhadas no limites de separador, mas a combinação de vírgulas e `TAB` poderá provocar resultados inconsistentes.       Para `Boolean` dados, `True` ou `False` está impresso. O `True` e `False` palavras-chave não são convertidas, independentemente do idioma.       Dados de data são escritos para o ficheiro utilizando o formato de data abreviada padrão reconhecido pelo seu sistema. Quando a data ou o componente de hora está em falta ou zero, apenas a parte fornecida é escrito no ficheiro.       Nada foi escrito para o ficheiro se `Output` dados estão vazios. No entanto, se `Output` dados da lista são `DBNull`, `Null` é escrito no ficheiro.       Para `Error` dados, é apresentado o resultado como `Error errorcode`. O `Error` palavra-chave não está traduzido independentemente do idioma.       Todos os dados escritos para o ficheiro utilizando `Print` internationally suporte para; ou seja, os dados está corretamente formatados utilizando o separador decimal adequado. Se o utilizador pretende para a saída de dados para utilização por várias regiões, `Write` deve ser utilizada.       Escrever um ficheiro utilizando o `Print` ou `PrintLine` funções requer `Write` aceder a partir do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Print` and `PrintLine` functions to write data to a file.  \n  \n [!code-vb[VbVbalrCatRef#53](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._146_1.vb)]"
  syntax:
    content: public static void Print (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Output
      type: System.Object[]
      description: "Opcional. Zero ou mais delimitada por vírgulas expressões para escrever um ficheiro.       O `Output` argumento definições são: <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;> </xref>: o modo de ficheiro é inválido.       <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;></xref>: `FileNumber` não existe."
  overload: Microsoft.VisualBasic.FileSystem.Print*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])
  id: PrintLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: PrintLine(Int32,Object[])
  nameWithType: FileSystem.PrintLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.PrintLine(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Escritas formatado para apresentar os dados para um ficheiro sequencial."
  remarks: "O `Print` e `PrintLine` funções são fornecidas para retro-compatibilidade e poderá afetar o desempenho. Para aplicações não legado, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a ficheiros com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       `Print`não inclui uma linha no final de uma linha; No entanto,`PrintLine` incluem uma linha.       Os dados escritos com `Print` normalmente é de leitura de um ficheiro ao utilizar `LineInput` ou `Input`.       Se omitir `Output` para `PrintLine`, uma linha em branco está impresso; para o ficheiro `Print`, nada é de saída. Várias expressões separadas por uma vírgula irão ser alinhadas no limites de separador, mas a combinação de vírgulas e `TAB` poderá provocar resultados inconsistentes.       Para `Boolean` dados, `True` ou `False` está impresso. O `True` e `False` palavras-chave não são convertidas, independentemente do idioma.       Dados de data são escritos para o ficheiro utilizando o formato de data abreviada padrão reconhecido pelo sistema. Quando a data ou o componente de hora está em falta ou zero, apenas a parte fornecida é escrito no ficheiro.       Nada foi escrito para o ficheiro se `Output` dados estão vazios. No entanto, se `Output` dados da lista são `DBNull`, `Null` é escrito no ficheiro.       Para `Error` dados, é apresentado o resultado como `Error errorcode`. O `Error` palavra-chave não está traduzido independentemente do idioma.       Todos os dados escritos para o ficheiro utilizando `Print` internationally suporte para; ou seja, os dados está corretamente formatados utilizando o separador decimal adequado. Se o utilizador pretende para a saída de dados para utilização por várias regiões, `Write` deve ser utilizada.       Escrever um ficheiro utilizando o `Print` ou `PrintLine` funções requer `Write` aceder a partir do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Print` and `PrintLine` functions to write data to a file.  \n  \n [!code-vb[VbVbalrCatRef#53](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._245_1.vb)]"
  syntax:
    content: public static void PrintLine (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Output
      type: System.Object[]
      description: "Opcional. Zero ou mais delimitada por vírgulas expressões para escrever um ficheiro.       O `Output` argumento definições são: <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;> </xref>: o modo de ficheiro é inválido.       <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;></xref>: `FileNumber` não existe."
  overload: Microsoft.VisualBasic.FileSystem.PrintLine*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)
  id: Rename(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Rename(String,String)
  nameWithType: FileSystem.Rename(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.Rename(String,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Muda o nome de um ficheiro de disco ou diretório. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_Rename&quot; name=&quot;Rename&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "O`Rename` função muda o nome de um ficheiro e move-o para um diretório diferente, se for necessário. O `Rename` função pode mover um ficheiro através de unidades, mas esta pode apenas mudar o nome de um diretório existente quando ambos `NewPath` e `OldPath` estão localizados na mesma unidade. `Rename`Não é possível criar um novo ficheiro ou diretório.       Utilizar o `Rename` função num ficheiro aberto produz um erro. Tem de fechar um ficheiro aberto antes de mudar o nome-lo. `Rename`argumentos não podem incluir universais de caráter (?) e carateres de múltiplos (*).      > [!IMPORTANT] > Quando utilizar `Rename` para copiar um ficheiro a partir de uma localização desprotegida para uma localização protegida, o ficheiro mantém os direitos menos restritos. Verificação para se certificar de que não são de introduzir um possível risco de segurança."
  example:
  - "This example uses the `Rename` function to rename a file. For purposes of this example, assume that the directories that are specified already exist.  \n  \n [!code-vb[VbVbalrCatRef#30](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._97_1.vb)]"
  syntax:
    content: public static void Rename (string OldPath, string NewPath);
    parameters:
    - id: OldPath
      type: System.String
      description: "Necessário. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>expressão que especifica o nome de ficheiro existente e a localização. `OldPath`Pode incluir o diretório e a unidade do ficheiro."
    - id: NewPath
      type: System.String
      description: "Necessário. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>expressão que especifica o novo nome de ficheiro e a localização. `NewPath`Pode incluir o diretório e a unidade a localização de destino. O nome de ficheiro especificado pelo `NewPath` já não podem existir."
  overload: Microsoft.VisualBasic.FileSystem.Rename*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O caminho é inválido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>OldPath</code>o ficheiro não existe."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Não é possível mudar o nome de dispositivo diferentes."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Reset
  id: Reset
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Reset()
  nameWithType: FileSystem.Reset()
  fullName: Microsoft.VisualBasic.FileSystem.Reset()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Fechar todos os ficheiros abertos através da utilização de disco a <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> função. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_Reset&quot; name=&quot;Reset&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "O `Reset` função fecha todos os ficheiros de Active Directory abertos pelo `FileOpen` funcionar e tem a mesma função que `FileClose()` sem quaisquer parâmetros."
  example:
  - "This example uses the `Reset` function to close all open files and write the contents of all file buffers to disk. Note the use of the `Object` variable `FileNumber` as both a string and a number.  \n  \n [!code-vb[VbVbalrCatRef#12](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._117_1.vb)]"
  syntax:
    content: public static void Reset ();
    parameters: []
  overload: Microsoft.VisualBasic.FileSystem.Reset*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.RmDir(System.String)
  id: RmDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: RmDir(String)
  nameWithType: FileSystem.RmDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.RmDir(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Remove um diretório existente. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_RmDir&quot; name=&quot;RmDir&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory*>"
  remarks: "Ocorre um erro se tentar utilizar `RmDir` num diretório que contém ficheiros. Utilize o `Kill` função para eliminar todos os ficheiros antes de tentar remover um diretório."
  example:
  - "This example uses the `RmDir` function to remove an existing directory.  \n  \n [!code-vb[VbVbalrCatRef#31](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._20_1.vb)]"
  syntax:
    content: public static void RmDir (string Path);
    parameters:
    - id: Path
      type: System.String
      description: "Necessário. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>expressão que identifica o diretório ou uma pasta para ser removido. `Path`Pode incluir a unidade. Não se for especificada nenhuma unidade, <xref uid=&quot;langword_csharp_RmDir&quot; name=&quot;RmDir&quot; href=&quot;&quot;> </xref> remove o diretório na unidade atual."
  overload: Microsoft.VisualBasic.FileSystem.RmDir*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Path</code>Não foi especificado ou está vazio."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Diretório de destino contém ficheiros."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Diretório não existe."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32)
  id: Seek(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Seek(Int32)
  nameWithType: FileSystem.Seek(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Devolve um <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> especificando a posição actual de leitura/escrita num ficheiro aberto utilizando o <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> function ou define a posição para a próxima operação de leitura/escrita num ficheiro aberta utilizando o <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> função. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_Seek&quot; name=&quot;Seek&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`Seek`Devolve um valor entre 1 e 2 147 483 647 (equivalente a 2 ^ 31-1), inclusive.       O seguinte descreve os valores devolvidos para cada modo de acesso do ficheiro: |||   |-|-|   | Modo | Devolver valor |   | `Random`| Número de registo seguinte lidas ou escritas |   | `Binary`, `Input`, `Output`, `Append`| Posição de bytes em que ocorre a seguinte operação. É o primeiro byte num ficheiro na posição 1, o segundo byte na posição 2 e assim sucessivamente. |"
  example:
  - "This example uses the `Seek` function to return the current file position. The example assumes `TestFile` is a file that contains records of the structure `Record`.  \n  \n [!code-vb[VbVbalrCatRef#47](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_1.vb)]  \n  \n For files opened in `Random` mode, `Seek` returns the number of next record.  \n  \n [!code-vb[VbVbalrCatRef#48](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_2.vb)]  \n  \n For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#49](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_3.vb)]  \n  \n This example uses the `Seek` function to set the position for the next read or write in a file.  \n  \n For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#52](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_4.vb)]"
  syntax:
    content: public static long Seek (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Um <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> que contém um número de ficheiro válido."
    return:
      type: System.Int64
      description: "Devolve um <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> especificando a posição actual de leitura/escrita num ficheiro aberto utilizando o <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> function ou define a posição para a próxima operação de leitura/escrita num ficheiro aberta utilizando o <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> função."
  overload: Microsoft.VisualBasic.FileSystem.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)
  id: Seek(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Seek(Int32,Int64)
  nameWithType: FileSystem.Seek(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Devolve um <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> especificando a posição actual de leitura/escrita num ficheiro aberto utilizando o <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> function ou define a posição para a próxima operação de leitura/escrita num ficheiro aberta utilizando o <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> função. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_Seek&quot; name=&quot;Seek&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`Seek`Devolve um valor entre 1 e 2 147 483 647 (equivalente a 2 ^ 31-1), inclusive.       O seguinte descreve os valores devolvidos para cada modo de acesso do ficheiro: |||   |-|-|   | Modo | Devolver valor |   | `Random`| Número de registo seguinte lidas ou escritas |   | `Binary`, `Input`, `Output`, `Append`| Posição de bytes em que ocorre a seguinte operação. É o primeiro byte num ficheiro na posição 1, o segundo byte na posição 2 e assim sucessivamente. |"
  example:
  - "This example uses the `Seek` function to return the current file position. The example assumes `TestFile` is a file that contains records of the structure `Record`.  \n  \n [!code-vb[VbVbalrCatRef#47](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_1.vb)]  \n  \n For files opened in `Random` mode, `Seek` returns the number of next record.  \n  \n [!code-vb[VbVbalrCatRef#48](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_2.vb)]  \n  \n For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#49](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_3.vb)]  \n  \n This example uses the `Seek` function to set the position for the next read or write in a file.  \n  \n For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#52](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_4.vb)]"
  syntax:
    content: public static void Seek (int FileNumber, long Position);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Um <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> que contém um número de ficheiro válido."
    - id: Position
      type: System.Int64
      description: "Necessário. Número no intervalo 1-2 147 483 647, inclusive, que indica onde a próxima leitura/escrita operação deve ocorrer."
  overload: Microsoft.VisualBasic.FileSystem.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  id: SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: SetAttr(String,FileAttribute)
  nameWithType: FileSystem.SetAttr(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.SetAttr(String,FileAttribute)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Define o atributo informações para um ficheiro. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe uma maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_SetAttr&quot; name=&quot;SetAttr&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Ocorre um erro de tempo de execução se tentar definir os atributos de um ficheiro aberto.       O `Attributes` valores de enumeração de argumento são os seguintes: |||   |-|-|-|   | Valor | Constante | Descrição |   | `Normal`|`vbNormal`| Normal (predefinição). |   | `ReadOnly`|`vbReadOnly`| Só de leitura. |   | `Hidden`|`vbHidden`| Oculto. |   | `System`|`vbSystem`| Ficheiro de sistema. |   | `Volume`|`vbVolume`| Etiqueta do volume |   | `Directory`|`vbDirectory`| Diretório ou uma pasta. |   | `Archive`|`vbArchive`| O ficheiro foi alterado desde a última cópia de segurança. |   | `Alias`|`vbAlias`| O ficheiro tem um nome diferente. |      > [!NOTE] > Estes enumerações são especificadas pela linguagem Visual Basic. Os nomes podem ser utilizados em qualquer lugar no seu código em vez dos valores reais."
  example:
  - "This example uses the `SetAttr` function to set attributes for a file.  \n  \n [!code-vb[VbVbalrCatRef#14](~/add/codesnippet/visualbasic/7c37826d-7b37-4e2d-b69a-_1.vb)]"
  syntax:
    content: public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);
    parameters:
    - id: PathName
      type: System.String
      description: "Necessário. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>expressão que especifica um nome de ficheiro. `PathName`Pode incluir diretórios ou de pasta e unidade."
    - id: Attributes
      type: Microsoft.VisualBasic.FileAttribute
      description: "Necessário. Expressão de constante ou numérica, cuja soma especifica atributos de ficheiro."
  overload: Microsoft.VisualBasic.FileSystem.SetAttr*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Attribute</code>o tipo é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.SPC(System.Int16)
  id: SPC(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: SPC(Int16)
  nameWithType: FileSystem.SPC(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.SPC(Int16)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Utilizado com o <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> função para a posição de saída."
  remarks: "Se `Count` é inferior à largura da linha de saída, a impressão seguinte posição imediatamente segue o número de espaços de impresso. Se`Count` é maior do que a largura da linha de saída, `SPC` calcula a posição de impressão seguinte utilizando a fórmula: `currentprintposition`(+ (`Count``Mod``width`)) por exemplo, se a posição de impressão atual é 24, a largura da linha de saída é 80 e especificar `SPC(`90`)`, o imprimir seguinte irá iniciar na posição 34 (posição impressão atual + o resto dos 90/80). Se a diferença entre a posição de impressão atual e a largura da linha de saída é inferior a `Count` (ou `Count` `Mod` *largura*), o `SPC` função avançará para o início da linha seguinte e gera espaços iguais a `Count` – (*largura* – *currentprintposition*).      > [!NOTE] > Certifique-se as colunas de tabela são ao nível suficiente para permitir a vasta letras."
  example:
  - "This example uses the `SPC` function to position output in a file and in the **Output** window.  \n  \n [!code-vb[VbVbalrCatRef#16](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._222_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.SpcInfo SPC (short Count);
    parameters:
    - id: Count
      type: System.Int16
      description: "Necessário. O número de espaços para inserir antes de apresentar ou imprimir a seguinte expressão numa lista."
    return:
      type: Microsoft.VisualBasic.SpcInfo
      description: "Utilizado com o <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> função para a posição de saída."
  overload: Microsoft.VisualBasic.FileSystem.SPC*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.TAB
  id: TAB
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: TAB()
  nameWithType: FileSystem.TAB()
  fullName: Microsoft.VisualBasic.FileSystem.TAB()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Utilizado com o <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> funções para a posição de saída."
  remarks: "Se a posição actual de impressão na linha atual é maior do que `Column`, `TAB` avançará para o valor de coluna igual a `Column` a seguinte linha de saída. Se `Column` é inferior a 1, `TAB` move a posição de impressão para a coluna 1. Se `Column` é maior do que a largura da linha de saída, `TAB` calcula a posição de impressão seguinte utilizando a fórmula: largura Mod de coluna, por exemplo, se *largura* é 80 e especificar `TAB(`90`)`, o seguinte imprimir será iniciada na coluna 10 (o resto 90/80). Se `Column` é inferior a posição de impressão atual, impressão começa na linha seguinte na posição impressão calculada. Se a posição de impressão calculada é maior do que a posição actual de impressão, impressão inicia o calculado em Imprimir posição na mesma linha.       A posição de impressão mais â esquerda de uma linha de saída é sempre 1. Quando utiliza o `Print` ou `PrintLine` funções imprimam em ficheiros, a posição de impressão mais â direita é a largura actual do ficheiro de saída, que pode configurar a utilizar o `FileWidth` função.       O `TAB` função também pode ser utilizada com o `WriteLine` função. Não pode ser utilizado com <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>ou <xref:System.Console.WriteLine%2A?displayProperty=fullName>.</xref:System.Console.WriteLine%2A?displayProperty=fullName> </xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>      > [!NOTE] > Certifique-se as colunas de tabela são ao nível suficiente para conter letras wide."
  example:
  - "This example uses the `TAB` function to position output in a file and in the **Output** window.  \n  \n [!code-vb[VbVbalrCatRef#37](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._165_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.TabInfo TAB ();
    parameters: []
    return:
      type: Microsoft.VisualBasic.TabInfo
      description: "Utilizado com o <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> funções para a posição de saída."
  overload: Microsoft.VisualBasic.FileSystem.TAB*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.TAB(System.Int16)
  id: TAB(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: TAB(Int16)
  nameWithType: FileSystem.TAB(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.TAB(Int16)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Utilizado com o <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> funções para a posição de saída."
  remarks: "Se a posição actual de impressão na linha atual é superior ao `Column`, `TAB` avançará para o valor de coluna igual a `Column` a seguinte linha de saída. Se `Column` é inferior a 1, `TAB` move a posição de impressão para a coluna 1. Se `Column` é maior do que a largura da linha de saída, `TAB` calcula a posição de impressão seguinte utilizando a fórmula: largura Mod de coluna, por exemplo, se *largura* é 80 e especificar `TAB(`90`)`, o seguinte imprimir será iniciada na coluna 10 (o resto 90/80). Se `Column` é inferior a posição de impressão atual, impressão começa na linha seguinte na posição impressão calculada. Se a posição de impressão calculada é maior do que a posição actual de impressão, impressão inicia o calculado em Imprimir posição na mesma linha.       A posição de impressão mais â esquerda de uma linha de saída é sempre 1. Quando utiliza o `Print` ou `PrintLine` funções imprimam em ficheiros, a posição de impressão mais â direita é a largura actual do ficheiro de saída, que pode configurar a utilizar o `FileWidth` função.       O `TAB` função também pode ser utilizada com o `WriteLine` função. Não pode ser utilizado com <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>ou <xref:System.Console.WriteLine%2A?displayProperty=fullName>.</xref:System.Console.WriteLine%2A?displayProperty=fullName> </xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>      > [!NOTE] > Certifique-se as colunas de tabela são ao nível suficiente para conter letras wide."
  example:
  - "This example uses the `TAB` function to position output in a file and in the **Output** window.  \n  \n [!code-vb[VbVbalrCatRef#37](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._125_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.TabInfo TAB (short Column);
    parameters:
    - id: Column
      type: System.Int16
      description: "Opcional. O número de coluna movido para antes de apresentar ou imprimir a seguinte expressão numa lista. Se for omitido, <xref uid=&quot;langword_csharp_TAB&quot; name=&quot;TAB&quot; href=&quot;&quot;> </xref> move o ponto de inserção para o início da zona de impressão seguinte."
    return:
      type: Microsoft.VisualBasic.TabInfo
      description: "Utilizado com o <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> funções para a posição de saída."
  overload: Microsoft.VisualBasic.FileSystem.TAB*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)
  id: Unlock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Unlock(Int32)
  nameWithType: FileSystem.Unlock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Controla o acesso por outros processos a totalidade ou parte de um ficheiro aberto utilizando o <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> função. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> e <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "O `Lock` e `Unlock` as funções são utilizadas em ambientes onde vários processos poderão ter acesso ao mesmo ficheiro.       `Lock`e `Unlock` funções são sempre utilizadas pares. Os argumentos `Lock` e `Unlock` têm de ser idênticos.       Se `Record`, ou `FromRecord` e `ToRecord` não são foi fornecido, o bloqueio será para o ficheiro de todo. Se `Record` sozinho especificado único registo será bloqueado/desbloqueado.       Se o ficheiro tiver sido aberto para sequencial entrada ou saída, `Lock` e `Unlock` afetam o ficheiro de todo, independentemente do intervalo especificado pelas `FromRecord` e`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._26_1.vb)]"
  syntax:
    content: public static void Unlock (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
  overload: Microsoft.VisualBasic.FileSystem.Unlock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)
  id: Unlock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Unlock(Int32,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Controla o acesso por outros processos a totalidade ou parte de um ficheiro aberto utilizando o <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> função. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> e <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "O `Lock` e `Unlock` as funções são utilizadas em ambientes onde vários processos poderão ter acesso ao mesmo ficheiro.       `Lock`e `Unlock` funções são sempre utilizadas pares. Os argumentos `Lock` e `Unlock` têm de ser idênticos.       Se `Record`, ou `FromRecord` e `ToRecord` não são foi fornecido, o bloqueio será para o ficheiro de todo. Se `Record` sozinho especificado único registo será bloqueado/desbloqueado.       Se o ficheiro tiver sido aberto para sequencial entrada ou saída, `Lock` e `Unlock` afetam o ficheiro de todo, independentemente do intervalo especificado pelas `FromRecord` e`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._210_1.vb)]"
  syntax:
    content: public static void Unlock (int FileNumber, long Record);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: Record
      type: System.Int64
      description: "Opcional. Número do único registo ou um byte para bloquear ou desbloquear"
  overload: Microsoft.VisualBasic.FileSystem.Unlock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)
  id: Unlock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Unlock(Int32,Int64,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Controla o acesso por outros processos a totalidade ou parte de um ficheiro aberto utilizando o <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> função. O <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funcionalidade dá-lhe maior produtividade e desempenho em operações de e/s de ficheiro que <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> e <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Para obter mais informações, consulte <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "O `Lock` e `Unlock` as funções são utilizadas em ambientes onde vários processos poderão ter acesso ao mesmo ficheiro.       `Lock`e `Unlock` funções são sempre utilizadas pares. Os argumentos `Lock` e `Unlock` têm de ser idênticos.       Se `Record`, ou `FromRecord` e `ToRecord` não são foi fornecido, o bloqueio será para o ficheiro de todo. Se `Record` sozinho especificado único registo será bloqueado/desbloqueado.       Se o ficheiro tiver sido aberto para sequencial entrada ou saída, `Lock` e `Unlock` afetam o ficheiro de todo, independentemente do intervalo especificado pelas `FromRecord` e`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/93b8910d-5e06-4d09-8b8b-_1.vb)]"
  syntax:
    content: public static void Unlock (int FileNumber, long FromRecord, long ToRecord);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Qualquer número de ficheiro válido."
    - id: FromRecord
      type: System.Int64
      description: "Opcional. Número do primeiro registo ou byte para bloquear ou desbloquear."
    - id: ToRecord
      type: System.Int64
      description: "Opcional. Número do último registo ou byte para bloquear ou desbloquear."
  overload: Microsoft.VisualBasic.FileSystem.Unlock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])
  id: Write(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Write(Int32,Object[])
  nameWithType: FileSystem.Write(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Write(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Escreve dados num ficheiro sequencial. Os dados escritos com <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> normalmente é de leitura de um ficheiro ao utilizar <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref>."
  remarks: "O `Write` e `WriteLine` funções são fornecidas para retro-compatibilidade e poderá afetar o desempenho. Para aplicações não legado, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a ficheiros com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Se omitir `Output`, uma linha em branco está impresso no ficheiro. Várias expressões podem ser separadas com uma vírgula.       Ao contrário do `Print` função, o `Write` função insere vírgulas entre os itens e aspas à volta de cadeias que são escritos no ficheiro. Não é necessário colocar delimitadores explícitos na lista. Quando `Write` é utilizada para escrever dados para um ficheiro, apenas numérico, `Boolean`, data, null, e `Error` são suportados os formatos de dados. Os seguintes pressupostos universais forem seguidos para que os dados podem sempre ler e corretamente interpretado utilizando `Input`, independentemente da região:-dados numéricos sempre foi escritos utilizando o período de como o separador decimal.      -Para `Boolean` dados, `#TRUE#` ou `#FALSE#` está impresso. O `True` e `False` palavras-chave não são convertidas, independentemente da região.      -Data de dados são escritos para o ficheiro utilizando o formato de data universal. Quando a data ou o componente de hora está em falta ou zero, apenas a parte fornecida é escrito no ficheiro.      -Nada foi escrito para o ficheiro se `Output` dados estão vazios. No entanto, para dados nula, `#NULL#` é escrito.      -Para `Error` dados, é apresentado o resultado como `#ERROR errorcode#`. O `Error` palavra-chave não está traduzido, independentemente da região.       `WriteLine`Insere um caráter de nova linha (ou seja, uma linha/retorno de avanço feed, ou `Chr(13) + Chr(10)`), depois de serem escritos no caráter final `Output` para o ficheiro.       Pode incorporar aspas numa cadeia utilizando aspas, ou &quot;&quot;. Por exemplo, [!code-vb [VbVbalrCatRef&#63;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._145_1.vb) ] devolve uma cadeia com o valor de `Double quotation marks aren&quot;t &quot;difficult&quot; to handle`.       Escrever um ficheiro utilizando o `Write` ou `WriteLine` funções requer `Append` aceder a partir do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Write` function to write raw data to a sequential file.  \n  \n [!code-vb[VbVbalrCatRef#64](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._145_2.vb)]"
  syntax:
    content: public static void Write (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Um <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> expressão que contém a qualquer número de ficheiro válido."
    - id: Output
      type: System.Object[]
      description: "Opcional. Uma ou mais delimitada por vírgulas expressões para escrever um ficheiro."
  overload: Microsoft.VisualBasic.FileSystem.Write*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Modo de ficheiro é inválido."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])
  id: WriteLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: WriteLine(Int32,Object[])
  nameWithType: FileSystem.WriteLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.WriteLine(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Escreve dados num ficheiro sequencial. Os dados escritos com <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> normalmente é de leitura de um ficheiro ao utilizar <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref>."
  remarks: "O `Write` e `WriteLine` funções são fornecidas para retro-compatibilidade e poderá afetar o desempenho. Para aplicações não legado, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a ficheiros com o Visual Basic](~/add/includes/ajax-current-ext-md.md).       Se omitir `Output`, uma linha em branco está impresso no ficheiro. Várias expressões podem ser separadas com uma vírgula.       Ao contrário do `Print` função, o `Write` função insere vírgulas entre os itens e aspas à volta de cadeias que são escritos no ficheiro. Não é necessário colocar delimitadores explícitos na lista. Quando `Write` é utilizada para escrever dados para um ficheiro, apenas numérico, `Boolean`, data, null, e `Error` são suportados os formatos de dados. Os seguintes pressupostos universais forem seguidos para que os dados podem sempre ler e corretamente interpretado utilizando `Input`, independentemente da região:-dados numéricos sempre foi escritos utilizando o período de como o separador decimal.      -Para `Boolean` dados, `#TRUE#` ou `#FALSE#` está impresso. O `True` e `False` palavras-chave não são convertidas, independentemente da região.      -Data de dados são escritos para o ficheiro utilizando o formato de data universal. Quando a data ou o componente de hora está em falta ou zero, apenas a parte fornecida é escrito no ficheiro.      -Nada foi escrito para o ficheiro se `Output` dados estão vazios. No entanto, para dados nula, `#NULL#` é escrito.      -Para `Error` dados, é apresentado o resultado como `#ERROR errorcode#`. O `Error` palavra-chave não está traduzido, independentemente da região.       `WriteLine`Insere um caráter de nova linha (ou seja, uma linha/retorno de avanço feed, ou `Chr(13) + Chr(10)`), depois de serem escritos no caráter final `Output` para o ficheiro.       Pode incorporar aspas numa cadeia utilizando aspas, ou &quot;&quot;. Por exemplo, [!code-vb [VbVbalrCatRef&#63;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._172_1.vb) ] devolve uma cadeia com o valor de `Double quotation marks aren&quot;t &quot;difficult&quot; to handle`.       Escrever um ficheiro utilizando o `Write` ou `WriteLine` funções requer `Append` aceder a partir do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Write` function to write raw data to a sequential file.  \n  \n [!code-vb[VbVbalrCatRef#64](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._172_2.vb)]"
  syntax:
    content: public static void WriteLine (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Necessário. Um <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> expressão que contém a qualquer número de ficheiro válido."
    - id: Output
      type: System.Object[]
      description: "Opcional. Uma ou mais delimitada por vírgulas expressões para escrever um ficheiro."
  overload: Microsoft.VisualBasic.FileSystem.WriteLine*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.IO.EndOfStreamException
  isExternal: true
  name: System.IO.EndOfStreamException
- uid: Microsoft.VisualBasic.FileSystem.ChDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDir(String)
  nameWithType: FileSystem.ChDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDir(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDrive(Char)
  nameWithType: FileSystem.ChDrive(Char)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(Char)
- uid: System.Char
  parent: System
  isExternal: true
  name: Char
  nameWithType: Char
  fullName: System.Char
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDrive(String)
  nameWithType: FileSystem.ChDrive(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(String)
- uid: Microsoft.VisualBasic.FileSystem.CurDir
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: CurDir()
  nameWithType: FileSystem.CurDir()
  fullName: Microsoft.VisualBasic.FileSystem.CurDir()
- uid: Microsoft.VisualBasic.FileSystem.CurDir(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: CurDir(Char)
  nameWithType: FileSystem.CurDir(Char)
  fullName: Microsoft.VisualBasic.FileSystem.CurDir(Char)
- uid: Microsoft.VisualBasic.FileSystem.Dir
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Dir()
  nameWithType: FileSystem.Dir()
  fullName: Microsoft.VisualBasic.FileSystem.Dir()
- uid: Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Dir(String,FileAttribute)
  nameWithType: FileSystem.Dir(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.Dir(String,FileAttribute)
- uid: Microsoft.VisualBasic.FileAttribute
  parent: Microsoft.VisualBasic
  isExternal: false
  name: FileAttribute
  nameWithType: FileAttribute
  fullName: Microsoft.VisualBasic.FileAttribute
- uid: Microsoft.VisualBasic.FileSystem.EOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: EOF(Int32)
  nameWithType: FileSystem.EOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.EOF(Int32)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileAttr(Int32)
  nameWithType: FileSystem.FileAttr(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileAttr(Int32)
- uid: Microsoft.VisualBasic.OpenMode
  parent: Microsoft.VisualBasic
  isExternal: false
  name: OpenMode
  nameWithType: OpenMode
  fullName: Microsoft.VisualBasic.OpenMode
- uid: Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileClose(Int32[])
  nameWithType: FileSystem.FileClose(Int32[])
  fullName: Microsoft.VisualBasic.FileSystem.FileClose(Int32[])
- uid: System.Int32[]
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32[]
  spec.csharp:
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileCopy(String,String)
  nameWithType: FileSystem.FileCopy(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.FileCopy(String,String)
- uid: Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileDateTime(String)
  nameWithType: FileSystem.FileDateTime(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileDateTime(String)
- uid: System.DateTime
  parent: System
  isExternal: true
  name: DateTime
  nameWithType: DateTime
  fullName: System.DateTime
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Boolean,Int64)
  nameWithType: FileSystem.FileGet(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Boolean,Int64)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Byte,Int64)
  nameWithType: FileSystem.FileGet(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Byte,Int64)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Char,Int64)
  nameWithType: FileSystem.FileGet(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Char,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,DateTime,Int64)
  nameWithType: FileSystem.FileGet(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,DateTime,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Decimal,Int64)
  nameWithType: FileSystem.FileGet(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Decimal,Int64)
- uid: System.Decimal
  parent: System
  isExternal: true
  name: Decimal
  nameWithType: Decimal
  fullName: System.Decimal
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Double,Int64)
  nameWithType: FileSystem.FileGet(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Double,Int64)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Int16,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int16,Int64)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Int32,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Int64,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Single,Int64)
  nameWithType: FileSystem.FileGet(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Single,Int64)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,ValueType,Int64)
  nameWithType: FileSystem.FileGet(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,ValueType,Int64)
- uid: System.ValueType
  parent: System
  isExternal: true
  name: ValueType
  nameWithType: ValueType
  fullName: System.ValueType
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FileGet(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,String,Int64,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGetObject(Int32,Object,Int64)
  nameWithType: FileSystem.FileGetObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGetObject(Int32,Object,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileLen(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileLen(String)
  nameWithType: FileSystem.FileLen(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileLen(String)
- uid: Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  nameWithType: FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
- uid: Microsoft.VisualBasic.OpenAccess
  parent: Microsoft.VisualBasic
  isExternal: false
  name: OpenAccess
  nameWithType: OpenAccess
  fullName: Microsoft.VisualBasic.OpenAccess
- uid: Microsoft.VisualBasic.OpenShare
  parent: Microsoft.VisualBasic
  isExternal: false
  name: OpenShare
  nameWithType: OpenShare
  fullName: Microsoft.VisualBasic.OpenShare
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Boolean,Int64)
  nameWithType: FileSystem.FilePut(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Boolean,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Byte,Int64)
  nameWithType: FileSystem.FilePut(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Byte,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Char,Int64)
  nameWithType: FileSystem.FilePut(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Char,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,DateTime,Int64)
  nameWithType: FileSystem.FilePut(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,DateTime,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Decimal,Int64)
  nameWithType: FileSystem.FilePut(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Decimal,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Double,Int64)
  nameWithType: FileSystem.FilePut(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Double,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Int16,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int16,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Int32,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Int64,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Single,Int64)
  nameWithType: FileSystem.FilePut(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Single,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,ValueType,Int64)
  nameWithType: FileSystem.FilePut(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,ValueType,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Object,Object,Object)
  nameWithType: FileSystem.FilePut(Object,Object,Object)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Object,Object,Object)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FilePut(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,String,Int64,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePutObject(Int32,Object,Int64)
  nameWithType: FileSystem.FilePutObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePutObject(Int32,Object,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileWidth(Int32,Int32)
  nameWithType: FileSystem.FileWidth(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileWidth(Int32,Int32)
- uid: Microsoft.VisualBasic.FileSystem.FreeFile
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FreeFile()
  nameWithType: FileSystem.FreeFile()
  fullName: Microsoft.VisualBasic.FileSystem.FreeFile()
- uid: Microsoft.VisualBasic.FileSystem.GetAttr(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: GetAttr(String)
  nameWithType: FileSystem.GetAttr(String)
  fullName: Microsoft.VisualBasic.FileSystem.GetAttr(String)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Boolean)
  nameWithType: FileSystem.Input(Int32,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Byte)
  nameWithType: FileSystem.Input(Int32,Byte)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Byte)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Char)
  nameWithType: FileSystem.Input(Int32,Char)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Char)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,DateTime)
  nameWithType: FileSystem.Input(Int32,DateTime)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,DateTime)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Decimal)
  nameWithType: FileSystem.Input(Int32,Decimal)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Decimal)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Double)
  nameWithType: FileSystem.Input(Int32,Double)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Double)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Int16)
  nameWithType: FileSystem.Input(Int32,Int16)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int16)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Int32)
  nameWithType: FileSystem.Input(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int32)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Int64)
  nameWithType: FileSystem.Input(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Object)
  nameWithType: FileSystem.Input(Int32,Object)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Object)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Single)
  nameWithType: FileSystem.Input(Int32,Single)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Single)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,String)
  nameWithType: FileSystem.Input(Int32,String)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,String)
- uid: Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: InputString(Int32,Int32)
  nameWithType: FileSystem.InputString(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.InputString(Int32,Int32)
- uid: Microsoft.VisualBasic.FileSystem.Kill(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Kill(String)
  nameWithType: FileSystem.Kill(String)
  fullName: Microsoft.VisualBasic.FileSystem.Kill(String)
- uid: Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LineInput(Int32)
  nameWithType: FileSystem.LineInput(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LineInput(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Loc(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Loc(Int32)
  nameWithType: FileSystem.Loc(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Loc(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock(Int32)
  nameWithType: FileSystem.Lock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock(Int32,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock(Int32,Int64,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.LOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LOF(Int32)
  nameWithType: FileSystem.LOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LOF(Int32)
- uid: Microsoft.VisualBasic.FileSystem.MkDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: MkDir(String)
  nameWithType: FileSystem.MkDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.MkDir(String)
- uid: Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Print(Int32,Object[])
  nameWithType: FileSystem.Print(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Print(Int32,Object[])
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: PrintLine(Int32,Object[])
  nameWithType: FileSystem.PrintLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.PrintLine(Int32,Object[])
- uid: Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Rename(String,String)
  nameWithType: FileSystem.Rename(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.Rename(String,String)
- uid: Microsoft.VisualBasic.FileSystem.Reset
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Reset()
  nameWithType: FileSystem.Reset()
  fullName: Microsoft.VisualBasic.FileSystem.Reset()
- uid: Microsoft.VisualBasic.FileSystem.RmDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: RmDir(String)
  nameWithType: FileSystem.RmDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.RmDir(String)
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Seek(Int32)
  nameWithType: FileSystem.Seek(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Seek(Int32,Int64)
  nameWithType: FileSystem.Seek(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SetAttr(String,FileAttribute)
  nameWithType: FileSystem.SetAttr(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.SetAttr(String,FileAttribute)
- uid: Microsoft.VisualBasic.FileSystem.SPC(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SPC(Int16)
  nameWithType: FileSystem.SPC(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.SPC(Int16)
- uid: Microsoft.VisualBasic.SpcInfo
  parent: Microsoft.VisualBasic
  isExternal: false
  name: SpcInfo
  nameWithType: SpcInfo
  fullName: Microsoft.VisualBasic.SpcInfo
- uid: Microsoft.VisualBasic.FileSystem.TAB
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: TAB()
  nameWithType: FileSystem.TAB()
  fullName: Microsoft.VisualBasic.FileSystem.TAB()
- uid: Microsoft.VisualBasic.TabInfo
  parent: Microsoft.VisualBasic
  isExternal: false
  name: TabInfo
  nameWithType: TabInfo
  fullName: Microsoft.VisualBasic.TabInfo
- uid: Microsoft.VisualBasic.FileSystem.TAB(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: TAB(Int16)
  nameWithType: FileSystem.TAB(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.TAB(Int16)
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock(Int32)
  nameWithType: FileSystem.Unlock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock(Int32,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock(Int32,Int64,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Write(Int32,Object[])
  nameWithType: FileSystem.Write(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Write(Int32,Object[])
- uid: Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: WriteLine(Int32,Object[])
  nameWithType: FileSystem.WriteLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.WriteLine(Int32,Object[])
- uid: Microsoft.VisualBasic.FileSystem.ChDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDir
  nameWithType: FileSystem.ChDir
- uid: Microsoft.VisualBasic.FileSystem.ChDrive*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDrive
  nameWithType: FileSystem.ChDrive
- uid: Microsoft.VisualBasic.FileSystem.CurDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: CurDir
  nameWithType: FileSystem.CurDir
- uid: Microsoft.VisualBasic.FileSystem.Dir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Dir
  nameWithType: FileSystem.Dir
- uid: Microsoft.VisualBasic.FileSystem.EOF*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: EOF
  nameWithType: FileSystem.EOF
- uid: Microsoft.VisualBasic.FileSystem.FileAttr*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileAttr
  nameWithType: FileSystem.FileAttr
- uid: Microsoft.VisualBasic.FileSystem.FileClose*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileClose
  nameWithType: FileSystem.FileClose
- uid: Microsoft.VisualBasic.FileSystem.FileCopy*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileCopy
  nameWithType: FileSystem.FileCopy
- uid: Microsoft.VisualBasic.FileSystem.FileDateTime*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileDateTime
  nameWithType: FileSystem.FileDateTime
- uid: Microsoft.VisualBasic.FileSystem.FileGet*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet
  nameWithType: FileSystem.FileGet
- uid: Microsoft.VisualBasic.FileSystem.FileGetObject*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGetObject
  nameWithType: FileSystem.FileGetObject
- uid: Microsoft.VisualBasic.FileSystem.FileLen*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileLen
  nameWithType: FileSystem.FileLen
- uid: Microsoft.VisualBasic.FileSystem.FileOpen*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileOpen
  nameWithType: FileSystem.FileOpen
- uid: Microsoft.VisualBasic.FileSystem.FilePut*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut
  nameWithType: FileSystem.FilePut
- uid: Microsoft.VisualBasic.FileSystem.FilePutObject*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePutObject
  nameWithType: FileSystem.FilePutObject
- uid: Microsoft.VisualBasic.FileSystem.FileWidth*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileWidth
  nameWithType: FileSystem.FileWidth
- uid: Microsoft.VisualBasic.FileSystem.FreeFile*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FreeFile
  nameWithType: FileSystem.FreeFile
- uid: Microsoft.VisualBasic.FileSystem.GetAttr*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: GetAttr
  nameWithType: FileSystem.GetAttr
- uid: Microsoft.VisualBasic.FileSystem.Input*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input
  nameWithType: FileSystem.Input
- uid: Microsoft.VisualBasic.FileSystem.InputString*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: InputString
  nameWithType: FileSystem.InputString
- uid: Microsoft.VisualBasic.FileSystem.Kill*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Kill
  nameWithType: FileSystem.Kill
- uid: Microsoft.VisualBasic.FileSystem.LineInput*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LineInput
  nameWithType: FileSystem.LineInput
- uid: Microsoft.VisualBasic.FileSystem.Loc*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Loc
  nameWithType: FileSystem.Loc
- uid: Microsoft.VisualBasic.FileSystem.Lock*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock
  nameWithType: FileSystem.Lock
- uid: Microsoft.VisualBasic.FileSystem.LOF*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LOF
  nameWithType: FileSystem.LOF
- uid: Microsoft.VisualBasic.FileSystem.MkDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: MkDir
  nameWithType: FileSystem.MkDir
- uid: Microsoft.VisualBasic.FileSystem.Print*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Print
  nameWithType: FileSystem.Print
- uid: Microsoft.VisualBasic.FileSystem.PrintLine*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: PrintLine
  nameWithType: FileSystem.PrintLine
- uid: Microsoft.VisualBasic.FileSystem.Rename*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Rename
  nameWithType: FileSystem.Rename
- uid: Microsoft.VisualBasic.FileSystem.Reset*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Reset
  nameWithType: FileSystem.Reset
- uid: Microsoft.VisualBasic.FileSystem.RmDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: RmDir
  nameWithType: FileSystem.RmDir
- uid: Microsoft.VisualBasic.FileSystem.Seek*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Seek
  nameWithType: FileSystem.Seek
- uid: Microsoft.VisualBasic.FileSystem.SetAttr*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SetAttr
  nameWithType: FileSystem.SetAttr
- uid: Microsoft.VisualBasic.FileSystem.SPC*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SPC
  nameWithType: FileSystem.SPC
- uid: Microsoft.VisualBasic.FileSystem.TAB*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: TAB
  nameWithType: FileSystem.TAB
- uid: Microsoft.VisualBasic.FileSystem.Unlock*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock
  nameWithType: FileSystem.Unlock
- uid: Microsoft.VisualBasic.FileSystem.Write*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Write
  nameWithType: FileSystem.Write
- uid: Microsoft.VisualBasic.FileSystem.WriteLine*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: WriteLine
  nameWithType: FileSystem.WriteLine
