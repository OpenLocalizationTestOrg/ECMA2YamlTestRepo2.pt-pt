### YamlMime:ManagedReference
items:
- uid: System.IO.Log.LogRecordSequence
  id: LogRecordSequence
  children:
  - System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)
  - System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)
  - System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.LogRecordSequence.BaseSequenceNumber
  - System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.CreateReservationCollection
  - System.IO.Log.LogRecordSequence.Dispose
  - System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.Flush
  - System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.LastSequenceNumber
  - System.IO.Log.LogRecordSequence.LogStore
  - System.IO.Log.LogRecordSequence.MaximumRecordLength
  - System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  - System.IO.Log.LogRecordSequence.ReadRestartAreas
  - System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.LogRecordSequence.ReservedBytes
  - System.IO.Log.LogRecordSequence.RestartSequenceNumber
  - System.IO.Log.LogRecordSequence.RetryAppend
  - System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.TailPinned
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  langs:
  - csharp
  name: LogRecordSequence
  nameWithType: LogRecordSequence
  fullName: System.IO.Log.LogRecordSequence
  type: Class
  summary: "Representa uma sequência de registo armazenada num <xref href=&quot;System.IO.Log.LogStore&quot;> </xref>."
  remarks: "A classe de LogRecordSequence fornece uma implementação da interface de sequência de registos por cima de um registo de sistema de ficheiros de registo comuns (CLFS). Para além das funcionalidades padrão orientado para o registo, fornece um modelo de política de evitando condições de registo-completo e multiplexação de clientes no mesmo ficheiro físico. Funciona com o <xref:System.IO.Log.LogStore>classe, que fornece uma interface para diretamente manipular e gerir um CLFS ficheiro de registo.</xref:System.IO.Log.LogStore> A relação entre o <xref:System.IO.Log.LogStore>classe e a classe de LogRecordSequence é semelhante para a relação entre um ficheiro de disco e um <xref:System.IO.FileStream>objeto.</xref:System.IO.FileStream> </xref:System.IO.Log.LogStore> O ficheiro de disco possibilita o armazenamento concreto e tem atributos, tais como o comprimento e a hora do último acesso; enquanto o <xref:System.IO.FileStream>objeto fornece uma vista do ficheiro que pode ser utilizado para ler a partir do mesmo e escrita ao mesmo.</xref:System.IO.FileStream> Da mesma forma, o <xref:System.IO.Log.LogStore>classe tem atributos como uma política e uma coleção de extensões de disco; e a classe de LogRecordSequence fornece um mecanismo de orientado para o registo de mensagens em fila para ler e escrever dados.</xref:System.IO.Log.LogStore>"
  example:
  - "This example shows how to use the LogRecordSequence class:  \n  \n [!code-cs[S_UELogRecordSequence#0](~/add/codesnippet/csharp/t-system.io.log.logrecor_1.cs)]\n [!code-vb[S_UELogRecordSequence#0](~/add/codesnippet/visualbasic/t-system.io.log.logrecor_1.vb)]"
  syntax:
    content: 'public sealed class LogRecordSequence : IDisposable, System.IO.Log.IRecordSequence'
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  - System.IO.Log.IRecordSequence
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)
  id: '#ctor(System.IO.Log.LogStore)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(LogStore)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> classe com o arquivo de registo especificado."
  remarks: "O tamanho de memória intermédia determina o tamanho máximo do registo que pode ser anexado ou de leitura. Este construtor é definido um valor predefinido de 64. O número pretendido de memórias intermédias está definido para 10."
  syntax:
    content: public LogRecordSequence (System.IO.Log.LogStore logStore);
    parameters:
    - id: logStore
      type: System.IO.Log.LogStore
      description: "O <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> que deve utilizar esta sequência de registo."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>logStore</code>Não é válido."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)
  id: '#ctor(System.String,System.IO.FileMode)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> classe com um caminho especificado para o arquivo de registos e o modo de acesso."
  remarks: "Este construtor inicializa uma nova <xref:System.IO.Log.LogRecordSequence>num novo <xref:System.IO.Log.LogStore>objeto abre-se com o caminho especificado e modo.</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogRecordSequence> É dado acesso de leitura/escrita para o arquivo e é abrir o arquivo de partilha de acesso de leitura."
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o ficheiro de base do arquivo do registo para abrir."
    - id: mode
      type: System.IO.FileMode
      description: "Um do <xref href=&quot;System.IO.FileMode&quot;> </xref> valores que determina como abrir ou criar o arquivo."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>é uma cadeia vazia (&quot;&quot;).       - ou - <code>path</code> contém apenas espaços em branco.       - ou - <code>path</code> contém um ou mais carateres inválidos."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>contém um valor inválido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Não é possível localizar o ficheiro."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorre um erro de e/s ao abrir o arquivo de registos."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para a sequência de registo especificado é negado pelo sistema operativo."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Esta operação não é suportada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>não pode ser utilizado porque o componente de sistema de ficheiros de registo comuns (CLFS) necessário não está instalado. Instale o componente CLFS se estiver disponível para a sua plataforma ou utilize o <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> classe."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)
  id: '#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(LogStore,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> classe com o arquivo de registo especificado, o tamanho da memória intermédia para cada registo e a memória intermédia número."
  remarks: "Utilize este construtor se pretender especificar valores para `bufferSize` e `bufferCount` e não pretender utilizar o valor predefinido de 64 para `bufferSize` e 10 para `bufferCount`."
  syntax:
    content: public LogRecordSequence (System.IO.Log.LogStore logStore, int bufferSize, int bufferCount);
    parameters:
    - id: logStore
      type: System.IO.Log.LogStore
      description: "O <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> que deve utilizar esta sequência de registo."
    - id: bufferSize
      type: System.Int32
      description: "O tamanho de memória intermédia pretendida em bytes. O tamanho de memória intermédia determina o tamanho máximo do registo que pode ser anexado ou de leitura."
    - id: bufferCount
      type: System.Int32
      description: "O número pretendido de memórias intermédias."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>logStore</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize </code>é negativo ou zero.       - ou - <code>bufferCount</code> é negativo ou zero."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> classe com um caminho especificado para o arquivo de registos e os modos de acesso e partilha."
  remarks: "Este construtor inicializa uma nova <xref:System.IO.Log.LogRecordSequence>num novo <xref:System.IO.Log.LogStore>objeto abre-se com o caminho especificado, o modo e o acesso.</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogRecordSequence> Abrir o arquivo de partilha de acesso de leitura."
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o ficheiro de base do arquivo do registo para abrir."
    - id: mode
      type: System.IO.FileMode
      description: "Um do <xref href=&quot;System.IO.FileMode&quot;> </xref> valores que determina como abrir ou criar o arquivo."
    - id: access
      type: System.IO.FileAccess
      description: "Um do <xref href=&quot;System.IO.FileAccess&quot;> </xref> valores que determina a forma como o ficheiro pode ser acedido pelo <xref href=&quot;System.IO.Log.LogStore&quot;> </xref>."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>é uma cadeia vazia (&quot;&quot;).       - ou - <code>path</code> contém apenas espaços em branco.       - ou - <code>path</code> contém um ou mais carateres inválidos."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>contém um valor inválido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Não é possível localizar o ficheiro."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorre um erro de e/s ao abrir o arquivo de registos."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para a sequência de registo especificado é negado pelo sistema operativo."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Esta operação não é suportada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>não pode ser utilizado porque o componente de sistema de ficheiros de registo comuns (CLFS) necessário não está instalado. Instale o componente CLFS se estiver disponível para a sua plataforma ou utilize o <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> classe."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> classe com um caminho especificado para o arquivo de registos e o modo de acesso."
  remarks: "Este construtor inicializa uma nova <xref:System.IO.Log.LogRecordSequence>num novo <xref:System.IO.Log.LogStore>objeto abre-se com o caminho especificado, o modo e o acesso.</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogRecordSequence> Abrir o arquivo de partilha de acesso especificado."
  example:
  - "This example shows how to use this <xref:System.IO.Log.LogRecordSequence> constructor:  \n  \n [!code-cs[S_UELogRecordSequence#1](~/add/codesnippet/csharp/5a33f64b-b9a0-4b07-9df4-_1.cs)]\n [!code-vb[S_UELogRecordSequence#1](~/add/codesnippet/visualbasic/5a33f64b-b9a0-4b07-9df4-_1.vb)]"
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o ficheiro de base do arquivo do registo para abrir."
    - id: mode
      type: System.IO.FileMode
      description: "Um do <xref href=&quot;System.IO.FileMode&quot;> </xref> valores que determina como abrir ou criar o arquivo."
    - id: access
      type: System.IO.FileAccess
      description: "Um do <xref href=&quot;System.IO.FileAccess&quot;> </xref> valores que determina a forma como o ficheiro pode ser acedido pelo <xref href=&quot;System.IO.Log.LogStore&quot;> </xref>."
    - id: share
      type: System.IO.FileShare
      description: "Um do <xref href=&quot;System.IO.FileShare&quot;> </xref> valores que determina a forma como o arquivo de registo será partilhado entre processos."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>é uma cadeia vazia (&quot;&quot;).       - ou - <code>path</code> contém apenas espaços em branco.       - ou - <code>path</code> contém um ou mais carateres inválidos."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>contém um valor inválido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Não é possível localizar o ficheiro."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorre um erro de e/s ao abrir o arquivo de registos."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para a sequência de registo especificado é negado pelo sistema operativo."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Esta operação não é suportada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>não pode ser utilizado porque o componente de sistema de ficheiros de registo comuns (CLFS) necessário não está instalado. Instale o componente CLFS se estiver disponível para a sua plataforma ou utilize o <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> classe."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> classe com um caminho especificado para o arquivo de registos, permissões de ficheiro, modos de acesso e partilha e o tamanho da memória intermédia e contagem de registos."
  remarks: "Este construtor inicializa uma nova <xref:System.IO.Log.LogRecordSequence>num novo <xref:System.IO.Log.LogStore>objeto abre-se com o caminho especificado, o modo e o acesso.</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogRecordSequence> Abrir o arquivo de partilha de acesso especificado."
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o ficheiro de base do arquivo do registo para abrir."
    - id: mode
      type: System.IO.FileMode
      description: "Um do <xref href=&quot;System.IO.FileMode&quot;> </xref> valores que determina como abrir ou criar o arquivo."
    - id: access
      type: System.IO.FileAccess
      description: "Um do <xref href=&quot;System.IO.FileAccess&quot;> </xref> valores que determina a forma como o ficheiro pode ser acedido pelo <xref href=&quot;System.IO.Log.LogStore&quot;> </xref>."
    - id: share
      type: System.IO.FileShare
      description: "Um do <xref href=&quot;System.IO.FileShare&quot;> </xref> valores que determina a forma como o arquivo de registo será partilhado entre processos."
    - id: bufferSize
      type: System.Int32
      description: "O tamanho de memória intermédia pretendida em bytes. O tamanho de memória intermédia determina o tamanho máximo do registo que pode ser anexado ou de leitura."
    - id: bufferCount
      type: System.Int32
      description: "O número pretendido de memórias intermédias."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>é uma cadeia vazia (&quot;&quot;).       - ou - <code>path</code> contém apenas espaços em branco.       - ou - <code>path</code> contém um ou mais carateres inválidos."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>contém um valor inválido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Não é possível localizar o ficheiro."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorre um erro de e/s ao abrir o arquivo de registos."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para a sequência de registo especificado é negado pelo sistema operativo."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Esta operação não é suportada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>não pode ser utilizado porque o componente de sistema de ficheiros de registo comuns (CLFS) necessário não está instalado. Instale o componente CLFS se estiver disponível para a sua plataforma ou utilize o <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> classe."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> classe."
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount, System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o ficheiro de base do arquivo do registo para abrir."
    - id: mode
      type: System.IO.FileMode
      description: "Um <xref href=&quot;System.IO.FileMode&quot;> </xref> valor que determina como abrir ou criar o arquivo."
    - id: access
      type: System.IO.FileAccess
      description: "Um <xref href=&quot;System.IO.FileAccess&quot;> </xref> valor que determina a forma como o arquivo de registos pode ser acedido."
    - id: share
      type: System.IO.FileShare
      description: "Um <xref href=&quot;System.IO.FileShare&quot;> </xref> valor que determina a forma como o arquivo de registo será partilhado entre processos."
    - id: bufferSize
      type: System.Int32
      description: "O tamanho de memória intermédia pretendida em bytes. O tamanho de memória intermédia determina o tamanho máximo do registo que pode ser anexado ou de leitura."
    - id: bufferCount
      type: System.Int32
      description: "O número pretendido de memórias intermédias."
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "Um <xref href=&quot;System.Security.AccessControl.FileSecurity&quot;> </xref> valor que especifica a segurança para definir no arquivo recentemente criado, se o arquivo tem de ser criado."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O ficheiro especificado pelo <code> path </code> não é válido.       - ou - o nome de ficheiro do arquivo de registo especificado não é válido.       - ou - <code> mode </code> tem um valor de <xref href=&quot;System.IO.FileMode&quot;> </xref>e não pode ser utilizada sem acesso de escrita.       - ou - <code> mode </code> tem um valor de <xref href=&quot;System.IO.FileMode&quot;> </xref>e não pode ser utilizada sem acesso de escrita."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Um ou mais dos argumentos são <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Um ou mais dos argumentos estão fora do intervalo."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "O ficheiro especificado pelo <code> path </code> não é possível encontrar."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Não foi possível efetuar o pedido devido a uma exceção de e/s inesperada.       - ou - o ficheiro especificado pelo <code> path </code> não pode ser acedida porque está a ser utilizado por outro processo.       - ou - o ficheiro especificado pelo <code> path </code> não é possível criar porque o ficheiro ou diretório já existe.       - ou - não foi possível vincular o identificador de registo para o conjunto de threads.       - ou - a versão ou formato de ficheiro de registo especificado é inválida."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Esta operação não é suportada."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>não pode ser utilizado porque o componente de sistema de ficheiros de registo comuns (CLFS) necessário não está instalado. Instale o componente CLFS se estiver disponível para a sua plataforma ou utilize o <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> classe."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para a sequência de registo especificado é negado pelo sistema operativo."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  id: AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Move o número de sequência base do registo de reencaminhar. Este método não pode ser herdado."
  remarks: "Este método é frequentemente usado com o <xref:System.IO.Log.LogRecordSequence.TailPinned>eventos para libertar espaço num registo.</xref:System.IO.Log.LogRecordSequence.TailPinned> O <xref:System.IO.Log.LogRecordSequence.TailPinned>evento indica que necessita de seguimento da sequência (ou seja, o número de sequência base) para ser movida de reencaminhar para libertar espaço.</xref:System.IO.Log.LogRecordSequence.TailPinned> Libertar espaço pode ser feito por qualquer um dos escrita reiniciar áreas utilizando o <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>método, ou truncar o registo e utilizando o método de AdvanceBaseSequenceNumber para avançar o número de sequência base de um registo para um especificado pelo `newBaseSequenceNumber` parâmetro.</xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> O código de exemplo na secção de exemplo demonstra a abordagem segundo.       Tenha em atenção que chamar este método é igual à definição de uma nova sequência base número utilizando o <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>método, exceto que nenhum registo de reinício é escrito no registo.</xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>"
  example:
  - "This example shows how to use the AdvanceBaseSequenceNumber method with the <xref:System.IO.Log.LogRecordSequence.TailPinned> event to free up space in a log sequence.  \n  \n```  \nrecordSequence.RetryAppend = true;  \nrecordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  \n  \nvoid HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  \n{  \n   // tailPinnedEventArgs.TargetSequenceNumber is the target   \n   // sequence number to free up space to.    \n   // However, this sequence number is not necessarily valid.  We have  \n   // to use this sequence number as a starting point for finding a  \n   // valid point within the log to advance toward. You need to  \n   // identify a record with a sequence number equal to, or greater  \n   // than TargetSequenceNumber; let's call this   \n   // realTargetSequenceNumber. Once found, move the base  \n  \n   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  \n  \n}  \n```"
  syntax:
    content: public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Especifica a nova base <xref href=&quot;System.IO.Log.SequenceNumber&quot;> </xref> para o registo. Isto tem de estar no intervalo entre o número de sequência base atual e o último número de sequência do registo, inclusivamente."
  overload: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSequenceNumber</code>Não é válido para esta sequência."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Um arquivo novo ou existente caudo ou base do registo ativo é inválido.       - ou - <code> newBaseSequenceNumber </code> não se situa entre os números de sequência base e final desta sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Não foi possível efetuar o pedido devido a uma exceção de e/s inesperada.       - ou - não foi possível efetuar o pedido devido a um erro de dispositivo e/s."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O registo especificado não tem quaisquer extensões. Uma ou mais extensões têm de ser criados antes de uma sequência de registos pode ser utilizada."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para a sequência de registo especificado é negado pelo sistema operativo."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos está cheia."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Escreve um registo para o <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>. Este método não pode ser herdado."
  remarks: "Dados contidos no `data` parâmetro será CONCATENAR para uma matriz de bytes único para acrescentar como o registo. No entanto, nenhum aprovisionar é efetuada para dividir os dados no segmentos de matriz quando o registo de leitura.       Normalmente, este método é concluída antes do registo foi escrito. Para se certificar de que foi escrito um registo, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador utilizando o `recordAppendOptions` parâmetro ou chamada de <xref:System.IO.Log.LogRecordSequence.Flush%2A>método.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  example:
  - "The following example demonstrates how to use this method to append a log record to the sequence.  \n  \n [!code-cs[S_UELogRecordSequence#13](~/add/codesnippet/csharp/11cb4ef9-9d52-4994-983c-_1.cs)]\n [!code-vb[S_UELogRecordSequence#13](~/add/codesnippet/visualbasic/11cb4ef9-9d52-4994-983c-_1.vb)]"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de utilizador especificado."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica a forma como os dados devem ser escritos."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo registo anexado."
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não é válido para esta sequência.       - ou - <code>data</code> não podem ser acrescentados porque é maior do que o tamanho máximo de registos.       - ou - <code>reservations</code> não foi criada por esta sequência de registo."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Um ou mais dos argumentos são <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não se situa entre os números de sequência base e final desta sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Não foi possível efetuar o pedido devido a uma exceção de e/s inesperada.       - ou - não foi possível efetuar o pedido devido a um erro de dispositivo e/s."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Não é possível efetuar a operação porque a sequência de registos foi aberta com acesso só de leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para a sequência de registo especificado é negado pelo sistema operativo."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Acrescenta um registo para o <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>. Este método não pode ser herdado."
  remarks: "Dados contidos no `data` parâmetro será CONCATENAR para uma matriz de bytes único para acrescentar como o registo. No entanto, nenhum aprovisionar é efetuada para dividir os dados no segmentos de matriz quando o registo de leitura.       Normalmente, este método é concluída antes do registo foi escrito. Para se certificar de que foi escrito um registo, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador utilizando o `recordAppendOptions` parâmetro ou chamada de <xref:System.IO.Log.LogRecordSequence.Flush%2A>método.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de utilizador especificado."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica a forma como os dados devem ser escritos."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo registo anexado."
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não é válido para esta sequência.       - ou - <code>data</code> não podem ser acrescentados porque é maior do que o tamanho máximo de registos.       - ou - <code>reservations</code> não foi criada por esta sequência de registo."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Um ou mais dos argumentos são <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não se situa entre os números de sequência base e final desta sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Não foi possível efetuar o pedido devido a uma exceção de e/s inesperada.       - ou - não foi possível efetuar o pedido devido a um erro de dispositivo e/s."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Não é possível efetuar a operação porque a sequência de registos foi aberta com acesso só de leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para a sequência de registo especificado é negado pelo sistema operativo."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Acrescenta um registo para o <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>, utilizar espaço reservado anteriormente na sequência. Este método não pode ser herdado."
  remarks: "Dados contidos no `data` parâmetro será CONCATENAR para uma matriz de bytes único para acrescentar como o registo. No entanto, nenhum aprovisionar é efetuada para dividir os dados no segmentos de matriz quando o registo de leitura.       O registo anexado irá consumir o espaço que foi anteriormente reservado, utilizando uma reserva especificada pelo `reservations` parâmetro. Se a acrescentar for bem sucedida, irá consumir a área de reserva menor, que pode conter os dados e de que a área de reserva será removida da coleção.       Normalmente, este método é concluída antes do registo foi escrito. Para se certificar de que foi escrito um registo, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador utilizando o `recordAppendOptions` parâmetro ou chamada de <xref:System.IO.Log.LogRecordSequence.Flush%2A>método.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de utilizador especificado."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica a forma como os dados devem ser escritos."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> que contém a reserva que deve ser utilizada para este registo."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo registo anexado."
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não é válido para esta sequência.       - ou - <code>data</code> não podem ser acrescentados porque é maior do que o tamanho máximo de registos.       - ou - <code>reservations</code> não foi criada por esta sequência de registo."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Um ou mais dos argumentos são <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não se situa entre os números de sequência base e final desta sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Não foi possível efetuar o pedido devido a uma exceção de e/s inesperada.       - ou - não foi possível efetuar o pedido devido a um erro de dispositivo e/s."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Não é possível efetuar a operação porque a sequência de registos foi aberta com acesso só de leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para a sequência de registo especificado é negado pelo sistema operativo."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Nenhuma reserva suficientemente grande para caber <code> data </code> pode ser encontrado na <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Acrescenta um registo para o <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>, utilizar espaço reservado anteriormente na sequência. Este método não pode ser herdado."
  remarks: "Dados contidos no `data` parâmetro será CONCATENAR para uma matriz de bytes único para acrescentar como o registo. No entanto, nenhum aprovisionar é efetuada para dividir os dados no segmentos de matriz quando o registo de leitura.       O registo anexado irá consumir o espaço que foi anteriormente reservado, utilizando uma reserva especificada pelo `reservations` parâmetro. Se a acrescentar for bem sucedida, irá consumir a área de reserva menor, que pode conter os dados e de que a área de reserva será removida da coleção.       Normalmente, este método é concluída antes do registo foi escrito. Para se certificar de que foi escrito um registo, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador utilizando o `recordAppendOptions` parâmetro ou chamada de <xref:System.IO.Log.IRecordSequence.Flush%2A>método.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de utilizador especificado."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica a forma como os dados devem ser escritos."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> que contém a reserva que deve ser utilizada para este registo."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo registo anexado."
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não é válido para esta sequência.       - ou - <code>data</code> não podem ser acrescentados porque é maior do que o tamanho máximo de registos.       - ou - <code>reservations</code> não foi criada por esta sequência de registo."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Um ou mais dos argumentos são <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não se situa entre os números de sequência base e final desta sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Não foi possível efetuar o pedido devido a uma exceção de e/s inesperada.       - ou - não foi possível efetuar o pedido devido a um erro de dispositivo e/s."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Não é possível efetuar a operação porque a sequência de registos foi aberta com acesso só de leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para a sequência de registo especificado é negado pelo sistema operativo."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Nenhuma reserva suficientemente grande para caber <code> data </code> pode ser encontrado na <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BaseSequenceNumber
  id: BaseSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BaseSequenceNumber
  nameWithType: LogRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.BaseSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Obtém o número de sequência de registo válido primeiro na atual <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>."
  remarks: "Números de sequência válido são maior que ou igual a BaseSequenceNumber e inferior ao <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>.</xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>       O valor desta propriedade pode ser alterado ao chamar o <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>método ou <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>método.</xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> </xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>"
  example:
  - "This example shows how to use the BaseSequenceNumber member in a loop.  \n  \n [!code-cs[S_UELogRecordSequence#10](~/add/codesnippet/csharp/p-system.io.log.logrecor_2_1.cs)]\n [!code-vb[S_UELogRecordSequence#10](~/add/codesnippet/visualbasic/p-system.io.log.logrecor_2_1.vb)]"
  syntax:
    content: public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "O menor número de sequência que corresponde a um registo válido no <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>."
  overload: System.IO.Log.LogRecordSequence.BaseSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A propriedade foi acedida depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Começa uma assíncrona acrescentar a operação. Este método não pode ser herdado."
  remarks: "Deverá passar a <xref:System.IAsyncResult>devolvido por este método para o <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>método para se certificar de que concluiu a operação de acréscimo e de recursos podem ser libertados adequadamente.</xref:System.IO.Log.LogRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Se tiver ocorrido um erro durante uma acrescentar assíncrona, não é emitida uma exceção até o <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>método for chamado com o <xref:System.IAsyncResult>devolvido por este método.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndAppend%2A>       Dados contidos no `data` parâmetro será CONCATENAR para uma matriz de bytes único para acrescentar como o registo. No entanto, nenhum aprovisionar é efetuada para dividir os dados no segmentos de matriz quando o registo de leitura.       Normalmente, este método é concluída antes do registo foi escrito. Para se certificar de que foi escrito um registo, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador utilizando o `recordAppendOptions` parâmetro ou chamada de <xref:System.IO.Log.LogRecordSequence.Flush%2A>método.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de utilizador especificado."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica a forma como os dados devem ser escritos."
    - id: callback
      type: System.AsyncCallback
      description: "Uma opcional chamada de retorno assíncrona, ser chamado quando a acrescentar estiver concluída."
    - id: state
      type: System.Object
      description: "Um objeto fornecidos pelo utilizador que distingue este determinado assíncrona acrescentar pedido a partir de outros pedidos."
    return:
      type: System.IAsyncResult
      description: "Um <xref:System.IAsyncResult>que representa a acrescentar assíncrono, o que pode ainda estar pendentes.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>nextUndoRecord</code>ou <code>previousRecord</code> não é válido para esta sequência.       - ou - <code>data</code> não podem ser acrescentados porque é maior do que o tamanho máximo de registos.       - ou - <code>reservations</code> não foi criada por esta sequência de registo."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Um ou mais dos argumentos são <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>nextUndoRecord</code>ou <code>previousRecord</code> não se situa entre os números de sequência base e final desta sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Não foi possível efetuar o pedido devido a uma exceção de e/s inesperada.       - ou - não foi possível efetuar o pedido devido a um erro de dispositivo e/s."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Não é possível efetuar a operação porque a sequência de registos foi aberta com acesso só de leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para a sequência de registo especificado é negado pelo sistema operativo."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Começa uma assíncrona acrescentar a operação. Este método não pode ser herdado."
  remarks: "Deverá passar a <xref:System.IAsyncResult>devolvido por este método para o <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>método para se certificar de que concluiu a operação de acréscimo e de recursos podem ser libertados adequadamente.</xref:System.IO.Log.LogRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Se tiver ocorrido um erro durante uma acrescentar assíncrona, não é emitida uma exceção até o <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>método for chamado com o <xref:System.IAsyncResult>devolvido por este método.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndAppend%2A>       Dados contidos no `data` parâmetro será CONCATENAR para uma matriz de bytes único para acrescentar como o registo. No entanto, nenhum aprovisionar é efetuada para dividir os dados no segmentos de matriz quando o registo de leitura.       Normalmente, este método é concluída antes do registo foi escrito. Para se certificar de que foi escrito um registo, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador utilizando o `recordAppendOptions` parâmetro ou chamada de <xref:System.IO.Log.LogRecordSequence.Flush%2A>método.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de utilizador especificado."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica a forma como os dados devem ser escritos."
    - id: callback
      type: System.AsyncCallback
      description: "Uma opcional chamada de retorno assíncrona, ser chamado quando a acrescentar estiver concluída."
    - id: state
      type: System.Object
      description: "Um objeto fornecidos pelo utilizador que distingue este determinado assíncrona acrescentar pedido a partir de outros pedidos."
    return:
      type: System.IAsyncResult
      description: "Um <xref:System.IAsyncResult>que representa a acrescentar assíncrono, o que pode ainda estar pendentes.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não é válido para esta sequência.       - ou - <code>data</code> não podem ser acrescentados porque é maior do que o tamanho máximo de registos.       - ou - <code>reservations</code> não foi criada por esta sequência de registo."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Um ou mais dos argumentos são <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não se situa entre os números de sequência base e final desta sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Não foi possível efetuar o pedido devido a uma exceção de e/s inesperada.       - ou - não foi possível efetuar o pedido devido a um erro de dispositivo e/s."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Não é possível efetuar a operação porque a sequência de registos foi aberta com acesso só de leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para a sequência de registo especificado é negado pelo sistema operativo."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Começa uma assíncrona acrescentar a operação. Este método não pode ser herdado."
  remarks: "Deverá passar a <xref:System.IAsyncResult>devolvido por este método para o <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>método para se certificar de que concluiu a operação de acréscimo e de recursos podem ser libertados adequadamente.</xref:System.IO.Log.LogRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Se tiver ocorrido um erro durante uma acrescentar assíncrona, não é emitida uma exceção até o <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>método for chamado com o <xref:System.IAsyncResult>devolvido por este método.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndAppend%2A>       Dados contidos no `data` parâmetro será CONCATENAR para uma matriz de bytes único para acrescentar como o registo. No entanto, nenhum aprovisionar é efetuada para dividir os dados no segmentos de matriz quando o registo de leitura.       O registo anexado irá consumir o espaço que foi anteriormente reservado, utilizando uma reserva especificada pelo `reservations` parâmetro. Se a acrescentar for bem sucedida, irá consumir a área de reserva menor, que pode conter os dados e de que a área de reserva será removida da coleção.       Normalmente, este método é concluída antes do registo foi escrito. Para se certificar de que foi escrito um registo, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador utilizando o `recordAppendOptions` parâmetro ou chamada de <xref:System.IO.Log.LogRecordSequence.Flush%2A>método.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de utilizador especificado."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica a forma como os dados devem ser escritos."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> que contém a reserva que deve ser utilizada para este registo."
    - id: callback
      type: System.AsyncCallback
      description: "Uma opcional chamada de retorno assíncrona, ser chamado quando a acrescentar estiver concluída."
    - id: state
      type: System.Object
      description: "Um objeto fornecidos pelo utilizador que distingue este determinado assíncrona acrescentar pedido a partir de outros pedidos."
    return:
      type: System.IAsyncResult
      description: "Um <xref:System.IAsyncResult>que representa a acrescentar assíncrono, o que pode ainda estar pendentes.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não é válido para esta sequência.       - ou - <code>data</code> não podem ser acrescentados porque é maior do que o tamanho máximo de registos.       - ou - <code>reservations</code> não foi criada por esta sequência de registo."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Um ou mais dos argumentos são <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não se situa entre os números de sequência base e final desta sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Não foi possível efetuar o pedido devido a uma exceção de e/s inesperada.       - ou - não foi possível efetuar o pedido devido a um erro de dispositivo e/s."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Não é possível efetuar a operação porque a sequência de registos foi aberta com acesso só de leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para a sequência de registo especificado é negado pelo sistema operativo."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Nenhuma reserva suficientemente grande para caber <code> data </code> pode ser encontrado na <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Começa uma assíncrona acrescentar a operação. Este método não pode ser herdado."
  remarks: "Deverá passar a <xref:System.IAsyncResult>devolvido por este método para o <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>método para se certificar de que concluiu a operação de acréscimo e de recursos podem ser libertados adequadamente.</xref:System.IO.Log.LogRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Se tiver ocorrido um erro durante uma acrescentar assíncrona, não é emitida uma exceção até o <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>método for chamado com o <xref:System.IAsyncResult>devolvido por este método.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndAppend%2A>       Dados contidos no `data` parâmetro será CONCATENAR para uma matriz de bytes único para acrescentar como o registo. No entanto, nenhum aprovisionar é efetuada para dividir os dados no segmentos de matriz quando o registo de leitura.       O registo anexado irá consumir o espaço que foi anteriormente reservado, utilizando uma reserva especificada pelo `reservations` parâmetro. Se a acrescentar for bem sucedida, irá consumir a área de reserva menor, que pode conter os dados e de que a área de reserva será removida da coleção.       Normalmente, este método é concluída antes do registo foi escrito. Para se certificar de que foi escrito um registo, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador utilizando o `recordAppendOptions` parâmetro ou chamada de <xref:System.IO.Log.LogRecordSequence.Flush%2A>método.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de utilizador especificado."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica a forma como os dados devem ser escritos."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> que contém a reserva que deve ser utilizada para este registo."
    - id: callback
      type: System.AsyncCallback
      description: "Uma opcional chamada de retorno assíncrona, ser chamado quando a acrescentar estiver concluída."
    - id: state
      type: System.Object
      description: "Um objeto fornecidos pelo utilizador que distingue este determinado assíncrona acrescentar pedido a partir de outros pedidos."
    return:
      type: System.IAsyncResult
      description: "Um <xref:System.IAsyncResult>que representa a acrescentar assíncrono, o que pode ainda estar pendentes.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não é válido para esta sequência.       - ou - <code>data</code> não podem ser acrescentados porque é maior do que o tamanho máximo de registos.       - ou - <code>reservations</code> não foi criada por esta sequência de registo."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Um ou mais dos argumentos são <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não se situa entre os números de sequência base e final desta sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Não foi possível efetuar o pedido devido a uma exceção de e/s inesperada.       - ou - não foi possível efetuar o pedido devido a um erro de dispositivo e/s."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Não é possível efetuar a operação porque a sequência de registos foi aberta com acesso só de leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para a sequência de registo especificado é negado pelo sistema operativo."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Nenhuma reserva suficientemente grande para caber <code> data </code> pode ser encontrado na <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  id: BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Começa uma operação assíncrona libertação, utilizar espaço reservado anteriormente na sequência. Este método não pode ser herdado."
  remarks: "Deverá passar a <xref:System.IAsyncResult>devolvido pelo método atual para o <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>método para se certificar de que o esvaziamento terminar e de recursos são libertados adequadamente.</xref:System.IO.Log.LogRecordSequence.EndFlush%2A> </xref:System.IAsyncResult> Se ocorrer um erro durante um esvaziamento assíncrono, não é emitida uma exceção até o <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>método for chamado com o <xref:System.IAsyncResult>devolvido por este método.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndFlush%2A>       Chamar este método garante que todos os registos que foi anexado ao <xref:System.IO.Log.LogRecordSequence>são escritos de forma durável.</xref:System.IO.Log.LogRecordSequence>       Se foi eliminada uma sequência de registo de, ou se obtiver um argumento inválido, as exceções forem emitidas imediatamente dentro esta operação. Erros que ocorreram durante um pedido de libertação assíncrono, por exemplo, uma falha de disco durante o pedido de e/s, irão resultar em exceções a ser geradas quando o <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>método é chamado.</xref:System.IO.Log.LogRecordSequence.EndFlush%2A>"
  syntax:
    content: public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do registo mais recente que deve ser escrito. Se esta <xref href=&quot;System.IO.Log.SequenceNumber&quot;> </xref> é inválido, em seguida, todos os registos devem ser escritos."
    - id: callback
      type: System.AsyncCallback
      description: "Uma opcional chamada de retorno assíncrona, ser chamado quando a remoção estiver concluída."
    - id: state
      type: System.Object
      description: "Um objeto de fornecidos pelo utilizador que distingue este pedido de libertação assíncrono específico de outros pedidos."
    return:
      type: System.IAsyncResult
      description: "Um <xref:System.IAsyncResult>que representa o assíncrona esvaziar operação, o que pode ainda estar pendentes.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>sequenceNumber</code>Não é válido para esta sequência."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>sequenceNumber</code>não se encontra entre os números de sequência base e final desta sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Não foi possível efetuar o pedido devido a uma exceção de e/s inesperada."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O registo especificado não tem quaisquer extensões. Uma ou mais extensões têm de ser criados antes de uma sequência de registos pode ser utilizada."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Não é possível efetuar a operação porque a sequência de registos foi aberta com acesso só de leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para a sequência de registo especificado é negado pelo sistema operativo."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Começa uma reserva assíncrona e acrescentar a operação. Este método não pode ser herdado."
  remarks: "Deverá passar a <xref:System.IAsyncResult>devolvido por este método para o <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>método para se certificar de que concluiu a operação de acréscimo e de recursos podem ser libertados adequadamente.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> Se tiver ocorrido um erro durante uma acrescentar assíncrona, não é emitida uma exceção até o <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>método for chamado com o <xref:System.IAsyncResult>devolvido por este método.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>       Dados contidos no `data` parâmetro será CONCATENAR para uma matriz de bytes único para acrescentar como o registo. No entanto, nenhum aprovisionar é efetuada para dividir os dados no segmentos de matriz quando o registo de leitura.       As reservas especificadas são adicionadas para a reserva fornecida coleção numa operação atómica com um registo acrescentar a operação. Se a acrescentar falhar, não existe espaço está reservado.       Normalmente, este método pode concluir antes do registo foi escrito. Para se certificar de que foi escrito um registo, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador utilizando o `recordAppendOptions` parâmetro ou chamada de <xref:System.IO.Log.LogRecordSequence.Flush%2A>método.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       Se foi eliminada uma sequência de registo de, ou se obtiver um argumento inválido, as exceções forem emitidas imediatamente dentro esta operação. Erros que ocorreram durante um pedido de acréscimo assíncrona, por exemplo, uma falha de disco durante o pedido de e/s, irão resultar em exceções a ser geradas quando o <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>método é chamado.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de utilizador especificado."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica a forma como os dados devem ser escritos."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A coleção de reserva para tornar as reservas no."
    - id: reservations
      type: System.Int64[]
      description: "As reservas para que, em bytes."
    - id: callback
      type: System.AsyncCallback
      description: "Uma opcional chamada de retorno assíncrona, ser chamado quando a acrescentar estiver concluída."
    - id: state
      type: System.Object
      description: "Um objeto fornecidos pelo utilizador que distingue este determinado assíncrona acrescentar pedido a partir de outros pedidos."
    return:
      type: System.IAsyncResult
      description: "Um <xref:System.IAsyncResult>que representa esta operação assíncrona, que foi ainda estar pendente.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não é válido para esta sequência.       - ou - <code>data</code> não podem ser acrescentados porque é maior do que o tamanho máximo de registos.       - ou - <code>reservations</code> não foi criada por esta sequência de registo."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Um ou mais dos argumentos são <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não se situa entre os números de sequência base e final desta sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Não foi possível efetuar o pedido devido a uma exceção de e/s inesperada.       - ou - não foi possível efetuar o pedido devido a um erro de dispositivo e/s."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Não é possível efetuar a operação porque a sequência de registos foi aberta com acesso só de leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para a sequência de registo especificado é negado pelo sistema operativo."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Nenhuma reserva suficientemente grande para caber <code> data </code> pode ser encontrado na <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Começa uma reserva assíncrona e acrescentar a operação. Este método não pode ser herdado."
  remarks: "Deverá passar a <xref:System.IAsyncResult>devolvido por este método para o <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>método para se certificar de que concluiu a operação de acréscimo e de recursos podem ser libertados adequadamente.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> Se tiver ocorrido um erro durante uma acrescentar assíncrona, não é emitida uma exceção até o <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>método for chamado com o <xref:System.IAsyncResult>devolvido por este método.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>       Dados contidos no `data` parâmetro será CONCATENAR para uma matriz de bytes único para acrescentar como o registo. No entanto, nenhum aprovisionar é efetuada para dividir os dados no segmentos de matriz quando o registo de leitura.       As reservas especificadas são adicionadas para a reserva fornecida coleção numa operação atómica com um registo acrescentar a operação. Se a acrescentar falhar, não existe espaço está reservado.       Normalmente, este método pode concluir antes do registo foi escrito. Para se certificar de que foi escrito um registo, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador utilizando o `recordAppendOptions` parâmetro ou chamada de <xref:System.IO.Log.LogRecordSequence.Flush%2A>método.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       Se foi eliminada uma sequência de registo de, ou se obtiver um argumento inválido, as exceções forem emitidas imediatamente dentro esta operação. Erros que ocorreram durante um pedido de acréscimo assíncrona, por exemplo, uma falha de disco durante o pedido de e/s, irão resultar em exceções a ser geradas quando o <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>método é chamado.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de utilizador especificado."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica a forma como os dados devem ser escritos."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A coleção de reserva para tornar as reservas no."
    - id: reservations
      type: System.Int64[]
      description: "As reservas para que, em bytes."
    - id: callback
      type: System.AsyncCallback
      description: "Uma opcional chamada de retorno assíncrona, ser chamado quando a acrescentar estiver concluída."
    - id: state
      type: System.Object
      description: "Um objeto fornecidos pelo utilizador que distingue este determinado assíncrona acrescentar pedido a partir de outros pedidos."
    return:
      type: System.IAsyncResult
      description: "Um <xref:System.IAsyncResult>que representa esta operação assíncrona, que foi ainda estar pendente.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao acrescentar o registo."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos não foi possível efetuar o espaço livre suficiente para conter o novo registo de ou para efetuar a reserva."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Começa uma operação de escrita de área reinício assíncrona, utilizar espaço reservado anteriormente na sequência. Este método não pode ser herdado."
  remarks: "Deverá passar a <xref:System.IAsyncResult>devolvido por este método para o <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>método para se certificar de que concluiu a operação de escrita de área de reinício e de recursos podem ser libertados adequadamente.</xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> Se tiver ocorrido um erro durante uma operação de escrita de área de reinício assíncrona, não é emitida uma exceção até o <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>método for chamado com o <xref:System.IAsyncResult>devolvido por este método.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>       Dados contidos no `data` parâmetro será CONCATENAR para uma matriz de bytes único para acrescentar como o registo. No entanto, nenhum aprovisionar é efetuada para dividir os dados no segmentos de matriz quando o registo de leitura.       Quando a operação for concluída com êxito, o número de sequência base foi atualizado. Todos os registos com números de sequência de menor que o novo número de sequência base não estão acessíveis.       Se um <xref:System.IO.Log.ReservationCollection>for especificado, a área de reinício escrito irá consumir o espaço que foi anteriormente reservado, utilizando uma reserva contida na coleção.</xref:System.IO.Log.ReservationCollection> Se o método for bem sucedida, consumirá a reserva de menor que pode conter os dados e de que a reserva será removida da coleção.       Se foi eliminada uma sequência de registo de, ou se obtiver um argumento inválido, as exceções forem emitidas imediatamente dentro esta operação. Erros que ocorreram durante um pedido de acréscimo assíncrona, por exemplo, uma falha de disco durante o pedido de e/s, irão resultar em exceções a ser geradas quando o <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>método é chamado.</xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Segmentos de matriz de bytes que serão concatenados e acrescentados como o registo."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "O novo número de sequência base. O número sequencial especificado tem de ser maior que ou igual ao número de sequência base atual."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> que contém a reserva que deve ser utilizada para esta área de reinício."
    - id: callback
      type: System.AsyncCallback
      description: "Uma opcional chamada de retorno assíncrona, ser chamado quando a operação de escrita de área de reinício estiver concluída."
    - id: state
      type: System.Object
      description: "Um objeto de fornecidos pelo utilizador que distingue este pedido de escrita de área específica de reinício assíncrona de outros pedidos."
    return:
      type: System.IAsyncResult
      description: "Um <xref:System.IAsyncResult>que representa o assíncrona reiniciar operação de escrita de área, pode ainda estar pendentes.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code>Não é válido para esta sequência.       - ou - o número de sequência de início de enumeração de registo especificado é inválido.       - ou - <code>data</code> não podem ser acrescentados porque é maior do que o tamanho máximo de registos.       - ou - <code>reservation</code> não foi criada por esta sequência de registo."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Uma ou mais dos parâmetros é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Um arquivo novo ou existente caudo ou base do registo ativo é inválido.       - ou - <code> newBaseSeqNum </code> não se situa entre os números de sequência base e final desta sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Não foi possível efetuar o pedido devido a uma exceção de e/s inesperada.       - ou - não foi possível efetuar o pedido devido a um erro de dispositivo e/s."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para a sequência de registo especificado é negado pelo sistema operativo."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos está cheia."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Começa uma operação de escrita de área reinício assíncrona, utilizar espaço reservado anteriormente na sequência. Este método não pode ser herdado."
  remarks: "Deverá passar a <xref:System.IAsyncResult>devolvido por este método para o <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>método para se certificar de que concluiu a operação de escrita de área de reinício e de recursos podem ser libertados adequadamente.</xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> Se tiver ocorrido um erro durante uma operação de escrita de área de reinício assíncrona, não é emitida uma exceção até o <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>método for chamado com o <xref:System.IAsyncResult>devolvido por este método.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>       Dados contidos no `data` parâmetro será CONCATENAR para uma matriz de bytes único para acrescentar como o registo. No entanto, nenhum aprovisionar é efetuada para dividir os dados no segmentos de matriz quando o registo de leitura.       Quando a operação for concluída com êxito, o número de sequência base foi atualizado. Todos os registos com números de sequência de menor que o novo número de sequência base não estão acessíveis.       Se um <xref:System.IO.Log.ReservationCollection>for especificado, a área de reinício escrito irá consumir o espaço que foi anteriormente reservado, utilizando uma reserva contida na coleção.</xref:System.IO.Log.ReservationCollection> Se o método for bem sucedida, consumirá a reserva de menor que pode conter os dados e de que a reserva será removida da coleção.       Se foi eliminada uma sequência de registo de, ou se obtiver um argumento inválido, as exceções forem emitidas imediatamente dentro esta operação. Erros que ocorreram durante um pedido de acréscimo assíncrona, por exemplo, uma falha de disco durante o pedido de e/s, irão resultar em exceções a ser geradas quando o <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>método é chamado.</xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "O novo número de sequência base. O número sequencial especificado tem de ser maior que ou igual ao número de sequência base atual."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> que contém a reserva que deve ser utilizada para esta área de reinício."
    - id: callback
      type: System.AsyncCallback
      description: "Uma opcional chamada de retorno assíncrona, ser chamado quando a operação de escrita de área de reinício estiver concluída."
    - id: state
      type: System.Object
      description: "Um objeto de fornecidos pelo utilizador que distingue este pedido de escrita de área específica de reinício assíncrona de outros pedidos."
    return:
      type: System.IAsyncResult
      description: "Um <xref:System.IAsyncResult>que representa o assíncrona reiniciar operação de escrita de área, pode ainda estar pendentes.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code>Não é válido para esta sequência.       - ou - o número de sequência de início de enumeração de registo especificado é inválido.       - ou - <code>data</code> não podem ser acrescentados porque é maior do que o tamanho máximo de registos.       - ou - <code>reservationCollection</code> não foi criada por esta sequência de registo."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Uma ou mais dos parâmetros é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Um arquivo novo ou existente caudo ou base do registo ativo é inválido.       - ou - <code> newBaseSeqNum </code> não se situa entre os números de sequência base e final desta sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Não foi possível efetuar o pedido devido a uma exceção de e/s inesperada.       - ou - não foi possível efetuar o pedido devido a um erro de dispositivo e/s."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para a sequência de registo especificado é negado pelo sistema operativo."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos está cheia."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.CreateReservationCollection
  id: CreateReservationCollection
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: CreateReservationCollection()
  nameWithType: LogRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.LogRecordSequence.CreateReservationCollection()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Cria uma nova <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>. Este método não pode ser herdado."
  remarks: ''
  example:
  - "Reservations can be performed in two ways as shown in the following examples. You can adopt the practices in the samples for robust processing. Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.  \n  \n```  \n//Using the ReserveAndAppend Method  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nlong[] lengthOfUndoRecords = new long[] { 1000 };  \nrecordSequence.ReserveAndAppend(recordData,  \n                                                     userSqn,  \n                                                     previousSqn,  \n                                                     RecordSequenceAppendOptions.None,  \n                                                     reservations,  \n                                                     lengthOfUndoRecords);  \nrecordSequence.Append(undoRecordData,    // If necessary …  \n                                    userSqn,  \n                                    previousSqn,  \n                                    RecordSequenceAppendOptions.ForceFlush,  \n                                    reservations);  \n  \n// Using the Manual Approach  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nreservations.Add(lengthOfUndoRecord);  \ntry  \n{  \n   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  \n}  \ncatch (Exception)  \n{  \n   reservations.Remove(lengthOfUndoRecord);  \n   throw;  \n}  \n  \nrecordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  \n```"
  syntax:
    content: public System.IO.Log.ReservationCollection CreateReservationCollection ();
    parameters: []
    return:
      type: System.IO.Log.ReservationCollection
      description: "Criado recentemente <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>."
  overload: System.IO.Log.LogRecordSequence.CreateReservationCollection*
  exceptions:
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Dispose
  id: Dispose
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Dispose()
  nameWithType: LogRecordSequence.Dispose()
  fullName: System.IO.Log.LogRecordSequence.Dispose()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Liberta os recursos utilizados pelo componente."
  remarks: ''
  example:
  - "This example shows how to use Dispose to release resource:  \n  \n [!code-cs[S_UELogRecordSequence#11](~/add/codesnippet/csharp/m-system.io.log.logrecor_1.cs)]\n [!code-vb[S_UELogRecordSequence#11](~/add/codesnippet/visualbasic/m-system.io.log.logrecor_1.vb)]  \n  \n [!code-cs[S_UELogRecordSequence#12](~/add/codesnippet/csharp/m-system.io.log.logrecor_2.cs)]\n [!code-vb[S_UELogRecordSequence#12](~/add/codesnippet/visualbasic/m-system.io.log.logrecor_2.vb)]"
  syntax:
    content: public void Dispose ();
    parameters: []
  overload: System.IO.Log.LogRecordSequence.Dispose*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)
  id: EndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Terminar uma assíncrona acrescentar a operação. Este método não pode ser herdado."
  remarks: "Este método bloqueia enquanto a operação de e/s tiver sido concluída. Erros ocorridos durante um pedido de escrita assíncrona, tais como uma falha de disco durante o pedido de e/s ficam visíveis quando EndAppend é chamado.       Este método tem de ser chamado exatamente uma vez em cada <xref:System.IAsyncResult>devolvido pelo <xref:System.IO.Log.LogRecordSequence.BeginAppend%2A>método.</xref:System.IO.Log.LogRecordSequence.BeginAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Uma referência para o pedido de e/s assíncrona pendente."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo registo anexado."
  overload: System.IO.Log.LogRecordSequence.EndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>Não é válido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Não foi possível efetuar o pedido devido a uma exceção de e/s inesperada.       - ou - não foi possível efetuar o pedido devido a um erro de dispositivo e/s."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End &quot; name=&quot;End &quot; href=&quot;&quot;></xref>já foi chamado para esta operação assíncrona."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Não é possível efetuar a operação porque a sequência de registos foi aberta com acesso só de leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para a sequência de registo especificado é negado pelo sistema operativo."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)
  id: EndFlush(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndFlush(IAsyncResult)
  nameWithType: LogRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndFlush(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Termina uma operação assíncrona. Este método não pode ser herdado."
  remarks: "Este método bloqueia enquanto a operação de e/s tiver sido concluída. Erros ocorridos durante um pedido de libertação assíncrono, tais como uma falha de disco durante o pedido de e/s ficam visíveis quando EndFlush é chamado.       Este método tem de ser chamado exatamente uma vez em cada <xref:System.IAsyncResult>devolvido pelo <xref:System.IO.Log.LogRecordSequence.BeginFlush%2A>método.</xref:System.IO.Log.LogRecordSequence.BeginFlush%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Uma referência para o pedido de e/s assíncrona pendente."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do último registo escrito."
  overload: System.IO.Log.LogRecordSequence.EndFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>Não é válido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Não foi possível efetuar o pedido devido a uma exceção de e/s inesperada."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>já foi chamado para esta operação assíncrona."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Não é possível efetuar a operação porque a sequência de registos foi aberta com acesso só de leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para a sequência de registo especificado é negado pelo sistema operativo."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  id: EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndReserveAndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Terminar uma assíncrona reserva e acrescentar a operação. Este método não pode ser herdado."
  remarks: "Este método bloqueia enquanto a operação de e/s tiver sido concluída. Erros ocorridos durante um pedido de escrita assíncrona, tais como uma falha de disco durante o pedido de e/s ficam visíveis quando EndReserveAndAppend é chamado.       Este método tem de ser chamado exatamente uma vez em cada <xref:System.IAsyncResult>devolvido pelo <xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A>método.</xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Uma referência para o pedido de e/s assíncrona pendente."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo registo anexado."
  overload: System.IO.Log.LogRecordSequence.EndReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>Não é válido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Não foi possível efetuar o pedido devido a uma exceção de e/s inesperada.       - ou - não foi possível efetuar o pedido devido a um erro de dispositivo e/s."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>já foi chamado para esta operação assíncrona."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Não é possível efetuar a operação porque a sequência de registos foi aberta com acesso só de leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para a sequência de registo especificado é negado pelo sistema operativo."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  id: EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: LogRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndWriteRestartArea(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Termina uma operação de escrita de área de reinício assíncrona. Este método não pode ser herdado."
  remarks: "Este método bloqueia enquanto a operação de e/s tiver sido concluída. Erros ocorridos durante um pedido de escrita assíncrona, tais como uma falha de disco durante o pedido de e/s ficam visíveis quando EndWriteRestartArea é chamado.       Este método tem de ser chamado exatamente uma vez em cada <xref:System.IAsyncResult>devolvido pelo <xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A>método.</xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Uma referência para o pedido de e/s assíncrona pendente."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do registo escrito do registo."
  overload: System.IO.Log.LogRecordSequence.EndWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>Não é válido."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Um arquivo novo ou existente caudo ou base do registo ativo é inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Não foi possível efetuar o pedido devido a uma exceção de e/s inesperada."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>já foi chamado para esta operação assíncrona."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para a sequência de registo especificado é negado pelo sistema operativo."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos está cheia."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Flush
  id: Flush
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Flush()
  nameWithType: LogRecordSequence.Flush()
  fullName: System.IO.Log.LogRecordSequence.Flush()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Garante que todos os registos anexados escritos. Este método não pode ser herdado."
  remarks: "Chamar este método garante que todos os registos que foi anexado ao <xref:System.IO.Log.LogRecordSequence>escritos forma durável.</xref:System.IO.Log.LogRecordSequence>"
  syntax:
    content: public System.IO.Log.SequenceNumber Flush ();
    parameters: []
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do último registo escrito."
  overload: System.IO.Log.LogRecordSequence.Flush*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao limpar os dados."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Esta operação não é suportada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para a sequência de registo especificado é negado pelo sistema operativo."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos não foi possível efetuar o espaço livre suficiente para conter a nova área de reinício."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O registo especificado não tem quaisquer extensões. Uma ou mais extensões têm de ser criados antes de uma sequência de registos pode ser utilizada."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)
  id: Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Flush(SequenceNumber)
  nameWithType: LogRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.Flush(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Garante que todos os registos anexados até e incluindo o registo com o número sequencial especificado forma durável escritos. Este método não pode ser herdado."
  remarks: "Chamar que este método garante que todos os registos de sequência de números até e incluindo o número sequencial especificado forma durável escritos."
  syntax:
    content: public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do registo mais recente que deve ser escrito. Se esta <xref href=&quot;System.IO.Log.SequenceNumber&quot;> </xref> é inválido, em seguida, todos os registos devem ser escritos."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do último registo escrito."
  overload: System.IO.Log.LogRecordSequence.Flush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>sequenceNumber</code>Não é válido para esta sequência."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>sequenceNumber</code>não se encontra entre os números de sequência base e final desta sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Não foi possível efetuar o pedido devido a uma exceção de e/s inesperada."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O registo especificado não tem quaisquer extensões. Uma ou mais extensões têm de ser criados antes de uma sequência de registos pode ser utilizada."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Não é possível efetuar a operação porque a sequência de registos foi aberta com acesso só de leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para a sequência de registo especificado é negado pelo sistema operativo."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.LastSequenceNumber
  id: LastSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LastSequenceNumber
  nameWithType: LogRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.LastSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Obtém o número de sequência que é maior do que o último registo anexado"
  remarks: "Esta propriedade contém um número de sequência é assegurado para ser maior do que o número de sequência do último anexado registo. Números de sequência válido são maior que ou igual a <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A>e inferior ao LastSequenceNumber.</xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> Todos os outros números de sequência são inválidos."
  syntax:
    content: public System.IO.Log.SequenceNumber LastSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "Número de uma sequência que é maior do que o último registo anexado."
  overload: System.IO.Log.LogRecordSequence.LastSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A propriedade foi acedida depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.LogStore
  id: LogStore
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogStore
  nameWithType: LogRecordSequence.LogStore
  fullName: System.IO.Log.LogRecordSequence.LogStore
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Obtém o <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> que contém os dados para esta sequência de registo. Este método não pode ser herdado."
  remarks: ''
  example:
  - "This example shows how to use the LogStore member to add extents.  \n  \n [!code-cs[S_UELogRecordSequence#11](~/add/codesnippet/csharp/p-system.io.log.logrecor_1_1.cs)]\n [!code-vb[S_UELogRecordSequence#11](~/add/codesnippet/visualbasic/p-system.io.log.logrecor_1_1.vb)]"
  syntax:
    content: public System.IO.Log.LogStore LogStore { get; }
    return:
      type: System.IO.Log.LogStore
      description: "O <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> que contém os dados para esta sequência de registo."
  overload: System.IO.Log.LogRecordSequence.LogStore*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.MaximumRecordLength
  id: MaximumRecordLength
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: MaximumRecordLength
  nameWithType: LogRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.LogRecordSequence.MaximumRecordLength
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Obtém o tamanho máximo de um registo que pode ser adicionado a esta sequência de registo."
  syntax:
    content: public long MaximumRecordLength { get; }
    return:
      type: System.Int64
      description: "O tamanho máximo de um registo que pode ser adicionado a esta sequência de registo."
  overload: System.IO.Log.LogRecordSequence.MaximumRecordLength*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  id: ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Devolve uma coleção enumeráveis de registos na sequência. Este método não pode ser herdado."
  remarks: "Este método devolve uma coleção enumeráveis de registos na sequência. A ordem dos registos enumerados depende do valor da `logRecordEnum` parâmetro."
  example:
  - "This example shows how to use ReadLogRecords in a loop.  \n  \n [!code-cs[S_UELogRecordSequence#10](~/add/codesnippet/csharp/65162f37-dafe-4315-8e44-_1.cs)]\n [!code-vb[S_UELogRecordSequence#10](~/add/codesnippet/visualbasic/65162f37-dafe-4315-8e44-_1.vb)]"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);
    parameters:
    - id: start
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do registo primeiro onde começa a leitura."
    - id: logRecordEnum
      type: System.IO.Log.LogRecordEnumeratorType
      description: "Um <xref href=&quot;System.IO.Log.LogRecordEnumeratorType&quot;> </xref> valor que especifica a forma (ou seja, reencaminhar ou trás) em que regista deve ser lida a partir de um <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>."
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "Uma coleção enumeráveis de registos na sequência."
  overload: System.IO.Log.LogRecordSequence.ReadLogRecords*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>start</code>Não é válido para esta sequência.       - ou - <code>logRecordEnum</code> é inválido.       - ou - o elemento especificado não foi encontrado na coleção."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>start</code>não se encontra entre os números de sequência base e final desta sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Não foi possível efetuar o pedido devido a uma exceção de e/s inesperada.       - ou - não foi possível efetuar o pedido devido a um erro de dispositivo e/s.       - ou o tamanho de memória intermédia utilizada para escrever o registo é maior do que o tamanho de memória intermédia que está a ser utilizado para o ler.       - ou - a sequência de registos está danificada.       - ou - a versão ou formato de ficheiro de registo especificado é inválida.       - ou - o registo foi escrito com uma versão incompatível da sequência de registo."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A operação é inválida porque a enumeração não foi iniciada. Uma chamada para <xref:System.Collections.IEnumerator.MoveNext*>têm de ser efetuadas.</xref:System.Collections.IEnumerator.MoveNext*>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para a sequência de registo especificado é negado pelo sistema operativo."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReadRestartAreas
  id: ReadRestartAreas
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReadRestartAreas()
  nameWithType: LogRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.LogRecordSequence.ReadRestartAreas()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Devolve uma coleção de áreas de reinício enumeráveis na sequência. Este método não pode ser herdado."
  remarks: "As áreas de reinício são enumeradas na ordem de número de sequência inversa, ou seja, do número de sequência maior para o menor número de sequência. Reinicie apenas áreas com números de sequência entre o último número de sequência e o número de sequência base são enumerados."
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadRestartAreas ();
    parameters: []
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "Uma coleção enumeráveis de áreas de reinício na sequência."
  overload: System.IO.Log.LogRecordSequence.ReadRestartAreas*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>start</code>não se encontra entre os números de sequência base e final desta sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Não foi possível efetuar o pedido devido a uma exceção de e/s inesperada.       - ou - não foi possível efetuar o pedido devido a um erro de dispositivo e/s.       - ou o tamanho de memória intermédia utilizada para escrever o registo é maior do que o tamanho de memória intermédia que está a ser utilizado para o ler.       - ou - a sequência de registos está danificada.       - ou - a versão ou formato de ficheiro de registo especificado é inválida.       - ou - o registo foi escrito com uma versão incompatível da sequência de registo."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A operação é inválida porque a enumeração não foi iniciada. Uma chamada para <xref:System.Collections.IEnumerator.MoveNext*>têm de ser efetuadas.</xref:System.Collections.IEnumerator.MoveNext*>       - ou a enumeração terminou."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para a sequência de registo especificado é negado pelo sistema operativo."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Faz uma reserva único e acrescenta um registo para a sequência automaticamente. Este método não pode ser herdado."
  remarks: "Dados contidos no `data` parâmetro será CONCATENAR para uma matriz de bytes único para acrescentar como o registo. No entanto, nenhum aprovisionar é efetuada para dividir os dados no segmentos de matriz quando o registo de leitura.       As reservas especificadas são adicionadas para a reserva fornecida coleção numa operação atómica com um registo acrescentar a operação. Se a acrescentar falhar, não existe espaço está reservado.       Normalmente, este método pode concluir antes do registo foi escrito. Para se certificar de que foi escrito um registo, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador utilizando o `recordAppendOptions` parâmetro ou chamada de <xref:System.IO.Log.LogRecordSequence.Flush%2A>método.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  example:
  - "The following example shows how to use this method to make reservations. Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.  \n  \n```  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nlong[] lengthOfUndoRecords = new long[] { 1000 };  \nrecordSequence.ReserveAndAppend(recordData,  \n                                                     userSqn,  \n                                                     previousSqn,  \n                                                     RecordSequenceAppendOptions.None,  \n                                                     reservations,  \n                                                     lengthOfUndoRecords);  \nrecordSequence.Append(undoRecordData,    // If necessary …  \n                                    userSqn,  \n                                    previousSqn,  \n                                    RecordSequenceAppendOptions.ForceFlush,  \n                                    reservations);  \n```"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de utilizador especificado."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica a forma como os dados devem ser escritos."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> que contém a coleção para tornar as reservas no."
    - id: reservations
      type: System.Int64[]
      description: "As reservas para que, em bytes."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo registo anexado."
  overload: System.IO.Log.LogRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>nextUndoRecord</code>ou <code>previousRecord</code> não é válido para esta sequência.       - ou - <code>data</code> não podem ser acrescentados porque é maior do que o tamanho máximo de registos.       - ou - <code>reservations</code> não foi criada por esta sequência de registo."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Um ou mais dos argumentos são <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>nextUndoRecord</code>ou <code>previousRecord</code> não se situa entre os números de sequência base e final desta sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Não foi possível efetuar o pedido devido a uma exceção de e/s inesperada.       - ou - não foi possível efetuar o pedido devido a um erro de dispositivo e/s."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Não é possível efetuar a operação porque a sequência de registos foi aberta com acesso só de leitura."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para a sequência de registo especificado é negado pelo sistema operativo."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Nenhuma reserva suficientemente grande para caber <code> data </code> pode ser encontrado na <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Faz uma reserva único e acrescenta um registo para a sequência automaticamente. Este método não pode ser herdado."
  remarks: "Dados contidos no `data` parâmetro será CONCATENAR para uma matriz de bytes único para acrescentar como o registo. No entanto, nenhum aprovisionar é efetuada para dividir os dados no segmentos de matriz quando o registo de leitura.       As reservas especificadas são adicionadas para a reserva fornecida coleção numa operação atómica com um registo acrescentar a operação. Se a acrescentar falhar, não existe espaço está reservado.       Normalmente, este método pode concluir antes do registo foi escrito. Para se certificar de que foi escrito um registo, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador utilizando o `recordAppendOptions` parâmetro ou chamada de <xref:System.IO.Log.LogRecordSequence.Flush%2A>método.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de utilizador especificado."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica a forma como os dados devem ser escritos."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A coleção de reserva para tornar as reservas no."
    - id: reservations
      type: System.Int64[]
      description: "As reservas para que, em bytes."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo registo anexado."
  overload: System.IO.Log.LogRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao acrescentar o registo."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos não foi possível efetuar o espaço livre suficiente para conter o novo registo de ou para efetuar a reserva."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Um ou mais dos argumentos são <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>ou <code>previousRecord</code> não se situa entre os números de sequência base e final desta sequência."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Não é possível efetuar a operação porque a sequência de registos foi aberta com acesso só de leitura."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para a sequência de registo especificado é negado pelo sistema operativo."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Nenhuma reserva suficientemente grande para caber <code> data </code> pode ser encontrado na <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReservedBytes
  id: ReservedBytes
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReservedBytes
  nameWithType: LogRecordSequence.ReservedBytes
  fullName: System.IO.Log.LogRecordSequence.ReservedBytes
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Obtém o número total de bytes que tenham sido reservado."
  syntax:
    content: public long ReservedBytes { get; }
    return:
      type: System.Int64
      description: "O tamanho total de todas as reservas efetuadas nesta sequência de registo."
  overload: System.IO.Log.LogRecordSequence.ReservedBytes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A propriedade foi acedida depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.RestartSequenceNumber
  id: RestartSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: RestartSequenceNumber
  nameWithType: LogRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.RestartSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Obtém o número de sequência da área do reinício mais próximo para o fim do registo."
  remarks: "Uma área de reinício é utilizada para armazenar temporariamente as informações que contém a última operação de ponto de verificação do cliente. O sistema de ficheiro de registo (CLFS) comuns mantém que reiniciar duas áreas para garantir que, pelo menos, uma área válida está sempre disponível. Quando for necessária uma recuperação, o CLFS lê respectiva área de reinício e todos os dados a partir a última operação de ponto de verificação. Estes dados inicializa a tabela de transação, a tabela de páginas com falhas e a tabela de ficheiro aberto para que possam ser utilizados no processo de recuperação.       Utilizar o <xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A>método, pode remover mais recentemente gravadas reiniciar área.</xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência da área do reinício mais próximo para o fim do registo."
  overload: System.IO.Log.LogRecordSequence.RestartSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A propriedade foi acedida depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.RetryAppend
  id: RetryAppend
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: RetryAppend
  nameWithType: LogRecordSequence.RetryAppend
  fullName: System.IO.Log.LogRecordSequence.RetryAppend
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Obtém ou define um valor que indica se pretende ou não acrescenta automaticamente tentada novamente se o registo está cheio."
  remarks: "Se o valor desta propriedade é `true`e um <xref:System.IO.Log.LogRecordSequence.Append%2A>chamada falha porque não existe espaço suficiente na sequência, a sequência de registos irá tentar efetuar a espaço livre e repita a acrescentar.</xref:System.IO.Log.LogRecordSequence.Append%2A>"
  example:
  - "This example shows how to use the RetryAppend property.  \n  \n [!code-cs[S_UELogRecordSequence#3](~/add/codesnippet/csharp/p-system.io.log.logrecor_0_1.cs)]\n [!code-vb[S_UELogRecordSequence#3](~/add/codesnippet/visualbasic/p-system.io.log.logrecor_0_1.vb)]"
  syntax:
    content: public bool RetryAppend { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>se acrescenta automaticamente tentada novamente se o registo está cheio; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. A predefinição é <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.Log.LogRecordSequence.RetryAppend*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A propriedade foi acedida depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)
  id: SetLastRecord(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: SetLastRecord(SequenceNumber)
  nameWithType: LogRecordSequence.SetLastRecord(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.SetLastRecord(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Define o último registo <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>."
  remarks: "O número sequencial especificado tem de ser maior do que o número de sequência base.       Quando tiver concluído este método, todos os registos que tinham anteriormente foi anexados com números de sequência maiores do que o número sequencial especificado não estão acessíveis."
  syntax:
    content: public void SetLastRecord (System.IO.Log.SequenceNumber sequenceNumber);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "A nova de última sequência número no <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>.       Isto deve referir-se a um registo atual válido atualmente no registo."
  overload: System.IO.Log.LogRecordSequence.SetLastRecord*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>sequenceNumber</code>Não é válido para esta sequência."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Um arquivo novo ou existente caudo ou base do registo ativo é inválido.       - ou - <code> sequenceNumber </code> não se situa entre os números de sequência base e final desta sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Não foi possível efetuar o pedido devido a uma exceção de e/s inesperada.       - ou - foi atingido o fim do registo.       - ou - a versão ou formato de ficheiro de registo especificado é inválida."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para a sequência de registo especificado é negado pelo sistema operativo."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.TailPinned
  id: TailPinned
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: TailPinned
  nameWithType: LogRecordSequence.TailPinned
  fullName: System.IO.Log.LogRecordSequence.TailPinned
  type: Event
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Indica a necessidade de mover o seguimento da sequência."
  remarks: "Pode acionados este evento quando a sequência de registos ficou sem espaço. Quando este evento é desencadeado, seguimento da sequência (ou seja, o número de sequência base) é movido reencaminhar para libertar espaço.       O evento pode ser desencadeado em qualquer altura quando a sequência de registo decide que este tem libertar espaço, por algum motivo. Por exemplo, pode decidir o motor de política CLFS accionar o evento quando determina que tails de clientes de registo dois partilhar o mesmo ficheiro de registo estão muito afastados. Libertar espaço pode ser feito ao escrever áreas de reinício, ou truncar o registo e utilizar o <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>método para limpar espaço.</xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> O código de exemplo na secção de exemplo demonstra a abordagem segundo.       Também pode chamar o <xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A>método fora do evento TailPinned para libertar espaço.</xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A> Uma área de reinício é semelhante a um ponto de verificação no registo de outro sistemas de processamento. Chamar este método indica que a aplicação considera todos os registos anteriores antes da área de reinício como totalmente concluída e acrescenta utilizável para registo futuro. Semelhante para quaisquer outros registos, o registo escrito por este método necessita de espaço livre real no registo para a função."
  example:
  - "This example shows how to use the TailPinned event.  \n  \n```  \nrecordSequence.RetryAppend = true;  \nrecordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  \n  \nvoid HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  \n{  \n   // tailPinnedEventArgs.TargetSequenceNumber is the target   \n   // sequence number to free up space to.    \n   // However, this sequence number is not necessarily valid.  We have  \n   // to use this sequence number as a starting point for finding a  \n   // valid point within the log to advance toward. You need to  \n   // identify a record with a sequence number equal to, or greater  \n   // than TargetSequenceNumber; let's call this   \n   // realTargetSequenceNumber. Once found, move the base  \n  \n   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  \n  \n}  \n```"
  syntax:
    content: public event EventHandler<System.IO.Log.TailPinnedEventArgs> TailPinned;
    return:
      type: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  id: WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Escreve uma área de reinício para a <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>. Este método não pode ser herdado."
  remarks: "Uma área de reinício é utilizada para armazenar temporariamente as informações que contém a última operação de ponto de verificação do cliente. O sistema de ficheiro de registo (CLFS) comuns mantém que reiniciar duas áreas para garantir que, pelo menos, uma área válida está sempre disponível. Quando for necessária uma recuperação, o CLFS lê respectiva área de reinício e todos os dados a partir a última operação de ponto de verificação. Estes dados inicializa a tabela de transação, a tabela de páginas com falhas e a tabela de ficheiro aberto para que possam ser utilizados no processo de recuperação.       Uma área de reinício pode ser lidos utilizando o <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>método.</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       Os dados nos segmentos de matriz de bytes serão CONCATENAR para uma matriz de bytes único para acrescentar como o registo. Não existem aprovisionar é efetuada para dividir os dados no segmentos de matriz ao ler a área de reinício."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Um segmento de matriz que será concatenado e acrescentado como o registo."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de escrita de reiniciar área."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao escrever a área de reinício."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos não foi possível efetuar o espaço livre suficiente para conter a nova área de reinício."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Um ou mais dos argumentos são <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para a sequência de registo especificado é negado pelo sistema operativo."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Escreve uma área de reinício para a <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>. Este método não pode ser herdado."
  remarks: "Uma área de reinício é utilizada para armazenar temporariamente as informações que contém a última operação de ponto de verificação do cliente. O sistema de ficheiro de registo (CLFS) comuns mantém que reiniciar duas áreas para garantir que, pelo menos, uma área válida está sempre disponível. Quando for necessária uma recuperação, o CLFS lê respectiva área de reinício e todos os dados a partir a última operação de ponto de verificação. Estes dados inicializa a tabela de transação, a tabela de páginas com falhas e a tabela de ficheiro aberto para que possam ser utilizados no processo de recuperação.       Uma área de reinício pode ser lidos utilizando o <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>método.</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       Os dados nos segmentos de matriz de bytes serão CONCATENAR para uma matriz de bytes único para acrescentar como o registo. Não existem aprovisionar é efetuada para dividir os dados no segmentos de matriz ao ler a área de reinício."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de escrita de reiniciar área."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao escrever a área de reinício."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos não foi possível efetuar o espaço livre suficiente para conter a nova área de reinício."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Um ou mais dos argumentos são <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para a sequência de registo especificado é negado pelo sistema operativo."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Escreve uma área de reinício para a <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> e atualiza o número de sequência base. Este método não pode ser herdado."
  remarks: "Uma área de reinício é utilizada para armazenar temporariamente as informações que contém a última operação de ponto de verificação do cliente. O sistema de ficheiro de registo (CLFS) comuns mantém que reiniciar duas áreas para garantir que, pelo menos, uma área válida está sempre disponível. Quando for necessária uma recuperação, o CLFS lê respectiva área de reinício e todos os dados a partir a última operação de ponto de verificação. Estes dados inicializa a tabela de transação, a tabela de páginas com falhas e a tabela de ficheiro aberto para que possam ser utilizados no processo de recuperação.       Uma área de reinício pode ser lidos utilizando o <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>método.</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       Quando uma área de reinício é escrito na, os dados nos segmentos de matriz de bytes são concatenados para uma matriz de bytes único para acrescentar como o registo. Não existem aprovisionar é efetuada para dividir os dados no segmentos de matriz ao ler a área de reinício.       Quando concluir com êxito este método, o número de sequência base foi atualizado. Todos os registos com números de sequência de menor que o novo número de sequência base não estão acessíveis.       Se foi eliminada uma sequência de registo de, ou se obtiver um argumento inválido, as exceções forem emitidas imediatamente dentro esta operação. Erros que ocorreram durante um pedido de acréscimo assíncrona, por exemplo, uma falha de disco durante o pedido de e/s, irão resultar em exceções a ser geradas quando o <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>método é chamado.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "O novo número de sequência base. O número sequencial especificado tem de ser maior que ou igual ao número de sequência base atual."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de escrita de reiniciar área."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao escrever a área de reinício."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos não foi possível efetuar o espaço livre suficiente para conter a nova área de reinício."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Escreve uma área de reinício para a <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> e atualiza o número de sequência base. Este método não pode ser herdado."
  remarks: "Uma área de reinício é utilizada para armazenar temporariamente as informações que contém a última operação de ponto de verificação do cliente. O sistema de ficheiro de registo (CLFS) comuns mantém que reiniciar duas áreas para garantir que, pelo menos, uma área válida está sempre disponível. Quando for necessária uma recuperação, o CLFS lê respectiva área de reinício e todos os dados a partir a última operação de ponto de verificação. Estes dados inicializa a tabela de transação, a tabela de páginas com falhas e a tabela de ficheiro aberto para que possam ser utilizados no processo de recuperação.       Uma área de reinício pode ser lidos utilizando o <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>método.</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       Quando uma área de reinício é escrito na, os dados nos segmentos de matriz de bytes são concatenados para uma matriz de bytes único para acrescentar como o registo. Não existem aprovisionar é efetuada para dividir os dados no segmentos de matriz ao ler a área de reinício.       Quando concluir com êxito este método, o número de sequência base foi atualizado. Todos os registos com números de sequência de menor que o novo número de sequência base não estão acessíveis.       Se foi eliminada uma sequência de registo de, ou se obtiver um argumento inválido, as exceções forem emitidas imediatamente dentro esta operação. Erros que ocorreram durante um pedido de acréscimo assíncrona, por exemplo, uma falha de disco durante o pedido de e/s, irão resultar em exceções a ser geradas quando o <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>método é chamado.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "O novo número de sequência base. O número sequencial especificado tem de ser maior que ou igual ao número de sequência base atual."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de escrita de reiniciar área."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao escrever a área de reinício."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos não foi possível efetuar o espaço livre suficiente para conter a nova área de reinício."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Escreve uma área de reinício para a <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> utilizando uma reserva de e atualiza o número de sequência base. Este método não pode ser herdado."
  remarks: "Uma área de reinício é utilizada para armazenar temporariamente as informações que contém a última operação de ponto de verificação do cliente. O sistema de ficheiro de registo (CLFS) comuns mantém que reiniciar duas áreas para garantir que, pelo menos, uma área válida está sempre disponível. Quando for necessária uma recuperação, o CLFS lê respectiva área de reinício e todos os dados a partir a última operação de ponto de verificação. Estes dados inicializa a tabela de transação, a tabela de páginas com falhas e a tabela de ficheiro aberto para que possam ser utilizados no processo de recuperação.       Uma área de reinício pode ser lidos utilizando o <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>método.</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       Quando uma área de reinício é escrito na, os dados nos segmentos de matriz de bytes são concatenados para uma matriz de bytes único para acrescentar como o registo. Não existem aprovisionar é efetuada para dividir os dados no segmentos de matriz ao ler a área de reinício.       Se não for especificada uma reserva, a área de reinício escrito irá consumir espaço que foi anteriormente reservado, utilizando uma reserva contida na coleção. Se o método for bem sucedida, consumirá a reserva de menor que pode conter os dados e de que a reserva será removida da coleção.       Quando concluir com êxito este método, o número de sequência base foi atualizado. Todos os registos com números de sequência de menor que o novo número de sequência base não estão acessíveis.       Se foi eliminada uma sequência de registo de, ou se obtiver um argumento inválido, as exceções forem emitidas imediatamente dentro esta operação. Erros que ocorreram durante um pedido de acréscimo assíncrona, por exemplo, uma falha de disco durante o pedido de e/s, irão resultar em exceções a ser geradas quando o <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>método é chamado.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "O novo número de sequência base. O número sequencial especificado tem de ser maior que ou igual ao número de sequência base atual."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> que contém a reserva que deve ser utilizada para esta área de reinício."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de escrita de reiniciar área."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao escrever a área de reinício."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos não foi possível efetuar o espaço livre suficiente para conter a nova área de reinício."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Escreve uma área de reinício para a <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> utilizando uma reserva de e atualiza o número de sequência base. Este método não pode ser herdado."
  remarks: "Uma área de reinício é utilizada para armazenar temporariamente as informações que contém a última operação de ponto de verificação do cliente. O sistema de ficheiro de registo (CLFS) comuns mantém que reiniciar duas áreas para garantir que, pelo menos, uma área válida está sempre disponível. Quando for necessária uma recuperação, o CLFS lê respectiva área de reinício e todos os dados a partir a última operação de ponto de verificação. Estes dados inicializa a tabela de transação, a tabela de páginas com falhas e a tabela de ficheiro aberto para que possam ser utilizados no processo de recuperação.       Uma área de reinício pode ser lidos utilizando o <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>método.</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       Quando uma área de reinício é escrito na, os dados nos segmentos de matriz de bytes são concatenados para uma matriz de bytes único para acrescentar como o registo. Não existem aprovisionar é efetuada para dividir os dados no segmentos de matriz ao ler a área de reinício.       Se não for especificada uma reserva, a área de reinício escrito irá consumir espaço que foi anteriormente reservado, utilizando uma reserva contida na coleção. Se o método for bem sucedida, consumirá a reserva de menor que pode conter os dados e de que a reserva será removida da coleção.       Quando concluir com êxito este método, o número de sequência base foi atualizado. Todos os registos com números de sequência de menor que o novo número de sequência base não estão acessíveis.       Se foi eliminada uma sequência de registo de, ou se obtiver um argumento inválido, as exceções forem emitidas imediatamente dentro esta operação. Erros que ocorreram durante um pedido de acréscimo assíncrona, por exemplo, uma falha de disco durante o pedido de e/s, irão resultar em exceções a ser geradas quando o <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>método é chamado.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "O novo número de sequência base. O número sequencial especificado tem de ser maior que ou igual ao número de sequência base atual."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> que contém a reserva que deve ser utilizada para esta área de reinício."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de escrita de reiniciar área."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code>Não é válido para esta sequência.       - ou - o número de sequência de início de enumeração de registo especificado é inválido.       - ou - <code>data</code> não podem ser acrescentados porque é maior do que o tamanho máximo de registos.       - ou - <code>reservationCollection</code> não foi criada por esta sequência de registo."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Uma ou mais dos parâmetros é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Um arquivo novo ou existente caudo ou base do registo ativo é inválido.       - ou - <code> newBaseSeqNum </code> não se situa entre os números de sequência base e final desta sequência."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Não foi possível efetuar o pedido devido a uma exceção de e/s inesperada.       - ou - não foi possível efetuar o pedido devido a um erro de dispositivo e/s."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução do programa."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para a sequência de registo especificado é negado pelo sistema operativo."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos está cheia."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IO.Log.SequenceFullException
  parent: System.IO.Log
  isExternal: false
  name: SequenceFullException
  nameWithType: SequenceFullException
  fullName: System.IO.Log.SequenceFullException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.IO.Log.ReservationNotFoundException
  parent: System.IO.Log
  isExternal: false
  name: ReservationNotFoundException
  nameWithType: ReservationNotFoundException
  fullName: System.IO.Log.ReservationNotFoundException
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(LogStore)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore)
- uid: System.IO.Log.LogStore
  parent: System.IO.Log
  isExternal: false
  name: LogStore
  nameWithType: LogStore
  fullName: System.IO.Log.LogStore
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.IO.FileMode
  parent: System.IO
  isExternal: false
  name: FileMode
  nameWithType: FileMode
  fullName: System.IO.FileMode
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(LogStore,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
- uid: System.IO.FileShare
  parent: System.IO
  isExternal: false
  name: FileShare
  nameWithType: FileShare
  fullName: System.IO.FileShare
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
- uid: System.Security.AccessControl.FileSecurity
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSecurity
  nameWithType: FileSecurity
  fullName: System.Security.AccessControl.FileSecurity
- uid: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
- uid: System.IO.Log.SequenceNumber
  parent: System.IO.Log
  isExternal: false
  name: SequenceNumber
  nameWithType: SequenceNumber
  fullName: System.IO.Log.SequenceNumber
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.ArraySegment{System.Byte}
  parent: System
  isExternal: true
  name: ArraySegment<Byte>
  nameWithType: ArraySegment<Byte>
  fullName: System.ArraySegment<System.Byte>
  spec.csharp:
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.RecordAppendOptions
  parent: System.IO.Log
  isExternal: false
  name: RecordAppendOptions
  nameWithType: RecordAppendOptions
  fullName: System.IO.Log.RecordAppendOptions
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
  parent: System.Collections.Generic
  isExternal: true
  name: IList<ArraySegment<Byte>>
  nameWithType: IList<ArraySegment<Byte>>
  fullName: System.Collections.Generic.IList<System.ArraySegment<System.Byte>>
  spec.csharp:
  - uid: System.Collections.Generic.IList`1
    name: IList
    nameWithType: IList
    fullName: IList<System.ArraySegment<System.Byte>>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.ReservationCollection
  parent: System.IO.Log
  isExternal: false
  name: ReservationCollection
  nameWithType: ReservationCollection
  fullName: System.IO.Log.ReservationCollection
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.LogRecordSequence.BaseSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: LogRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.Int64[]
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64[]
  spec.csharp:
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: Int64[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.CreateReservationCollection
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: CreateReservationCollection()
  nameWithType: LogRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.LogRecordSequence.CreateReservationCollection()
- uid: System.IO.Log.LogRecordSequence.Dispose
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Dispose()
  nameWithType: LogRecordSequence.Dispose()
  fullName: System.IO.Log.LogRecordSequence.Dispose()
- uid: System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndAppend(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndFlush(IAsyncResult)
  nameWithType: LogRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndFlush(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndReserveAndAppend(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: LogRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndWriteRestartArea(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.Flush
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Flush()
  nameWithType: LogRecordSequence.Flush()
  fullName: System.IO.Log.LogRecordSequence.Flush()
- uid: System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Flush(SequenceNumber)
  nameWithType: LogRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.Flush(SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.LastSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: LogRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.LastSequenceNumber
- uid: System.IO.Log.LogRecordSequence.LogStore
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogStore
  nameWithType: LogRecordSequence.LogStore
  fullName: System.IO.Log.LogRecordSequence.LogStore
- uid: System.IO.Log.LogRecordSequence.MaximumRecordLength
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: LogRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.LogRecordSequence.MaximumRecordLength
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
- uid: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<LogRecord>
  nameWithType: IEnumerable<LogRecord>
  fullName: System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.IO.Log.LogRecord>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.LogRecord
    name: LogRecord
    nameWithType: LogRecord
    fullName: LogRecord
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordEnumeratorType
  parent: System.IO.Log
  isExternal: false
  name: LogRecordEnumeratorType
  nameWithType: LogRecordEnumeratorType
  fullName: System.IO.Log.LogRecordEnumeratorType
- uid: System.IO.Log.LogRecordSequence.ReadRestartAreas
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadRestartAreas()
  nameWithType: LogRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.LogRecordSequence.ReadRestartAreas()
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.LogRecordSequence.ReservedBytes
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: LogRecordSequence.ReservedBytes
  fullName: System.IO.Log.LogRecordSequence.ReservedBytes
- uid: System.IO.Log.LogRecordSequence.RestartSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: LogRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.LogRecordSequence.RetryAppend
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: LogRecordSequence.RetryAppend
  fullName: System.IO.Log.LogRecordSequence.RetryAppend
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: SetLastRecord(SequenceNumber)
  nameWithType: LogRecordSequence.SetLastRecord(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.SetLastRecord(SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.TailPinned
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: TailPinned
  nameWithType: LogRecordSequence.TailPinned
  fullName: System.IO.Log.LogRecordSequence.TailPinned
- uid: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<TailPinnedEventArgs>
  nameWithType: EventHandler<TailPinnedEventArgs>
  fullName: System.EventHandler<System.IO.Log.TailPinnedEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.IO.Log.TailPinnedEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.TailPinnedEventArgs
    name: TailPinnedEventArgs
    nameWithType: TailPinnedEventArgs
    fullName: TailPinnedEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.LogRecordSequence.#ctor*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence
  nameWithType: LogRecordSequence.LogRecordSequence
- uid: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber
  nameWithType: LogRecordSequence.AdvanceBaseSequenceNumber
- uid: System.IO.Log.LogRecordSequence.Append*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append
  nameWithType: LogRecordSequence.Append
- uid: System.IO.Log.LogRecordSequence.BaseSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: LogRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.LogRecordSequence.BeginAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend
  nameWithType: LogRecordSequence.BeginAppend
- uid: System.IO.Log.LogRecordSequence.BeginFlush*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginFlush
  nameWithType: LogRecordSequence.BeginFlush
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginReserveAndAppend
  nameWithType: LogRecordSequence.BeginReserveAndAppend
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginWriteRestartArea
  nameWithType: LogRecordSequence.BeginWriteRestartArea
- uid: System.IO.Log.LogRecordSequence.CreateReservationCollection*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: CreateReservationCollection
  nameWithType: LogRecordSequence.CreateReservationCollection
- uid: System.IO.Log.LogRecordSequence.Dispose*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Dispose
  nameWithType: LogRecordSequence.Dispose
- uid: System.IO.Log.LogRecordSequence.EndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndAppend
  nameWithType: LogRecordSequence.EndAppend
- uid: System.IO.Log.LogRecordSequence.EndFlush*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndFlush
  nameWithType: LogRecordSequence.EndFlush
- uid: System.IO.Log.LogRecordSequence.EndReserveAndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndReserveAndAppend
  nameWithType: LogRecordSequence.EndReserveAndAppend
- uid: System.IO.Log.LogRecordSequence.EndWriteRestartArea*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndWriteRestartArea
  nameWithType: LogRecordSequence.EndWriteRestartArea
- uid: System.IO.Log.LogRecordSequence.Flush*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Flush
  nameWithType: LogRecordSequence.Flush
- uid: System.IO.Log.LogRecordSequence.LastSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: LogRecordSequence.LastSequenceNumber
- uid: System.IO.Log.LogRecordSequence.LogStore*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogStore
  nameWithType: LogRecordSequence.LogStore
- uid: System.IO.Log.LogRecordSequence.MaximumRecordLength*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: LogRecordSequence.MaximumRecordLength
- uid: System.IO.Log.LogRecordSequence.ReadLogRecords*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadLogRecords
  nameWithType: LogRecordSequence.ReadLogRecords
- uid: System.IO.Log.LogRecordSequence.ReadRestartAreas*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadRestartAreas
  nameWithType: LogRecordSequence.ReadRestartAreas
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReserveAndAppend
  nameWithType: LogRecordSequence.ReserveAndAppend
- uid: System.IO.Log.LogRecordSequence.ReservedBytes*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: LogRecordSequence.ReservedBytes
- uid: System.IO.Log.LogRecordSequence.RestartSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: LogRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.LogRecordSequence.RetryAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: LogRecordSequence.RetryAppend
- uid: System.IO.Log.LogRecordSequence.SetLastRecord*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: SetLastRecord
  nameWithType: LogRecordSequence.SetLastRecord
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea
  nameWithType: LogRecordSequence.WriteRestartArea
