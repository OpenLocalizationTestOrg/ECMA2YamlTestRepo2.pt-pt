### YamlMime:ManagedReference
items:
- uid: System.IO.Log.LogRecordSequence
  id: LogRecordSequence
  children:
  - System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)
  - System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)
  - System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.LogRecordSequence.BaseSequenceNumber
  - System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.CreateReservationCollection
  - System.IO.Log.LogRecordSequence.Dispose
  - System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.Flush
  - System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.LastSequenceNumber
  - System.IO.Log.LogRecordSequence.LogStore
  - System.IO.Log.LogRecordSequence.MaximumRecordLength
  - System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  - System.IO.Log.LogRecordSequence.ReadRestartAreas
  - System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.LogRecordSequence.ReservedBytes
  - System.IO.Log.LogRecordSequence.RestartSequenceNumber
  - System.IO.Log.LogRecordSequence.RetryAppend
  - System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.TailPinned
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  langs:
  - csharp
  name: LogRecordSequence
  nameWithType: LogRecordSequence
  fullName: System.IO.Log.LogRecordSequence
  type: Class
  summary: "Represents a record sequence stored in a <xref href=&quot;System.IO.Log.LogStore&quot;></xref>."
  remarks: "The LogRecordSequence class provides an implementation of the record sequence interface on top of a Common Log File System (CLFS) log. In addition to the standard record-oriented features, it provides a policy model for avoiding log-full conditions, and multiplexing of clients on the same physical file. It works with the <xref:System.IO.Log.LogStore> class, which provides an interface for directly manipulating and managing a CLFS log file. The relationship between the <xref:System.IO.Log.LogStore> class and the LogRecordSequence class is similar to the relationship between a disk file and a <xref:System.IO.FileStream> object. The disk file provides the concrete storage, and has attributes such as length and last access time; while the <xref:System.IO.FileStream> object provides a view on the file that can be used to read from it and write to it. Similarly, the <xref:System.IO.Log.LogStore> class has attributes like a policy and a collection of disk extents; and the LogRecordSequence class provides a record-oriented mechanism for reading and writing data."
  example:
  - "This example shows how to use the LogRecordSequence class:  \n  \n [!code-cs[S_UELogRecordSequence#0](~/add/codesnippet/csharp/t-system.io.log.logrecor_1.cs)]\n [!code-vb[S_UELogRecordSequence#0](~/add/codesnippet/visualbasic/t-system.io.log.logrecor_1.vb)]"
  syntax:
    content: 'public sealed class LogRecordSequence : IDisposable, System.IO.Log.IRecordSequence'
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  - System.IO.Log.IRecordSequence
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)
  id: '#ctor(System.IO.Log.LogStore)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(LogStore)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Initializes a new instance of the <xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref> class with the specified log store."
  remarks: "The buffer size determines the maximum size of the record that can be appended or read. In this constructor, a default value of 64 is set. The desired number of buffers is set to 10."
  syntax:
    content: public LogRecordSequence (System.IO.Log.LogStore logStore);
    parameters:
    - id: logStore
      type: System.IO.Log.LogStore
      description: "The <xref href=&quot;System.IO.Log.LogStore&quot;></xref> that this record sequence should use."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>logStore</code> is invalid."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)
  id: '#ctor(System.String,System.IO.FileMode)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Initializes a new instance of the <xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref> class with a specified path to the log store and the access mode."
  remarks: "This constructor initializes a new <xref:System.IO.Log.LogRecordSequence> on a new <xref:System.IO.Log.LogStore> object that it opens with the specified path and mode. It is given read/write access to the store, and the store is opened sharing Read access."
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode);
    parameters:
    - id: path
      type: System.String
      description: "A relative or absolute path for the base file of the log store to open."
    - id: mode
      type: System.IO.FileMode
      description: "One of the <xref href=&quot;System.IO.FileMode&quot;></xref> values that determines how to open or create the store."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code> is an empty string (&quot;&quot;).       -or-       <code>path</code> contains only white space.       -or-       <code>path</code> contains one or more invalid characters."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code> contains an invalid value."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "The file cannot be found."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "An I/O error occurs when opening the log store."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Access for the specified log sequence is denied by the operating system."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "This operation is not supported."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref> cannot be used because the required Common Log File System (CLFS) component is not installed. Install the CLFS component if it is available for your platform, or use the <xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref> class."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)
  id: '#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(LogStore,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Initializes a new instance of the <xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref> class with the specified log store, buffer size for each record, and buffer number."
  remarks: "Use this constructor if you want to specify values for `bufferSize` and `bufferCount` and do not want to use the default value of 64 for `bufferSize` and 10 for `bufferCount`."
  syntax:
    content: public LogRecordSequence (System.IO.Log.LogStore logStore, int bufferSize, int bufferCount);
    parameters:
    - id: logStore
      type: System.IO.Log.LogStore
      description: "The <xref href=&quot;System.IO.Log.LogStore&quot;></xref> that this record sequence should use."
    - id: bufferSize
      type: System.Int32
      description: "The desired buffer size in bytes. The buffer size determines the maximum size of the record that can be appended or read."
    - id: bufferCount
      type: System.Int32
      description: "The desired number of buffers."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>logStore</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize </code>is negative or zero.       -or-       <code>bufferCount</code> is negative or zero."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Initializes a new instance of the <xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref> class with a specified path to the log store and the access and share modes."
  remarks: "This constructor initializes a new <xref:System.IO.Log.LogRecordSequence> on a new <xref:System.IO.Log.LogStore> object that it opens with the specified path, mode, and access. The store is opened sharing Read access."
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access);
    parameters:
    - id: path
      type: System.String
      description: "A relative or absolute path for the base file of the log store to open."
    - id: mode
      type: System.IO.FileMode
      description: "One of the <xref href=&quot;System.IO.FileMode&quot;></xref> values that determines how to open or create the store."
    - id: access
      type: System.IO.FileAccess
      description: "One of the <xref href=&quot;System.IO.FileAccess&quot;></xref> values that determines how the file can be accessed by the <xref href=&quot;System.IO.Log.LogStore&quot;></xref>."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code> is an empty string (&quot;&quot;).       -or-       <code>path</code> contains only white space.       -or-       <code>path</code> contains one or more invalid characters."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code> contains an invalid value."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "The file cannot be found."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "An I/O error occurs when opening the log store."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Access for the specified log sequence is denied by the operating system."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "This operation is not supported."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref> cannot be used because the required Common Log File System (CLFS) component is not installed. Install the CLFS component if it is available for your platform, or use the <xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref> class."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Initializes a new instance of the <xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref> class with a specified path to the log store and the access mode."
  remarks: "This constructor initializes a new <xref:System.IO.Log.LogRecordSequence> on a new <xref:System.IO.Log.LogStore> object that it opens with the specified path, mode, and access. The store is opened sharing the specified access."
  example:
  - "This example shows how to use this <xref:System.IO.Log.LogRecordSequence> constructor:  \n  \n [!code-cs[S_UELogRecordSequence#1](~/add/codesnippet/csharp/5a33f64b-b9a0-4b07-9df4-_1.cs)]\n [!code-vb[S_UELogRecordSequence#1](~/add/codesnippet/visualbasic/5a33f64b-b9a0-4b07-9df4-_1.vb)]"
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
    parameters:
    - id: path
      type: System.String
      description: "A relative or absolute path for the base file of the log store to open."
    - id: mode
      type: System.IO.FileMode
      description: "One of the <xref href=&quot;System.IO.FileMode&quot;></xref> values that determines how to open or create the store."
    - id: access
      type: System.IO.FileAccess
      description: "One of the <xref href=&quot;System.IO.FileAccess&quot;></xref> values that determines how the file can be accessed by the <xref href=&quot;System.IO.Log.LogStore&quot;></xref>."
    - id: share
      type: System.IO.FileShare
      description: "One of the <xref href=&quot;System.IO.FileShare&quot;></xref> values that determines how the log store will be shared among processes."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code> is an empty string (&quot;&quot;).       -or-       <code>path</code> contains only white space.       -or-       <code>path</code> contains one or more invalid characters."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code> contains an invalid value."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "The file cannot be found."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "An I/O error occurs when opening the log store."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Access for the specified log sequence is denied by the operating system."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "This operation is not supported."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref> cannot be used because the required Common Log File System (CLFS) component is not installed. Install the CLFS component if it is available for your platform, or use the <xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref> class."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Initializes a new instance of the <xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref> class with a specified path to the log store, file permission, access and share modes, and the buffer size and count for records."
  remarks: "This constructor initializes a new <xref:System.IO.Log.LogRecordSequence> on a new <xref:System.IO.Log.LogStore> object that it opens with the specified path, mode, and access. The store is opened sharing the specified access."
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount);
    parameters:
    - id: path
      type: System.String
      description: "A relative or absolute path for the base file of the log store to open."
    - id: mode
      type: System.IO.FileMode
      description: "One of the <xref href=&quot;System.IO.FileMode&quot;></xref> values that determines how to open or create the store."
    - id: access
      type: System.IO.FileAccess
      description: "One of the <xref href=&quot;System.IO.FileAccess&quot;></xref> values that determines how the file can be accessed by the <xref href=&quot;System.IO.Log.LogStore&quot;></xref>."
    - id: share
      type: System.IO.FileShare
      description: "One of the <xref href=&quot;System.IO.FileShare&quot;></xref> values that determines how the log store will be shared among processes."
    - id: bufferSize
      type: System.Int32
      description: "The desired buffer size in bytes. The buffer size determines the maximum size of the record that can be appended or read."
    - id: bufferCount
      type: System.Int32
      description: "The desired number of buffers."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code> is an empty string (&quot;&quot;).       -or-       <code>path</code> contains only white space.       -or-       <code>path</code> contains one or more invalid characters."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code> contains an invalid value."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "The file cannot be found."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "An I/O error occurs when opening the log store."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Access for the specified log sequence is denied by the operating system."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "This operation is not supported."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref> cannot be used because the required Common Log File System (CLFS) component is not installed. Install the CLFS component if it is available for your platform, or use the <xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref> class."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Initializes a new instance of the <xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref> class."
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount, System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: path
      type: System.String
      description: "A relative or absolute path for the base file of the log store to open."
    - id: mode
      type: System.IO.FileMode
      description: "A valid <xref href=&quot;System.IO.FileMode&quot;></xref> value that determines how to open or create the store."
    - id: access
      type: System.IO.FileAccess
      description: "A valid <xref href=&quot;System.IO.FileAccess&quot;></xref> value that determines how the log store can be accessed."
    - id: share
      type: System.IO.FileShare
      description: "A valid <xref href=&quot;System.IO.FileShare&quot;></xref> value that determines how the log store will be shared among processes."
    - id: bufferSize
      type: System.Int32
      description: "The desired buffer size in bytes. The buffer size determines the maximum size of the record that can be appended or read."
    - id: bufferCount
      type: System.Int32
      description: "The desired number of buffers."
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "A valid <xref href=&quot;System.Security.AccessControl.FileSecurity&quot;></xref> value that specifies the security to set on the newly created store if the store must be created."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The file specified by <code>path</code> is not valid.       -or-       The specified log store file name is not valid.       -or-       <code>mode</code> has a value of <xref href=&quot;System.IO.FileMode&quot;></xref>, and cannot be used without write access.       -or-       <code>mode</code> has a value of <xref href=&quot;System.IO.FileMode&quot;></xref>, and cannot be used without write access."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "One or more of the arguments are <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "One or more of the arguments are out of range."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "The file specified by <code>path</code> cannot be found."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "The request could not be performed because of an unexpected I/O exception.       -or-       The file specified by <code>path</code> cannot be accessed because it is in use by another process.       -or-       The file specified by <code>path</code> cannot be created because the file or directory already exists.       -or-       The log handle could not be bound to the thread pool.       -or-       The specified log file format or version is invalid."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "This operation is not supported."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The method was called after the sequence has been disposed of."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref> cannot be used because the required Common Log File System (CLFS) component is not installed. Install the CLFS component if it is available for your platform, or use the <xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref> class."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "The record sequence is full."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Access for the specified log sequence is denied by the operating system."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  id: AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Moves the base sequence number of the log forward. This method cannot be inherited."
  remarks: "This method is often used with the <xref:System.IO.Log.LogRecordSequence.TailPinned> event to free up space in a record. The <xref:System.IO.Log.LogRecordSequence.TailPinned> event indicates that the tail of the sequence (that is, the base sequence number) needs to be moved forward to free up space. Freeing space can be done by either writing restart areas using the <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> method, or truncating the log and using the AdvanceBaseSequenceNumber method to advance the base sequence number of a log to the one specified by the `newBaseSequenceNumber` parameter. The code sample in the Example section demonstrates the second approach.       Note that calling this method is the same as setting a new base sequence number using the <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> method, except that no restart record is written to the log."
  example:
  - "This example shows how to use the AdvanceBaseSequenceNumber method with the <xref:System.IO.Log.LogRecordSequence.TailPinned> event to free up space in a log sequence.  \n  \n```  \nrecordSequence.RetryAppend = true;  \nrecordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  \n  \nvoid HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  \n{  \n   // tailPinnedEventArgs.TargetSequenceNumber is the target   \n   // sequence number to free up space to.    \n   // However, this sequence number is not necessarily valid.  We have  \n   // to use this sequence number as a starting point for finding a  \n   // valid point within the log to advance toward. You need to  \n   // identify a record with a sequence number equal to, or greater  \n   // than TargetSequenceNumber; let's call this   \n   // realTargetSequenceNumber. Once found, move the base  \n  \n   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  \n  \n}  \n```"
  syntax:
    content: public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Specifies the new base <xref href=&quot;System.IO.Log.SequenceNumber&quot;></xref> for the log. This must lie in the range between the current base sequence number and the last sequence number of the log inclusively."
  overload: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSequenceNumber</code> is not valid for this sequence."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "A new or existing archive tail or base of the active log is invalid.       -or-       <code>newBaseSequenceNumber</code> is not between the base and last sequence numbers of this sequence."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "The request could not be performed because of an unexpected I/O exception.       -or-       The request could not be performed because of an I/O device error."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The specified log does not have any extents. One or more extents must be created before a record sequence may be used."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The method was called after the sequence has been disposed of."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Access for the specified log sequence is denied by the operating system."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "The record sequence is full."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Writes a log record to the <xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>. This method cannot be inherited."
  remarks: "Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method."
  example:
  - "The following example demonstrates how to use this method to append a log record to the sequence.  \n  \n [!code-cs[S_UELogRecordSequence#13](~/add/codesnippet/csharp/11cb4ef9-9d52-4994-983c-_1.cs)]\n [!code-vb[S_UELogRecordSequence#13](~/add/codesnippet/visualbasic/11cb4ef9-9d52-4994-983c-_1.vb)]"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "A list of byte array segments that will be concatenated and appended as the record."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the next record in the user-specified order."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the next record in Previous order."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "A valid value of <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref> that specifies how the data should be written."
    return:
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the appended log record."
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code> or <code>previousRecord</code> is not valid for this sequence.       -or-       <code>data</code> cannot be appended because it is larger than the maximum record size.       -or-       <code>reservations</code> was not created by this record sequence."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "One or more of the arguments are <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code> or <code>previousRecord</code> is not between the base and last sequence numbers of this sequence."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "The request could not be performed because of an unexpected I/O exception.       -or-       The request could not be performed because of an I/O device error."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The operation cannot be performed because the record sequence was opened with read-only access."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The method was called after the sequence has been disposed of."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "The record sequence is full."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Access for the specified log sequence is denied by the operating system."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Appends a log record to the <xref href=&quot;System.IO.Log.IRecordSequence&quot;></xref>. This method cannot be inherited."
  remarks: "Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method."
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "A list of byte array segments that will be concatenated and appended as the record."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the next record in the user-specified order."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the next record in Previous order."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "A valid value of <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref> that specifies how the data should be written."
    return:
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the appended log record."
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code> or <code>previousRecord</code> is not valid for this sequence.       -or-       <code>data</code> cannot be appended because it is larger than the maximum record size.       -or-       <code>reservations</code> was not created by this record sequence."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "One or more of the arguments are <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code> or <code>previousRecord</code> is not between the base and last sequence numbers of this sequence."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "The request could not be performed because of an unexpected I/O exception.       -or-       The request could not be performed because of an I/O device error."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The operation cannot be performed because the record sequence was opened with read-only access."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The method was called after the sequence has been disposed of."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "The record sequence is full."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Access for the specified log sequence is denied by the operating system."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Appends a log record to the <xref href=&quot;System.IO.Log.IRecordSequence&quot;></xref>, using space previously reserved in the sequence. This method cannot be inherited."
  remarks: "Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter. If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.       Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method."
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "A list of byte array segments that will be concatenated and appended as the record."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the next record in the user-specified order."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the next record in Previous order."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "A valid value of <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref> that specifies how the data should be written."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;></xref> that contains the reservation that should be used for this record."
    return:
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the appended log record."
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code> or <code>previousRecord</code> is not valid for this sequence.       -or-       <code>data</code> cannot be appended because it is larger than the maximum record size.       -or-       <code>reservations</code> was not created by this record sequence."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "One or more of the arguments are <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code> or <code>previousRecord</code> is not between the base and last sequence numbers of this sequence."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "The request could not be performed because of an unexpected I/O exception.       -or-       The request could not be performed because of an I/O device error."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The operation cannot be performed because the record sequence was opened with read-only access."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The method was called after the sequence has been disposed of."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "The record sequence is full."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Access for the specified log sequence is denied by the operating system."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "No reservation large enough to fit <code>data</code> can be found in <code>reservations</code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Appends a log record to the <xref href=&quot;System.IO.Log.IRecordSequence&quot;></xref>, using space previously reserved in the sequence. This method cannot be inherited."
  remarks: "Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter. If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.       Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method."
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "A list of byte array segments that will be concatenated and appended as the record."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the next record in the user-specified order."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the next record in Previous order."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "A valid value of <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref> that specifies how the data should be written."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;></xref> that contains the reservation that should be used for this record."
    return:
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the appended log record."
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code> or <code>previousRecord</code> is not valid for this sequence.       -or-       <code>data</code> cannot be appended because it is larger than the maximum record size.       -or-       <code>reservations</code> was not created by this record sequence."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "One or more of the arguments are <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code> or <code>previousRecord</code> is not between the base and last sequence numbers of this sequence."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "The request could not be performed because of an unexpected I/O exception.       -or-       The request could not be performed because of an I/O device error."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The operation cannot be performed because the record sequence was opened with read-only access."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The method was called after the sequence has been disposed of."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "The record sequence is full."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Access for the specified log sequence is denied by the operating system."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "No reservation large enough to fit <code>data</code> can be found in <code>reservations</code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BaseSequenceNumber
  id: BaseSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BaseSequenceNumber
  nameWithType: LogRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.BaseSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Gets the sequence number of the first valid record in the current <xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>."
  remarks: "Valid sequence numbers are greater than or equal to BaseSequenceNumber and less than <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>.       The value of this property can be changed by calling the <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> method or <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> method."
  example:
  - "This example shows how to use the BaseSequenceNumber member in a loop.  \n  \n [!code-cs[S_UELogRecordSequence#10](~/add/codesnippet/csharp/p-system.io.log.logrecor_2_1.cs)]\n [!code-vb[S_UELogRecordSequence#10](~/add/codesnippet/visualbasic/p-system.io.log.logrecor_2_1.vb)]"
  syntax:
    content: public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "The lowest sequence number that corresponds to a valid record in the <xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>."
  overload: System.IO.Log.LogRecordSequence.BaseSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The property was accessed after the sequence has been disposed of."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Begins an asynchronous append operation. This method cannot be inherited."
  remarks: "You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method."
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "A list of byte array segments that will be concatenated and appended as the record."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the next record in the user-specified order."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the next record in Previous order."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "A valid value of <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref> that specifies how the data should be written."
    - id: callback
      type: System.AsyncCallback
      description: "An optional asynchronous callback, to be called when the append is complete."
    - id: state
      type: System.Object
      description: "A user-provided object that distinguishes this particular asynchronous append request from other requests."
    return:
      type: System.IAsyncResult
      description: "An <xref:System.IAsyncResult> that represents the asynchronous append, which could still be pending."
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>nextUndoRecord</code> or <code>previousRecord</code> is not valid for this sequence.       -or-       <code>data</code> cannot be appended because it is larger than the maximum record size.       -or-       <code>reservations</code> was not created by this record sequence."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "One or more of the arguments are <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>nextUndoRecord</code> or <code>previousRecord</code> is not between the base and last sequence numbers of this sequence."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "The request could not be performed because of an unexpected I/O exception.       -or-       The request could not be performed because of an I/O device error."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The operation cannot be performed because the record sequence was opened with read-only access."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The method was called after the sequence has been disposed of."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "The record sequence is full."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Access for the specified log sequence is denied by the operating system."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Begins an asynchronous append operation. This method cannot be inherited."
  remarks: "You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method."
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "A list of byte array segments that will be concatenated and appended as the record."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the next record in the user-specified order."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the next record in Previous order."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "A valid value of <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref> that specifies how the data should be written."
    - id: callback
      type: System.AsyncCallback
      description: "An optional asynchronous callback, to be called when the append is complete."
    - id: state
      type: System.Object
      description: "A user-provided object that distinguishes this particular asynchronous append request from other requests."
    return:
      type: System.IAsyncResult
      description: "An <xref:System.IAsyncResult> that represents the asynchronous append, which could still be pending."
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code> or <code>previousRecord</code> is not valid for this sequence.       -or-       <code>data</code> cannot be appended because it is larger than the maximum record size.       -or-       <code>reservations</code> was not created by this record sequence."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "One or more of the arguments are <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code> or <code>previousRecord</code> is not between the base and last sequence numbers of this sequence."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "The request could not be performed because of an unexpected I/O exception.       -or-       The request could not be performed because of an I/O device error."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The operation cannot be performed because the record sequence was opened with read-only access."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The method was called after the sequence has been disposed of."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "The record sequence is full."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Access for the specified log sequence is denied by the operating system."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Begins an asynchronous append operation. This method cannot be inherited."
  remarks: "You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter. If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.       Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method."
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "A list of byte array segments that will be concatenated and appended as the record."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the next record in the user-specified order."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the next record in Previous order."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "A valid value of <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref> that specifies how the data should be written."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;></xref> that contains the reservation that should be used for this record."
    - id: callback
      type: System.AsyncCallback
      description: "An optional asynchronous callback, to be called when the append is complete."
    - id: state
      type: System.Object
      description: "A user-provided object that distinguishes this particular asynchronous append request from other requests."
    return:
      type: System.IAsyncResult
      description: "An <xref:System.IAsyncResult> that represents the asynchronous append, which could still be pending."
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code> or <code>previousRecord</code> is not valid for this sequence.       -or-       <code>data</code> cannot be appended because it is larger than the maximum record size.       -or-       <code>reservations</code> was not created by this record sequence."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "One or more of the arguments are <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code> or <code>previousRecord</code> is not between the base and last sequence numbers of this sequence."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "The request could not be performed because of an unexpected I/O exception.       -or-       The request could not be performed because of an I/O device error."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The operation cannot be performed because the record sequence was opened with read-only access."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The method was called after the sequence has been disposed of."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "The record sequence is full."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Access for the specified log sequence is denied by the operating system."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "No reservation large enough to fit <code>data</code> can be found in <code>reservations</code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Begins an asynchronous append operation. This method cannot be inherited."
  remarks: "You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter. If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.       Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method."
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "A list of byte array segments that will be concatenated and appended as the record."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the next record in the user-specified order."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the next record in Previous order."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "A valid value of <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref> that specifies how the data should be written."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;></xref> that contains the reservation that should be used for this record."
    - id: callback
      type: System.AsyncCallback
      description: "An optional asynchronous callback, to be called when the append is complete."
    - id: state
      type: System.Object
      description: "A user-provided object that distinguishes this particular asynchronous append request from other requests."
    return:
      type: System.IAsyncResult
      description: "An <xref:System.IAsyncResult> that represents the asynchronous append, which could still be pending."
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code> or <code>previousRecord</code> is not valid for this sequence.       -or-       <code>data</code> cannot be appended because it is larger than the maximum record size.       -or-       <code>reservations</code> was not created by this record sequence."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "One or more of the arguments are <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code> or <code>previousRecord</code> is not between the base and last sequence numbers of this sequence."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "The request could not be performed because of an unexpected I/O exception.       -or-       The request could not be performed because of an I/O device error."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The operation cannot be performed because the record sequence was opened with read-only access."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The method was called after the sequence has been disposed of."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "The record sequence is full."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Access for the specified log sequence is denied by the operating system."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "No reservation large enough to fit <code>data</code> can be found in <code>reservations</code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  id: BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Begins an asynchronous flush operation, using space previously reserved in the sequence. This method cannot be inherited."
  remarks: "You should pass the <xref:System.IAsyncResult> returned by the current method to the <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> method to ensure that the flush completes and resources are freed appropriately. If an error occurs during an asynchronous flush, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> method is called with the <xref:System.IAsyncResult> returned by this method.       Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.LogRecordSequence> are durably written.       If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous flush request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> method is called."
  syntax:
    content: public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the latest record that must be written. If this <xref href=&quot;System.IO.Log.SequenceNumber&quot;></xref> is invalid, then all records must be written."
    - id: callback
      type: System.AsyncCallback
      description: "An optional asynchronous callback, to be called when the flush is complete."
    - id: state
      type: System.Object
      description: "A user-provided object that distinguishes this particular asynchronous flush request from other requests."
    return:
      type: System.IAsyncResult
      description: "An <xref:System.IAsyncResult> that represents the asynchronous flush operation, which could still be pending."
  overload: System.IO.Log.LogRecordSequence.BeginFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>sequenceNumber</code> is not valid for this sequence."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>sequenceNumber</code> is not between the base and last sequence numbers of this sequence."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "The request could not be performed because of an unexpected I/O exception."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The specified log does not have any extents. One or more extents must be created before a record sequence can be used."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The operation cannot be performed because the record sequence was opened with read-only access."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The method was called after the sequence has been disposed of."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "The record sequence is full."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Access for the specified log sequence is denied by the operating system."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Begins an asynchronous reserve and append operation. This method cannot be inherited."
  remarks: "You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation. If the append fails, no space is reserved.       Normally, this method may complete before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.       If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called."
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "A list of byte array segments that will be concatenated and appended as the record."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the next record in the user-specified order."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the next record in Previous order."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "A valid value of <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref> that specifies how the data should be written."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "The reservation collection to make reservations in."
    - id: reservations
      type: System.Int64[]
      description: "The reservations to make, in bytes."
    - id: callback
      type: System.AsyncCallback
      description: "An optional asynchronous callback, to be called when the append is complete."
    - id: state
      type: System.Object
      description: "A user-provided object that distinguishes this particular asynchronous append request from other requests."
    return:
      type: System.IAsyncResult
      description: "An <xref:System.IAsyncResult> that represents this asynchronous operation, which could still be pending."
  overload: System.IO.Log.LogRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code> or <code>previousRecord</code> is not valid for this sequence.       -or-       <code>data</code> cannot be appended because it is larger than the maximum record size.       -or-       <code>reservations</code> was not created by this record sequence."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "One or more of the arguments are <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code> or <code>previousRecord</code> is not between the base and last sequence numbers of this sequence."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "The request could not be performed because of an unexpected I/O exception.       -or-       The request could not be performed because of an I/O device error."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The operation cannot be performed because the record sequence was opened with read-only access."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The method was called after the sequence has been disposed of."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "The record sequence is full."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Access for the specified log sequence is denied by the operating system."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "No reservation large enough to fit <code>data</code> can be found in <code>reservations</code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Begins an asynchronous reserve and append operation. This method cannot be inherited."
  remarks: "You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation. If the append fails, no space is reserved.       Normally, this method may complete before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.       If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called."
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "A list of byte array segments that will be concatenated and appended as the record."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the next record in the user-specified order."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the next record in Previous order."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "A valid value of <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref> that specifies how the data should be written."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "The reservation collection to make reservations in."
    - id: reservations
      type: System.Int64[]
      description: "The reservations to make, in bytes."
    - id: callback
      type: System.AsyncCallback
      description: "An optional asynchronous callback, to be called when the append is complete."
    - id: state
      type: System.Object
      description: "A user-provided object that distinguishes this particular asynchronous append request from other requests."
    return:
      type: System.IAsyncResult
      description: "An <xref:System.IAsyncResult> that represents this asynchronous operation, which could still be pending."
  overload: System.IO.Log.LogRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "One or more of the arguments is invalid."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "An I/O error occurred while appending the record."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "The record sequence could not make enough free space to contain the new record, or to make the reservation."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The method was called after the sequence has been disposed of."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Begins an asynchronous restart area write operation, using space previously reserved in the sequence. This method cannot be inherited."
  remarks: "You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method to ensure that the restart area write operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method is called with the <xref:System.IAsyncResult> returned by this method.       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       When the operation successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.       If a <xref:System.IO.Log.ReservationCollection> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection. If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.       If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method is called."
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Byte array segments that will be concatenated and appended as the record."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;></xref> that contains the reservation that should be used for this restart area."
    - id: callback
      type: System.AsyncCallback
      description: "An optional asynchronous callback, to be called when the restart area write is complete."
    - id: state
      type: System.Object
      description: "A user-provided object that distinguishes this particular asynchronous restart area write request from other requests."
    return:
      type: System.IAsyncResult
      description: "An <xref:System.IAsyncResult> that represents the asynchronous restart area write operation, which could still be pending."
  overload: System.IO.Log.LogRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code> is not valid for this sequence.       -or-       The specified log enumeration start sequence number is invalid.       -or-       <code>data</code> cannot be appended because it is larger than the maximum record size.       -or-       <code>reservation</code> was not created by this record sequence."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "One or more of the parameters is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "A new or existing archive tail or base of the active log is invalid.       -or-       <code>newBaseSeqNum</code> is not between the base and last sequence numbers of this sequence."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "The request could not be performed because of an unexpected I/O exception.       -or-       The request could not be performed because of an I/O device error."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The method was called after the sequence has been disposed of."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Access for the specified log sequence is denied by the operating system."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "The record sequence is full."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Begins an asynchronous restart area write operation, using space previously reserved in the sequence. This method cannot be inherited."
  remarks: "You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method to ensure that the restart area write operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method is called with the <xref:System.IAsyncResult> returned by this method.       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       When the operation successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.       If a <xref:System.IO.Log.ReservationCollection> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection. If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.       If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method is called."
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "A list of byte array segments that will be concatenated and appended as the record."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;></xref> that contains the reservation that should be used for this restart area."
    - id: callback
      type: System.AsyncCallback
      description: "An optional asynchronous callback, to be called when the restart area write is complete."
    - id: state
      type: System.Object
      description: "A user-provided object that distinguishes this particular asynchronous restart area write request from other requests."
    return:
      type: System.IAsyncResult
      description: "An <xref:System.IAsyncResult> that represents the asynchronous restart area write operation, which could still be pending."
  overload: System.IO.Log.LogRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code> is not valid for this sequence.       -or-       The specified log enumeration start sequence number is invalid.       -or-       <code>data</code> cannot be appended because it is larger than the maximum record size.       -or-       <code>reservationCollection</code> was not created by this record sequence."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "One or more of the parameters is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "A new or existing archive tail or base of the active log is invalid.       -or-       <code>newBaseSeqNum</code> is not between the base and last sequence numbers of this sequence."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "The request could not be performed because of an unexpected I/O exception.       -or-       The request could not be performed because of an I/O device error."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The method was called after the sequence has been disposed of."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Access for the specified log sequence is denied by the operating system."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "The record sequence is full."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.CreateReservationCollection
  id: CreateReservationCollection
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: CreateReservationCollection()
  nameWithType: LogRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.LogRecordSequence.CreateReservationCollection()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Creates a new <xref href=&quot;System.IO.Log.ReservationCollection&quot;></xref>. This method cannot be inherited."
  remarks: ''
  example:
  - "Reservations can be performed in two ways as shown in the following examples. You can adopt the practices in the samples for robust processing. Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.  \n  \n```  \n//Using the ReserveAndAppend Method  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nlong[] lengthOfUndoRecords = new long[] { 1000 };  \nrecordSequence.ReserveAndAppend(recordData,  \n                                                     userSqn,  \n                                                     previousSqn,  \n                                                     RecordSequenceAppendOptions.None,  \n                                                     reservations,  \n                                                     lengthOfUndoRecords);  \nrecordSequence.Append(undoRecordData,    // If necessary …  \n                                    userSqn,  \n                                    previousSqn,  \n                                    RecordSequenceAppendOptions.ForceFlush,  \n                                    reservations);  \n  \n// Using the Manual Approach  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nreservations.Add(lengthOfUndoRecord);  \ntry  \n{  \n   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  \n}  \ncatch (Exception)  \n{  \n   reservations.Remove(lengthOfUndoRecord);  \n   throw;  \n}  \n  \nrecordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  \n```"
  syntax:
    content: public System.IO.Log.ReservationCollection CreateReservationCollection ();
    parameters: []
    return:
      type: System.IO.Log.ReservationCollection
      description: "The newly created <xref href=&quot;System.IO.Log.ReservationCollection&quot;></xref>."
  overload: System.IO.Log.LogRecordSequence.CreateReservationCollection*
  exceptions:
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Dispose
  id: Dispose
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Dispose()
  nameWithType: LogRecordSequence.Dispose()
  fullName: System.IO.Log.LogRecordSequence.Dispose()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Releases the resources used by the component."
  remarks: ''
  example:
  - "This example shows how to use Dispose to release resource:  \n  \n [!code-cs[S_UELogRecordSequence#11](~/add/codesnippet/csharp/m-system.io.log.logrecor_1.cs)]\n [!code-vb[S_UELogRecordSequence#11](~/add/codesnippet/visualbasic/m-system.io.log.logrecor_1.vb)]  \n  \n [!code-cs[S_UELogRecordSequence#12](~/add/codesnippet/csharp/m-system.io.log.logrecor_2.cs)]\n [!code-vb[S_UELogRecordSequence#12](~/add/codesnippet/visualbasic/m-system.io.log.logrecor_2.vb)]"
  syntax:
    content: public void Dispose ();
    parameters: []
  overload: System.IO.Log.LogRecordSequence.Dispose*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The method was called after the sequence has been disposed of."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)
  id: EndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Ends an asynchronous append operation. This method cannot be inherited."
  remarks: "This method blocks until the I/O operation has completed. Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when EndAppend is called.       This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.LogRecordSequence.BeginAppend%2A> method."
  syntax:
    content: public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "A reference to the outstanding asynchronous I/O request."
    return:
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the appended log record."
  overload: System.IO.Log.LogRecordSequence.EndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code> is invalid."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "The request could not be performed because of an unexpected I/O exception.       -or-       The request could not be performed because of an I/O device error."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End &quot; name=&quot;End &quot; href=&quot;&quot;></xref>has already been called for this asynchronous operation."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The operation cannot be performed because the record sequence was opened with read-only access."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The method was called after the sequence has been disposed of."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "The record sequence is full."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Access for the specified log sequence is denied by the operating system."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)
  id: EndFlush(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndFlush(IAsyncResult)
  nameWithType: LogRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndFlush(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Ends an asynchronous flush operation. This method cannot be inherited."
  remarks: "This method blocks until the I/O operation has completed. Errors that occur during an asynchronous flush request, such as a disk failure during the I/O request, become visible when EndFlush is called.       This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.LogRecordSequence.BeginFlush%2A> method."
  syntax:
    content: public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "A reference to the outstanding asynchronous I/O request."
    return:
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the last record written."
  overload: System.IO.Log.LogRecordSequence.EndFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code> is invalid."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "The request could not be performed because of an unexpected I/O exception."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref> has already been called for this asynchronous operation."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The operation cannot be performed because the record sequence was opened with read-only access."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The method was called after the sequence has been disposed of."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "The record sequence is full."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Access for the specified log sequence is denied by the operating system."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  id: EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndReserveAndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Ends an asynchronous reserve and append operation. This method cannot be inherited."
  remarks: "This method blocks until the I/O operation has completed. Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when EndReserveAndAppend is called.       This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A> method."
  syntax:
    content: public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "A reference to the outstanding asynchronous I/O request."
    return:
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the appended log record."
  overload: System.IO.Log.LogRecordSequence.EndReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code> is invalid."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "The request could not be performed because of an unexpected I/O exception.       -or-       The request could not be performed because of an I/O device error."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref> has already been called for this asynchronous operation."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The operation cannot be performed because the record sequence was opened with read-only access."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The method was called after the sequence has been disposed of."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "The record sequence is full."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Access for the specified log sequence is denied by the operating system."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  id: EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: LogRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndWriteRestartArea(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Ends an asynchronous restart area write operation. This method cannot be inherited."
  remarks: "This method blocks until the I/O operation has completed. Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when EndWriteRestartArea is called.       This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A> method."
  syntax:
    content: public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "A reference to the outstanding asynchronous I/O request."
    return:
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the written log record."
  overload: System.IO.Log.LogRecordSequence.EndWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code> is not valid."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "A new or existing archive tail or base of the active log is invalid."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "The request could not be performed because of an unexpected I/O exception."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref> has already been called for this asynchronous operation."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The method was called after the sequence has been disposed of."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Access for the specified log sequence is denied by the operating system."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "The record sequence is full."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Flush
  id: Flush
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Flush()
  nameWithType: LogRecordSequence.Flush()
  fullName: System.IO.Log.LogRecordSequence.Flush()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Ensures that all appended records have been written. This method cannot be inherited."
  remarks: "Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.LogRecordSequence> have been durably written."
  syntax:
    content: public System.IO.Log.SequenceNumber Flush ();
    parameters: []
    return:
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the last record written."
  overload: System.IO.Log.LogRecordSequence.Flush*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "An I/O error occurred while flushing the data."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The method was called after the sequence has been disposed of."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "This operation is not supported."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Access for the specified log sequence is denied by the operating system."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "The record sequence could not make enough free space to contain the new restart area."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The specified log does not have any extents. One or more extents must be created before a record sequence can be used."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)
  id: Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Flush(SequenceNumber)
  nameWithType: LogRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.Flush(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Ensures that all appended records up to and including the record with the specified sequence number have been durably written. This method cannot be inherited."
  remarks: "Calling this method ensures that all records with sequence numbers up to and including the specified sequence number have been durably written."
  syntax:
    content: public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the latest record that must be written. If this <xref href=&quot;System.IO.Log.SequenceNumber&quot;></xref> is invalid, then all records must be written."
    return:
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the last record written."
  overload: System.IO.Log.LogRecordSequence.Flush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>sequenceNumber</code> is not valid for this sequence."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>sequenceNumber</code> is not between the base and last sequence numbers of this sequence."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "The request could not be performed because of an unexpected I/O exception."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The specified log does not have any extents. One or more extents must be created before a record sequence can be used."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The operation cannot be performed because the record sequence was opened with read-only access."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The method was called after the sequence has been disposed of."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "The record sequence is full."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Access for the specified log sequence is denied by the operating system."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.LastSequenceNumber
  id: LastSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LastSequenceNumber
  nameWithType: LogRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.LastSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Gets the sequence number which is greater than the last record appended"
  remarks: "This property contains a sequence number that is guaranteed to be larger than the sequence number of the last appended record. Valid sequence numbers are greater than or equal to <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> and less than LastSequenceNumber. All other sequence numbers are invalid."
  syntax:
    content: public System.IO.Log.SequenceNumber LastSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "A sequence number which is greater than the last record appended."
  overload: System.IO.Log.LogRecordSequence.LastSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The property was accessed after the sequence has been disposed of."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.LogStore
  id: LogStore
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogStore
  nameWithType: LogRecordSequence.LogStore
  fullName: System.IO.Log.LogRecordSequence.LogStore
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Gets the <xref href=&quot;System.IO.Log.LogStore&quot;></xref> that contains the data for this record sequence. This method cannot be inherited."
  remarks: ''
  example:
  - "This example shows how to use the LogStore member to add extents.  \n  \n [!code-cs[S_UELogRecordSequence#11](~/add/codesnippet/csharp/p-system.io.log.logrecor_1_1.cs)]\n [!code-vb[S_UELogRecordSequence#11](~/add/codesnippet/visualbasic/p-system.io.log.logrecor_1_1.vb)]"
  syntax:
    content: public System.IO.Log.LogStore LogStore { get; }
    return:
      type: System.IO.Log.LogStore
      description: "The <xref href=&quot;System.IO.Log.LogStore&quot;></xref> that contains the data for this record sequence."
  overload: System.IO.Log.LogRecordSequence.LogStore*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.MaximumRecordLength
  id: MaximumRecordLength
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: MaximumRecordLength
  nameWithType: LogRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.LogRecordSequence.MaximumRecordLength
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Gets the maximum size of a record that can be added to this record sequence."
  syntax:
    content: public long MaximumRecordLength { get; }
    return:
      type: System.Int64
      description: "The maximum size of a record that can be added to this record sequence."
  overload: System.IO.Log.LogRecordSequence.MaximumRecordLength*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  id: ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Returns an enumerable collection of records in the sequence. This method cannot be inherited."
  remarks: "This method returns an enumerable collection of records in the sequence. The order of the enumerated records depends on the value of the `logRecordEnum` parameter."
  example:
  - "This example shows how to use ReadLogRecords in a loop.  \n  \n [!code-cs[S_UELogRecordSequence#10](~/add/codesnippet/csharp/65162f37-dafe-4315-8e44-_1.cs)]\n [!code-vb[S_UELogRecordSequence#10](~/add/codesnippet/visualbasic/65162f37-dafe-4315-8e44-_1.vb)]"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);
    parameters:
    - id: start
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the first record where the reading starts."
    - id: logRecordEnum
      type: System.IO.Log.LogRecordEnumeratorType
      description: "A valid <xref href=&quot;System.IO.Log.LogRecordEnumeratorType&quot;></xref> value that specifies the manner (that is, forward or backward) in which records should be read from a <xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>."
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "An enumerable collection of records in the sequence."
  overload: System.IO.Log.LogRecordSequence.ReadLogRecords*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>start</code> is not valid for this sequence.       -or-       <code>logRecordEnum</code> is invalid.       -or-       The specified element was not found in the collection."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>start</code> is not between the base and last sequence numbers of this sequence."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "The request could not be performed because of an unexpected I/O exception.       -or-       The request could not be performed because of an I/O device error.       -or       The buffer size used to write the log record is larger than the buffer size being used to read it.       -or-       The record sequence is corrupted.       -or-       The specified log file format or version is invalid.       -or-       The record was written with an incompatible version of the record sequence."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The operation is invalid because the enumeration has not been started. A call to <xref:System.Collections.IEnumerator.MoveNext*> must be made."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The method was called after the sequence has been disposed of."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Access for the specified log sequence is denied by the operating system."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReadRestartAreas
  id: ReadRestartAreas
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReadRestartAreas()
  nameWithType: LogRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.LogRecordSequence.ReadRestartAreas()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Returns an enumerable collection of the restart areas in the sequence. This method cannot be inherited."
  remarks: "The restart areas are enumerated in reverse sequence number order, that is, from the highest sequence number to the lowest sequence number. Only restart areas with sequence numbers between the last sequence number and the base sequence number are enumerated."
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadRestartAreas ();
    parameters: []
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "An enumerable collection of the restart areas in the sequence."
  overload: System.IO.Log.LogRecordSequence.ReadRestartAreas*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>start</code> is not between the base and last sequence numbers of this sequence."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "The request could not be performed because of an unexpected I/O exception.       -or-       The request could not be performed because of an I/O device error.       -or       The buffer size used to write the log record is larger than the buffer size being used to read it.       -or-       The record sequence is corrupted.       -or-       The specified log file format or version is invalid.       -or-       The record was written with an incompatible version of the record sequence."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The operation is invalid because the enumeration has not been started. A call to <xref:System.Collections.IEnumerator.MoveNext*> must be made.       -or       The enumeration has ended."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The method was called after the sequence has been disposed of."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Access for the specified log sequence is denied by the operating system."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Automatically makes a single reservation and appends a record to the sequence. This method cannot be inherited."
  remarks: "Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation. If the append fails, no space is reserved.       Normally, this method may complete before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method."
  example:
  - "The following example shows how to use this method to make reservations. Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.  \n  \n```  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nlong[] lengthOfUndoRecords = new long[] { 1000 };  \nrecordSequence.ReserveAndAppend(recordData,  \n                                                     userSqn,  \n                                                     previousSqn,  \n                                                     RecordSequenceAppendOptions.None,  \n                                                     reservations,  \n                                                     lengthOfUndoRecords);  \nrecordSequence.Append(undoRecordData,    // If necessary …  \n                                    userSqn,  \n                                    previousSqn,  \n                                    RecordSequenceAppendOptions.ForceFlush,  \n                                    reservations);  \n```"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "A list of byte array segments that will be concatenated and appended as the record."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the next record in the user-specified order."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the next record in Previous order."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "A valid value of <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref> that specifies how the data should be written."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;></xref> that contains the collection to make reservations in."
    - id: reservations
      type: System.Int64[]
      description: "The reservations to make, in bytes."
    return:
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the appended log record."
  overload: System.IO.Log.LogRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>nextUndoRecord</code> or <code>previousRecord</code> is not valid for this sequence.       -or-       <code>data</code> cannot be appended because it is larger than the maximum record size.       -or-       <code>reservations</code> was not created by this record sequence."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "One or more of the arguments are <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>nextUndoRecord</code> or <code>previousRecord</code> is not between the base and last sequence numbers of this sequence."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "The request could not be performed because of an unexpected I/O exception.       -or-       The request could not be performed because of an I/O device error."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The operation cannot be performed because the record sequence was opened with read-only access."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The method was called after the sequence has been disposed of."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "The record sequence is full."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Access for the specified log sequence is denied by the operating system."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "No reservation large enough to fit <code>data</code> can be found in <code>reservations</code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Automatically makes a single reservation and appends a record to the sequence. This method cannot be inherited."
  remarks: "Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation. If the append fails, no space is reserved.       Normally, this method may complete before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method."
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "A list of byte array segments that will be concatenated and appended as the record."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the next record in the user-specified order."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the next record in Previous order."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "A valid value of <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref> that specifies how the data should be written."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "The reservation collection to make reservations in."
    - id: reservations
      type: System.Int64[]
      description: "The reservations to make, in bytes."
    return:
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the appended log record."
  overload: System.IO.Log.LogRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "One or more of the arguments is invalid."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "An I/O error occurred while appending the record."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "The record sequence could not make enough free space to contain the new record, or to make the reservation."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The method was called after the sequence has been disposed of."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "One or more of the arguments are <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code> or <code>previousRecord</code> is not between the base and last sequence numbers of this sequence."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The operation cannot be performed because the record sequence was opened with read-only access."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Access for the specified log sequence is denied by the operating system."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "No reservation large enough to fit <code>data</code> can be found in <code>reservations</code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReservedBytes
  id: ReservedBytes
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReservedBytes
  nameWithType: LogRecordSequence.ReservedBytes
  fullName: System.IO.Log.LogRecordSequence.ReservedBytes
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Gets the total number of bytes that have been reserved."
  syntax:
    content: public long ReservedBytes { get; }
    return:
      type: System.Int64
      description: "The total size of all reservations made in this record sequence."
  overload: System.IO.Log.LogRecordSequence.ReservedBytes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The property was accessed after the sequence has been disposed of."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.RestartSequenceNumber
  id: RestartSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: RestartSequenceNumber
  nameWithType: LogRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.RestartSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Gets the sequence number of the restart area closest to the end of the log."
  remarks: "A restart area is used to temporarily store information containing a client&quot;s last checkpoint operation. The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available. When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.       Using the <xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A> method, you can remove the most recently written restart area."
  syntax:
    content: public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the restart area closest to the end of the log."
  overload: System.IO.Log.LogRecordSequence.RestartSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The property was accessed after the sequence has been disposed of."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.RetryAppend
  id: RetryAppend
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: RetryAppend
  nameWithType: LogRecordSequence.RetryAppend
  fullName: System.IO.Log.LogRecordSequence.RetryAppend
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Gets or sets a value indicating whether or not appends are automatically retried if the log is full."
  remarks: "If the value of this property is `true`, and an <xref:System.IO.Log.LogRecordSequence.Append%2A> call fails because there is not enough space in the sequence, the record sequence will try to free space and retry the append."
  example:
  - "This example shows how to use the RetryAppend property.  \n  \n [!code-cs[S_UELogRecordSequence#3](~/add/codesnippet/csharp/p-system.io.log.logrecor_0_1.cs)]\n [!code-vb[S_UELogRecordSequence#3](~/add/codesnippet/visualbasic/p-system.io.log.logrecor_0_1.vb)]"
  syntax:
    content: public bool RetryAppend { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref> if appends are automatically retried if the log is full; otherwise, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>. The default is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>."
  overload: System.IO.Log.LogRecordSequence.RetryAppend*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The property was accessed after the sequence has been disposed of."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)
  id: SetLastRecord(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: SetLastRecord(SequenceNumber)
  nameWithType: LogRecordSequence.SetLastRecord(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.SetLastRecord(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Sets the last record in the <xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>."
  remarks: "The specified sequence number must be larger than the base sequence number.       When this method completes, all records that had previously been appended with sequence numbers greater than the specified sequence number are inaccessible."
  syntax:
    content: public void SetLastRecord (System.IO.Log.SequenceNumber sequenceNumber);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "The new last sequence number in the <xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>.       This should refer to a current valid record   currently in the log."
  overload: System.IO.Log.LogRecordSequence.SetLastRecord*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>sequenceNumber</code> is not valid for this sequence."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "A new or existing archive tail or base of the active log is invalid.       -or-       <code>sequenceNumber</code> is not between the base and last sequence numbers of this sequence."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "The request could not be performed because of an unexpected I/O exception.       -or-       The end of the log has been reached.       -or-       The specified log file format or version is invalid."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The method was called after the sequence has been disposed of."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Access for the specified log sequence is denied by the operating system."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.TailPinned
  id: TailPinned
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: TailPinned
  nameWithType: LogRecordSequence.TailPinned
  fullName: System.IO.Log.LogRecordSequence.TailPinned
  type: Event
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Signals the need to move the tail of the sequence."
  remarks: "You can fire this event when the record sequence has run out of space. When this event is fired, the tail of the sequence (that is, the base sequence number) is moved forward to free up space.       The event can be fired at any time when the record sequence decides that it must free up space, for any reason. For example, the CLFS policy engine may decide to fire the event when it determines that the tails of two log clients sharing the same log file are too far apart. Freeing space can be done by either writing restart areas, or truncating the log and using the <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> method to clear space. The code sample in the Example section demonstrates the second approach.       You can also call the <xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A> method outside of the TailPinned event to free space. A restart area is similar to a checkpoint in other log processing systems. Calling this method indicates that the application considers all prior records before the restart area as fully completed, and usable for future record appends. Similar to any other records, the record written by this method requires actual free space in the log to function."
  example:
  - "This example shows how to use the TailPinned event.  \n  \n```  \nrecordSequence.RetryAppend = true;  \nrecordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  \n  \nvoid HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  \n{  \n   // tailPinnedEventArgs.TargetSequenceNumber is the target   \n   // sequence number to free up space to.    \n   // However, this sequence number is not necessarily valid.  We have  \n   // to use this sequence number as a starting point for finding a  \n   // valid point within the log to advance toward. You need to  \n   // identify a record with a sequence number equal to, or greater  \n   // than TargetSequenceNumber; let's call this   \n   // realTargetSequenceNumber. Once found, move the base  \n  \n   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  \n  \n}  \n```"
  syntax:
    content: public event EventHandler<System.IO.Log.TailPinnedEventArgs> TailPinned;
    return:
      type: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
      description: "To be added."
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  id: WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Writes a restart area to the <xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>. This method cannot be inherited."
  remarks: "A restart area is used to temporarily store information containing a client&quot;s last checkpoint operation. The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available. When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.       A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.       The data in the byte array segments will be concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "An array segment that will be concatenated and appended as the record."
    return:
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the written restart area."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "One or more of the arguments is invalid."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "An I/O error occurred while writing the restart area."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "The record sequence could not make enough free space to contain the new restart area."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The method was called after the sequence has been disposed of."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "One or more of the arguments are <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Access for the specified log sequence is denied by the operating system."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Writes a restart area to the <xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>. This method cannot be inherited."
  remarks: "A restart area is used to temporarily store information containing a client&quot;s last checkpoint operation. The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available. When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.       A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.       The data in the byte array segments will be concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "A list of byte array segments that will be concatenated and appended as the record."
    return:
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the written restart area."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "One or more of the arguments is invalid."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "An I/O error occurred while writing the restart area."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "The record sequence could not make enough free space to contain the new restart area."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The method was called after the sequence has been disposed of."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "One or more of the arguments are <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Access for the specified log sequence is denied by the operating system."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Writes a restart area to the <xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref> and updates the base sequence number. This method cannot be inherited."
  remarks: "A restart area is used to temporarily store information containing a client&quot;s last checkpoint operation. The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available. When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.       A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.       When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.       When this method successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.       If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "A list of byte array segments that will be concatenated and appended as the record."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number."
    return:
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the written restart area."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "One or more of the arguments is invalid."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "An I/O error occurred while writing the restart area."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "The record sequence could not make enough free space to contain the new restart area."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The method was called after the sequence has been disposed of."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Writes a restart area to the <xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref> and updates the base sequence number. This method cannot be inherited."
  remarks: "A restart area is used to temporarily store information containing a client&quot;s last checkpoint operation. The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available. When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.       A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.       When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.       When this method successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.       If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "A list of byte array segments that will be concatenated and appended as the record."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number."
    return:
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the written restart area."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "One or more of the arguments is invalid."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "An I/O error occurred while writing the restart area."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "The record sequence could not make enough free space to contain the new restart area."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The method was called after the sequence has been disposed of."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Writes a restart area to the <xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref> using a reservation, and updates the base sequence number. This method cannot be inherited."
  remarks: "A restart area is used to temporarily store information containing a client&quot;s last checkpoint operation. The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available. When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.       A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.       When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.       If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection. If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.       When this method successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.       If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "A list of byte array segments that will be concatenated and appended as the record."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;></xref> that contains the reservation that should be used for this restart area."
    return:
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the written restart area."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "One or more of the arguments is invalid."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "An I/O error occurred while writing the restart area."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "The record sequence could not make enough free space to contain the new restart area."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The method was called after the sequence has been disposed of."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Writes a restart area to the <xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref> using a reservation, and updates the base sequence number. This method cannot be inherited."
  remarks: "A restart area is used to temporarily store information containing a client&quot;s last checkpoint operation. The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available. When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.       A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.       When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.       If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection. If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.       When this method successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.       If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "A list of byte array segments that will be concatenated and appended as the record."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;></xref> that contains the reservation that should be used for this restart area."
    return:
      type: System.IO.Log.SequenceNumber
      description: "The sequence number of the written restart area."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code> is not valid for this sequence.       -or-       The specified log enumeration start sequence number is invalid.       -or-       <code>data</code> cannot be appended because it is larger than the maximum record size.       -or-       <code>reservationCollection</code> was not created by this record sequence."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "One or more of the parameters is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "A new or existing archive tail or base of the active log is invalid.       -or-       <code>newBaseSeqNum</code> is not between the base and last sequence numbers of this sequence."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "The request could not be performed because of an unexpected I/O exception.       -or-       The request could not be performed because of an I/O device error."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "The method was called after the sequence has been disposed of."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "There is not enough memory to continue the execution of the program."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Access for the specified log sequence is denied by the operating system."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "The record sequence is full."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IO.Log.SequenceFullException
  parent: System.IO.Log
  isExternal: false
  name: SequenceFullException
  nameWithType: SequenceFullException
  fullName: System.IO.Log.SequenceFullException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.IO.Log.ReservationNotFoundException
  parent: System.IO.Log
  isExternal: false
  name: ReservationNotFoundException
  nameWithType: ReservationNotFoundException
  fullName: System.IO.Log.ReservationNotFoundException
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(LogStore)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore)
- uid: System.IO.Log.LogStore
  parent: System.IO.Log
  isExternal: false
  name: LogStore
  nameWithType: LogStore
  fullName: System.IO.Log.LogStore
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.IO.FileMode
  parent: System.IO
  isExternal: false
  name: FileMode
  nameWithType: FileMode
  fullName: System.IO.FileMode
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(LogStore,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
- uid: System.IO.FileShare
  parent: System.IO
  isExternal: false
  name: FileShare
  nameWithType: FileShare
  fullName: System.IO.FileShare
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
- uid: System.Security.AccessControl.FileSecurity
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSecurity
  nameWithType: FileSecurity
  fullName: System.Security.AccessControl.FileSecurity
- uid: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
- uid: System.IO.Log.SequenceNumber
  parent: System.IO.Log
  isExternal: false
  name: SequenceNumber
  nameWithType: SequenceNumber
  fullName: System.IO.Log.SequenceNumber
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.ArraySegment{System.Byte}
  parent: System
  isExternal: true
  name: ArraySegment<Byte>
  nameWithType: ArraySegment<Byte>
  fullName: System.ArraySegment<System.Byte>
  spec.csharp:
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.RecordAppendOptions
  parent: System.IO.Log
  isExternal: false
  name: RecordAppendOptions
  nameWithType: RecordAppendOptions
  fullName: System.IO.Log.RecordAppendOptions
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
  parent: System.Collections.Generic
  isExternal: true
  name: IList<ArraySegment<Byte>>
  nameWithType: IList<ArraySegment<Byte>>
  fullName: System.Collections.Generic.IList<System.ArraySegment<System.Byte>>
  spec.csharp:
  - uid: System.Collections.Generic.IList`1
    name: IList
    nameWithType: IList
    fullName: IList<System.ArraySegment<System.Byte>>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.ReservationCollection
  parent: System.IO.Log
  isExternal: false
  name: ReservationCollection
  nameWithType: ReservationCollection
  fullName: System.IO.Log.ReservationCollection
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.LogRecordSequence.BaseSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: LogRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.Int64[]
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64[]
  spec.csharp:
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: Int64[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.CreateReservationCollection
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: CreateReservationCollection()
  nameWithType: LogRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.LogRecordSequence.CreateReservationCollection()
- uid: System.IO.Log.LogRecordSequence.Dispose
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Dispose()
  nameWithType: LogRecordSequence.Dispose()
  fullName: System.IO.Log.LogRecordSequence.Dispose()
- uid: System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndAppend(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndFlush(IAsyncResult)
  nameWithType: LogRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndFlush(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndReserveAndAppend(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: LogRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndWriteRestartArea(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.Flush
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Flush()
  nameWithType: LogRecordSequence.Flush()
  fullName: System.IO.Log.LogRecordSequence.Flush()
- uid: System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Flush(SequenceNumber)
  nameWithType: LogRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.Flush(SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.LastSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: LogRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.LastSequenceNumber
- uid: System.IO.Log.LogRecordSequence.LogStore
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogStore
  nameWithType: LogRecordSequence.LogStore
  fullName: System.IO.Log.LogRecordSequence.LogStore
- uid: System.IO.Log.LogRecordSequence.MaximumRecordLength
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: LogRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.LogRecordSequence.MaximumRecordLength
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
- uid: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<LogRecord>
  nameWithType: IEnumerable<LogRecord>
  fullName: System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.IO.Log.LogRecord>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.LogRecord
    name: LogRecord
    nameWithType: LogRecord
    fullName: LogRecord
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordEnumeratorType
  parent: System.IO.Log
  isExternal: false
  name: LogRecordEnumeratorType
  nameWithType: LogRecordEnumeratorType
  fullName: System.IO.Log.LogRecordEnumeratorType
- uid: System.IO.Log.LogRecordSequence.ReadRestartAreas
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadRestartAreas()
  nameWithType: LogRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.LogRecordSequence.ReadRestartAreas()
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.LogRecordSequence.ReservedBytes
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: LogRecordSequence.ReservedBytes
  fullName: System.IO.Log.LogRecordSequence.ReservedBytes
- uid: System.IO.Log.LogRecordSequence.RestartSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: LogRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.LogRecordSequence.RetryAppend
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: LogRecordSequence.RetryAppend
  fullName: System.IO.Log.LogRecordSequence.RetryAppend
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: SetLastRecord(SequenceNumber)
  nameWithType: LogRecordSequence.SetLastRecord(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.SetLastRecord(SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.TailPinned
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: TailPinned
  nameWithType: LogRecordSequence.TailPinned
  fullName: System.IO.Log.LogRecordSequence.TailPinned
- uid: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<TailPinnedEventArgs>
  nameWithType: EventHandler<TailPinnedEventArgs>
  fullName: System.EventHandler<System.IO.Log.TailPinnedEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.IO.Log.TailPinnedEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.TailPinnedEventArgs
    name: TailPinnedEventArgs
    nameWithType: TailPinnedEventArgs
    fullName: TailPinnedEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.LogRecordSequence.#ctor*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence
  nameWithType: LogRecordSequence.LogRecordSequence
- uid: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber
  nameWithType: LogRecordSequence.AdvanceBaseSequenceNumber
- uid: System.IO.Log.LogRecordSequence.Append*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append
  nameWithType: LogRecordSequence.Append
- uid: System.IO.Log.LogRecordSequence.BaseSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: LogRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.LogRecordSequence.BeginAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend
  nameWithType: LogRecordSequence.BeginAppend
- uid: System.IO.Log.LogRecordSequence.BeginFlush*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginFlush
  nameWithType: LogRecordSequence.BeginFlush
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginReserveAndAppend
  nameWithType: LogRecordSequence.BeginReserveAndAppend
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginWriteRestartArea
  nameWithType: LogRecordSequence.BeginWriteRestartArea
- uid: System.IO.Log.LogRecordSequence.CreateReservationCollection*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: CreateReservationCollection
  nameWithType: LogRecordSequence.CreateReservationCollection
- uid: System.IO.Log.LogRecordSequence.Dispose*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Dispose
  nameWithType: LogRecordSequence.Dispose
- uid: System.IO.Log.LogRecordSequence.EndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndAppend
  nameWithType: LogRecordSequence.EndAppend
- uid: System.IO.Log.LogRecordSequence.EndFlush*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndFlush
  nameWithType: LogRecordSequence.EndFlush
- uid: System.IO.Log.LogRecordSequence.EndReserveAndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndReserveAndAppend
  nameWithType: LogRecordSequence.EndReserveAndAppend
- uid: System.IO.Log.LogRecordSequence.EndWriteRestartArea*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndWriteRestartArea
  nameWithType: LogRecordSequence.EndWriteRestartArea
- uid: System.IO.Log.LogRecordSequence.Flush*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Flush
  nameWithType: LogRecordSequence.Flush
- uid: System.IO.Log.LogRecordSequence.LastSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: LogRecordSequence.LastSequenceNumber
- uid: System.IO.Log.LogRecordSequence.LogStore*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogStore
  nameWithType: LogRecordSequence.LogStore
- uid: System.IO.Log.LogRecordSequence.MaximumRecordLength*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: LogRecordSequence.MaximumRecordLength
- uid: System.IO.Log.LogRecordSequence.ReadLogRecords*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadLogRecords
  nameWithType: LogRecordSequence.ReadLogRecords
- uid: System.IO.Log.LogRecordSequence.ReadRestartAreas*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadRestartAreas
  nameWithType: LogRecordSequence.ReadRestartAreas
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReserveAndAppend
  nameWithType: LogRecordSequence.ReserveAndAppend
- uid: System.IO.Log.LogRecordSequence.ReservedBytes*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: LogRecordSequence.ReservedBytes
- uid: System.IO.Log.LogRecordSequence.RestartSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: LogRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.LogRecordSequence.RetryAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: LogRecordSequence.RetryAppend
- uid: System.IO.Log.LogRecordSequence.SetLastRecord*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: SetLastRecord
  nameWithType: LogRecordSequence.SetLastRecord
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea
  nameWithType: LogRecordSequence.WriteRestartArea
