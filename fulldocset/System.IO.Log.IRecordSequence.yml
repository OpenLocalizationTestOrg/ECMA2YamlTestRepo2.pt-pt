### YamlMime:ManagedReference
items:
- uid: System.IO.Log.IRecordSequence
  id: IRecordSequence
  children:
  - System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.IRecordSequence.BaseSequenceNumber
  - System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.CreateReservationCollection
  - System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.Flush
  - System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.LastSequenceNumber
  - System.IO.Log.IRecordSequence.MaximumRecordLength
  - System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  - System.IO.Log.IRecordSequence.ReadRestartAreas
  - System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.IRecordSequence.ReservedBytes
  - System.IO.Log.IRecordSequence.RestartSequenceNumber
  - System.IO.Log.IRecordSequence.RetryAppend
  - System.IO.Log.IRecordSequence.TailPinned
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  langs:
  - csharp
  name: IRecordSequence
  nameWithType: IRecordSequence
  fullName: System.IO.Log.IRecordSequence
  type: Interface
  summary: "Fornece uma interface genérica para uma sequência de registos."
  remarks: "A interface IRecordSequence fornece uma interface abstrata para uma transmissão em fluxo e orientado para o registo. Uma instância de IRecordSequence pode ser utilizada para ler e escrever os registos de registo.       A interface IRecordSequence fornece as seguintes capacidades - acrescentar o registo de registos ao utilizar o <xref:System.IO.Log.IRecordSequence.Append%2A>métodos.</xref:System.IO.Log.IRecordSequence.Append%2A>      -Leia os registos anexados utilizando o <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A>método.</xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A>      -Escrever um reinício especial registo utilizando o <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>método.</xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>      -Leia reiniciar registos do escrito mais recentemente reinício registos com o <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>método.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>      -Esvaziar os registos para arquivo durável utilizando o <xref:System.IO.Log.IRecordSequence.Flush%2A>método.</xref:System.IO.Log.IRecordSequence.Flush%2A>      -Reservar espaço para acrescentar registos.      -Espaço de registo livre por avançadas a base do registo.      -Receber <xref:System.IO.Log.IRecordSequence.TailPinned>notificações de eventos para mover a base do registo a espaço livre.</xref:System.IO.Log.IRecordSequence.TailPinned>       Registos são anexados a uma instância de IRecordSequence, e cada registo é dado um número de sequência exclusivo. Números de sequência estritamente forma monótona estão aumentar dentro de uma sequência de registo fornecido. Um registo é composta pelos dados opaco, fornecidos para a instância de IRecordSequence num <xref:System.Collections.IList>de ArraySegments de bytes.</xref:System.Collections.IList>       A interface IRecordSequence também expõe as propriedades básicas alguns que fornece informações sobre limites de registo.      -O <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>propriedade contém o número de sequência de registo válido primeiro na sequência de registo.</xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>      -O <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>propriedade contém um número de sequência é assegurado para ser maior do que o número de sequência do último anexado registo.</xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>      -O <xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A>propriedade contém o número de sequência da área do último reinício escrito.</xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A>      -O <xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A>propriedade contém o tamanho do registo maior que pode ser anexado a ou ler a partir da sequência.</xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A>      -O <xref:System.IO.Log.IRecordSequence.ReservedBytes%2A>propriedade contém o tamanho total de todas as reservas efetuadas nesta sequência de registos.</xref:System.IO.Log.IRecordSequence.ReservedBytes%2A>      -Se a <xref:System.IO.Log.IRecordSequence.RetryAppend%2A>propriedade está definida como `true`e um <xref:System.IO.Log.IRecordSequence.Append%2A>Falha na operação porque não existe espaço na sequência, a sequência de registos tentará espaço livre e repita a operação de acréscimo.</xref:System.IO.Log.IRecordSequence.Append%2A> </xref:System.IO.Log.IRecordSequence.RetryAppend%2A>"
  syntax:
    content: 'public interface IRecordSequence : IDisposable'
  implements:
  - System.IDisposable
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  id: AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Move o número de sequência base do registo de reencaminhar."
  remarks: "Quando utiliza um <xref:System.IO.Log.LogRecordSequence>instância e tente ao produzir o número de sequência para libertar espaço no registo, o novo número de sequência base têm de residir numa extensão de registo diferentes para a extensão anterior ser assinalado como vazio.</xref:System.IO.Log.LogRecordSequence> Libertar extensões parcialmente não é suportada."
  syntax:
    content: public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "O novo número de sequência base da sequência de registo."
  overload: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSequenceNumber</code>Não é válido."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSequenceNumber</code>não está ativo no registo."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao modificar a sequência."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos está cheia."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, escreve um registo para o <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  remarks: "Dados contidos no `data` parâmetro será CONCATENAR para uma matriz de bytes único para acrescentar como o registo. No entanto, nenhum aprovisionar é efetuada para dividir os dados no segmentos de matriz quando o registo de leitura.       Normalmente, este método é concluída antes do registo foi escrito. Para se certificar de que foi escrito um registo, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador utilizando o `recordAppendOptions` parâmetro ou chamada de <xref:System.IO.Log.IRecordSequence.Flush%2A>método.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de utilizador especificado."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica a forma como os dados devem ser escritos."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo registo anexado."
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao acrescentar o registo."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos não foi possível efetuar o espaço livre suficiente para conter o novo registo."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, acrescenta um registo para o <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  remarks: "Dados contidos no `data` parâmetro será CONCATENAR para uma matriz de bytes único para acrescentar como o registo. No entanto, nenhum aprovisionar é efetuada para dividir os dados no segmentos de matriz quando o registo de leitura.       Normalmente, este método é concluída antes do registo foi escrito. Para se certificar de que foi escrito um registo, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador utilizando o `recordAppendOptions` parâmetro ou chamada de <xref:System.IO.Log.IRecordSequence.Flush%2A>método.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de utilizador especificado."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica a forma como os dados devem ser escritos."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo registo anexado."
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao acrescentar o registo."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos não foi possível efetuar o espaço livre suficiente para conter o novo registo."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, acrescenta um registo para o <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>, utilizar espaço reservado anteriormente na sequência."
  remarks: "Dados contidos no `data` parâmetro será CONCATENAR para uma matriz de bytes único para acrescentar como o registo. No entanto, nenhum aprovisionar é efetuada para dividir os dados no segmentos de matriz quando o registo de leitura.       O registo anexado irá consumir o espaço que foi anteriormente reservado, utilizando uma reserva especificada pelo `reservations` parâmetro. Se a acrescentar for bem sucedida, irá consumir a área de reserva menor, que pode conter os dados e de que a área de reserva será removida da coleção.       Normalmente, este método é concluída antes do registo foi escrito. Para se certificar de que foi escrito um registo, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador utilizando o `recordAppendOptions` parâmetro ou chamada de <xref:System.IO.Log.IRecordSequence.Flush%2A>método.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de utilizador especificado."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica a forma como os dados devem ser escritos."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> que contém a reserva que deve ser utilizada para este registo."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo registo anexado."
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao acrescentar o registo."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos não foi possível efetuar o espaço livre suficiente para conter o novo registo."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, acrescenta um registo para o <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>, utilizar espaço reservado anteriormente na sequência."
  remarks: "Dados contidos no `data` parâmetro será CONCATENAR para uma matriz de bytes único para acrescentar como o registo. No entanto, nenhum aprovisionar é efetuada para dividir os dados no segmentos de matriz quando o registo de leitura.       O registo anexado irá consumir o espaço que foi anteriormente reservado, utilizando uma reserva especificada pelo `reservations` parâmetro. Se a acrescentar for bem sucedida, irá consumir a área de reserva menor, que pode conter os dados e de que a área de reserva será removida da coleção.       Normalmente, este método é concluída antes do registo foi escrito. Para se certificar de que foi escrito um registo, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador utilizando o `recordAppendOptions` parâmetro ou chamada de <xref:System.IO.Log.IRecordSequence.Flush%2A>método.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de utilizador especificado."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica a forma como os dados devem ser escritos."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> que contém a reserva que deve ser utilizada para este registo."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo registo anexado."
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao acrescentar o registo."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos não foi possível efetuar o espaço livre suficiente para conter o novo registo."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BaseSequenceNumber
  id: BaseSequenceNumber
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BaseSequenceNumber
  nameWithType: IRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.IRecordSequence.BaseSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, obtém o número de sequência de registo válido primeiro na atual <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  remarks: "Números de sequência válido são maior que ou igual a BaseSequenceNumber e inferior ao <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.</xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>       O valor desta propriedade pode ser alterado ao chamar o <xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A>ou <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>método.</xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> </xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "O menor número de sequência que corresponde a um registo válido no <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  overload: System.IO.Log.IRecordSequence.BaseSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A propriedade foi acedida depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, começa uma assíncrona acrescentar a operação."
  remarks: "Deverá passar a <xref:System.IAsyncResult>devolvido por este método para o <xref:System.IO.Log.IRecordSequence.EndAppend%2A>método para se certificar de que concluiu a operação de acréscimo e de recursos podem ser libertados adequadamente.</xref:System.IO.Log.IRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Se tiver ocorrido um erro durante uma acrescentar assíncrona, não é emitida uma exceção até o <xref:System.IO.Log.IRecordSequence.EndAppend%2A>método for chamado com o <xref:System.IAsyncResult>devolvido por este método.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndAppend%2A>       Dados contidos no `data` parâmetro será CONCATENAR para uma matriz de bytes único para acrescentar como o registo. No entanto, nenhum aprovisionar é efetuada para dividir os dados no segmentos de matriz quando o registo de leitura.       Normalmente, este método é concluída antes do registo foi escrito. Para se certificar de que foi escrito um registo, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador utilizando o `recordAppendOptions` parâmetro ou chamada de <xref:System.IO.Log.IRecordSequence.Flush%2A>método.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de utilizador especificado."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica a forma como os dados devem ser escritos."
    - id: callback
      type: System.AsyncCallback
      description: "Uma opcional chamada de retorno assíncrona, ser chamado quando a acrescentar estiver concluída."
    - id: state
      type: System.Object
      description: "Um objeto fornecidos pelo utilizador que distingue este determinado assíncrona acrescentar pedido a partir de outros pedidos."
    return:
      type: System.IAsyncResult
      description: "Um <xref:System.IAsyncResult>que representa a acrescentar assíncrono, o que pode ainda estar pendentes.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao acrescentar o registo."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos não foi possível efetuar o espaço livre suficiente para conter o novo registo."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, começa uma assíncrona acrescentar a operação, utilizando o espaço reservado anteriormente na sequência."
  remarks: "Deverá passar a <xref:System.IAsyncResult>devolvido por este método para o <xref:System.IO.Log.IRecordSequence.EndAppend%2A>método para se certificar de que concluiu a operação de acréscimo e de recursos podem ser libertados adequadamente.</xref:System.IO.Log.IRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Se tiver ocorrido um erro durante uma acrescentar assíncrona, não é emitida uma exceção até o <xref:System.IO.Log.IRecordSequence.EndAppend%2A>método for chamado com o <xref:System.IAsyncResult>devolvido por este método.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndAppend%2A>       Dados contidos no `data` parâmetro será CONCATENAR para uma matriz de bytes único para acrescentar como o registo. No entanto, nenhum aprovisionar é efetuada para dividir os dados no segmentos de matriz quando o registo de leitura.       Normalmente, este método é concluída antes do registo foi escrito. Para se certificar de que foi escrito um registo, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador utilizando o `recordAppendOptions` parâmetro ou chamada de <xref:System.IO.Log.IRecordSequence.Flush%2A>método.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de utilizador especificado."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica a forma como os dados devem ser escritos."
    - id: callback
      type: System.AsyncCallback
      description: "Uma opcional chamada de retorno assíncrona, ser chamado quando a acrescentar estiver concluída."
    - id: state
      type: System.Object
      description: "Um objeto fornecidos pelo utilizador que distingue este determinado assíncrona acrescentar pedido a partir de outros pedidos."
    return:
      type: System.IAsyncResult
      description: "Um <xref:System.IAsyncResult>que representa a acrescentar assíncrono, o que pode ainda estar pendentes.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao acrescentar o registo."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos não foi possível efetuar o espaço livre suficiente para conter o novo registo."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, começa uma assíncrona acrescentar operação utilizando espaço reservado anteriormente na sequência."
  remarks: "Deverá passar a <xref:System.IAsyncResult>devolvido por este método para o <xref:System.IO.Log.IRecordSequence.EndAppend%2A>método para se certificar de que concluiu a operação de acréscimo e de recursos podem ser libertados adequadamente.</xref:System.IO.Log.IRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Se tiver ocorrido um erro durante uma acrescentar assíncrona, não é emitida uma exceção até o <xref:System.IO.Log.IRecordSequence.EndAppend%2A>método for chamado com o <xref:System.IAsyncResult>devolvido por este método.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndAppend%2A>       Dados contidos no `data` parâmetro será CONCATENAR para uma matriz de bytes único para acrescentar como o registo. No entanto, nenhum aprovisionar é efetuada para dividir os dados no segmentos de matriz quando o registo de leitura.       O registo anexado irá consumir o espaço que foi anteriormente reservado, utilizando uma reserva especificada pelo `reservations` parâmetro. Se a acrescentar for bem sucedida, irá consumir a área de reserva menor, que pode conter os dados e de que a área de reserva será removida da coleção.       Normalmente, este método é concluída antes do registo foi escrito. Para se certificar de que foi escrito um registo, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador utilizando o `recordAppendOptions` parâmetro ou chamada de <xref:System.IO.Log.IRecordSequence.Flush%2A>método.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de utilizador especificado."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica a forma como os dados devem ser escritos."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> que contém a reserva que deve ser utilizada para este registo."
    - id: callback
      type: System.AsyncCallback
      description: "Uma opcional chamada de retorno assíncrona, ser chamado quando a acrescentar estiver concluída."
    - id: state
      type: System.Object
      description: "Um objeto fornecidos pelo utilizador que distingue este determinado assíncrona acrescentar pedido a partir de outros pedidos."
    return:
      type: System.IAsyncResult
      description: "Um <xref:System.IAsyncResult>que representa a acrescentar assíncrono, o que pode ainda estar pendentes.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao acrescentar o registo."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos não foi possível efetuar o espaço livre suficiente para conter o novo registo."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, começa uma assíncrona acrescentar a operação, utilizando o espaço reservado anteriormente na sequência."
  remarks: "Deverá passar a <xref:System.IAsyncResult>devolvido por este método para o <xref:System.IO.Log.IRecordSequence.EndAppend%2A>método para se certificar de que concluiu a operação de acréscimo e de recursos podem ser libertados adequadamente.</xref:System.IO.Log.IRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Se tiver ocorrido um erro durante uma acrescentar assíncrona, não é emitida uma exceção até o <xref:System.IO.Log.IRecordSequence.EndAppend%2A>método for chamado com o <xref:System.IAsyncResult>devolvido por este método.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndAppend%2A>       Dados contidos no `data` parâmetro será CONCATENAR para uma matriz de bytes único para acrescentar como o registo. No entanto, nenhum aprovisionar é efetuada para dividir os dados no segmentos de matriz quando o registo de leitura.       O registo anexado irá consumir o espaço que foi anteriormente reservado, utilizando uma reserva especificada pelo `reservations` parâmetro. Se a acrescentar for bem sucedida, irá consumir a área de reserva menor, que pode conter os dados e de que a área de reserva será removida da coleção.       Normalmente, este método é concluída antes do registo foi escrito. Para se certificar de que foi escrito um registo, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador utilizando o `recordAppendOptions` parâmetro ou chamada de <xref:System.IO.Log.IRecordSequence.Flush%2A>método.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousUndoRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de utilizador especificado."
    - id: previousUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica a forma como os dados devem ser escritos."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> que contém a reserva que deve ser utilizada para este registo."
    - id: callback
      type: System.AsyncCallback
      description: "Uma opcional chamada de retorno assíncrona, ser chamado quando a acrescentar estiver concluída."
    - id: state
      type: System.Object
      description: "Um objeto fornecidos pelo utilizador que distingue este determinado assíncrona acrescentar pedido a partir de outros pedidos."
    return:
      type: System.IAsyncResult
      description: "Um <xref:System.IAsyncResult>que representa a acrescentar assíncrono, o que pode ainda estar pendentes.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao acrescentar o registo."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos não foi possível efetuar o espaço livre suficiente para conter o novo registo."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  id: BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, inicia uma operação assíncrona libertação, utilizar espaço reservado anteriormente na sequência."
  remarks: "Deverá passar a <xref:System.IAsyncResult>devolvido pelo método atual para o <xref:System.IO.Log.IRecordSequence.EndFlush%2A>método para se certificar de que o esvaziamento terminar e de recursos são libertados adequadamente.</xref:System.IO.Log.IRecordSequence.EndFlush%2A> </xref:System.IAsyncResult> Se ocorrer um erro durante um esvaziamento assíncrono, não é emitida uma exceção até o <xref:System.IO.Log.IRecordSequence.EndFlush%2A>método for chamado com o <xref:System.IAsyncResult>devolvido por este método.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndFlush%2A>       Chamar este método garante que todos os registos que foi anexado ao <xref:System.IO.Log.IRecordSequence>são escritos de forma durável.</xref:System.IO.Log.IRecordSequence>       Se foi eliminada uma sequência de registo de, ou se obtiver um argumento inválido, as exceções forem emitidas imediatamente dentro esta operação. Erros que ocorreram durante um pedido de libertação assíncrono, por exemplo, uma falha de disco durante o pedido de e/s, irão resultar em exceções a ser geradas quando o <xref:System.IO.Log.IRecordSequence.EndFlush%2A>método é chamado.</xref:System.IO.Log.IRecordSequence.EndFlush%2A>"
  syntax:
    content: public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do registo mais recente que deve ser escrito. Se esta <xref href=&quot;System.IO.Log.SequenceNumber&quot;> </xref> é inválido, em seguida, todos os registos devem ser escritos."
    - id: callback
      type: System.AsyncCallback
      description: "Uma opcional chamada de retorno assíncrona, ser chamado quando a remoção estiver concluída."
    - id: state
      type: System.Object
      description: "Um objeto de fornecidos pelo utilizador que distingue este pedido de libertação assíncrono específico de outros pedidos."
    return:
      type: System.IAsyncResult
      description: "Um <xref:System.IAsyncResult>que representa o assíncrona esvaziar operação, o que pode ainda estar pendentes.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao limpar os dados."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituídas numa classe derivada, começa uma reserva assíncrona e acrescentar a operação."
  remarks: "Deverá passar a <xref:System.IAsyncResult>devolvido por este método para o <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>método para se certificar de que concluiu a operação de acréscimo e de recursos podem ser libertados adequadamente.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> Se tiver ocorrido um erro durante uma acrescentar assíncrona, não é emitida uma exceção até o <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>método for chamado com o <xref:System.IAsyncResult>devolvido por este método.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>       Dados contidos no `data` parâmetro será CONCATENAR para uma matriz de bytes único para acrescentar como o registo. No entanto, nenhum aprovisionar é efetuada para dividir os dados no segmentos de matriz quando o registo de leitura.       As reservas especificadas são adicionadas para a reserva fornecida coleção numa operação atómica com um registo acrescentar a operação. Se a acrescentar falhar, não existe espaço está reservado.       Normalmente, este método pode concluir antes do registo foi escrito. Para se certificar de que foi escrito um registo, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador utilizando o `recordAppendOptions` parâmetro ou chamada de <xref:System.IO.Log.IRecordSequence.Flush%2A>método.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       Se foi eliminada uma sequência de registo de, ou se obtiver um argumento inválido, as exceções forem emitidas imediatamente dentro esta operação. Erros que ocorreram durante um pedido de acréscimo assíncrona, por exemplo, uma falha de disco durante o pedido de e/s, irão resultar em exceções a ser geradas quando o <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>método é chamado.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de utilizador especificado."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica a forma como os dados devem ser escritos."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A coleção de reserva para tornar as reservas no."
    - id: reservations
      type: System.Int64[]
      description: "As reservas para que, em bytes."
    - id: callback
      type: System.AsyncCallback
      description: "Uma opcional chamada de retorno assíncrona, ser chamado quando a acrescentar estiver concluída."
    - id: state
      type: System.Object
      description: "Um objeto fornecidos pelo utilizador que distingue este determinado assíncrona acrescentar pedido a partir de outros pedidos."
    return:
      type: System.IAsyncResult
      description: "Um <xref:System.IAsyncResult>que representa esta operação assíncrona, que foi ainda estar pendente.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao acrescentar o registo."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos não foi possível efetuar o espaço livre suficiente para conter o novo registo de ou para efetuar a reserva."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituídas numa classe derivada, começa uma reserva assíncrona e acrescentar a operação."
  remarks: "Deverá passar a <xref:System.IAsyncResult>devolvido por este método para o <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>método para se certificar de que concluiu a operação de acréscimo e de recursos podem ser libertados adequadamente.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> Se tiver ocorrido um erro durante uma acrescentar assíncrona, não é emitida uma exceção até o <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>método for chamado com o <xref:System.IAsyncResult>devolvido por este método.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>       Dados contidos no `data` parâmetro será CONCATENAR para uma matriz de bytes único para acrescentar como o registo. No entanto, nenhum aprovisionar é efetuada para dividir os dados no segmentos de matriz quando o registo de leitura.       As reservas especificadas são adicionadas para a reserva fornecida coleção numa operação atómica com um registo acrescentar a operação. Se a acrescentar falhar, não existe espaço está reservado.       Normalmente, este método pode concluir antes do registo foi escrito. Para se certificar de que foi escrito um registo, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador utilizando o `recordAppendOptions` parâmetro ou chamada de <xref:System.IO.Log.IRecordSequence.Flush%2A>método.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       Se foi eliminada uma sequência de registo de, ou se obtiver um argumento inválido, as exceções forem emitidas imediatamente dentro esta operação. Erros que ocorreram durante um pedido de acréscimo assíncrona, por exemplo, uma falha de disco durante o pedido de e/s, irão resultar em exceções a ser geradas quando o <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>método é chamado.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de utilizador especificado."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica a forma como os dados devem ser escritos."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A coleção de reserva para tornar as reservas no."
    - id: reservations
      type: System.Int64[]
      description: "As reservas para que, em bytes."
    - id: callback
      type: System.AsyncCallback
      description: "Uma opcional chamada de retorno assíncrona, ser chamado quando a acrescentar estiver concluída."
    - id: state
      type: System.Object
      description: "Um objeto fornecidos pelo utilizador que distingue este determinado assíncrona acrescentar pedido a partir de outros pedidos."
    return:
      type: System.IAsyncResult
      description: "Um <xref:System.IAsyncResult>que representa esta operação assíncrona, que foi ainda estar pendente.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao acrescentar o registo."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos não foi possível efetuar o espaço livre suficiente para conter o novo registo de ou para efetuar a reserva."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, inicia uma operação de escrita de área reinício assíncrona, utilizar espaço reservado anteriormente na sequência."
  remarks: "Deverá passar a <xref:System.IAsyncResult>devolvido por este método para o <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>método, para garantir que a operação de escrita de área de reinício foi concluída e recursos que podem ser libertados adequadamente.</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> Se tiver ocorrido um erro durante uma operação de escrita de área de reinício assíncrona, não é emitida uma exceção até o <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>método for chamado com o <xref:System.IAsyncResult>devolvido por este método.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>       Dados contidos no `data` parâmetro será CONCATENAR para uma matriz de bytes único para acrescentar como o registo. No entanto, nenhum aprovisionar é efetuada para dividir os dados no segmentos de matriz quando o registo de leitura.       Quando a operação for concluída com êxito, o número de sequência base foi atualizado. Todos os registos com números de sequência de menor que o novo número de sequência base não estão acessíveis.       Se um <xref:System.IO.Log.ReservationCollection>for especificado, a área de reinício escrito irá consumir o espaço que foi anteriormente reservado, utilizando uma reserva contida na coleção.</xref:System.IO.Log.ReservationCollection> Se o método for bem sucedida, consumirá a reserva de menor que pode conter os dados e de que a reserva será removida da coleção.       Se foi eliminada uma sequência de registo de, ou se obtiver um argumento inválido, as exceções forem emitidas imediatamente dentro esta operação. Erros que ocorreram durante um pedido de acréscimo assíncrona, por exemplo, uma falha de disco durante o pedido de e/s, irão resultar em exceções a ser geradas quando o <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>método é chamado.</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "O novo número de sequência base. O número sequencial especificado tem de ser maior que ou igual ao número de sequência base atual."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> que contém a reserva que deve ser utilizada para esta área de reinício."
    - id: callback
      type: System.AsyncCallback
      description: "Uma opcional chamada de retorno assíncrona, ser chamado quando a operação de escrita de área de reinício estiver concluída."
    - id: state
      type: System.Object
      description: "Um objeto de fornecidos pelo utilizador que distingue este pedido de escrita de área específica de reinício assíncrona de outros pedidos."
    return:
      type: System.IAsyncResult
      description: "Um <xref:System.IAsyncResult>que representa o assíncrona reiniciar operação de escrita de área, pode ainda estar pendentes.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginWriteRestartArea*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, inicia uma operação de escrita de área reinício assíncrona, utilizar espaço reservado anteriormente na sequência."
  remarks: "Deverá passar a <xref:System.IAsyncResult>devolvido por este método para o <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>método para se certificar de que concluiu a operação de escrita de área de reinício e de recursos podem ser libertados adequadamente.</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> Se tiver ocorrido um erro durante uma operação de escrita de área de reinício assíncrona, não é emitida uma exceção até o <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>método for chamado com o <xref:System.IAsyncResult>devolvido por este método.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>       Dados contidos no `data` parâmetro será CONCATENAR para uma matriz de bytes único para acrescentar como o registo. No entanto, nenhum aprovisionar é efetuada para dividir os dados no segmentos de matriz quando o registo de leitura.       Quando a operação for concluída com êxito, o número de sequência base foi atualizado. Todos os registos com números de sequência de menor que o novo número de sequência base não estão acessíveis.       Se um <xref:System.IO.Log.ReservationCollection>for especificado, a área de reinício escrito irá consumir o espaço que foi anteriormente reservado, utilizando uma reserva contida na coleção.</xref:System.IO.Log.ReservationCollection> Se o método for bem sucedida, consumirá a reserva de menor que pode conter os dados e de que a reserva será removida da coleção.       Se foi eliminada uma sequência de registo de, ou se obtiver um argumento inválido, as exceções forem emitidas imediatamente dentro esta operação. Erros que ocorreram durante um pedido de acréscimo assíncrona, por exemplo, uma falha de disco durante o pedido de e/s, irão resultar em exceções a ser geradas quando o <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>método é chamado.</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "O novo número de sequência base. O número sequencial especificado tem de ser maior que ou igual ao número de sequência base atual."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> que contém a reserva que deve ser utilizada para esta área de reinício."
    - id: callback
      type: System.AsyncCallback
      description: "Uma opcional chamada de retorno assíncrona, ser chamado quando a operação de escrita de área de reinício estiver concluída."
    - id: state
      type: System.Object
      description: "Um objeto de fornecidos pelo utilizador que distingue este pedido de escrita de área específica de reinício assíncrona de outros pedidos."
    return:
      type: System.IAsyncResult
      description: "Um <xref:System.IAsyncResult>que representa o assíncrona reiniciar operação de escrita de área, pode ainda estar pendentes.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao escrever a área de reinício."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos não foi possível efetuar o espaço livre suficiente para conter o novo registo."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.CreateReservationCollection
  id: CreateReservationCollection
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: CreateReservationCollection()
  nameWithType: IRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.IRecordSequence.CreateReservationCollection()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, cria um novo <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>."
  syntax:
    content: public System.IO.Log.ReservationCollection CreateReservationCollection ();
    parameters: []
    return:
      type: System.IO.Log.ReservationCollection
      description: "Criado recentemente <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>."
  overload: System.IO.Log.IRecordSequence.CreateReservationCollection*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)
  id: EndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, termina uma assíncrona acrescentar a operação."
  remarks: "Este método bloqueia enquanto a operação de e/s tiver sido concluída. Erros ocorridos durante um pedido de escrita assíncrona, tais como uma falha de disco durante o pedido de e/s ficam visíveis quando EndAppend é chamado.       Este método tem de ser chamado exatamente uma vez em cada <xref:System.IAsyncResult>devolvido pelo <xref:System.IO.Log.IRecordSequence.BeginAppend%2A>método.</xref:System.IO.Log.IRecordSequence.BeginAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Uma referência para o pedido de e/s assíncrona pendente."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo registo anexado."
  overload: System.IO.Log.IRecordSequence.EndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)
  id: EndFlush(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndFlush(IAsyncResult)
  nameWithType: IRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndFlush(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, termina uma operação assíncrona."
  remarks: "Este método bloqueia enquanto a operação de e/s tiver sido concluída. Erros ocorridos durante um pedido de libertação assíncrono, tais como uma falha de disco durante o pedido de e/s ficam visíveis quando EndFlush é chamado.       Este método tem de ser chamado exatamente uma vez em cada <xref:System.IAsyncResult>devolvido pelo <xref:System.IO.Log.IRecordSequence.BeginFlush%2A>método.</xref:System.IO.Log.IRecordSequence.BeginFlush%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Uma referência para o pedido de e/s assíncrona pendente."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do último registo escrito."
  overload: System.IO.Log.IRecordSequence.EndFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  id: EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndReserveAndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, termina uma assíncrona reserva e acrescentar a operação."
  remarks: "Este método bloqueia enquanto a operação de e/s tiver sido concluída. Erros ocorridos durante um pedido de escrita assíncrona, tais como uma falha de disco durante o pedido de e/s ficam visíveis quando EndReserveAndAppend é chamado.       Este método tem de ser chamado exatamente uma vez em cada <xref:System.IAsyncResult>devolvido pelo <xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A>método.</xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Uma referência para o pedido de e/s assíncrona pendente."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo registo anexado."
  overload: System.IO.Log.IRecordSequence.EndReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  id: EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: IRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndWriteRestartArea(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, termina uma operação de escrita de área de reinício assíncrona."
  remarks: "Este método bloqueia enquanto a operação de e/s tiver sido concluída. Erros ocorridos durante um pedido de escrita assíncrona, tais como uma falha de disco durante o pedido de e/s ficam visíveis quando EndWriteRestartArea é chamado.       Este método tem de ser chamado exatamente uma vez em cada <xref:System.IAsyncResult>devolvido pelo <xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A>método.</xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Uma referência para o pedido de e/s assíncrona pendente."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do registo escrito do registo."
  overload: System.IO.Log.IRecordSequence.EndWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Flush
  id: Flush
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Flush()
  nameWithType: IRecordSequence.Flush()
  fullName: System.IO.Log.IRecordSequence.Flush()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, garante que todos os registos anexados escritos."
  remarks: "Chamar este método garante que todos os registos que foi anexado ao <xref:System.IO.Log.IRecordSequence>escritos forma durável.</xref:System.IO.Log.IRecordSequence>"
  syntax:
    content: public System.IO.Log.SequenceNumber Flush ();
    parameters: []
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do último registo escrito."
  overload: System.IO.Log.IRecordSequence.Flush*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao limpar os dados."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)
  id: Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Flush(SequenceNumber)
  nameWithType: IRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.Flush(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, garante que todos os registos anexados até e incluindo o registo com o número sequencial especificado forma durável escritos."
  remarks: "Chamar que este método garante que todos os registos de sequência de números até e incluindo o número sequencial especificado forma durável escritos."
  syntax:
    content: public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do registo mais recente que deve ser escrito. Se esta <xref href=&quot;System.IO.Log.SequenceNumber&quot;> </xref> é inválido, em seguida, todos os registos devem ser escritos."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do último registo escrito."
  overload: System.IO.Log.IRecordSequence.Flush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao limpar os dados."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.LastSequenceNumber
  id: LastSequenceNumber
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: LastSequenceNumber
  nameWithType: IRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.IRecordSequence.LastSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, obtém o número de sequência que é maior do que o último registo anexado."
  remarks: "Esta propriedade contém um número de sequência é assegurado para ser maior do que o número de sequência do último anexado registo. Números de sequência válido são maior que ou igual a <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>e inferior ao LastSequenceNumber.</xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>      > [!NOTE] > Quando utilizar uma <xref:System.IO.Log.LogRecordSequence>instância, o <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>valor pode tornar-se Desatualizadas até que os registos são libertados no registo.</xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A> </xref:System.IO.Log.LogRecordSequence> Ver <xref:System.IO.Log.IRecordSequence.Flush%2A>e <xref:System.IO.Log.RecordAppendOptions>para obter mais informações sobre como limpar registos..</xref:System.IO.Log.RecordAppendOptions> </xref:System.IO.Log.IRecordSequence.Flush%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber LastSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "Número de uma sequência que é maior do que o último registo anexado."
  overload: System.IO.Log.IRecordSequence.LastSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A propriedade foi acedida depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.MaximumRecordLength
  id: MaximumRecordLength
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: MaximumRecordLength
  nameWithType: IRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.IRecordSequence.MaximumRecordLength
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, obtém o tamanho do registo maior que pode ser anexado a ou lida esta sequência, em bytes."
  syntax:
    content: public long MaximumRecordLength { get; }
    return:
      type: System.Int64
      description: "O tamanho do registo de maior que pode ser anexado a ou lida esta sequência, em bytes."
  overload: System.IO.Log.IRecordSequence.MaximumRecordLength*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A propriedade foi acedida depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  id: ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, devolve uma coleção enumeráveis de registos na sequência."
  remarks: "Quando substituí-lo de uma classe derivada, devolve uma coleção enumeráveis de registos na sequência. A ordem dos registos enumerados depende do valor da `logRecordEnum` parâmetro."
  example:
  - "This sample demonstrates the use of the ReadLogRecords method.  \n  \n```c#  \nusing System;  \n using System.IO;  \n using System.IO.Log;  \n  \n class ReadRecordsSample  \n {  \n     static SequenceNumber AppendRecord(IRecordSequence sequence,  \n                                        string message,  \n                                        SequenceNumber user,  \n                                        SequenceNumber previous)  \n     {  \n         MemoryStream data = new MemoryStream();  \n         BinaryWriter writer = new BinaryWriter(data);  \n         writer.Write(message);  \n  \n         ArraySegment<byte>[] segments;  \n         segments = new ArraySegment<byte>[1];  \n         segments[0] = new ArraySegment(data.GetBuffer(),  \n                                        0,  \n                                        Data.Length);  \n  \n         return sequence.Append(segments,  \n                                user,  \n                                previous,  \n                                WriteFlags.None);  \n     }  \n  \n     public static void Main(string[] args)  \n     {  \n         IRecordSequence sequence;  \n         sequence = new FileIRecordSequence(args[0]);  \n  \n         SequenceNumber a, b, c, d;  \n  \n         a = AppendRecord(sequence,  \n                          \"This is record A\",  \n                          SequenceNumber.Invalid,  \n                          SequenceNumber.Invalid);  \n         Console.WriteLine(\"Record A has sequence number System.IO.Log\", a);  \n  \n         b = AppendRecord(sequence,  \n                          \"This is record B\",  \n                          a,  \n                          a);  \n         Console.WriteLine(\"Record B has sequence number System.IO.Log\", b);  \n  \n         c = AppendRecord(sequence,  \n                          \"This is record C\",  \n                          a,  \n                          a);  \n         Console.WriteLine(\"Record C has sequence number System.IO.Log\", c);  \n  \n         d = AppendRecord(sequence,  \n                          \"This is record D\",  \n                          b,  \n                          c);  \n         Console.WriteLine(\"Record D has sequence number System.IO.Log\", d);  \n  \n         foreach(LogRecord record in  \n                 sequence.ReadLogRecords(a, ReadDirection.Forward))  \n         {  \n             BinaryReader reader = new BinaryReader(record.Data);  \n             Console.WriteLine(\"System.IO.Log: T:System.IO.Log.IRecordSequence\",  \n                               record.SequenceNumber,  \n                               reader.ReadString());  \n         }  \n  \n         foreach(LogRecord record in  \n                 sequence.ReadLogRecords(d, ReadDirection.User))  \n         {  \n             BinaryReader reader = new BinaryReader(record.Data);  \n             Console.WriteLine(\"System.IO.Log: T:System.IO.Log.IRecordSequence\",  \n                               record.SequenceNumber,  \n                               reader.ReadString());  \n         }  \n  \n         foreach(LogRecord record in  \n                 sequence.ReadLogRecords(d, ReadDirection.Previous))  \n         {  \n             BinaryReader reader = new BinaryReader(record.Data);  \n             Console.WriteLine(\"System.IO.Log: T:System.IO.Log.IRecordSequence\",  \n                               record.SequenceNumber,  \n                               reader.ReadString());  \n         }  \n     }  \n       }  \n```"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);
    parameters:
    - id: start
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do registo primeiro onde começa a leitura."
    - id: logRecordEnum
      type: System.IO.Log.LogRecordEnumeratorType
      description: "Um <xref href=&quot;System.IO.Log.LogRecordEnumeratorType&quot;> </xref> valor que especifica a forma (ou seja, reencaminhar ou trás) em que regista deve ser lida a partir de um <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>."
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "Uma coleção enumeráveis de registos na sequência."
  overload: System.IO.Log.IRecordSequence.ReadLogRecords*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao ler o registo."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReadRestartAreas
  id: ReadRestartAreas
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReadRestartAreas()
  nameWithType: IRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.IRecordSequence.ReadRestartAreas()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, devolve uma coleção de áreas de reinício enumeráveis na sequência."
  remarks: "As áreas de reinício são enumeradas na ordem de número de sequência inversa, ou seja, do número de sequência maior para o menor número de sequência. Reinicie apenas áreas com números de sequência entre o último número de sequência e o número de sequência base são enumerados.      > [!NOTE] > Se a extensão de registo que contém o <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>torna-se danificado, este método pode acionar um <xref:System.IO.IOException>com a mensagem de erro &quot;não foi possível efetuar o pedido devido a uma exceção de e/s inesperada.</xref:System.IO.IOException> </xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> Foi devolvido o seguinte código de erro: &quot;80070026&quot; &quot;."
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadRestartAreas ();
    parameters: []
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "Uma coleção enumeráveis de áreas de reinício na sequência."
  overload: System.IO.Log.IRecordSequence.ReadRestartAreas*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao ler o registo."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, faz com que um único reserva e automaticamente acrescenta um registo para a sequência."
  remarks: "Dados contidos no `data` parâmetro será CONCATENAR para uma matriz de bytes único para acrescentar como o registo. No entanto, nenhum aprovisionar é efetuada para dividir os dados no segmentos de matriz quando o registo de leitura.       As reservas especificadas são adicionadas para a reserva fornecida coleção numa operação atómica com um registo acrescentar a operação. Se a acrescentar falhar, não existe espaço está reservado.       Normalmente, este método pode concluir antes do registo foi escrito. Para se certificar de que foi escrito um registo, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador utilizando o `recordAppendOptions` parâmetro ou chamada de <xref:System.IO.Log.IRecordSequence.Flush%2A>método.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de utilizador especificado."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica a forma como os dados devem ser escritos."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> que contém a coleção para tornar as reservas no."
    - id: reservations
      type: System.Int64[]
      description: "As reservas para que, em bytes."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo registo anexado."
  overload: System.IO.Log.IRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao acrescentar o registo."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos não foi possível efetuar o espaço livre suficiente para conter o novo registo de ou para efetuar a reserva."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, faz com que um único reserva e automaticamente acrescenta um registo para a sequência."
  remarks: "Dados contidos no `data` parâmetro será CONCATENAR para uma matriz de bytes único para acrescentar como o registo. No entanto, nenhum aprovisionar é efetuada para dividir os dados no segmentos de matriz quando o registo de leitura.       As reservas especificadas são adicionadas para a reserva fornecida coleção numa operação atómica com um registo acrescentar a operação. Se a acrescentar falhar, não existe espaço está reservado.       Normalmente, este método pode concluir antes do registo foi escrito. Para se certificar de que foi escrito um registo, especifique o <xref:System.IO.Log.RecordAppendOptions>sinalizador utilizando o `recordAppendOptions` parâmetro ou chamada de <xref:System.IO.Log.IRecordSequence.Flush%2A>método.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de utilizador especificado."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte na ordem de anterior."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Um valor válido de <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> que especifica a forma como os dados devem ser escritos."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A coleção de reserva para tornar as reservas no."
    - id: reservations
      type: System.Int64[]
      description: "As reservas para que, em bytes."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo registo anexado."
  overload: System.IO.Log.IRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao acrescentar o registo."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos não foi possível efetuar o espaço livre suficiente para conter o novo registo de ou para efetuar a reserva."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReservedBytes
  id: ReservedBytes
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReservedBytes
  nameWithType: IRecordSequence.ReservedBytes
  fullName: System.IO.Log.IRecordSequence.ReservedBytes
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, obtém o número total de bytes que tenham sido reservado."
  syntax:
    content: public long ReservedBytes { get; }
    return:
      type: System.Int64
      description: "O tamanho total de todas as reservas efetuadas nesta sequência de registo."
  overload: System.IO.Log.IRecordSequence.ReservedBytes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A propriedade foi acedida depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.RestartSequenceNumber
  id: RestartSequenceNumber
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: RestartSequenceNumber
  nameWithType: IRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.IRecordSequence.RestartSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, obtém o número de sequência da área do reinício escrito mais recentemente."
  remarks: "Uma área de reinício é utilizada para armazenar temporariamente as informações que contém a última operação de ponto de verificação do cliente. Quando for necessária uma recuperação, pode analisar a área de reinício para obter todos os dados a última operação de ponto de verificação. Estes dados inicializa a tabela de transação, a tabela de páginas com falhas e a tabela de ficheiro aberto para que possam ser utilizados no processo de recuperação."
  syntax:
    content: public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de mais recentemente gravadas reiniciar área."
  overload: System.IO.Log.IRecordSequence.RestartSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A propriedade foi acedida depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.RetryAppend
  id: RetryAppend
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: RetryAppend
  nameWithType: IRecordSequence.RetryAppend
  fullName: System.IO.Log.IRecordSequence.RetryAppend
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Obtém ou define um valor que indica se acrescenta automaticamente tentada novamente se o registo está cheio."
  remarks: "Se o valor desta propriedade é `true`e um <xref:System.IO.Log.IRecordSequence.Append%2A>chamada falha porque não existe espaço suficiente na sequência, a sequência de registos irá tentar efetuar a espaço livre e repita a acrescentar.</xref:System.IO.Log.IRecordSequence.Append%2A>"
  syntax:
    content: public bool RetryAppend { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>se acrescenta automaticamente tentada novamente se o registo está cheio; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. A predefinição é <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.Log.IRecordSequence.RetryAppend*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A propriedade foi acedida depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.TailPinned
  id: TailPinned
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: TailPinned
  nameWithType: IRecordSequence.TailPinned
  fullName: System.IO.Log.IRecordSequence.TailPinned
  type: Event
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Ocorre quando a sequência de registo determina que a cauda têm de ser movida de reencaminhar."
  remarks: "Pode acionados este evento quando a sequência de registos ficou sem espaço. Quando este evento é desencadeado, seguimento da sequência (ou seja, o número de sequência base) é movido reencaminhar para libertar espaço."
  syntax:
    content: public event EventHandler<System.IO.Log.TailPinnedEventArgs> TailPinned;
    return:
      type: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  id: WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, escreve uma área de reinício para a <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  remarks: "Uma área de reinício é utilizada para armazenar temporariamente as informações que contém a última operação de ponto de verificação do cliente. O sistema de ficheiro de registo (CLFS) comuns mantém que reiniciar duas áreas para garantir que, pelo menos, uma área válida está sempre disponível. Quando for necessária uma recuperação, o CLFS lê respectiva área de reinício e todos os dados a partir a última operação de ponto de verificação. Estes dados inicializa a tabela de transação, a tabela de páginas com falhas e a tabela de ficheiro aberto para que possam ser utilizados no processo de recuperação.       Uma área de reinício pode ser lidos utilizando o <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>método.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       Os dados nos segmentos de matriz de bytes serão CONCATENAR para uma matriz de bytes único para acrescentar como o registo. Não existem aprovisionar é efetuada para dividir os dados no segmentos de matriz ao ler a área de reinício."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de escrita de reiniciar área."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao escrever a área de reinício."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos não foi possível efetuar o espaço livre suficiente para conter a nova área de reinício."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, escreve uma área de reinício para a <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  remarks: "Uma área de reinício é utilizada para armazenar temporariamente as informações que contém a última operação de ponto de verificação do cliente. Quando for necessária uma recuperação, pode analisar a área de reinício para obter todos os dados a última operação de ponto de verificação. Estes dados inicializa a tabela de transação, a tabela de páginas com falhas e a tabela de ficheiro aberto para que possam ser utilizados no processo de recuperação. Uma área de reinício pode ser lidos utilizando o <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>método.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       Os dados nos segmentos de matriz de bytes serão CONCATENAR para uma matriz de bytes único para acrescentar como o registo. Não existem aprovisionar é efetuada para dividir os dados no segmentos de matriz ao ler a área de reinício."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de escrita de reiniciar área."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao escrever a área de reinício."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos não foi possível efetuar o espaço livre suficiente para conter a nova área de reinício."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, escreve uma área de reinício para a <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref> e atualiza o número de sequência base"
  remarks: "Uma área de reinício é utilizada para armazenar temporariamente as informações que contém a última operação de ponto de verificação do cliente. Quando for necessária uma recuperação, pode analisar a área de reinício para obter todos os dados a última operação de ponto de verificação. Estes dados inicializa a tabela de transação, a tabela de páginas com falhas e a tabela de ficheiro aberto para que possam ser utilizados no processo de recuperação. Uma área de reinício pode ser lidos utilizando o <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>método.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       Quando uma área de reinício é escrito na, os dados nos segmentos de matriz de bytes são concatenados para uma matriz de bytes único para acrescentar como o registo. Não existem aprovisionar é efetuada para dividir os dados no segmentos de matriz ao ler a área de reinício.       Quando concluir com êxito este método, o número de sequência base foi atualizado. Todos os registos com números de sequência de menor que o novo número de sequência base não estão acessíveis."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "O novo número de sequência base. O número sequencial especificado tem de ser maior que ou igual ao número de sequência base atual."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de escrita de reiniciar área."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao escrever a área de reinício."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos não foi possível efetuar o espaço livre suficiente para conter a nova área de reinício."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, escreve uma área de reinício para a <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref> e atualiza o número de sequência base."
  remarks: "Uma área de reinício é utilizada para armazenar temporariamente as informações que contém a última operação de ponto de verificação do cliente. Quando for necessária uma recuperação, pode analisar a área de reinício para obter todos os dados a última operação de ponto de verificação. Estes dados inicializa a tabela de transação, a tabela de páginas com falhas e a tabela de ficheiro aberto para que possam ser utilizados no processo de recuperação. Uma área de reinício pode ser lidos utilizando o <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>método.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       Quando uma área de reinício é escrito na, os dados nos segmentos de matriz de bytes são concatenados para uma matriz de bytes único para acrescentar como o registo. Não existem aprovisionar é efetuada para dividir os dados no segmentos de matriz ao ler a área de reinício.       Quando concluir com êxito este método, o número de sequência base foi atualizado. Todos os registos com números de sequência de menor que o novo número de sequência base não estão acessíveis."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "O novo número de sequência base. O número sequencial especificado tem de ser maior que ou igual ao número de sequência base atual."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de escrita de reiniciar área."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao escrever a área de reinício."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos não foi possível efetuar o espaço livre suficiente para conter a nova área de reinício."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, escreve uma área de reinício para a <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref> utilizando uma reserva de e atualiza o número de sequência base"
  remarks: "Uma área de reinício é utilizada para armazenar temporariamente as informações que contém a última operação de ponto de verificação do cliente. Quando for necessária uma recuperação, pode analisar a área de reinício para obter todos os dados a última operação de ponto de verificação. Estes dados inicializa a tabela de transação, a tabela de páginas com falhas e a tabela de ficheiro aberto para que possam ser utilizados no processo de recuperação. Uma área de reinício pode ser lidos utilizando o <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>método.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       Quando uma área de reinício é escrito na, os dados nos segmentos de matriz de bytes são concatenados para uma matriz de bytes único para acrescentar como o registo. Não existem aprovisionar é efetuada para dividir os dados no segmentos de matriz ao ler a área de reinício.       Se não for especificada uma reserva, a área de reinício escrito irá consumir espaço que foi anteriormente reservado, utilizando uma reserva contida na coleção. Se o método for bem sucedida, consumirá a reserva de menor que pode conter os dados e de que a reserva será removida da coleção.       Quando concluir com êxito este método, o número de sequência base foi atualizado. Todos os registos com números de sequência de menor que o novo número de sequência base não estão acessíveis.       Se foi eliminada uma sequência de registo de, ou se obtiver um argumento inválido, as exceções forem emitidas imediatamente dentro esta operação. Erros que ocorreram durante um pedido de acréscimo assíncrona, por exemplo, uma falha de disco durante o pedido de e/s, irão resultar em exceções a ser geradas quando o <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>método é chamado.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "O novo número de sequência base. O número sequencial especificado tem de ser maior que ou igual ao número de sequência base atual."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> que contém a reserva que deve ser utilizada para esta área de reinício."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de escrita de reiniciar área."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao escrever a área de reinício."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos não foi possível efetuar o espaço livre suficiente para conter a nova área de reinício."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, escreve uma área de reinício para a <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref> utilizando uma reserva de e atualiza o número de sequência base."
  remarks: "Uma área de reinício é utilizada para armazenar temporariamente as informações que contém a última operação de ponto de verificação do cliente. Quando for necessária uma recuperação, pode analisar a área de reinício para obter todos os dados a última operação de ponto de verificação. Estes dados inicializa a tabela de transação, a tabela de páginas com falhas e a tabela de ficheiro aberto para que possam ser utilizados no processo de recuperação. Uma área de reinício pode ser lidos utilizando o <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>método.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       Quando uma área de reinício é escrito na, os dados nos segmentos de matriz de bytes são concatenados para uma matriz de bytes único para acrescentar como o registo. Não existem aprovisionar é efetuada para dividir os dados no segmentos de matriz ao ler a área de reinício.       Se não for especificada uma reserva, a área de reinício escrito irá consumir espaço que foi anteriormente reservado, utilizando uma reserva contida na coleção. Se o método for bem sucedida, consumirá a reserva de menor que pode conter os dados e de que a reserva será removida da coleção.       Quando concluir com êxito este método, o número de sequência base foi atualizado. Todos os registos com números de sequência de menor que o novo número de sequência base não estão acessíveis.       Se foi eliminada uma sequência de registo de, ou se obtiver um argumento inválido, as exceções forem emitidas imediatamente dentro esta operação. Erros que ocorreram durante um pedido de acréscimo assíncrona, por exemplo, uma falha de disco durante o pedido de e/s, irão resultar em exceções a ser geradas quando o <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>método é chamado.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Uma lista de segmentos de matriz de bytes que será concatenado e acrescentado como o registo."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "O novo número de sequência base. O número sequencial especificado tem de ser maior que ou igual ao número de sequência base atual."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> que contém a reserva que deve ser utilizada para esta área de reinício."
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de escrita de reiniciar área."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um ou mais dos argumentos são inválido."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorreu um erro de e/s ao escrever a área de reinício."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos não foi possível efetuar o espaço livre suficiente para conter a nova área de reinício."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
references:
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IO.Log.SequenceFullException
  parent: System.IO.Log
  isExternal: false
  name: SequenceFullException
  nameWithType: SequenceFullException
  fullName: System.IO.Log.SequenceFullException
- uid: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
- uid: System.IO.Log.SequenceNumber
  parent: System.IO.Log
  isExternal: false
  name: SequenceNumber
  nameWithType: SequenceNumber
  fullName: System.IO.Log.SequenceNumber
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.ArraySegment{System.Byte}
  parent: System
  isExternal: true
  name: ArraySegment<Byte>
  nameWithType: ArraySegment<Byte>
  fullName: System.ArraySegment<System.Byte>
  spec.csharp:
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.RecordAppendOptions
  parent: System.IO.Log
  isExternal: false
  name: RecordAppendOptions
  nameWithType: RecordAppendOptions
  fullName: System.IO.Log.RecordAppendOptions
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
  parent: System.Collections.Generic
  isExternal: true
  name: IList<ArraySegment<Byte>>
  nameWithType: IList<ArraySegment<Byte>>
  fullName: System.Collections.Generic.IList<System.ArraySegment<System.Byte>>
  spec.csharp:
  - uid: System.Collections.Generic.IList`1
    name: IList
    nameWithType: IList
    fullName: IList<System.ArraySegment<System.Byte>>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.ReservationCollection
  parent: System.IO.Log
  isExternal: false
  name: ReservationCollection
  nameWithType: ReservationCollection
  fullName: System.IO.Log.ReservationCollection
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.IRecordSequence.BaseSequenceNumber
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: IRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.IRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.Int64[]
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64[]
  spec.csharp:
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: Int64[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.CreateReservationCollection
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: CreateReservationCollection()
  nameWithType: IRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.IRecordSequence.CreateReservationCollection()
- uid: System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndAppend(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndFlush(IAsyncResult)
  nameWithType: IRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndFlush(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndReserveAndAppend(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: IRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndWriteRestartArea(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.Flush
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Flush()
  nameWithType: IRecordSequence.Flush()
  fullName: System.IO.Log.IRecordSequence.Flush()
- uid: System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Flush(SequenceNumber)
  nameWithType: IRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.Flush(SequenceNumber)
- uid: System.IO.Log.IRecordSequence.LastSequenceNumber
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: IRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.IRecordSequence.LastSequenceNumber
- uid: System.IO.Log.IRecordSequence.MaximumRecordLength
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: IRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.IRecordSequence.MaximumRecordLength
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
- uid: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<LogRecord>
  nameWithType: IEnumerable<LogRecord>
  fullName: System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.IO.Log.LogRecord>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.LogRecord
    name: LogRecord
    nameWithType: LogRecord
    fullName: LogRecord
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordEnumeratorType
  parent: System.IO.Log
  isExternal: false
  name: LogRecordEnumeratorType
  nameWithType: LogRecordEnumeratorType
  fullName: System.IO.Log.LogRecordEnumeratorType
- uid: System.IO.Log.IRecordSequence.ReadRestartAreas
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadRestartAreas()
  nameWithType: IRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.IRecordSequence.ReadRestartAreas()
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.IRecordSequence.ReservedBytes
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: IRecordSequence.ReservedBytes
  fullName: System.IO.Log.IRecordSequence.ReservedBytes
- uid: System.IO.Log.IRecordSequence.RestartSequenceNumber
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: IRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.IRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.IRecordSequence.RetryAppend
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: IRecordSequence.RetryAppend
  fullName: System.IO.Log.IRecordSequence.RetryAppend
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.Log.IRecordSequence.TailPinned
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: TailPinned
  nameWithType: IRecordSequence.TailPinned
  fullName: System.IO.Log.IRecordSequence.TailPinned
- uid: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<TailPinnedEventArgs>
  nameWithType: EventHandler<TailPinnedEventArgs>
  fullName: System.EventHandler<System.IO.Log.TailPinnedEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.IO.Log.TailPinnedEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.TailPinnedEventArgs
    name: TailPinnedEventArgs
    nameWithType: TailPinnedEventArgs
    fullName: TailPinnedEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber
  nameWithType: IRecordSequence.AdvanceBaseSequenceNumber
- uid: System.IO.Log.IRecordSequence.Append*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append
  nameWithType: IRecordSequence.Append
- uid: System.IO.Log.IRecordSequence.BaseSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: IRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.IRecordSequence.BeginAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend
  nameWithType: IRecordSequence.BeginAppend
- uid: System.IO.Log.IRecordSequence.BeginFlush*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginFlush
  nameWithType: IRecordSequence.BeginFlush
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginReserveAndAppend
  nameWithType: IRecordSequence.BeginReserveAndAppend
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginWriteRestartArea
  nameWithType: IRecordSequence.BeginWriteRestartArea
- uid: System.IO.Log.IRecordSequence.CreateReservationCollection*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: CreateReservationCollection
  nameWithType: IRecordSequence.CreateReservationCollection
- uid: System.IO.Log.IRecordSequence.EndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndAppend
  nameWithType: IRecordSequence.EndAppend
- uid: System.IO.Log.IRecordSequence.EndFlush*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndFlush
  nameWithType: IRecordSequence.EndFlush
- uid: System.IO.Log.IRecordSequence.EndReserveAndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndReserveAndAppend
  nameWithType: IRecordSequence.EndReserveAndAppend
- uid: System.IO.Log.IRecordSequence.EndWriteRestartArea*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndWriteRestartArea
  nameWithType: IRecordSequence.EndWriteRestartArea
- uid: System.IO.Log.IRecordSequence.Flush*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Flush
  nameWithType: IRecordSequence.Flush
- uid: System.IO.Log.IRecordSequence.LastSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: IRecordSequence.LastSequenceNumber
- uid: System.IO.Log.IRecordSequence.MaximumRecordLength*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: IRecordSequence.MaximumRecordLength
- uid: System.IO.Log.IRecordSequence.ReadLogRecords*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadLogRecords
  nameWithType: IRecordSequence.ReadLogRecords
- uid: System.IO.Log.IRecordSequence.ReadRestartAreas*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadRestartAreas
  nameWithType: IRecordSequence.ReadRestartAreas
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReserveAndAppend
  nameWithType: IRecordSequence.ReserveAndAppend
- uid: System.IO.Log.IRecordSequence.ReservedBytes*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: IRecordSequence.ReservedBytes
- uid: System.IO.Log.IRecordSequence.RestartSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: IRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.IRecordSequence.RetryAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: IRecordSequence.RetryAppend
- uid: System.IO.Log.IRecordSequence.WriteRestartArea*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea
  nameWithType: IRecordSequence.WriteRestartArea
