### YamlMime:ManagedReference
items:
- uid: System.Threading.Thread
  id: Thread
  children:
  - System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)
  - System.Threading.Thread.#ctor(System.Threading.ThreadStart)
  - System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)
  - System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)
  - System.Threading.Thread.Abort
  - System.Threading.Thread.Abort(System.Object)
  - System.Threading.Thread.AllocateDataSlot
  - System.Threading.Thread.AllocateNamedDataSlot(System.String)
  - System.Threading.Thread.ApartmentState
  - System.Threading.Thread.BeginCriticalRegion
  - System.Threading.Thread.BeginThreadAffinity
  - System.Threading.Thread.CurrentContext
  - System.Threading.Thread.CurrentCulture
  - System.Threading.Thread.CurrentPrincipal
  - System.Threading.Thread.CurrentThread
  - System.Threading.Thread.CurrentUICulture
  - System.Threading.Thread.DisableComObjectEagerCleanup
  - System.Threading.Thread.EndCriticalRegion
  - System.Threading.Thread.EndThreadAffinity
  - System.Threading.Thread.ExecutionContext
  - System.Threading.Thread.Finalize
  - System.Threading.Thread.FreeNamedDataSlot(System.String)
  - System.Threading.Thread.GetApartmentState
  - System.Threading.Thread.GetCompressedStack
  - System.Threading.Thread.GetData(System.LocalDataStoreSlot)
  - System.Threading.Thread.GetDomain
  - System.Threading.Thread.GetDomainID
  - System.Threading.Thread.GetHashCode
  - System.Threading.Thread.GetNamedDataSlot(System.String)
  - System.Threading.Thread.Interrupt
  - System.Threading.Thread.IsAlive
  - System.Threading.Thread.IsBackground
  - System.Threading.Thread.IsThreadPoolThread
  - System.Threading.Thread.Join
  - System.Threading.Thread.Join(System.Int32)
  - System.Threading.Thread.Join(System.TimeSpan)
  - System.Threading.Thread.ManagedThreadId
  - System.Threading.Thread.MemoryBarrier
  - System.Threading.Thread.Name
  - System.Threading.Thread.Priority
  - System.Threading.Thread.ResetAbort
  - System.Threading.Thread.Resume
  - System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)
  - System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)
  - System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)
  - System.Threading.Thread.Sleep(System.Int32)
  - System.Threading.Thread.Sleep(System.TimeSpan)
  - System.Threading.Thread.SpinWait(System.Int32)
  - System.Threading.Thread.Start
  - System.Threading.Thread.Start(System.Object)
  - System.Threading.Thread.Suspend
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  - System.Threading.Thread.ThreadState
  - System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)
  - System.Threading.Thread.VolatileRead(System.Byte@)
  - System.Threading.Thread.VolatileRead(System.Double@)
  - System.Threading.Thread.VolatileRead(System.Int16@)
  - System.Threading.Thread.VolatileRead(System.Int32@)
  - System.Threading.Thread.VolatileRead(System.Int64@)
  - System.Threading.Thread.VolatileRead(System.IntPtr@)
  - System.Threading.Thread.VolatileRead(System.Object@)
  - System.Threading.Thread.VolatileRead(System.SByte@)
  - System.Threading.Thread.VolatileRead(System.Single@)
  - System.Threading.Thread.VolatileRead(System.UInt16@)
  - System.Threading.Thread.VolatileRead(System.UInt32@)
  - System.Threading.Thread.VolatileRead(System.UInt64@)
  - System.Threading.Thread.VolatileRead(System.UIntPtr@)
  - System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)
  - System.Threading.Thread.VolatileWrite(System.Double@,System.Double)
  - System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)
  - System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)
  - System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)
  - System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)
  - System.Threading.Thread.VolatileWrite(System.Object@,System.Object)
  - System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)
  - System.Threading.Thread.VolatileWrite(System.Single@,System.Single)
  - System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)
  - System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)
  - System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)
  - System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)
  - System.Threading.Thread.Yield
  langs:
  - csharp
  name: Thread
  nameWithType: Thread
  fullName: System.Threading.Thread
  type: Class
  summary: "Cria e controla um thread, define a prioridade e obtém o respetivo estado."
  remarks: "Quando um processo é iniciado, o tempo de execução de idioma comum cria automaticamente um thread único em primeiro plano para executar código da aplicação. Juntamente com este thread de primeiro plano principal, um processo pode criar um ou mais threads para executar uma parte do código do programa associado ao processo. Estes threads podem ser executado em primeiro plano ou em segundo plano. Além disso, pode utilizar o <xref:System.Threading.ThreadPool>classe para executar código em threads de trabalho que são geridos pelo tempo de execução de idioma comum.</xref:System.Threading.ThreadPool>       Nesta secção [iniciar um thread](#Starting)[objectos de Thread obter](#Retrieving)[threads de primeiro plano e fundo](#Foreground)[cultura e threads](#Culture)[obter informações sobre e controlar threads](#Properties)[aceder ao código de origem para a classe de Thread](#Source) <a name=&quot;Starting&quot;> </a> # # iniciar um thread iniciar um thread, fornecendo um delegado que representa o método o thread está a executar o construtor de classe.                                Em seguida, chame o <xref:System.Threading.Thread.Start%2A>método para iniciar a execução.</xref:System.Threading.Thread.Start%2A>       Os construtores de Thread podem demorar um dos tipos de delegado dois, dependendo se pode transmitir um argumento para o método para ser executada:-se o método tem sem argumentos, transmita um <xref:System.Threading.ThreadStart>Delegar a este construtor.</xref:System.Threading.ThreadStart> Tem a assinatura: ```c#       public delegate void ThreadStart()       ``` ```vb       Public Delegate Sub ThreadStart()       ``` o exemplo seguinte cria e inicia um thread que executa o `ExecuteInForeground` método.           O método apresenta informações sobre algumas propriedades de thread, em seguida, executa um ciclo na qual interrompe para meio segundo e apresenta o número de segundos decorrido. Quando o thread foi executada para, pelo menos, cinco segundos, as extremidades de ciclo e o thread de termina a execução.           [!code-cs[System.Threading.Thread#1](~/add/codesnippet/csharp/t-system.threading.thread_1.cs)][!code-vb[System.Threading.Thread#1](~/add/codesnippet/visualbasic/t-system.threading.thread_1.vb) ] -se o método tem um argumento, transmita um <xref:System.Threading.ParameterizedThreadStart>Delegar a este construtor.</xref:System.Threading.ParameterizedThreadStart>       Tem a assinatura: ```c#       public delegate void ParameterizedThreadStart(object obj)       ``` ```vb       Public Delegate Sub ParameterizedThreadStart(obj As Object)       ``` o método executado pelo delegado do, em seguida, pode converter (em c#) ou converta (em Visual Basic) o parâmetro do tipo adequado.                     O exemplo seguinte é idêntico à anterior, exceto que chama o <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>construtor.</xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> Esta versão do `ExecuteInForeground` método tem um único parâmetro que representa o número aproximado de milissegundos no ciclo de consiste em executar.           [!code-cs[System.Threading.Thread#2](~/add/codesnippet/csharp/t-system.threading.thread_2.cs)][!code-vb[System.Threading.Thread#2](~/add/codesnippet/visualbasic/t-system.threading.thread_2.vb) ] não é necessário manter uma referência a um objecto de Thread depois de iniciar o thread.       O thread continua a executar até o procedimento de thread está concluído.      <a name=&quot;Retrieving&quot;></a># # Obter Thread objetos que pode utilizar o estático (`Shared` no Visual Basic) <xref:System.Threading.Thread.CurrentThread%2A>propriedade para obter uma referência para o thread atualmente em execução a partir do código que está a executar o thread.</xref:System.Threading.Thread.CurrentThread%2A> O exemplo seguinte utiliza o <xref:System.Threading.Thread.CurrentThread%2A>propriedade para apresentar informações sobre o thread de aplicação principal, outro thread de primeiro plano, um thread de segundo plano e um thread de conjunto de threads.</xref:System.Threading.Thread.CurrentThread%2A>       [!code-cs[System.Threading.Thread#4](~/add/codesnippet/csharp/t-system.threading.thread_3.cs)][!code-vb[System.Threading.Thread#4](~/add/codesnippet/visualbasic/t-system.threading.thread_3.vb) ] <a name=&quot;Foreground&quot;> </a> # # threads de primeiro plano e fundo instâncias da classe Thread representam os threads de primeiro plano ou threads em segundo plano.         Threads em segundo plano são idênticos aos threads de primeiro plano com uma exceção: um thread de segundo plano não manter a execução de um processo se todos os threads de primeiro plano foi terminado. Depois de todos os threads de primeiro plano foram parados, o tempo de execução deixa de todos os threads em segundo plano e será encerrado.       Por predefinição, os threads seguintes executar em primeiro plano:-o thread principal da aplicação.      -Todos os threads criados chamando um construtor de classe do Thread.       Os seguintes threads executados em segundo plano, por predefinição:-threads de agrupamento, que são um conjunto de threads de trabalho mantida pelo tempo de execução do Thread.  Pode configurar o trabalho de agrupamento e o agendamento de threads em threads de conjunto de threads, utilizando a <xref:System.Threading.ThreadPool>classe.</xref:System.Threading.ThreadPool>          > [!NOTE] > Baseado em tarefas operações assíncronas executar automaticamente em threads de conjunto de threads. Utilizam operações assíncronas baseado em tarefas a <xref:System.Threading.Tasks.Task>e <xref:System.Threading.Tasks.Task%601>classes para implementar o [padrão assíncrono baseado em tarefas](~/add/includes/ajax-current-ext-md.md).</xref:System.Threading.Tasks.Task%601> </xref:System.Threading.Tasks.Task>      -Todos os threads que introduzir o ambiente de execução gerido a partir do código não gerido.       Pode alterar um thread para executar em segundo plano, definindo o <xref:System.Threading.Thread.IsBackground%2A>propriedade em qualquer altura.</xref:System.Threading.Thread.IsBackground%2A>  Threads em segundo plano são úteis para todas as operações eventualmente devem continuar enquanto uma aplicação está em execução, mas não deve impedir que a aplicação de terminar, tais como a monitorização de alterações de sistema de ficheiros ou as ligações recebidas do socket.       O exemplo seguinte ilustra a diferença entre threads primeiro e segundo plano. É semelhante ao exemplo no primeiro o [iniciar um thread](#Starting) secção, exceto que define o thread para ser executado em segundo plano antes de iniciá-lo. Como mostra a saída, o ciclo for interrompido antes de ser executada para cinco segundos.       [!code-cs[System.Threading.Thread#3](~/add/codesnippet/csharp/t-system.threading.thread_4.cs)][!code-vb[System.Threading.Thread#3](~/add/codesnippet/visualbasic/t-system.threading.thread_4.vb) ] <a name=&quot;Culture&quot;> </a> # # cultura e threads cada thread tem uma cultura, representada pelo <xref:System.Threading.Thread.CurrentCulture%2A>propriedade e um idioma de IU, representado pelo <xref:System.Threading.Thread.CurrentUICulture%2A>propriedade.</xref:System.Threading.Thread.CurrentUICulture%2A> </xref:System.Threading.Thread.CurrentCulture%2A>          A cultura atual suporta a cultura sensíveis operações como analisar e formatação, comparação de cadeias e ordenação e também controla o sistema de escrita e calendário utilizado por um thread. Fornece a cultura da IU atual para obtenção de cultura sensíveis dos recursos nos ficheiros de recursos.       Quando um novo thread é instanciado, o idioma e cultura da IU são definidas pela cultura atual do sistema e cultura da IU e não pela cultura e cultura da IU do thread de que é criado novo thread. Isto significa que, por exemplo, que se o idioma atual do sistema é inglês (Estados Unidos) e o idioma atual do thread principal da aplicação é francês (França), o idioma de um novo thread criado chamando o <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>construtor do thread principal é inglês (Estados Unidos) e francês (França).</xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> Para obter mais informações, consulte a secção &quot;Cultura e threads&quot; o <xref:System.Globalization.CultureInfo>tópico de classe.</xref:System.Globalization.CultureInfo>      > [!IMPORTANT] > Isto não é verdade de threads que executar as operações assíncronas para aplicações que o destino de [!INCLUDE[net_v46](~/add/includes/net-v46-md.md)] e versões posteriores, neste caso, o idioma e cultura da IU faz parte do contexto de um operações assíncronas; o thread em que uma operação assíncrona executa por predefinição herda a cultura e cultura da IU do thread de que a operação assíncrona foi iniciada. Para obter mais informações, consulte a secção &quot;Cultura e baseado em tarefas operações assíncronas&quot; o <xref:System.Globalization.CultureInfo>tópico de classe.</xref:System.Globalization.CultureInfo>       Pode efetuar um dos seguintes procedimentos para se certificar de que todos os threads em execução numa aplicação partilhar o mesmo idioma e a cultura da IU:-pode passar um <xref:System.Globalization.CultureInfo>objeto que representa esse idioma para o <xref:System.Threading.ParameterizedThreadStart>Delegar ou <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName>método.</xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName> </xref:System.Threading.ParameterizedThreadStart> </xref:System.Globalization.CultureInfo>      -Para aplicações em execução no [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] e versões posteriores, pode definir o idioma e cultura da IU que está a ser atribuído a todos os threads criados num domínio de aplicação, definindo o valor da <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName>e <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName>Propriedades.</xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName> </xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName> Tenha em atenção que se trata de uma definição de domínio por aplicação.       Para obter mais informações e exemplos, consulte a secção &quot;Cultura e threads&quot; o <xref:System.Globalization.CultureInfo>tópico de classe.</xref:System.Globalization.CultureInfo>      <a name=&quot;Properties&quot;></a># # Obter informações e controlar threads pode obter um número de valores de propriedade que fornecem informações sobre um thread. Em alguns casos, também pode definir estes valores de propriedade para controlar a operação do thread. Estas propriedades de thread incluem:-um nome. <xref:System.Threading.Thread.Name%2A>é uma operação de escrita-uma vez a propriedade que pode utilizar para identificar um thread.</xref:System.Threading.Thread.Name%2A>  O valor predefinido é `null`.      -Um código de hash, que pode obter chamando a <xref:System.Threading.Thread.GetHashCode%2A>método.</xref:System.Threading.Thread.GetHashCode%2A> O código hash pode ser utilizado para identificar exclusivamente um thread; para a duração do seu thread, o código hash irá não entrar em conflito com o valor de outro thread, independentemente do domínio de aplicação a partir do qual obter o valor.      -Um ID de thread. O valor da só de leitura <xref:System.Threading.Thread.ManagedThreadId%2A>propriedade é atribuída pelo runtime e identifica exclusivamente um thread dentro do respetivo processo.</xref:System.Threading.Thread.ManagedThreadId%2A>          > [!NOTE] > Um sistema operativo [ID da thread](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) não tem qualquer relação fixa a um thread gerido, porque um anfitrião não gerido pode controlar a relação entre threads geridas e não geridas. Especificamente, pode utilizar um anfitrião sofisticado o [API de alojamento de CLR](https://msdn.microsoft.com/library/ms404385.aspx) agendar vários threads geridos contra o mesmo thread do sistema operativo ou para mover um thread gerido entre threads diferentes do sistema operativo.      -Estado actual do thread o. Durante a respetiva existência, um thread é sempre num ou mais dos Estados definidos pelo <xref:System.Threading.ThreadState>propriedade.</xref:System.Threading.ThreadState>      -Um nível de prioridade agendamento, que é definido pelo <xref:System.Threading.ThreadPriority>propriedade.</xref:System.Threading.ThreadPriority> Embora o que pode definir este valor para pedir a prioridade de um thread, não é assegurada para ser cumpridas pelo sistema operativo.      -O só de leitura <xref:System.Threading.Thread.IsThreadPoolThread%2A>propriedade, o que indica se um thread é um thread de conjunto de threads.</xref:System.Threading.Thread.IsThreadPoolThread%2A>      -O <xref:System.Threading.Thread.IsBackground%2A>propriedade.</xref:System.Threading.Thread.IsBackground%2A> Para obter mais informações, consulte o [threads de primeiro plano e fundo](#Foreground) secção.      <a name=&quot;Source&quot;></a># # Aceder ao código de origem para a classe de Thread para ver o código de origem do .NET Framework para a classe de Thread, consulte o [referência origem](http://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96). Pode percorrer o código de origem online, transfira a referência para visualização offline e siga os passos as origens (incluindo correções de erros e atualizações) durante a depuração; consulte [instruções](http://referencesource.microsoft.com/)."
  example:
  - "The following example demonstrates simple threading functionality.  \n  \n [!code-cpp[Classic Thread Example#1](~/add/codesnippet/cpp/t-system.threading.thread_5.cpp)]\n [!code-vb[Classic Thread Example#1](~/add/codesnippet/visualbasic/t-system.threading.thread_5.vb)]\n [!code-cs[Classic Thread Example#1](~/add/codesnippet/csharp/t-system.threading.thread_5.cs)]  \n  \n This code produces output similar to the following:  \n  \n```  \n[VB, C++, C#]  \nMain thread: Start a second thread.  \nMain thread: Do some work.  \nThreadProc: 0  \nMain thread: Do some work.  \nThreadProc: 1  \nMain thread: Do some work.  \nThreadProc: 2  \nMain thread: Do some work.  \nThreadProc: 3  \nMain thread: Call Join(), to wait until ThreadProc ends.  \nThreadProc: 4  \nThreadProc: 5  \nThreadProc: 6  \nThreadProc: 7  \nThreadProc: 8  \nThreadProc: 9  \nMain thread: ThreadProc.Join has returned.  Press Enter to end program.  \n```"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]

      [System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread
  inheritance:
  - System.Object
  - System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  implements:
  - System.Runtime.InteropServices._Thread
  inheritedMembers: []
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)
  id: '#ctor(System.Threading.ParameterizedThreadStart)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ParameterizedThreadStart)
  nameWithType: Thread.Thread(ParameterizedThreadStart)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Threading.Thread&quot;> </xref> classe, especificando um delegado que permite que um objeto a ser transmitido para o thread quando o thread foi iniciado."
  remarks: "Um thread não começa a executar quando é criado. Para agendar o thread de execução, chame o <xref:System.Threading.Thread.Start%2A>método.</xref:System.Threading.Thread.Start%2A> Para transferir um objeto de dados para o thread, utilize o <xref:System.Threading.Thread.Start%28System.Object%29>sobrecarga de método.</xref:System.Threading.Thread.Start%28System.Object%29>      > [!NOTE] > Visual Basic utilizadores podem omitir o <xref:System.Threading.ThreadStart>construtor ao criar um thread.</xref:System.Threading.ThreadStart> Utilize o `AddressOf` operador ao transmitir o seu método, por exemplo `Dim t As New Thread(AddressOf ThreadProc)`. Visual Basic automaticamente chama o <xref:System.Threading.ThreadStart>construtor.</xref:System.Threading.ThreadStart>"
  example:
  - "The following example shows the syntax for creating and using a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.  \n  \n [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/cpp/m-system.threading.threa_19_1.cpp)]\n [!code-vb[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/visualbasic/m-system.threading.threa_19_1.vb)]\n [!code-cs[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/csharp/m-system.threading.threa_19_1.cs)]"
  syntax:
    content: public Thread (System.Threading.ParameterizedThreadStart start);
    parameters:
    - id: start
      type: System.Threading.ParameterizedThreadStart
      description: "Um delegado que representa os métodos para ser invocado quando este thread começa a executar."
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>start</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart)
  id: '#ctor(System.Threading.ThreadStart)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ThreadStart)
  nameWithType: Thread.Thread(ThreadStart)
  fullName: System.Threading.Thread.Thread(ThreadStart)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Threading.Thread&quot;> </xref> classe."
  remarks: "Um thread não começa a executar quando é criado. Para agendar o thread de execução, chame o <xref:System.Threading.Thread.Start%2A>método.</xref:System.Threading.Thread.Start%2A>      > [!NOTE] > Visual Basic utilizadores podem omitir o <xref:System.Threading.ThreadStart>construtor ao criar um thread.</xref:System.Threading.ThreadStart> Utilize o `AddressOf` operador ao transmitir o seu método por exemplo `Dim t As New Thread(AddressOf ThreadProc)`. Visual Basic automaticamente chama o <xref:System.Threading.ThreadStart>construtor.</xref:System.Threading.ThreadStart>"
  example:
  - "The following code example shows how to create a thread that executes a static method.  \n  \n [!code-cpp[System.Threading.Thread.ctor#1](~/add/codesnippet/cpp/m-system.threading.threa_18_1.cpp)]\n [!code-vb[System.Threading.Thread.ctor#1](~/add/codesnippet/visualbasic/m-system.threading.threa_18_1.vb)]\n [!code-cs[System.Threading.Thread.ctor#1](~/add/codesnippet/csharp/m-system.threading.threa_18_1.cs)]  \n  \n The following code example shows how to create a thread that executes an instance method.  \n  \n [!code-cs[System.Threading.Thread.ctor2#1](~/add/codesnippet/csharp/m-system.threading.threa_18_2.cs)]\n [!code-vb[System.Threading.Thread.ctor2#1](~/add/codesnippet/visualbasic/m-system.threading.threa_18_2.vb)]\n [!code-cpp[System.Threading.Thread.ctor2#1](~/add/codesnippet/cpp/m-system.threading.threa_18_2.cpp)]"
  syntax:
    content: public Thread (System.Threading.ThreadStart start);
    parameters:
    - id: start
      type: System.Threading.ThreadStart
      description: "A <xref href=&quot;System.Threading.ThreadStart&quot;> </xref> delegado que representa os métodos para ser invocado quando este thread começa a executar."
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>start</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)
  id: '#ctor(System.Threading.ParameterizedThreadStart,System.Int32)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ParameterizedThreadStart,Int32)
  nameWithType: Thread.Thread(ParameterizedThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Threading.Thread&quot;> </xref> classe, especificando um delegado que permite que um objeto a ser transmitido para o thread quando o thread está iniciado e especificar o tamanho da pilha máximo para o thread."
  remarks: "Evite utilizar esta sobrecarga de construtor. O tamanho da pilha de predefinido utilizado pelo <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>sobrecarga de construtor é o tamanho da pilha recomendada para threads.</xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> Se um thread tem problemas de memória, a causa mais provável é programação erro, como recursão infinita.      > [!IMPORTANT] > Começando com o [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], só pode definir o código de confiança totalmente `maxStackSize` para um valor que é maior do que o tamanho da pilha predefinida (1 megabyte). Se for especificado um valor maior para `maxStackSize` quando o código está em execução com fidedignidade parcial, `maxStackSize` é ignorada e o tamanho da pilha predefinida é utilizado. Sem exceção é emitida. Pode definir o código em qualquer nível de fidedignidade `maxStackSize` para um valor que é menor que o tamanho predefinido da pilha.      > [!NOTE] > Se estiver a desenvolver uma biblioteca totalmente fidedigna que será utilizada pelo código parcialmente fidedigno e terá de iniciar um thread que requer uma pilha de grandes dimensões, tem assert fidedignidade total antes de criar o thread ou será utilizado o tamanho predefinido da pilha. Não efetuar este procedimento, a menos que controlar totalmente o código que é executado no thread.       Se `maxStackSize` é inferior ao tamanho mínimo da pilha, é utilizado o tamanho da pilha mínimo. Se `maxStackSize` não é um múltiplo do tamanho da página, é arredondado ao múltiplo maior seguinte do tamanho da página. Por exemplo, se estiver a utilizar o .NET Framework versão 2.0 no Windows Vista, 256KB (262.144 bytes) é o tamanho da pilha mínima e o tamanho de página é 64KB (65,536 bytes).      > [!NOTE] > Em versões do Microsoft Windows antes do Windows XP e Windows Server 2003, `maxStackSize` é ignorada e o tamanho da pilha especificado no cabeçalho de executável é utilizado.       Se especificar um tamanho da pilha muito pequenos, poderá ter de desativar a pesquisa de capacidade excedida da pilha. Quando a pilha gravemente é restrita, a pesquisa pode próprio causar uma capacidade excedida da pilha. Para desativar a pesquisa de capacidade excedida de pilha, adicione o seguinte ao ficheiro de configuração de aplicação.      ```   <configuration>     <runtime>       <disableStackOverflowProbing enabled=&quot;true&quot;/>     </runtime>   </configuration>   ```"
  syntax:
    content: public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);
    parameters:
    - id: start
      type: System.Threading.ParameterizedThreadStart
      description: "A <xref href=&quot;System.Threading.ParameterizedThreadStart&quot;> </xref> delegado que representa os métodos para ser invocado quando este thread começa a executar."
    - id: maxStackSize
      type: System.Int32
      description: "O tamanho da pilha máximo, em bytes, para ser utilizado pelo thread ou 0 para utilizar o tamanho da pilha máximo predefinido especificado no cabeçalho para o executável.       Importante para parcialmente fidedigna código, `maxStackSize` é ignorada se for maior do que o tamanho predefinido da pilha. Sem exceção é emitida."
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>start</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>maxStackSize</code>é menor que zero."
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)
  id: '#ctor(System.Threading.ThreadStart,System.Int32)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ThreadStart,Int32)
  nameWithType: Thread.Thread(ThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ThreadStart,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Threading.Thread&quot;> </xref> classe, especificar o tamanho da pilha máximo para o thread."
  remarks: "Evite utilizar esta sobrecarga de construtor. O tamanho da pilha de predefinido utilizado pelo <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29>sobrecarga de construtor é o tamanho da pilha recomendada para threads.</xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> Se um thread tem problemas de memória, a causa mais provável é programação erro, como recursão infinita.      > [!IMPORTANT] > Começando com o [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], só pode definir o código de confiança totalmente `maxStackSize` para um valor que é maior do que o tamanho da pilha predefinida (1 megabyte). Se for especificado um valor maior para `maxStackSize` quando o código está em execução com fidedignidade parcial, `maxStackSize` é ignorada e o tamanho da pilha predefinida é utilizado. Sem exceção é emitida. Pode definir o código em qualquer nível de fidedignidade `maxStackSize` para um valor que é menor que o tamanho predefinido da pilha.      > [!NOTE] > Se estiver a desenvolver uma biblioteca totalmente fidedigna que será utilizada pelo código parcialmente fidedigno e terá de iniciar um thread que requer uma pilha de grandes dimensões, tem assert fidedignidade total antes de criar o thread ou será utilizado o tamanho predefinido da pilha. Não efetuar este procedimento, a menos que controlar totalmente o código que é executado no thread.       Se `maxStackSize` é inferior ao tamanho mínimo da pilha, é utilizado o tamanho da pilha mínimo. Se `maxStackSize` não é um múltiplo do tamanho da página, é arredondado ao múltiplo maior seguinte do tamanho da página. Por exemplo, se estiver a utilizar o .NET Framework versão 2.0 no Windows Vista, 256KB (262.144 bytes) é o tamanho da pilha mínima e o tamanho de página é 64KB (65,536 bytes).      > [!NOTE] > Em versões do Microsoft Windows antes do Windows XP e Windows Server 2003, `maxStackSize` é ignorada e o tamanho da pilha especificado no cabeçalho de executável é utilizado.       Se especificar um tamanho da pilha muito pequenos, poderá ter de desativar a pesquisa de capacidade excedida da pilha. Quando a pilha gravemente é restrita, a pesquisa pode próprio causar uma capacidade excedida da pilha. Para desativar a pesquisa de capacidade excedida de pilha, adicione o seguinte ao ficheiro de configuração de aplicação.      ```   <configuration>     <runtime>       <disableStackOverflowProbing enabled=&quot;true&quot;/>     </runtime>   </configuration>   ```"
  syntax:
    content: public Thread (System.Threading.ThreadStart start, int maxStackSize);
    parameters:
    - id: start
      type: System.Threading.ThreadStart
      description: "A <xref href=&quot;System.Threading.ThreadStart&quot;> </xref> delegado que representa os métodos para ser invocado quando este thread começa a executar."
    - id: maxStackSize
      type: System.Int32
      description: "O tamanho da pilha máximo, em bytes, para ser utilizado pelo thread ou 0 para utilizar o tamanho da pilha máximo predefinido especificado no cabeçalho para o executável.       Importante para parcialmente fidedigna código, `maxStackSize` é ignorada se for maior do que o tamanho predefinido da pilha. Sem exceção é emitida."
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>start</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>maxStackSize</code>é menor que zero."
  platform:
  - net462
- uid: System.Threading.Thread.Abort
  id: Abort
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Abort()
  nameWithType: Thread.Abort()
  fullName: System.Threading.Thread.Abort()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Gera um <xref href=&quot;System.Threading.ThreadAbortException&quot;> </xref> num thread no qual é invocado, para iniciar o processo de terminar o thread. Chamar este método normalmente termina o thread."
  remarks: "Quando este método é invocado num thread, o sistema emite um <xref:System.Threading.ThreadAbortException>no thread para abortar o mesmo.</xref:System.Threading.ThreadAbortException> `ThreadAbortException`é uma exceção especial que pode ser detetada pelo código da aplicação, mas é novamente iniciadas no fim do `catch` bloquear, a menos que <xref:System.Threading.Thread.ResetAbort%2A>é chamado.</xref:System.Threading.Thread.ResetAbort%2A> `ResetAbort`Cancela o pedido para abortar e impede o `ThreadAbortException` de terminar o thread. Unexecuted `finally` blocos são executados antes do thread foi abortado.      > [!NOTE] > Quando chama um thread `Abort` em si próprio, o efeito é semelhante para accionar uma excepção; os <xref:System.Threading.ThreadAbortException>acontece imediatamente, e o resultado é previsível.</xref:System.Threading.ThreadAbortException> No entanto, se chama um thread `Abort` noutro thread, a abortar interrupções qualquer código está em execução. Também é provável que construtor estático foi abortado. Em casos raros, isto poderá impedir instâncias dessa classe que está a ser criado nesse domínio de aplicação. Nas versões do .NET Framework 1.0 e 1.1, há a possibilidade do thread foi abortar enquanto um `finally` bloco está em execução, caso em que o `finally` bloco foi abortado.       O thread não é assegurado para abortar imediatamente ou de todo. Esta situação pode ocorrer se um thread uma quantidade de computação no unbounded o `finally` blocos que são denominados como parte do procedimento de abortar indefinidamente, deste modo, atrasando a abortar. Aguardar até o thread foi abortada, pode chamar o <xref:System.Threading.Thread.Join%2A>método no thread depois de chamar o método de abortar, mas não existe nenhuma garantia, a espera vai terminar.</xref:System.Threading.Thread.Join%2A>      > [!NOTE] > O thread que chama abortar poderão bloquear se o thread que está a ser abortado está numa região protegida de código, tais como um `catch` bloco, `finally` bloco ou região de execução restrita. Se o thread que chama abortar deter um bloqueio que requer que o thread de abortada, pode ocorrer um impasse.       Se `Abort` é chamado num thread que não foi iniciado, o thread irá abortar quando <xref:System.Threading.Thread.Start%2A>é chamado.</xref:System.Threading.Thread.Start%2A> Se `Abort` é chamado num thread que está bloqueado ou é suspenso, o thread é interrompido e, em seguida, abortado.       Se `Abort` é chamado num thread que tiver sido suspenso, um <xref:System.Threading.ThreadStateException>é emitida no thread de chamada <xref:System.Threading.Thread.Abort%2A>, e <xref:System.Threading.ThreadState>é adicionado ao <xref:System.Threading.Thread.ThreadState%2A>propriedade do thread abortado.</xref:System.Threading.Thread.ThreadState%2A> </xref:System.Threading.ThreadState> </xref:System.Threading.Thread.Abort%2A> </xref:System.Threading.ThreadStateException> A <xref:System.Threading.ThreadAbortException>não está a ser emitida no thread suspenso até <xref:System.Threading.Thread.Resume%2A>é chamado.</xref:System.Threading.Thread.Resume%2A> </xref:System.Threading.ThreadAbortException>       Se `Abort` é chamado num thread gerido enquanto está a executar código não gerido, um `ThreadAbortException` não é emitida até que o thread devolve para código gerido.       Se dois chamadas para `Abort` vêm ao mesmo tempo, é possível que uma chamada definir as informações de estado e a outra chamada para executar o `Abort`. No entanto, uma aplicação não consegue detetar esta situação.       Depois de `Abort` é invocado num thread, o estado do thread inclui <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> Depois do thread foi terminada devido a uma chamada com êxito para `Abort`, o estado do thread é alterado para <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> Com permissões suficientes, um thread que é o destino de uma `Abort` pode cancelar a abortar utilizando o `ResetAbort` método. Para obter um exemplo que demonstra a chamar o `ResetAbort` método, consulte o `ThreadAbortException` classe."
  syntax:
    content: public void Abort ();
    parameters: []
  overload: System.Threading.Thread.Abort*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "O thread que está a ser abortado está atualmente suspensa."
  platform:
  - net462
- uid: System.Threading.Thread.Abort(System.Object)
  id: Abort(System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Abort(Object)
  nameWithType: Thread.Abort(Object)
  fullName: System.Threading.Thread.Abort(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Gera um <xref href=&quot;System.Threading.ThreadAbortException&quot;> </xref> num thread no qual é invocado, para iniciar o processo de terminar o thread enquanto também fornecem informações sobre a terminação do thread da exceção. Chamar este método normalmente termina o thread."
  remarks: "Quando este método é invocado num thread, o sistema emite um <xref:System.Threading.ThreadAbortException>no thread para abortar o mesmo.</xref:System.Threading.ThreadAbortException> `ThreadAbortException`é uma exceção especial que pode ser detetada pelo código da aplicação, mas é novamente iniciadas no fim do `catch` bloquear, a menos que <xref:System.Threading.Thread.ResetAbort%2A>é chamado.</xref:System.Threading.Thread.ResetAbort%2A> `ResetAbort`Cancela o pedido para abortar e impede o `ThreadAbortException` de terminar o thread. Unexecuted `finally` blocos são executados antes do thread foi abortado.      > [!NOTE] > Quando chama um thread `Abort` em si próprio, o efeito é semelhante para accionar uma excepção; os <xref:System.Threading.ThreadAbortException>acontece imediatamente, e o resultado é previsível.</xref:System.Threading.ThreadAbortException> No entanto, se chama um thread `Abort` noutro thread, a abortar interrupções qualquer código está em execução. Há a possibilidade de que um construtor estático foi abortado. Em casos raros, isto poderá impedir instâncias dessa classe que está a ser criado nesse domínio de aplicação. Nas versões do .NET Framework 1.0 e 1.1, há a possibilidade do thread foi abortar enquanto um `finally` bloco está em execução, caso em que o `finally` bloco foi abortado.       O thread não é assegurado para abortar imediatamente ou de todo. Esta situação pode ocorrer se um thread uma quantidade de computação no unbounded o `finally` blocos que são denominados como parte do procedimento de abortar indefinidamente, deste modo, atrasando a abortar. Aguardar até o thread foi abortada, pode chamar o <xref:System.Threading.Thread.Join%2A>método no thread depois de chamar o método de abortar, mas não existe nenhuma garantia de que a espera vai terminar.</xref:System.Threading.Thread.Join%2A>      > [!NOTE] > O thread que chama <xref:System.Threading.Thread.Abort%2A>poderão bloquear se o thread que está a ser abortado está numa região protegida de código, tais como um `catch` bloco, `finally` bloco ou região de execução restrita.</xref:System.Threading.Thread.Abort%2A> Se o thread que chama <xref:System.Threading.Thread.Abort%2A>deter um bloqueio que requer que o thread de abortada, pode ocorrer um impasse.</xref:System.Threading.Thread.Abort%2A>       Se `Abort` é chamado num thread que não foi iniciado, o thread irá abortar quando <xref:System.Threading.Thread.Start%2A>é chamado.</xref:System.Threading.Thread.Start%2A> Se `Abort` é chamado num thread que está bloqueado ou é suspenso, o thread é interrompido e, em seguida, abortado.       Se `Abort` é chamado num thread que tiver sido suspenso, um <xref:System.Threading.ThreadStateException>é emitida no thread de chamada <xref:System.Threading.Thread.Abort%2A>, e <xref:System.Threading.ThreadState>é adicionado ao <xref:System.Threading.Thread.ThreadState%2A>propriedade do thread abortado.</xref:System.Threading.Thread.ThreadState%2A> </xref:System.Threading.ThreadState> </xref:System.Threading.Thread.Abort%2A> </xref:System.Threading.ThreadStateException> A <xref:System.Threading.ThreadAbortException>não está a ser emitida no thread suspenso até <xref:System.Threading.Thread.Resume%2A>é chamado.</xref:System.Threading.Thread.Resume%2A> </xref:System.Threading.ThreadAbortException>       Se `Abort` é chamado num thread gerido enquanto está a executar código não gerido, um `ThreadAbortException` não é emitida até que o thread devolve para código gerido.       Se dois chamadas para `Abort` vêm ao mesmo tempo, é possível que uma chamada definir as informações de estado e a outra chamada para executar o `Abort`. No entanto, uma aplicação não consegue detetar esta situação.       Depois de `Abort` é invocado num thread, o estado do thread inclui <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> Depois do thread foi terminada devido a uma chamada com êxito para `Abort`, o estado do thread é alterado para <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> Com permissões suficientes, um thread que é o destino de uma `Abort` pode cancelar a abortar utilizando o `ResetAbort` método. Para obter um exemplo que demonstra a chamar o `ResetAbort` método, consulte o `ThreadAbortException` classe."
  example:
  - "The following code example shows how to pass information to a thread that is being aborted.  \n  \n [!code-cs[System.Threading.Thread.Abort2#1](~/add/codesnippet/csharp/m-system.threading.threa_12_1.cs)]\n [!code-cpp[System.Threading.Thread.Abort2#1](~/add/codesnippet/cpp/m-system.threading.threa_12_1.cpp)]\n [!code-vb[System.Threading.Thread.Abort2#1](~/add/codesnippet/visualbasic/m-system.threading.threa_12_1.vb)]"
  syntax:
    content: public void Abort (object stateInfo);
    parameters:
    - id: stateInfo
      type: System.Object
      description: "Um objeto que contém informações específicas de aplicações, tais como Estado, o que pode ser utilizado pelo thread abortado."
  overload: System.Threading.Thread.Abort*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "O thread que está a ser abortado está atualmente suspensa."
  platform:
  - net462
- uid: System.Threading.Thread.AllocateDataSlot
  id: AllocateDataSlot
  parent: System.Threading.Thread
  langs:
  - csharp
  name: AllocateDataSlot()
  nameWithType: Thread.AllocateDataSlot()
  fullName: System.Threading.Thread.AllocateDataSlot()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Atribui um bloco de dados sem nome em todos os threads. Para um melhor desempenho, utilize os campos que são marcados com o <xref:System.ThreadStaticAttribute>atributo em vez disso.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]> O .NET Framework fornece dois mecanismos para utilizar o armazenamento local do thread (TLS): campos estáticos de thread relativo (ou seja, os campos que são marcados com o <xref:System.ThreadStaticAttribute>atributo) e blocos de dados.</xref:System.ThreadStaticAttribute> Campos estáticos de thread relativo fornecem muito melhor desempenho do que os blocos de dados e ativar a verificação de tipo de tempo de compilação. Para obter mais informações sobre a utilização de TLS, consulte [Thread armazenamento Local: campos estáticos de Thread relativo e dados ranhuras](~/add/includes/ajax-current-ext-md.md).       O espaço é alocado tendo em todos os threads.       Threads de utilizam um mecanismo de memória de armazenamento local para armazenar dados específicos do thread. O language runtime atribui uma matriz de arquivo de dados de ranhura multi para cada processo quando é criado. O thread pode alocar um bloco de dados no arquivo de dados, armazenar e obter dados de valor na ranhura de e libertar a ranhura para serem reutilizadas depois do thread de expira. Ranhuras de dados são exclusivas por thread. Nenhum outro thread (não do mesmo thread um subordinado) pode obter os dados."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_16_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_16_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_16_1.cpp)]  \n  \n **Second Example**  \n  \n The following code example demonstrates how to use a data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.DataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_16_2.cs)]\n [!code-cpp[System.Threading.Thread.DataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_16_2.cpp)]\n [!code-vb[System.Threading.Thread.DataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_16_2.vb)]"
  syntax:
    content: public static LocalDataStoreSlot AllocateDataSlot ();
    parameters: []
    return:
      type: System.LocalDataStoreSlot
      description: "O alocado com o nome bloco de dados em todos os threads."
  overload: System.Threading.Thread.AllocateDataSlot*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.AllocateNamedDataSlot(System.String)
  id: AllocateNamedDataSlot(System.String)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: AllocateNamedDataSlot(String)
  nameWithType: Thread.AllocateNamedDataSlot(String)
  fullName: System.Threading.Thread.AllocateNamedDataSlot(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Atribui um bloco de dados com nome em todos os threads. Para um melhor desempenho, utilize os campos que são marcados com o <xref:System.ThreadStaticAttribute>atributo em vez disso.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]> O .NET Framework fornece dois mecanismos para utilizar o armazenamento local do thread (TLS): campos estáticos de thread relativo (ou seja, os campos que são marcados com o <xref:System.ThreadStaticAttribute>atributo) e blocos de dados.</xref:System.ThreadStaticAttribute> Campos estáticos de thread relativo fornecem muito melhor desempenho do que os blocos de dados e ativar a verificação de tipo de tempo de compilação. Para obter mais informações sobre a utilização de TLS, consulte [Thread armazenamento Local: campos estáticos de Thread relativo e dados ranhuras](~/add/includes/ajax-current-ext-md.md).       Threads de utilizam um mecanismo de memória de armazenamento local para armazenar dados específicos do thread. O language runtime atribui uma matriz de arquivo de dados de ranhura multi para cada processo quando é criado. O thread pode alocar um bloco de dados no arquivo de dados, armazenar e obter dados de valor na ranhura de e libertar a ranhura para serem reutilizadas depois do thread de expira. Ranhuras de dados são exclusivas por thread. Nenhum outro thread (não do mesmo thread um subordinado) pode obter os dados.       Não é necessário utilizar o método de AllocateNamedDataSlot alocar um bloco de dados com nome, porque o <xref:System.Threading.Thread.GetNamedDataSlot%2A>método aloca a ranhura se já não foi atribuído.</xref:System.Threading.Thread.GetNamedDataSlot%2A>      > [!NOTE] > Se for utilizado o método AllocateNamedDataSlot, deve ser invocado no thread principal durante o arranque do programa, porque emite uma exceção, se uma ranhura com o nome especificado já foi atribuída. Não há nenhuma forma de testar se uma ranhura já foi atribuída.       As ranhuras alocadas com este método tem de ser libertadas com <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.</xref:System.Threading.Thread.FreeNamedDataSlot%2A>"
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_7_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_7_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_7_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n> [!NOTE]\n>  The example code does not use the AllocateNamedDataSlot method, because the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method allocates the slot if it has not already been allocated. If the AllocateNamedDataSlot method is used, it should be called in the main thread at program startup.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_7_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_7_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_7_2.vb)]"
  syntax:
    content: public static LocalDataStoreSlot AllocateNamedDataSlot (string name);
    parameters:
    - id: name
      type: System.String
      description: "O nome da ranhura de dados a ser alocados."
    return:
      type: System.LocalDataStoreSlot
      description: "O alocado com o nome bloco de dados em todos os threads."
  overload: System.Threading.Thread.AllocateNamedDataSlot*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um bloco de dados denominado com o nome especificado já existe."
  platform:
  - net462
- uid: System.Threading.Thread.ApartmentState
  id: ApartmentState
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ApartmentState
  nameWithType: Thread.ApartmentState
  fullName: System.Threading.Thread.ApartmentState
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém ou define o estado de apartamento deste thread."
  remarks: "**A propriedade ApartmentState está obsoleta.**  As alternativas não obsoletos são o <xref:System.Threading.Thread.GetApartmentState%2A>método ao obter o estado de apartamento e <xref:System.Threading.Thread.SetApartmentState%2A>método para definir o estado de apartamento.</xref:System.Threading.Thread.SetApartmentState%2A> </xref:System.Threading.Thread.GetApartmentState%2A>       Nas versões do .NET Framework 1.0 e 1.1, o `ApartmentState` propriedade marca um thread para indicar que são executados no apartamento de um único thread ou multithread. Esta propriedade pode ser definida quando o thread está no `Unstarted` ou `Running` thread Estado; no entanto, este pode ser definido apenas uma vez para um thread. Se a propriedade não foi definida, devolve `Unknown`.       Uma tentativa para utilizar a propriedade ApartmentState para definir o estado de apartamento de thread cujo estado apartment já foi definido é ignorada. No entanto, o <xref:System.Threading.Thread.SetApartmentState%2A>método gera um <xref:System.InvalidOperationException>neste caso.</xref:System.InvalidOperationException> </xref:System.Threading.Thread.SetApartmentState%2A>      > [!IMPORTANT] > No .NET Framework versão 2.0, threads novo são inicializados como <xref:System.Threading.ApartmentState?displayProperty=fullName>se respetivo estado de apartamento não foi definido antes de serem iniciadas.</xref:System.Threading.ApartmentState?displayProperty=fullName> O thread de aplicação principal é inicializado <xref:System.Threading.ApartmentState?displayProperty=fullName>por predefinição.</xref:System.Threading.ApartmentState?displayProperty=fullName> Já não pode definir o thread de aplicação principal <xref:System.Threading.ApartmentState?displayProperty=fullName>definindo a <xref:System.Threading.ApartmentState?displayProperty=fullName>propriedade na primeira linha de código.</xref:System.Threading.ApartmentState?displayProperty=fullName> </xref:System.Threading.ApartmentState?displayProperty=fullName> Utilize o <xref:System.STAThreadAttribute>em vez disso.</xref:System.STAThreadAttribute>       No .NET Framework versão 2.0, pode especificar o COM o modelo para uma aplicação de C++ através de thread do [/CLRTHREADATTRIBUTE (definir o atributo de Thread CLR)](~/add/includes/ajax-current-ext-md.md) opção do linker."
  example:
  - "The following code example demonstrates how to set the apartment state of a thread.  \n  \n [!code-cs[System.Threading.Thread.ApartmentState#1](~/add/codesnippet/csharp/p-system.threading.threa_8_1.cs)]\n [!code-cpp[System.Threading.Thread.ApartmentState#1](~/add/codesnippet/cpp/p-system.threading.threa_8_1.cpp)]\n [!code-vb[System.Threading.Thread.ApartmentState#1](~/add/codesnippet/visualbasic/p-system.threading.threa_8_1.vb)]"
  syntax:
    content: public System.Threading.ApartmentState ApartmentState { get; set; }
    return:
      type: System.Threading.ApartmentState
      description: "Um do <xref href=&quot;System.Threading.ApartmentState&quot;> </xref> valores. O valor inicial é <xref uid=&quot;langword_csharp_Unknown&quot; name=&quot;Unknown&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.ApartmentState*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "É efetuada uma tentativa de definir esta propriedade para um Estado que não é um estado apartment válido (estado diferente de apartamento de thread único (<xref uid=&quot;langword_csharp_STA&quot; name=&quot;STA&quot; href=&quot;&quot;></xref>) ou apartment multithread (<xref uid=&quot;langword_csharp_MTA&quot; name=&quot;MTA&quot; href=&quot;&quot;></xref>))."
  platform:
  - net462
- uid: System.Threading.Thread.BeginCriticalRegion
  id: BeginCriticalRegion
  parent: System.Threading.Thread
  langs:
  - csharp
  name: BeginCriticalRegion()
  nameWithType: Thread.BeginCriticalRegion()
  fullName: System.Threading.Thread.BeginCriticalRegion()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Notifica um anfitrião que execução está prestes a introduzir uma região do código em que os efeitos de um thread abortar ou uma exceção não processada possam comprometer a outras tarefas no domínio de aplicação."
  remarks: "Anfitriões do language runtime (CLR), como o Microsoft SQL Server 2005, podem estabelecer diferentes políticas para falhas em regiões críticas e não críticas do código. Uma região crítica é um em que os efeitos de um aborto de threads ou uma exceção não processada não poderão ser limitados para a tarefa atual. Por outro lado, um abort ou falha numa região não críticos de código afeta apenas a tarefa no qual ocorre o erro.       Por exemplo, considere uma tarefa que tenta alocar memória ao que contém um bloqueio. Se falhar a alocação de memória, abortar a tarefa atual não é suficiente para garantir a estabilidade do <xref:System.AppDomain>, porque podem existir outras tarefas no domínio a aguardar que o mesmo bloqueio.</xref:System.AppDomain> Se a tarefa atual foi terminada, outras tarefas podem ser estão bloqueadas.       Quando ocorre uma falha numa região crítico, o anfitrião poderá decidir ao descarregar a toda a <xref:System.AppDomain>em vez de aceitar o risco de continuar a execução num estado potencialmente instável.</xref:System.AppDomain> Para informar o anfitrião que o código é introduzir uma região crítico, chame BeginCriticalRegion. Chamar <xref:System.Threading.Thread.EndCriticalRegion%2A>Quando execução devolve para uma região não críticas do código.</xref:System.Threading.Thread.EndCriticalRegion%2A>       Ao utilizar este método no código que é executada no SQL Server 2005 requer o código para ser executado ao nível de proteção do anfitrião mais elevado."
  example:
  - "The following example demonstrates the use of the BeginCriticalRegion and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non-critical regions.  \n  \n [!code-cs[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/csharp/m-system.threading.threa_5_1.cs)]\n [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/cpp/m-system.threading.threa_5_1.cpp)]\n [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/visualbasic/m-system.threading.threa_5_1.vb)]"
  syntax:
    content: public static void BeginCriticalRegion ();
    parameters: []
  overload: System.Threading.Thread.BeginCriticalRegion*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.BeginThreadAffinity
  id: BeginThreadAffinity
  parent: System.Threading.Thread
  langs:
  - csharp
  name: BeginThreadAffinity()
  nameWithType: Thread.BeginThreadAffinity()
  fullName: System.Threading.Thread.BeginThreadAffinity()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Notifica um anfitrião que código gerido está prestes a executar as instruções que dependem a identidade do sistema operativo físico thread atual."
  remarks: "Alguns anfitriões do tempo de execução de idioma comuns, tais como o Microsoft SQL Server 2005, fornecem as suas próprias gestão thread. Um anfitrião que fornece a gestão do seu próprio thread pode mover uma tarefa em execução de um thread de sistema de operativo físico para outro em qualquer altura. A maioria das tarefas não são afetados por este mudar. No entanto, algumas tarefas têm afinidade de threads - ou seja, dependem a identidade de um thread de sistema de operativo físico. Estas tarefas devem informar o anfitrião quando são executados código que não deve ser mudado.       Por exemplo, se a sua aplicação chama uma API para adquirir um bloqueio de sistema operativo que tenha a afinidade de threads, como um CRITICAL_SECTION Win32, do sistema tem de chamar BeginThreadAffinity antes de adquirir o bloqueio e <xref:System.Threading.Thread.EndThreadAffinity%2A>após a libertação do bloqueio.</xref:System.Threading.Thread.EndThreadAffinity%2A>       Ao utilizar este método no código que é executada no SQL Server 2005 requer o código para ser executado ao nível de proteção do anfitrião mais elevado."
  example:
  - "The following example demonstrates the use of the BeginThreadAffinity and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.  \n  \n [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/cpp/m-system.threading.threa_0_1.cpp)]\n [!code-cs[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/csharp/m-system.threading.threa_0_1.cs)]\n [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/visualbasic/m-system.threading.threa_0_1.vb)]"
  syntax:
    content: public static void BeginThreadAffinity ();
    parameters: []
  overload: System.Threading.Thread.BeginThreadAffinity*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  platform:
  - net462
- uid: System.Threading.Thread.CurrentContext
  id: CurrentContext
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentContext
  nameWithType: Thread.CurrentContext
  fullName: System.Threading.Thread.CurrentContext
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém o contexto atual no qual o thread está a executar."
  syntax:
    content: public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }
    return:
      type: System.Runtime.Remoting.Contexts.Context
      description: "A <xref href=&quot;System.Runtime.Remoting.Contexts.Context&quot;> </xref> que representa o contexto do thread actual."
  overload: System.Threading.Thread.CurrentContext*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  platform:
  - net462
- uid: System.Threading.Thread.CurrentCulture
  id: CurrentCulture
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentCulture
  nameWithType: Thread.CurrentCulture
  fullName: System.Threading.Thread.CurrentCulture
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém ou define o idioma para o thread actual."
  remarks: "O <xref:System.Globalization.CultureInfo>objeto é devolvido por esta propriedade, juntamente com os objetos associados, determinar o formato predefinido para as datas, vezes, números, valores de moeda, a ordenação a ordem de texto, as maiúsculas e minúsculas convenções e comparações de cadeia.</xref:System.Globalization.CultureInfo> Consulte o <xref:System.Globalization.CultureInfo>de classe para saber mais sobre os nomes de cultura e identificadores, as diferenças entre as culturas invariável, independentes e específicas, e as informações de cultura da forma como afeta threads e domínios de aplicação.</xref:System.Globalization.CultureInfo> Consulte o <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName>propriedade para saber como o idioma predefinido de um thread é determinado e como os utilizadores definir informações de cultura para os respetivos computadores.</xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName>       Começando com o [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], pode definir a propriedade CurrentCulture para um idioma neutro. Isto acontece porque o comportamento do <xref:System.Globalization.CultureInfo>classe foi alterada: quando representa uma cultura neutra, os respetivos valores de propriedade (em particular, a <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, e <xref:System.Globalization.CultureInfo.TextInfo%2A>Propriedades) agora refletir o idioma específico que está associado ao idioma neutro.</xref:System.Globalization.CultureInfo.TextInfo%2A> </xref:System.Globalization.CultureInfo.NumberFormat%2A> </xref:System.Globalization.CultureInfo.DateTimeFormat%2A> </xref:System.Globalization.CultureInfo.CompareInfo%2A> </xref:System.Globalization.CultureInfo.Calendar%2A> </xref:System.Globalization.CultureInfo> Nas versões anteriores do .NET Framework, a propriedade CurrentCulture emitiu um <xref:System.NotSupportedException>exceção quando foi atribuída uma cultura neutra.</xref:System.NotSupportedException>"
  example:
  - "The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel. Additional code is needed.  \n  \n [!code-cpp[System.Threading.Thread.Culture#1](~/add/codesnippet/cpp/p-system.threading.threa_3_1.cpp)]\n [!code-cs[System.Threading.Thread.Culture#1](~/add/codesnippet/csharp/p-system.threading.threa_3_1.cs)]\n [!code-vb[System.Threading.Thread.Culture#1](~/add/codesnippet/visualbasic/p-system.threading.threa_3_1.vb)]"
  syntax:
    content: public System.Globalization.CultureInfo CurrentCulture { get; set; }
    return:
      type: System.Globalization.CultureInfo
      description: "Um objeto que representa o idioma para o thread actual."
  overload: System.Threading.Thread.CurrentCulture*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "A propriedade está definida como <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Threading.Thread.CurrentPrincipal
  id: CurrentPrincipal
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentPrincipal
  nameWithType: Thread.CurrentPrincipal
  fullName: System.Threading.Thread.CurrentPrincipal
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém ou define o principal atual do thread (para a segurança baseada em funções)."
  remarks: ''
  example:
  - "The following code example shows how to set and retrieve the principal of a thread.  \n  \n [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/add/codesnippet/cpp/p-system.threading.threa_11_1.cpp)]\n [!code-cs[System.Threading.Thread.CurrentPrincipal#1](~/add/codesnippet/csharp/p-system.threading.threa_11_1.cs)]\n [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/add/codesnippet/visualbasic/p-system.threading.threa_11_1.vb)]"
  syntax:
    content: public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }
    return:
      type: System.Security.Principal.IPrincipal
      description: "Um <xref:System.Security.Principal.IPrincipal>representando o contexto de segurança.</xref:System.Security.Principal.IPrincipal>"
  overload: System.Threading.Thread.CurrentPrincipal*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária para definir o principal."
  platform:
  - net462
- uid: System.Threading.Thread.CurrentThread
  id: CurrentThread
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentThread
  nameWithType: Thread.CurrentThread
  fullName: System.Threading.Thread.CurrentThread
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém o thread actualmente em execução."
  remarks: ''
  example:
  - "The following example creates a task that in turn creates 20 child tasks. The application itself, as well as each task, calls the `ShowThreadInformation` method, which uses the CurrentThread property  to display information about the thread on which it is running.  \n  \n [!code-vb[System.Threading.Thread.CurrentThread#1](~/add/codesnippet/visualbasic/p-system.threading.threa_1_1.vb)]\n [!code-cs[System.Threading.Thread.CurrentThread#1](~/add/codesnippet/csharp/p-system.threading.threa_1_1.cs)]  \n  \n Each child task generates 1 million random numbers between 1 and 1 million and returns their mean. The parent task calls the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> method to ensure that the child tasks have completed before displaying the mean returned by each task and calculating the mean of means.  \n  \n Note that while the application runs on a foreground thread, each task runs on a thread pool thread."
  syntax:
    content: public static System.Threading.Thread CurrentThread { get; }
    return:
      type: System.Threading.Thread
      description: "A <xref href=&quot;System.Threading.Thread&quot;> </xref> que é a representação do thread actualmente em execução."
  overload: System.Threading.Thread.CurrentThread*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.CurrentUICulture
  id: CurrentUICulture
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentUICulture
  nameWithType: Thread.CurrentUICulture
  fullName: System.Threading.Thread.CurrentUICulture
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém ou define a cultura atual utilizada pelo Gestor de recursos para consultar recursos do idioma específico no tempo de execução."
  remarks: "The UI culture specifies the resources an application needs to support user input and output, and by default is the same as the operating system culture. See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains. See the <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=fullName> property to learn how a thread's default UI culture is determined.  \n  \n The <xref:System.Globalization.CultureInfo> returned by this property can be a neutral culture. Neutral cultures should not be used with formatting methods such as [String.Format(IFormatProvider, String, Object\\[\\])](assetId:///M:System.String.Format(System.IFormatProvider,System.String,System.Object[])?qualifyHint=True&autoUpgrade=False), <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName>, and <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=fullName>. Use the <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=fullName> method to get a specific culture, or use the <xref:System.Threading.Thread.CurrentCulture%2A> property.  \n  \n> [!NOTE]\n>  The <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=fullName> method throws <xref:System.ArgumentException> for the neutral cultures \"zh-Hant\" (\"zh-CHT\") and \"zh-Hans\" (\"zh-CHS\")."
  example:
  - "The following example determines whether the language of the current thread's UI culture is French. If it is not, it sets the UI culture of the current thread to English (United States).  \n  \n [!code-cs[System.Threading.Thread.CurrentUICulture#1](~/add/codesnippet/csharp/p-system.threading.threa_2_1.cs)]\n [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/add/codesnippet/visualbasic/p-system.threading.threa_2_1.vb)]  \n  \n The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel. Additional code is needed.  \n  \n [!code-cpp[System.Threading.Thread.Culture#1](~/add/codesnippet/cpp/p-system.threading.threa_2_2.cpp)]\n [!code-cs[System.Threading.Thread.Culture#1](~/add/codesnippet/csharp/p-system.threading.threa_2_2.cs)]\n [!code-vb[System.Threading.Thread.Culture#1](~/add/codesnippet/visualbasic/p-system.threading.threa_2_2.vb)]"
  syntax:
    content: public System.Globalization.CultureInfo CurrentUICulture { get; set; }
    return:
      type: System.Globalization.CultureInfo
      description: "Um objeto que representa a cultura atual."
  overload: System.Threading.Thread.CurrentUICulture*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "A propriedade está definida como <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "A propriedade está definida como um nome de cultura que não pode ser utilizado para localizar um ficheiro de recursos. Os nomes de ficheiro de recursos tem de incluir apenas letras, números, hífenes e carateres de sublinhado."
  platform:
  - net462
- uid: System.Threading.Thread.DisableComObjectEagerCleanup
  id: DisableComObjectEagerCleanup
  parent: System.Threading.Thread
  langs:
  - csharp
  name: DisableComObjectEagerCleanup()
  nameWithType: Thread.DisableComObjectEagerCleanup()
  fullName: System.Threading.Thread.DisableComObjectEagerCleanup()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Desativa a limpeza automática de tempo de execução possível chamar EndRead wrappers (RCW) para o thread actual."
  remarks: "Por predefinição, o language runtime (CLR) limpa wrappers possível chamar EndRead do tempo de execução automaticamente. O CLR bombas mensagens durante a limpeza, o que poderá causar problemas de reentrancy para algumas aplicações que cumprem os critérios de atividade invulgares seguintes:-a aplicação gerar sua própria mensagem.      -A aplicação tem de controlar precisamente quando ocorre a gerar a mensagem.       Essas aplicações podem utilizar o método DisableComObjectEagerCleanup para impedir o CLR de fazer a recuperação automática de wrappers possível chamar EndRead do tempo de execução.       Quando este método foi chamado num thread, a limpeza automática não pode ser ativada novamente nesse thread. Quando a aplicação está pronta para limpar wrappers possível chamar EndRead do tempo de execução, utilize o <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName>método para instruir o tempo de execução para limpar todos os wrappers possível chamar EndRead de tempo de execução no contexto atual.</xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName> Gerar mensagem ocorre durante o método executa."
  syntax:
    content: public void DisableComObjectEagerCleanup ();
    parameters: []
  overload: System.Threading.Thread.DisableComObjectEagerCleanup*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.EndCriticalRegion
  id: EndCriticalRegion
  parent: System.Threading.Thread
  langs:
  - csharp
  name: EndCriticalRegion()
  nameWithType: Thread.EndCriticalRegion()
  fullName: System.Threading.Thread.EndCriticalRegion()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Notifica um anfitrião que execução está prestes a introduzir uma região do código em que os efeitos de um thread abortar ou uma exceção não processada estão limitados a tarefa atual."
  remarks: "Anfitriões do language runtime (CLR), como o Microsoft SQL Server 2005, podem estabelecer diferentes políticas para falhas em regiões críticas e não críticas do código. Uma região crítica é um em que os efeitos de um aborto de threads ou uma exceção não processada não poderão ser limitados para a tarefa atual. Por outro lado, um abort ou falha numa região não críticos de código afeta apenas a tarefa no qual ocorre o erro.       Por exemplo, considere uma tarefa que tenta alocar memória ao que contém um bloqueio. Se falhar a alocação de memória, abortar a tarefa atual não é suficiente para garantir a estabilidade do <xref:System.AppDomain>, porque podem existir outras tarefas no domínio a aguardar que o mesmo bloqueio.</xref:System.AppDomain> Se a tarefa atual foi terminada, outras tarefas podem ser estão bloqueadas.       Quando ocorre uma falha numa região crítico, o anfitrião poderá decidir ao descarregar a toda a <xref:System.AppDomain>em vez de aceitar o risco de continuar a execução num estado potencialmente instável.</xref:System.AppDomain> Para informar o anfitrião que o código é introduzir uma região crítico, chame <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</xref:System.Threading.Thread.BeginCriticalRegion%2A> Chame EndCriticalRegion quando execução regressar a uma região não críticas do código.       Ao utilizar este método no código que é executada no SQL Server 2005 requer o código para ser executado ao nível de proteção do anfitrião mais elevado."
  example:
  - "The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and EndCriticalRegion methods to divide a block of code into critical and non-critical regions.  \n  \n [!code-cs[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/csharp/m-system.threading.threa_1_1.cs)]\n [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/cpp/m-system.threading.threa_1_1.cpp)]\n [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/visualbasic/m-system.threading.threa_1_1.vb)]"
  syntax:
    content: public static void EndCriticalRegion ();
    parameters: []
  overload: System.Threading.Thread.EndCriticalRegion*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.EndThreadAffinity
  id: EndThreadAffinity
  parent: System.Threading.Thread
  langs:
  - csharp
  name: EndThreadAffinity()
  nameWithType: Thread.EndThreadAffinity()
  fullName: System.Threading.Thread.EndThreadAffinity()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Notifica um anfitrião que código gerido terminou a execução instruções que dependem a identidade do sistema operativo físico thread atual."
  remarks: "Alguns anfitriões do tempo de execução de idioma comuns, tais como o Microsoft SQL Server 2005, fornecem as suas próprias gestão thread. Um anfitrião que fornece a gestão do seu próprio thread pode mover uma tarefa em execução de um thread de sistema de operativo físico para outro em qualquer altura. A maioria das tarefas não são afetados por este mudar. No entanto, algumas tarefas têm afinidade de threads - ou seja, dependem a identidade de um thread de sistema de operativo físico. Estas tarefas devem informar o anfitrião quando são executados código que não deve ser mudado.       Por exemplo, se bloquear as chamadas de aplicação de uma API de sistema para adquirir um sistema operativo que tenha a afinidade de threads, como um CRITICAL_SECTION Win32, tem de chamar <xref:System.Threading.Thread.BeginThreadAffinity%2A>antes de adquirir o bloqueio e EndThreadAffinity após a libertação do bloqueio.</xref:System.Threading.Thread.BeginThreadAffinity%2A>       Ao utilizar este método no código que é executada no SQL Server 2005 requer o código para ser executado ao nível de proteção do anfitrião mais elevado."
  example:
  - "The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and EndThreadAffinity methods to notify a host that a block of code depends on the identity of a physical operating system thread.  \n  \n [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/cpp/m-system.threading.threa_3_1.cpp)]\n [!code-cs[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/csharp/m-system.threading.threa_3_1.cs)]\n [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/visualbasic/m-system.threading.threa_3_1.vb)]"
  syntax:
    content: public static void EndThreadAffinity ();
    parameters: []
  overload: System.Threading.Thread.EndThreadAffinity*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão necessária."
  platform:
  - net462
- uid: System.Threading.Thread.ExecutionContext
  id: ExecutionContext
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ExecutionContext
  nameWithType: Thread.ExecutionContext
  fullName: System.Threading.Thread.ExecutionContext
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém um <xref:System.Threading.ExecutionContext>objeto que contém informações sobre os vários contextos de thread atual.</xref:System.Threading.ExecutionContext>"
  remarks: "O <xref:System.Threading.ExecutionContext>classe fornece um único contentor para todas as informações relevantes para o thread lógico de execução.</xref:System.Threading.ExecutionContext> Isto inclui o contexto de segurança, contexto de chamada, contexto de sincronização, contexto de localização e o contexto de transação."
  syntax:
    content: public System.Threading.ExecutionContext ExecutionContext { get; }
    return:
      type: System.Threading.ExecutionContext
      description: "Um <xref:System.Threading.ExecutionContext>objeto que consolida as informações de contexto para o thread actual.</xref:System.Threading.ExecutionContext>"
  overload: System.Threading.Thread.ExecutionContext*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Finalize
  id: Finalize
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Finalize()
  nameWithType: Thread.Finalize()
  fullName: System.Threading.Thread.Finalize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Garante que os recursos são libertados e outras operações de limpeza são efetuadas quando o recoletor de lixo da memória reclama o <xref href=&quot;System.Threading.Thread&quot;> </xref> objeto."
  remarks: "As chamadas de recoletor de lixo Finalize quando o objeto atual está pronto para ser finalizada."
  syntax:
    content: ~Thread ();
    parameters: []
  overload: System.Threading.Thread.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.FreeNamedDataSlot(System.String)
  id: FreeNamedDataSlot(System.String)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: FreeNamedDataSlot(String)
  nameWithType: Thread.FreeNamedDataSlot(String)
  fullName: System.Threading.Thread.FreeNamedDataSlot(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Elimina a associação entre um nome e uma ranhura, para todos os threads no processo. Para um melhor desempenho, utilize os campos que são marcados com o <xref:System.ThreadStaticAttribute>atributo em vez disso.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]> O .NET Framework fornece dois mecanismos para utilizar o armazenamento local do thread (TLS): campos estáticos de thread relativo (ou seja, os campos que são marcados com o <xref:System.ThreadStaticAttribute>atributo) e blocos de dados.</xref:System.ThreadStaticAttribute> Campos estáticos de thread relativo fornecem muito melhor desempenho do que os blocos de dados e ativar a verificação de tipo de tempo de compilação. Para obter mais informações sobre a utilização de TLS, consulte [Thread armazenamento Local: campos estáticos de Thread relativo e dados ranhuras](~/add/includes/ajax-current-ext-md.md).       Depois de qualquer thread chamadas `FreeNamedDataSlot`, outro thread que chama <xref:System.Threading.Thread.GetNamedDataSlot%2A>com o mesmo nome irá alocar uma nova ranhura associada ao nome.</xref:System.Threading.Thread.GetNamedDataSlot%2A> As chamadas subsequentes para `GetNamedDataSlot` por qualquer thread irá devolver a nova ranhura. No entanto, qualquer thread que ainda tem um <xref:System.LocalDataStoreSlot?displayProperty=fullName>devolvido por uma chamada anterior para `GetNamedDataSlot` pode continuar a utilizar o bloco de antigo.</xref:System.LocalDataStoreSlot?displayProperty=fullName>       É lançada uma ranhura que foi associada com um nome de apenas quando cada `LocalDataStoreSlot` que foi obtido antes da chamada para `FreeNamedDataSlot` foi libertado e libertação da memória.       Threads de utilizam um mecanismo de memória de armazenamento local para armazenar dados específicos do thread. O language runtime atribui uma matriz de arquivo de dados de ranhura multi para cada processo quando é criado. O thread pode alocar um bloco de dados no arquivo de dados, armazenar e obter dados de valor na ranhura de e libertar a ranhura para serem reutilizadas depois do thread de expira. Ranhuras de dados são exclusivas por thread. Nenhum outro thread (não do mesmo thread um subordinado) pode obter os dados."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_9_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_9_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_9_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_9_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_9_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_9_2.vb)]"
  syntax:
    content: public static void FreeNamedDataSlot (string name);
    parameters:
    - id: name
      type: System.String
      description: "O nome da ranhura de dados a ser libertado."
  overload: System.Threading.Thread.FreeNamedDataSlot*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetApartmentState
  id: GetApartmentState
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetApartmentState()
  nameWithType: Thread.GetApartmentState()
  fullName: System.Threading.Thread.GetApartmentState()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Devolve um <xref href=&quot;System.Threading.ApartmentState&quot;> </xref> valor que indica o estado de apartamento."
  remarks: "Este método, juntamente com o <xref:System.Threading.Thread.SetApartmentState%2A>método e o <xref:System.Threading.Thread.TrySetApartmentState%2A>substitui o método, o <xref:System.Threading.Thread.ApartmentState%2A>propriedade.</xref:System.Threading.Thread.ApartmentState%2A> </xref:System.Threading.Thread.TrySetApartmentState%2A> </xref:System.Threading.Thread.SetApartmentState%2A>"
  example:
  - "The following code example demonstrates the GetApartmentState, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods. The code example creates a thread. Before the thread is started, GetApartmentState displays the initial <xref:System.Threading.ApartmentState?displayProperty=fullName> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState?displayProperty=fullName>. The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState?displayProperty=fullName> because the apartment state is already set. If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.  \n  \n After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again. This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.  \n  \n [!code-vb[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/visualbasic/m-system.threading.threa_11_1.vb)]\n [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/cpp/m-system.threading.threa_11_1.cpp)]\n [!code-cs[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/csharp/m-system.threading.threa_11_1.cs)]"
  syntax:
    content: public System.Threading.ApartmentState GetApartmentState ();
    parameters: []
    return:
      type: System.Threading.ApartmentState
      description: "Um do <xref href=&quot;System.Threading.ApartmentState&quot;> </xref> valores que indica o estado apartment do thread gerido. A predefinição é <xref href=&quot;System.Threading.ApartmentState&quot;> </xref>."
  overload: System.Threading.Thread.GetApartmentState*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetCompressedStack
  id: GetCompressedStack
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetCompressedStack()
  nameWithType: Thread.GetCompressedStack()
  fullName: System.Threading.Thread.GetCompressedStack()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Devolve um <xref href=&quot;System.Threading.CompressedStack&quot;> </xref> objetos que podem ser utilizados para capturar a pilha de para o thread actual."
  remarks: "Este método já não é suportado."
  syntax:
    content: public System.Threading.CompressedStack GetCompressedStack ();
    parameters: []
    return:
      type: System.Threading.CompressedStack
      description: "Nenhum."
  overload: System.Threading.Thread.GetCompressedStack*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Em todos os casos."
  platform:
  - net462
- uid: System.Threading.Thread.GetData(System.LocalDataStoreSlot)
  id: GetData(System.LocalDataStoreSlot)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetData(LocalDataStoreSlot)
  nameWithType: Thread.GetData(LocalDataStoreSlot)
  fullName: System.Threading.Thread.GetData(LocalDataStoreSlot)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém o valor da ranhura especificada no thread atual, dentro do domínio atual do thread actual. Para um melhor desempenho, utilize os campos que são marcados com o <xref:System.ThreadStaticAttribute>atributo em vez disso.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]> O .NET Framework fornece dois mecanismos para utilizar o armazenamento local do thread (TLS): campos estáticos de thread relativo (ou seja, os campos que são marcados com o <xref:System.ThreadStaticAttribute>atributo) e blocos de dados.</xref:System.ThreadStaticAttribute> Campos estáticos de thread relativo fornecem muito melhor desempenho do que os blocos de dados e ativar a verificação de tipo de tempo de compilação. Para obter mais informações sobre a utilização de TLS, consulte [Thread armazenamento Local: campos estáticos de Thread relativo e dados ranhuras](~/add/includes/ajax-current-ext-md.md).       Threads de utilizam um mecanismo de memória de armazenamento local para armazenar dados específicos do thread. O language runtime atribui uma matriz de arquivo de dados de ranhura multi para cada processo quando é criado. O thread pode alocar um bloco de dados no arquivo de dados, armazenar e obter dados de valor na ranhura de e libertar a ranhura para serem reutilizadas depois do thread de expira. Ranhuras de dados são exclusivas por thread. Nenhum outro thread (não do mesmo thread um subordinado) pode obter os dados.      > [!NOTE] > GetData é um `Shared` método sempre aplica-se a thread atualmente em execução, mesmo se chamá-la utilizando uma variável que se refira a outro thread. Para evitar confusões, utilize o nome de classe ao chamar `Shared` métodos: `Dim test As Object = Thread.GetData(testSlot)`."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_27_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_27_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_27_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.DataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_27_2.cs)]\n [!code-cpp[System.Threading.Thread.DataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_27_2.cpp)]\n [!code-vb[System.Threading.Thread.DataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_27_2.vb)]"
  syntax:
    content: public static object GetData (LocalDataStoreSlot slot);
    parameters:
    - id: slot
      type: System.LocalDataStoreSlot
      description: "O <xref href=&quot;System.LocalDataStoreSlot&quot;> </xref> partir do qual pode obter o valor."
    return:
      type: System.Object
      description: "O valor obtido."
  overload: System.Threading.Thread.GetData*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetDomain
  id: GetDomain
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetDomain()
  nameWithType: Thread.GetDomain()
  fullName: System.Threading.Thread.GetDomain()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Devolve o domínio atual no qual está a executar o thread actual."
  remarks: ''
  example:
  - "The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.  \n  \n [!code-cs[System.Threading.Thread.Domain#1](~/add/codesnippet/csharp/m-system.threading.threa_29_1.cs)]\n [!code-vb[System.Threading.Thread.Domain#1](~/add/codesnippet/visualbasic/m-system.threading.threa_29_1.vb)]\n [!code-cpp[System.Threading.Thread.Domain#1](~/add/codesnippet/cpp/m-system.threading.threa_29_1.cpp)]"
  syntax:
    content: public static AppDomain GetDomain ();
    parameters: []
    return:
      type: System.AppDomain
      description: "Um <xref href=&quot;System.AppDomain&quot;> </xref> que representa o domínio de aplicação atual do thread em execução."
  overload: System.Threading.Thread.GetDomain*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetDomainID
  id: GetDomainID
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetDomainID()
  nameWithType: Thread.GetDomainID()
  fullName: System.Threading.Thread.GetDomainID()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Devolve um identificador de domínio de aplicação único."
  remarks: ''
  example:
  - "The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.  \n  \n [!code-cs[System.Threading.Thread.Domain#1](~/add/codesnippet/csharp/m-system.threading.threa_17_1.cs)]\n [!code-vb[System.Threading.Thread.Domain#1](~/add/codesnippet/visualbasic/m-system.threading.threa_17_1.vb)]\n [!code-cpp[System.Threading.Thread.Domain#1](~/add/codesnippet/cpp/m-system.threading.threa_17_1.cpp)]"
  syntax:
    content: public static int GetDomainID ();
    parameters: []
    return:
      type: System.Int32
      description: "Inteiro sinal de 32 bits identificar exclusivamente o domínio de aplicação."
  overload: System.Threading.Thread.GetDomainID*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetHashCode
  id: GetHashCode
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetHashCode()
  nameWithType: Thread.GetHashCode()
  fullName: System.Threading.Thread.GetHashCode()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Devolve um código hash para o thread actual."
  remarks: "O código hash não é garantido ser exclusivo. Utilize o <xref:System.Threading.Thread.ManagedThreadId%2A>propriedade se precisar de um identificador exclusivo de um thread gerido.</xref:System.Threading.Thread.ManagedThreadId%2A>"
  syntax:
    content: public override int GetHashCode ();
    parameters: []
    return:
      type: System.Int32
      description: "Um valor de código de hash de número inteiro."
  overload: System.Threading.Thread.GetHashCode*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetNamedDataSlot(System.String)
  id: GetNamedDataSlot(System.String)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetNamedDataSlot(String)
  nameWithType: Thread.GetNamedDataSlot(String)
  fullName: System.Threading.Thread.GetNamedDataSlot(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Procura um bloco de dados com nome. Para um melhor desempenho, utilize os campos que são marcados com o <xref:System.ThreadStaticAttribute>atributo em vez disso.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]> O .NET Framework fornece dois mecanismos para utilizar o armazenamento local do thread (TLS): campos estáticos de thread relativo (ou seja, os campos que são marcados com o <xref:System.ThreadStaticAttribute>atributo) e blocos de dados.</xref:System.ThreadStaticAttribute> Campos estáticos de thread relativo fornecem muito melhor desempenho do que os blocos de dados e ativar a verificação de tipo de tempo de compilação. Para obter mais informações sobre a utilização de TLS, consulte [Thread armazenamento Local: campos estáticos de Thread relativo e dados ranhuras](~/add/includes/ajax-current-ext-md.md).       Threads de utilizam um mecanismo de memória de armazenamento local para armazenar dados específicos do thread. O language runtime atribui uma matriz de arquivo de dados de ranhura multi para cada processo quando é criado. O thread pode alocar um bloco de dados no arquivo de dados, armazenar e obter dados de valor na ranhura de e libertar a ranhura para serem reutilizadas depois do thread de expira. Ranhuras de dados são exclusivas por thread. Nenhum outro thread (não do mesmo thread um subordinado) pode obter os dados.       Se a ranhura com nome não existir, é atribuída a uma nova ranhura. Ranhuras de dados com nome são públicas e podem ser manipuladas a qualquer pessoa."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_13_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_13_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_13_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_13_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_13_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_13_2.vb)]"
  syntax:
    content: public static LocalDataStoreSlot GetNamedDataSlot (string name);
    parameters:
    - id: name
      type: System.String
      description: "O nome da ranhura de dados local."
    return:
      type: System.LocalDataStoreSlot
      description: "A <xref href=&quot;System.LocalDataStoreSlot&quot;> </xref> atribuído para este thread."
  overload: System.Threading.Thread.GetNamedDataSlot*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Interrupt
  id: Interrupt
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Interrupt()
  nameWithType: Thread.Interrupt()
  fullName: System.Threading.Thread.Interrupt()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Interrupções thread que está a ser o <xref uid=&quot;langword_csharp_WaitSleepJoin&quot; name=&quot;WaitSleepJoin&quot; href=&quot;&quot;> </xref> estado do thread."
  remarks: "Se este thread não está atualmente bloqueado num espera, modo de suspensão ou o estado de associação, irá ser interrompida quando começa junto a bloquear.       <xref:System.Threading.ThreadInterruptedException>é emitida o thread interrompido, mas não até os blocos de thread.</xref:System.Threading.ThreadInterruptedException> Se o thread nunca bloqueia, a exceção é acionada nunca e, por conseguinte, o thread pode ser concluída sem alguma vez que está a ser interrompido."
  example:
  - "The following code example shows the behavior of a running thread when it is interrupted and subsequently gets blocked.  \n  \n [!code-cpp[System.Threading.Thread.Interrupt#1](~/add/codesnippet/cpp/m-system.threading.threa_21_1.cpp)]\n [!code-vb[System.Threading.Thread.Interrupt#1](~/add/codesnippet/visualbasic/m-system.threading.threa_21_1.vb)]\n [!code-cs[System.Threading.Thread.Interrupt#1](~/add/codesnippet/csharp/m-system.threading.threa_21_1.cs)]"
  syntax:
    content: public void Interrupt ();
    parameters: []
  overload: System.Threading.Thread.Interrupt*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem o adequado <xref href=&quot;System.Security.Permissions.SecurityPermission&quot;> </xref>."
  platform:
  - net462
- uid: System.Threading.Thread.IsAlive
  id: IsAlive
  parent: System.Threading.Thread
  langs:
  - csharp
  name: IsAlive
  nameWithType: Thread.IsAlive
  fullName: System.Threading.Thread.IsAlive
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém um valor que indica o estado de execução do thread atual."
  syntax:
    content: public bool IsAlive { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se este thread foi iniciado e não tiver normalmente terminada ou abortada; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.IsAlive*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.IsBackground
  id: IsBackground
  parent: System.Threading.Thread
  langs:
  - csharp
  name: IsBackground
  nameWithType: Thread.IsBackground
  fullName: System.Threading.Thread.IsBackground
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém ou define um valor que indica se é ou não um thread um thread de segundo plano."
  remarks: "Um thread é o thread de segundo plano ou um thread de primeiro plano. Threads em segundo plano são idênticos aos threads de primeiro plano, à exceção de threads em segundo plano impede que um processo a terminar. Depois de todos os threads de primeiro plano que pertençam a um processo foi terminado, o tempo de execução de idioma comum termina o processo. Qualquer threads em segundo plano restantes são parados e não concluída.       Por predefinição, os threads seguintes executar em primeiro plano (ou seja, os respetivos devolve de propriedade IsBackground `false`):-o thread principal (ou o thread de aplicação principal).      -Todos os threads criados chamando um <xref:System.Threading.Thread>Construtor de classe.</xref:System.Threading.Thread>       Por predefinição, os threads seguintes executar em segundo plano (ou seja, os respetivos devolve de propriedade IsBackground `true`):-threads de agrupamento, que são um conjunto de threads de trabalho mantida pelo tempo de execução do Thread. Pode configurar o trabalho de agrupamento e o agendamento de threads em threads de conjunto de threads, utilizando a <xref:System.Threading.ThreadPool>classe.</xref:System.Threading.ThreadPool>          > [!NOTE] > Baseado em tarefas operações assíncronas executar automaticamente em threads de conjunto de threads.      -Todos os threads que introduzir o ambiente de execução gerido a partir do código não gerido."
  example:
  - "The following example contrasts the behavior of foreground and background threads. It creates a foreground thread and a background thread. The foreground thread keeps the process running until completes its `for` loop and terminates. However, as the output from the example shows, because the foreground thread has finished execution, the process is terminated before the background thread has completed execution.  \n  \n [!code-cs[System.Threading.Thread.IsBackground#1](~/add/codesnippet/csharp/p-system.threading.threa_7_1.cs)]\n [!code-cpp[System.Threading.Thread.IsBackground#1](~/add/codesnippet/cpp/p-system.threading.threa_7_1.cpp)]\n [!code-vb[System.Threading.Thread.IsBackground#1](~/add/codesnippet/visualbasic/p-system.threading.threa_7_1.vb)]"
  syntax:
    content: public bool IsBackground { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se este thread ou está a tornar-se de um thread de segundo plano; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.IsBackground*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "O thread está inactivo."
  platform:
  - net462
- uid: System.Threading.Thread.IsThreadPoolThread
  id: IsThreadPoolThread
  parent: System.Threading.Thread
  langs:
  - csharp
  name: IsThreadPoolThread
  nameWithType: Thread.IsThreadPoolThread
  fullName: System.Threading.Thread.IsThreadPoolThread
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém um valor que indica se é ou não um thread pertence ao conjunto de threads gerido."
  remarks: "Para obter mais informações consulte [agrupamento do Thread de gerido o](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example shows how to determine whether a thread is from the thread pool.  \n  \n [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/add/codesnippet/cpp/p-system.threading.threa_0_1.cpp)]\n [!code-cs[System.Threading.Thread.IsThreadPoolThread#1](~/add/codesnippet/csharp/p-system.threading.threa_0_1.cs)]\n [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/add/codesnippet/visualbasic/p-system.threading.threa_0_1.vb)]"
  syntax:
    content: public bool IsThreadPoolThread { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se este thread pertence ao conjunto de threads gerido; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.IsThreadPoolThread*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Join
  id: Join
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Join()
  nameWithType: Thread.Join()
  fullName: System.Threading.Thread.Join()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Bloqueia o thread que efectua até que o thread representado por esta instância termina, ao continuar a executar COM padrão e <xref uid=&quot;langword_csharp_SendMessage&quot; name=&quot;SendMessage&quot; href=&quot;&quot;> </xref> gerar."
  remarks: "A associação é um método de sincronização que bloqueia o thread de chamada (ou seja, o thread que chama o método) até que o thread cuja associação método é denominado foi concluída. Utilize este método para se certificar de que o thread foi terminado. O chamador irá bloquear indefinidamente, caso o thread não terminar. No exemplo seguinte, o `Thread1` thread chama o método de associação de `Thread2`, que faz com que `Thread1` para bloco até `Thread2` foi concluída.       [!code-cs[System.Threading.Thread.Join#1](~/add/codesnippet/csharp/m-system.threading.threa_24_1.cs)][!code-vb[System.Threading.Thread.Join#1](~/add/codesnippet/visualbasic/m-system.threading.threa_24_1.vb) ] se o thread já foi terminada quando <xref:System.Threading.Thread.Join%2A>é chamado o método devolve imediatamente.</xref:System.Threading.Thread.Join%2A>        > [!WARNING] > Nunca deve chamar o método de associação do <xref:System.Threading.Thread>objeto que representa o thread actual do thread atual.</xref:System.Threading.Thread> Isto faz com que a aplicação fique suspensa porque o thread actual tem de aguardar após a próprio indefinidamente, alterações este método o estado do thread que efectua a incluir <xref:System.Threading.ThreadState?displayProperty=fullName>.</xref:System.Threading.ThreadState?displayProperty=fullName> Não é possível invocar `Join` num thread que está a ser o <xref:System.Threading.ThreadState?displayProperty=fullName>Estado.</xref:System.Threading.ThreadState?displayProperty=fullName>"
  syntax:
    content: public void Join ();
    parameters: []
  overload: System.Threading.Thread.Join*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "O chamador tentou aderir a um thread que está a ser o <xref href=&quot;System.Threading.ThreadState&quot;> </xref> estado."
  - type: System.Threading.ThreadInterruptedException
    commentId: T:System.Threading.ThreadInterruptedException
    description: "O thread é interrompido ao aguardar a resposta."
  platform:
  - net462
- uid: System.Threading.Thread.Join(System.Int32)
  id: Join(System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Join(Int32)
  nameWithType: Thread.Join(Int32)
  fullName: System.Threading.Thread.Join(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Blocos de decorrido o thread que efectua até que o thread representado por esta instância termina ou o período de tempo especificado, ao continuar a executar COM padrão e SendMessage gerar."
  remarks: "A associação é um método de sincronização que bloqueia o thread de chamada (ou seja, o thread que chama o método) até que o thread de qualquer um dos cujo <xref:System.Threading.Thread.Join%2A>método é denominado foi concluída ou o intervalo de tempo limite expirou.</xref:System.Threading.Thread.Join%2A> No exemplo seguinte, o `Thread1` thread chamadas a <xref:System.Threading.Thread.Join>método de `Thread2`, que faz com que `Thread1` para bloquear o até `Thread2` foi concluída ou 2 segundos decorridos.</xref:System.Threading.Thread.Join>       [!code-cs[System.Threading.Thread.Join#2](~/add/codesnippet/csharp/m-system.threading.threa_8_1.cs)][!code-vb[System.Threading.Thread.Join#2](~/add/codesnippet/visualbasic/m-system.threading.threa_8_1.vb) ] se <xref:System.Threading.Timeout.Infinite?displayProperty=fullName>especificado para o `millisecondsTimeout` parâmetro, este método comporta-se de forma idêntica de <xref:System.Threading.Thread.Join>sobrecarga de método, exceto para o valor de retorno.</xref:System.Threading.Thread.Join> </xref:System.Threading.Timeout.Infinite?displayProperty=fullName>         Se o thread já foi terminada quando <xref:System.Threading.Thread.Join%2A>é chamado o método devolve imediatamente.</xref:System.Threading.Thread.Join%2A>       Este método altera o estado do thread que efectua a incluir <xref:System.Threading.ThreadState?displayProperty=fullName>.</xref:System.Threading.ThreadState?displayProperty=fullName> Não é possível invocar `Join` num thread que está a ser o <xref:System.Threading.ThreadState?displayProperty=fullName>Estado.</xref:System.Threading.ThreadState?displayProperty=fullName>"
  syntax:
    content: public bool Join (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "O número de milissegundos a aguardar para terminar o thread."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o thread foi terminada; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> se o thread não foi terminada após o período de tempo especificado pelo <code> millisecondsTimeout </code> parâmetro tiver decorrido."
  overload: System.Threading.Thread.Join*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "O valor de <code> millisecondsTimeout </code> é negativo e não é igual ao &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; em milissegundos."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "O thread não foi iniciado."
  platform:
  - net462
- uid: System.Threading.Thread.Join(System.TimeSpan)
  id: Join(System.TimeSpan)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Join(TimeSpan)
  nameWithType: Thread.Join(TimeSpan)
  fullName: System.Threading.Thread.Join(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Blocos de decorrido o thread que efectua até que o thread representado por esta instância termina ou o período de tempo especificado, ao continuar a executar COM padrão e SendMessage gerar."
  remarks: "A associação é um método de sincronização que bloqueia o thread de chamada (ou seja, o thread que chama o método) até que o thread de qualquer um dos cujo <xref:System.Threading.Thread.Join%2A>método é denominado foi concluída ou o intervalo de tempo limite expirou.</xref:System.Threading.Thread.Join%2A> No exemplo seguinte, o `Thread1` thread chamadas a <xref:System.Threading.Thread.Join>método de `Thread2`, que faz com que `Thread1` para bloquear o até `Thread2` foi concluída ou 2 segundos decorridos.</xref:System.Threading.Thread.Join>       [!code-cs[System.Threading.Thread.Join#3](~/add/codesnippet/csharp/m-system.threading.threa_28_1.cs)][!code-vb[System.Threading.Thread.Join#3](~/add/codesnippet/visualbasic/m-system.threading.threa_28_1.vb) ] se <xref:System.Threading.Timeout.Infinite?displayProperty=fullName>especificado para `timeout`, este método comporta-se de forma idêntica do <xref:System.Threading.Thread.Join>sobrecarga de método, exceto para o valor de retorno.</xref:System.Threading.Thread.Join> </xref:System.Threading.Timeout.Infinite?displayProperty=fullName>         Se o thread já foi terminada quando <xref:System.Threading.Thread.Join%2A>é chamado o método devolve imediatamente.</xref:System.Threading.Thread.Join%2A>       Este método altera o estado do thread atual para incluir <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> Não é possível invocar `Join` num thread que está a ser o <xref:System.Threading.ThreadState?displayProperty=fullName>Estado.</xref:System.Threading.ThreadState?displayProperty=fullName>"
  example:
  - "The following code example demonstrates how to use a `TimeSpan` value with the `Join` method.  \n  \n [!code-cpp[System.Threading.Thread.Timespan#1](~/add/codesnippet/cpp/m-system.threading.threa_28_2.cpp)]\n [!code-cs[System.Threading.Thread.Timespan#1](~/add/codesnippet/csharp/m-system.threading.threa_28_2.cs)]\n [!code-vb[System.Threading.Thread.Timespan#1](~/add/codesnippet/visualbasic/m-system.threading.threa_28_2.vb)]"
  syntax:
    content: public bool Join (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "A <xref:System.TimeSpan>definido como a quantidade de tempo ao aguardar por thread terminar.</xref:System.TimeSpan>"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o thread foi terminado; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> se o thread não foi terminada após o período de tempo especificado pelo <code> timeout </code> parâmetro tiver decorrido."
  overload: System.Threading.Thread.Join*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "O valor de <code> timeout </code> é negativo e não é igual ao &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; em milissegundos, ou é superior ao &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt; milissegundos."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "O chamador tentou aderir a um thread que está a ser o <xref href=&quot;System.Threading.ThreadState&quot;> </xref> estado."
  platform:
  - net462
- uid: System.Threading.Thread.ManagedThreadId
  id: ManagedThreadId
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ManagedThreadId
  nameWithType: Thread.ManagedThreadId
  fullName: System.Threading.Thread.ManagedThreadId
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém um identificador exclusivo para o thread actual gerido."
  remarks: "O valor da propriedade ManagedThreadId um thread serve para identificar exclusivamente essa thread dentro do respetivo processo.       O valor da propriedade ManagedThreadId varia ao longo do tempo, mesmo que o thread como um fibra implementa o código não gerido que aloja o language runtime."
  syntax:
    content: public int ManagedThreadId { get; }
    return:
      type: System.Int32
      description: "Um número inteiro que representa um identificador exclusivo para este thread gerido."
  overload: System.Threading.Thread.ManagedThreadId*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.MemoryBarrier
  id: MemoryBarrier
  parent: System.Threading.Thread
  langs:
  - csharp
  name: MemoryBarrier()
  nameWithType: Thread.MemoryBarrier()
  fullName: System.Threading.Thread.MemoryBarrier()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: 'Sincroniza o acesso à memória da seguinte forma: O processador de execução do thread atual não é possível reordenar as instruções em como executar de forma a que acede a memória antes da chamada para MemoryBarrier depois de acessos de memória que siga a chamada para MemoryBarrier.'
  remarks: "MemoryBarrier é necessário apenas em sistemas com multiprocessamento com memória fraca ordenar (por exemplo, um sistema empregar vários processadores Intel Itanium).       Para fins, a maioria do c# `lock` instrução, o Visual Basic `SyncLock` declaração, ou o <xref:System.Threading.Monitor>classe fornecem formas mais fácil para sincronizar dados.</xref:System.Threading.Monitor>"
  syntax:
    content: public static void MemoryBarrier ();
    parameters: []
  overload: System.Threading.Thread.MemoryBarrier*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Name
  id: Name
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Name
  nameWithType: Thread.Name
  fullName: System.Threading.Thread.Name
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém ou define o nome do thread."
  remarks: "Esta propriedade é escrita-uma vez. Porque o valor predefinido da propriedade de nome de um thread é `null`, pode determinar se um nome já foi explicitamente atribuído para o thread comparando-o com `null`.       A cadeia atribuída à propriedade nome pode incluir qualquer caráter Unicode."
  example:
  - "The following example shows how to name a thread.  \n  \n [!code-cs[System.Threading.Thread.Name#1](~/add/codesnippet/csharp/p-system.threading.threa_4_1.cs)]\n [!code-cpp[System.Threading.Thread.Name#1](~/add/codesnippet/cpp/p-system.threading.threa_4_1.cpp)]\n [!code-vb[System.Threading.Thread.Name#1](~/add/codesnippet/visualbasic/p-system.threading.threa_4_1.vb)]"
  syntax:
    content: public string Name { get; set; }
    return:
      type: System.String
      description: "Uma cadeia contendo o nome do thread, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> não se foi definido nenhum nome."
  overload: System.Threading.Thread.Name*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Foi pedida uma operação de definição, mas o <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> propriedade já foi definida."
  platform:
  - net462
- uid: System.Threading.Thread.Priority
  id: Priority
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Priority
  nameWithType: Thread.Priority
  fullName: System.Threading.Thread.Priority
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém ou define um valor que indica a prioridade de agendamento de um thread."
  remarks: "Um thread pode ser atribuído a qualquer um da seguinte prioridade <xref:System.Threading.ThreadPriority>valores:- `Highest`       -    `AboveNormal`       -    `Normal`       -    `BelowNormal`       -    `Lowest` sistemas operativos não são necessários para honrar a prioridade de um thread.</xref:System.Threading.ThreadPriority>"
  example:
  - "The following example shows the result of changing the priority of a thread. Three threads are created, the priority of one thread is set to <xref:System.Threading.ThreadPriority?displayProperty=fullName>, and the priority of a second is set to <xref:System.Threading.ThreadPriority?displayProperty=fullName>. Each thread increments a variable in a `while` loop and runs for a set time.  \n  \n [!code-cs[System.Threading.ThreadPriority#1](~/add/codesnippet/csharp/p-system.threading.threa_6_1.cs)]\n [!code-vb[System.Threading.ThreadPriority#1](~/add/codesnippet/visualbasic/p-system.threading.threa_6_1.vb)]"
  syntax:
    content: public System.Threading.ThreadPriority Priority { get; set; }
    return:
      type: System.Threading.ThreadPriority
      description: "Um do <xref href=&quot;System.Threading.ThreadPriority&quot;> </xref> valores. O valor predefinido é <xref href=&quot;System.Threading.ThreadPriority&quot;> </xref>."
  overload: System.Threading.Thread.Priority*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "O thread atingiu um estado final, tais como <xref href=&quot;System.Threading.ThreadState&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O valor especificado para uma operação de definição não é um <xref href=&quot;System.Threading.ThreadPriority&quot;> </xref> valor."
  platform:
  - net462
- uid: System.Threading.Thread.ResetAbort
  id: ResetAbort
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ResetAbort()
  nameWithType: Thread.ResetAbort()
  fullName: System.Threading.Thread.ResetAbort()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Cancela uma <xref:System.Threading.Thread.Abort*>pedida para o thread actual.</xref:System.Threading.Thread.Abort*>"
  remarks: "Este método só pode ser chamado por código com as permissões adequadas.       Quando é efetuada uma chamada para `Abort` terminar um thread, o sistema emite <xref:System.Threading.ThreadAbortException>.</xref:System.Threading.ThreadAbortException> `ThreadAbortException`é uma exceção de especial que pode ser detetada pelo código da aplicação, mas é novamente iniciada no fim do bloco catch, a menos que `ResetAbort` é chamado. `ResetAbort`Cancela o pedido para abortar e impede o `ThreadAbortException` de terminar o thread.       Consulte <xref:System.Threading.ThreadAbortException>para obter um exemplo que demonstra a chamar o `ResetAbort` método.</xref:System.Threading.ThreadAbortException>"
  syntax:
    content: public static void ResetAbort ();
    parameters: []
  overload: System.Threading.Thread.ResetAbort*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "<xref uid=&quot;langword_csharp_Abort&quot; name=&quot;Abort&quot; href=&quot;&quot;></xref>Não foi invocada no thread atual."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem a permissão de segurança necessárias para o thread actual."
  platform:
  - net462
- uid: System.Threading.Thread.Resume
  id: Resume
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Resume()
  nameWithType: Thread.Resume()
  fullName: System.Threading.Thread.Resume()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Retoma um thread que foi suspenso."
  remarks: >-
    > [!CAUTION]

    >  Do not use the <xref:System.Threading.Thread.Suspend%2A> and Resume methods to synchronize the activities of threads. You have no way of knowing what code a thread is executing when you suspend it. If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <xref:System.AppDomain> might be blocked. If you suspend a thread while it is executing a class constructor, other threads in the <xref:System.AppDomain> that attempt to use that class are blocked. Deadlocks can occur very easily.
  syntax:
    content: public void Resume ();
    parameters: []
  overload: System.Threading.Thread.Resume*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "O thread não foi iniciado, está inactivo ou não está no estado suspenso."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem o adequado <xref href=&quot;System.Security.Permissions.SecurityPermission&quot;> </xref>."
  platform:
  - net462
- uid: System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)
  id: SetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SetApartmentState(ApartmentState)
  nameWithType: Thread.SetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.SetApartmentState(ApartmentState)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Define o estado de apartamento de thread antes de que é iniciado."
  remarks: "Novo threads são inicializados como <xref:System.Threading.ApartmentState?displayProperty=fullName>se respetivo estado de apartamento não foi definido antes de serem iniciadas.</xref:System.Threading.ApartmentState?displayProperty=fullName> Estado apartment tem de ser definido antes de um thread é iniciado.      > [!NOTE] > O thread de aplicação principal é inicializado <xref:System.Threading.ApartmentState?displayProperty=fullName>por predefinição.</xref:System.Threading.ApartmentState?displayProperty=fullName> A única forma de definir o estado apartment do thread para aplicação principal <xref:System.Threading.ApartmentState?displayProperty=fullName>é para aplicar o <xref:System.STAThreadAttribute>atributo para o método de ponto de entrada.</xref:System.STAThreadAttribute> </xref:System.Threading.ApartmentState?displayProperty=fullName>       O método SetApartmentState, juntamente com o <xref:System.Threading.Thread.GetApartmentState%2A>método e o <xref:System.Threading.Thread.TrySetApartmentState%2A>substitui o método, o <xref:System.Threading.Thread.ApartmentState%2A>propriedade.</xref:System.Threading.Thread.ApartmentState%2A> </xref:System.Threading.Thread.TrySetApartmentState%2A> </xref:System.Threading.Thread.GetApartmentState%2A>"
  example:
  - "The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, SetApartmentState, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods. The code example creates a thread. Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState?displayProperty=fullName> state and SetApartmentState changes the state to <xref:System.Threading.ApartmentState?displayProperty=fullName>. The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState?displayProperty=fullName> because the apartment state is already set. If the same operation had been attempted with SetApartmentState, <xref:System.InvalidOperationException> would have been thrown.  \n  \n After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again. This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.  \n  \n [!code-vb[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/visualbasic/m-system.threading.threa_6_1.vb)]\n [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/cpp/m-system.threading.threa_6_1.cpp)]\n [!code-cs[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/csharp/m-system.threading.threa_6_1.cs)]"
  syntax:
    content: public void SetApartmentState (System.Threading.ApartmentState state);
    parameters:
    - id: state
      type: System.Threading.ApartmentState
      description: "O estado apartment de novo."
  overload: System.Threading.Thread.SetApartmentState*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>state</code>Não é um estado apartment válido."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "O thread já foi iniciado."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O estado de apartamento já foram inicializado."
  platform:
  - net462
- uid: System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)
  id: SetCompressedStack(System.Threading.CompressedStack)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SetCompressedStack(CompressedStack)
  nameWithType: Thread.SetCompressedStack(CompressedStack)
  fullName: System.Threading.Thread.SetCompressedStack(CompressedStack)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Aplica-se um capturada <xref href=&quot;System.Threading.CompressedStack&quot;> </xref> ao thread actual."
  remarks: "Este método já não é suportado."
  syntax:
    content: public void SetCompressedStack (System.Threading.CompressedStack stack);
    parameters:
    - id: stack
      type: System.Threading.CompressedStack
      description: "O <xref href=&quot;System.Threading.CompressedStack&quot;> </xref> objecto a aplicar ao thread actual."
  overload: System.Threading.Thread.SetCompressedStack*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Em todos os casos."
  platform:
  - net462
- uid: System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)
  id: SetData(System.LocalDataStoreSlot,System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SetData(LocalDataStoreSlot,Object)
  nameWithType: Thread.SetData(LocalDataStoreSlot,Object)
  fullName: System.Threading.Thread.SetData(LocalDataStoreSlot,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Define os dados na ranhura de especificado no thread em execução, para o domínio atual nesse thread. Para um melhor desempenho, utilize campos marcados com o <xref:System.ThreadStaticAttribute>atributo em vez disso.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]> O .NET Framework fornece dois mecanismos para utilizar o armazenamento local do thread (TLS): campos estáticos de thread relativo (ou seja, os campos que são marcados com o <xref:System.ThreadStaticAttribute>atributo) e blocos de dados.</xref:System.ThreadStaticAttribute> Campos estáticos de thread relativo fornecem muito melhor desempenho do que os blocos de dados e ativar a verificação de tipo de tempo de compilação. Para obter mais informações sobre a utilização de TLS, consulte [Thread armazenamento Local: campos estáticos de Thread relativo e dados ranhuras](~/add/includes/ajax-current-ext-md.md).       Threads de utilizam um mecanismo de memória de armazenamento local para armazenar dados específicos do thread. O language runtime atribui uma matriz de arquivo de dados de ranhura multi para cada processo quando é criado. O thread pode alocar um bloco de dados no arquivo de dados, armazenar e obter dados de valor na ranhura de e libertar a ranhura para serem reutilizadas após terminar o procedimento de thread e a <xref:System.Threading.Thread>objeto tem sido recuperado através da recolha de lixo.</xref:System.Threading.Thread> Ranhuras de dados são exclusivas por thread. Nenhum outro thread (não do mesmo thread um subordinado) pode obter os dados.      > [!NOTE] > SetData é um `Shared` método sempre aplica-se a thread atualmente em execução, mesmo se chamá-la utilizando uma variável que se refira a outro thread. Para evitar confusões, utilize o nome de classe ao chamar `Shared` métodos: `Thread.SetData(testSlot, &quot;test data&quot;)`."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_4_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_4_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_4_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_4_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_4_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_4_2.vb)]"
  syntax:
    content: public static void SetData (LocalDataStoreSlot slot, object data);
    parameters:
    - id: slot
      type: System.LocalDataStoreSlot
      description: "O <xref href=&quot;System.LocalDataStoreSlot&quot;> </xref> no qual pretende definir o valor."
    - id: data
      type: System.Object
      description: "O valor a ser definido."
  overload: System.Threading.Thread.SetData*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Sleep(System.Int32)
  id: Sleep(System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Sleep(Int32)
  nameWithType: Thread.Sleep(Int32)
  fullName: System.Threading.Thread.Sleep(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Suspende o thread atual para o número especificado de milissegundos."
  remarks: "O thread não será agendado para execução pelo sistema operativo para a quantidade de tempo especificado. Este método altera o estado do thread para incluir <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState>       Pode especificar <xref:System.Threading.Timeout.Infinite?displayProperty=fullName>para o `millisecondsTimeout` parâmetro para suspender o thread indefinidamente.</xref:System.Threading.Timeout.Infinite?displayProperty=fullName> No entanto, recomendamos que utilize outro <xref:System.Threading?displayProperty=fullName>classes, tal como <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, ou <xref:System.Threading.Semaphore>em vez disso, para sychronize threads ou gerir os recursos.</xref:System.Threading.Semaphore> </xref:System.Threading.EventWaitHandle> </xref:System.Threading.Monitor> </xref:System.Threading.Mutex> </xref:System.Threading?displayProperty=fullName>       Os batimentos serão relógio de sistema uma taxa específico chamado a resolução do relógio. O limite de tempo real pode não ser exatamente o tempo limite especificado, porque o tempo limite especificado será ajustado para a operação com batimentos de relógio. Para obter mais informações sobre resolução de relógio e o tempo de espera, consulte o [no modo de suspensão função](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) tópico. Este método chama o [no modo de suspensão função](http://msdn.microsoft.com/en-us/library/windows/desktop/ms686298.aspx) do sistema Windows APIs.       Este método não efetua padrão COM e SendMessage gerar.      > [!NOTE] > Se precisa de suspensão num thread que tenha <xref:System.STAThreadAttribute>, mas que pretende efetuar padrão COM e SendMessage gerar, considere a utilização de uma das sobrecargas do <xref:System.Threading.Thread.Join%2A>método que especifica um intervalo de tempo limite.</xref:System.Threading.Thread.Join%2A> </xref:System.STAThreadAttribute>"
  example:
  - "The following example uses the Sleep method to block the application's main thread.  \n  \n [!code-cs[Thread.Sleep#1](~/add/codesnippet/csharp/m-system.threading.threa_2_1.cs)]\n [!code-vb[Thread.Sleep#1](~/add/codesnippet/visualbasic/m-system.threading.threa_2_1.vb)]\n [!code-cpp[Thread.Sleep#1](~/add/codesnippet/cpp/m-system.threading.threa_2_1.cpp)]"
  syntax:
    content: public static void Sleep (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "O número de milissegundos para o qual o thread está suspenso. Se o valor da `millisecondsTimeout` argumento for zero, o thread relinquishes o resto do respetivo intervalo de tempo para qualquer thread do igual prioridade que está pronta para ser executado. Se existirem não existem outros threads igual prioridade que estão prontos para ser executada, a execução do thread atual não é suspenso."
  overload: System.Threading.Thread.Sleep*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "O valor de tempo limite é negativo e não é igual ao <xref:System.Threading.Timeout.Infinite>.</xref:System.Threading.Timeout.Infinite>"
  platform:
  - net462
- uid: System.Threading.Thread.Sleep(System.TimeSpan)
  id: Sleep(System.TimeSpan)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Sleep(TimeSpan)
  nameWithType: Thread.Sleep(TimeSpan)
  fullName: System.Threading.Thread.Sleep(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Suspende o thread atual para o período de tempo especificado."
  remarks: "O thread não será agendado para execução pelo sistema operativo para a quantidade de tempo especificado. Este método altera o estado do thread para incluir <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState>       Pode especificar <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName>para o `timeout` parâmetro para suspender o thread indefinidamente.</xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName> No entanto, recomendamos que utilize outro <xref:System.Threading?displayProperty=fullName>classes, tal como <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, ou <xref:System.Threading.Semaphore>em vez disso, para sychronize threads ou gerir os recursos.</xref:System.Threading.Semaphore> </xref:System.Threading.EventWaitHandle> </xref:System.Threading.Monitor> </xref:System.Threading.Mutex> </xref:System.Threading?displayProperty=fullName>       Esta sobrecarga de <xref:System.Threading.Thread.Sleep%2A>utiliza o número total de milissegundos inteiros no `timeout`.</xref:System.Threading.Thread.Sleep%2A> Milissegundos fracional são eliminados.       Este método não efetua padrão COM e SendMessage gerar.      > [!NOTE] > Se precisa de suspensão num thread que tenha <xref:System.STAThreadAttribute>, mas que pretende efetuar padrão COM e SendMessage gerar, considere a utilização de uma das sobrecargas do <xref:System.Threading.Thread.Join%2A>método que especifica um intervalo de tempo limite.</xref:System.Threading.Thread.Join%2A> </xref:System.STAThreadAttribute>"
  example:
  - "The following example uses the Sleep method overload to block the application's main thread five times, for two seconds each time.  \n  \n [!code-cpp[Thread.Sleep_TimeSpan#1](~/add/codesnippet/cpp/m-system.threading.threa_31_1.cpp)]\n [!code-cs[Thread.Sleep_TimeSpan#1](~/add/codesnippet/csharp/m-system.threading.threa_31_1.cs)]\n [!code-vb[Thread.Sleep_TimeSpan#1](~/add/codesnippet/visualbasic/m-system.threading.threa_31_1.vb)]"
  syntax:
    content: public static void Sleep (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "A quantidade de tempo para o qual o thread está suspenso. Se o valor da `millisecondsTimeout` argumento é &lt;xref:System.TimeSpan?displayProperty=fullName&gt;, o thread relinquishes o resto do respetivo intervalo de tempo para qualquer thread do igual prioridade que está pronta para ser executado. Se existirem não existem outros threads igual prioridade que estão prontos para ser executada, a execução do thread atual não é suspenso."
  overload: System.Threading.Thread.Sleep*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "O valor de <code> timeout </code> é negativo e não é igual ao &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; em milissegundos, ou é superior ao &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt; milissegundos."
  platform:
  - net462
- uid: System.Threading.Thread.SpinWait(System.Int32)
  id: SpinWait(System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SpinWait(Int32)
  nameWithType: Thread.SpinWait(Int32)
  fullName: System.Threading.Thread.SpinWait(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Faz com que um thread para aguardar o número de vezes definidos pelo <code> iterations </code> parâmetro."
  remarks: "O método SpinWait é útil para implementar as bloqueios. Classes no .NET Framework, tais como <xref:System.Threading.Monitor>e <xref:System.Threading.ReaderWriterLock>, utilize este método internamente.</xref:System.Threading.ReaderWriterLock> </xref:System.Threading.Monitor> SpinWait coloca essencialmente o processador no ciclo muito sólido, com a contagem de ciclo especificada pelo `iterations` parâmetro. Durante a espera depende, por conseguinte, a velocidade do processador.       Contraste isto com o <xref:System.Threading.Thread.Sleep%2A>método.</xref:System.Threading.Thread.Sleep%2A> Um thread que chama <xref:System.Threading.Thread.Sleep%2A>gera o resto do respetivo setor atual de tempo do processador, mesmo que o intervalo especificado é zero.</xref:System.Threading.Thread.Sleep%2A> Especificar um intervalo de diferente de zero para <xref:System.Threading.Thread.Sleep%2A>Remove o thread de consideração pelo programador thread até que o intervalo de tempo decorrido.</xref:System.Threading.Thread.Sleep%2A>       SpinWait não é, geralmente, útil para aplicações comum. Na maioria dos casos, deve utilizar as classes de sincronização fornecidas pelo .NET Framework; Por exemplo, chamada <xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName>ou uma instrução que encapsula num wrapper <xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName>(`lock` em c# ou `SyncLock` no Visual Basic).</xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName> </xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName>      > [!CAUTION] > No caso de raro, onde é vantajoso para evitar um comutador de contexto, por exemplo, quando sabe que uma alteração de estado é imminent, efetuar uma chamada ao método SpinWait no seu ciclo. O código que spinwait executa foi concebido para impedir que os problemas que podem ocorrer em computadores com vários processadores. Por exemplo, em computadores com vários processadores Intel a utilização de tecnologia Hyper-Threading, SpinWait impede a carência de processador em determinadas situações."
  syntax:
    content: public static void SpinWait (int iterations);
    parameters:
    - id: iterations
      type: System.Int32
      description: "Um 32-bit número inteiro com sinal que define quanto tempo um thread é de esperar."
  overload: System.Threading.Thread.SpinWait*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Start
  id: Start
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Start()
  nameWithType: Thread.Start()
  fullName: System.Threading.Thread.Start()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Faz com que o sistema operativo alterar o estado da instância atual <xref href=&quot;System.Threading.ThreadState&quot;> </xref>."
  remarks: "Depois de um thread é no <xref:System.Threading.ThreadState?displayProperty=fullName>Estado, o sistema operativo pode agendá-la para execução.</xref:System.Threading.ThreadState?displayProperty=fullName> O thread começa a executar na primeira linha do método representado pelo <xref:System.Threading.ThreadStart>ou <xref:System.Threading.ParameterizedThreadStart>delegado fornecido para o construtor de thread.</xref:System.Threading.ParameterizedThreadStart> </xref:System.Threading.ThreadStart> Tenha em atenção que a chamada de início não bloqueia o thread de chamada.      > [!NOTE] > Se esta sobrecarga é utilizada com um thread criado utilizando uma <xref:System.Threading.ParameterizedThreadStart>delegar, `null` é transmitido ao método executado pelo thread.</xref:System.Threading.ParameterizedThreadStart>       Assim que o thread termina, não podendo ser reiniciada com outra chamada `Start`."
  example:
  - "The following example creates and starts a thread.  \n  \n [!code-cpp[ThreadStart#1](~/add/codesnippet/cpp/m-system.threading.threa_25_1.cpp)]\n [!code-cs[ThreadStart#1](~/add/codesnippet/csharp/m-system.threading.threa_25_1.cs)]\n [!code-vb[ThreadStart#1](~/add/codesnippet/visualbasic/m-system.threading.threa_25_1.vb)]"
  syntax:
    content: public void Start ();
    parameters: []
  overload: System.Threading.Thread.Start*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "O thread já foi iniciado."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória disponível suficiente para iniciar este thread."
  platform:
  - net462
- uid: System.Threading.Thread.Start(System.Object)
  id: Start(System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Start(Object)
  nameWithType: Thread.Start(Object)
  fullName: System.Threading.Thread.Start(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Faz com que o sistema operativo alterar o estado da instância atual <xref href=&quot;System.Threading.ThreadState&quot;> </xref>e, opcionalmente, forneça um objeto que contém os dados a ser utilizado pelo método executa o thread."
  remarks: "Depois de um thread é no <xref:System.Threading.ThreadState?displayProperty=fullName>Estado, o sistema operativo pode agendá-la para execução.</xref:System.Threading.ThreadState?displayProperty=fullName> O thread começa a executar na primeira linha do método representado pelo <xref:System.Threading.ThreadStart>ou <xref:System.Threading.ParameterizedThreadStart>delegado fornecido para o construtor de thread.</xref:System.Threading.ParameterizedThreadStart> </xref:System.Threading.ThreadStart> Tenha em atenção que a chamada de início não bloqueia o thread de chamada.       Assim que o thread termina, não podendo ser reiniciada com outra chamada `Start`.       Esta sobrecarga e a <xref:System.Threading.ParameterizedThreadStart>delegado torna mais fácil transmitir dados para um procedimento de thread, mas a técnica não é seguro porque qualquer objeto possam ser transmitido para esta sobrecarga de.</xref:System.Threading.ParameterizedThreadStart> Uma forma mais robusta para transmitir dados para um procedimento de thread é colocar o procedimento de thread e os campos de dados para um objeto de trabalho. Para obter mais informações, consulte [criar Threads e transmissão de dados na hora de início](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example creates a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.  \n  \n [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/cpp/m-system.threading.threa_15_1.cpp)]\n [!code-vb[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/visualbasic/m-system.threading.threa_15_1.vb)]\n [!code-cs[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/csharp/m-system.threading.threa_15_1.cs)]"
  syntax:
    content: public void Start (object parameter);
    parameters:
    - id: parameter
      type: System.Object
      description: "Um objeto que contém dados para ser utilizado pelo método o thread de execução."
  overload: System.Threading.Thread.Start*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "O thread já foi iniciado."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória disponível suficiente para iniciar este thread."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Este thread foi criado utilizando uma <xref href=&quot;System.Threading.ThreadStart&quot;> </xref> delegar em vez de um <xref href=&quot;System.Threading.ParameterizedThreadStart&quot;> </xref> delegar."
  platform:
  - net462
- uid: System.Threading.Thread.Suspend
  id: Suspend
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Suspend()
  nameWithType: Thread.Suspend()
  fullName: System.Threading.Thread.Suspend()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Suspende o thread, ou se o thread já está suspenso, não tem qualquer efeito."
  remarks: "Se o thread já está suspenso, este método não tem efeito.      > [!CAUTION] > Não utilize a suspender e <xref:System.Threading.Thread.Resume%2A>métodos para sincronizar as atividades de threads.</xref:System.Threading.Thread.Resume%2A> Não tem nenhuma forma de saber o código de um thread está a executar quando suspende-lo. Se suspender um thread enquanto realiza bloqueios durante uma avaliação de permissão de segurança, outros threads no <xref:System.AppDomain>poderá ser bloqueado.</xref:System.AppDomain> Se suspender um thread enquanto está a executar um construtor de classe, outros threads no <xref:System.AppDomain>que tentam utilizar que classe estão bloqueadas.</xref:System.AppDomain> Impasses podem ocorrer muito facilmente."
  syntax:
    content: public void Suspend ();
    parameters: []
  overload: System.Threading.Thread.Suspend*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "O thread não foi iniciado ou está inactivo."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "O chamador não tem o adequado <xref href=&quot;System.Security.Permissions.SecurityPermission&quot;> </xref>."
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  id: System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Mapeia um conjunto de nomes para um conjunto de identificadores de emissão correspondente."
  remarks: "Este método é para acesso por classes geridas a partir do código não gerido e não deve ser chamado a partir do código gerido. Para obter mais informações sobre `IDispatch::GetIDsOfNames`, consulte a biblioteca da MSDN."
  syntax:
    content: void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
    parameters:
    - id: riid
      type: System.Guid
      description: "Reservado para utilização futura. Tem de ser IID_NULL."
    - id: rgszNames
      type: System.IntPtr
      description: "No passado a matriz de nomes deve ser mapeado."
    - id: cNames
      type: System.UInt32
      description: "Contagem dos nomes a ser mapeado."
    - id: lcid
      type: System.UInt32
      description: "O contexto de região na qual a interpretar os nomes."
    - id: rgDispId
      type: System.IntPtr
      description: "Matriz alocado de autor da chamada que recebe os IDs correspondentes aos nomes."
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Acesso de vinculação tardia utilizando o COM `IDispatch` interface não é suportada."
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  id: System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém as informações de tipo para um objeto, que, em seguida, pode ser utilizado para obter as informações de tipo para uma interface."
  remarks: "Este método é para acesso por classes geridas a partir do código não gerido e não deve ser chamado a partir do código gerido. Para obter mais informações sobre `IDispatch::GetTypeInfo`, consulte a biblioteca da MSDN."
  syntax:
    content: void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);
    parameters:
    - id: iTInfo
      type: System.UInt32
      description: "As informações de tipo de retorno."
    - id: lcid
      type: System.UInt32
      description: "O identificador de região para obter as informações de tipo."
    - id: ppTInfo
      type: System.IntPtr
      description: "Recebe um ponteiro para o objeto de informações do tipo pedido."
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Acesso de vinculação tardia utilizando o COM `IDispatch` interface não é suportada."
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  id: System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém o número de interfaces de informações de tipo que um objeto fornece (0 ou 1)."
  remarks: "Este método é para acesso por classes geridas a partir do código não gerido e não deve ser chamado a partir do código gerido. Para obter mais informações sobre `IDispatch::GetTypeInfoCount`, consulte a biblioteca da MSDN."
  syntax:
    content: void _Thread.GetTypeInfoCount (out uint pcTInfo);
    parameters:
    - id: pcTInfo
      type: System.UInt32
      description: "Aponta para uma localização que recebe o número de interfaces de informações de tipo fornecido pelo objeto."
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Acesso de vinculação tardia utilizando o COM `IDispatch` interface não é suportada."
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  id: System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Fornece acesso às propriedades e métodos expostos por um objeto."
  remarks: "Este método é para acesso por classes geridas a partir do código não gerido e não deve ser chamado a partir do código gerido. Para obter mais informações sobre `IDispatch::Invoke`, consulte a biblioteca da MSDN."
  syntax:
    content: void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    parameters:
    - id: dispIdMember
      type: System.UInt32
      description: "Identifica o membro."
    - id: riid
      type: System.Guid
      description: "Reservado para utilização futura. Tem de ser IID_NULL."
    - id: lcid
      type: System.UInt32
      description: "O contexto de região na qual interpretar argumentos."
    - id: wFlags
      type: System.Int16
      description: "Sinalizadores que descrevem o contexto da chamada."
    - id: pDispParams
      type: System.IntPtr
      description: "Apontador para uma estrutura que contém uma matriz de argumentos, uma matriz de argumento DISPID para os argumentos com nome e contagens para o número de elementos nas matrizes."
    - id: pVarResult
      type: System.IntPtr
      description: "Apontador para a localização onde o resultado é que sejam armazenadas."
    - id: pExcepInfo
      type: System.IntPtr
      description: "Apontador para uma estrutura que contém informações de exceção."
    - id: puArgErr
      type: System.IntPtr
      description: "O índice do primeiro argumento tem um erro."
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Acesso de vinculação tardia utilizando o COM `IDispatch` interface não é suportada."
  platform:
  - net462
- uid: System.Threading.Thread.ThreadState
  id: ThreadState
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ThreadState
  nameWithType: Thread.ThreadState
  fullName: System.Threading.Thread.ThreadState
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Obtém um valor que contém os Estados do thread atual."
  remarks: "A propriedade ThreadState fornece informações mais específicas que o <xref:System.Threading.Thread.IsAlive%2A>propriedade.</xref:System.Threading.Thread.IsAlive%2A>      > [!IMPORTANT] > Estado thread é apenas de interesse em cenários de depuração. O código nunca deve utilizar o estado de thread para sincronizar as atividades de threads."
  example:
  - "The following code example demonstrates accessing the `ThreadState` of a thread.  \n  \n [!code-cs[System.Threading.Thread.ThreadState#1](~/add/codesnippet/csharp/p-system.threading.threa_5_1.cs)]\n [!code-vb[System.Threading.Thread.ThreadState#1](~/add/codesnippet/visualbasic/p-system.threading.threa_5_1.vb)]\n [!code-cpp[System.Threading.Thread.ThreadState#1](~/add/codesnippet/cpp/p-system.threading.threa_5_1.cpp)]"
  syntax:
    content: public System.Threading.ThreadState ThreadState { get; }
    return:
      type: System.Threading.ThreadState
      description: "Um do <xref href=&quot;System.Threading.ThreadState&quot;> </xref> valores que indica o estado do thread atual. O valor inicial é <xref uid=&quot;langword_csharp_Unstarted&quot; name=&quot;Unstarted&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.ThreadState*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)
  id: TrySetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: TrySetApartmentState(ApartmentState)
  nameWithType: Thread.TrySetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.TrySetApartmentState(ApartmentState)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Define o estado de apartamento de thread antes de que é iniciado."
  remarks: "Novo threads são inicializados como <xref:System.Threading.ApartmentState?displayProperty=fullName>se respetivo estado de apartamento não foi definido antes de serem iniciadas.</xref:System.Threading.ApartmentState?displayProperty=fullName> Estado apartment tem de ser definido antes de um thread é iniciado.      > [!NOTE] > O thread de aplicação principal é inicializado <xref:System.Threading.ApartmentState?displayProperty=fullName>por predefinição.</xref:System.Threading.ApartmentState?displayProperty=fullName> A única forma de definir o estado apartment do thread para aplicação principal <xref:System.Threading.ApartmentState?displayProperty=fullName>é para aplicar o <xref:System.STAThreadAttribute>atributo para o método de ponto de entrada.</xref:System.STAThreadAttribute> </xref:System.Threading.ApartmentState?displayProperty=fullName>       O método TrySetApartmentState, juntamente com o <xref:System.Threading.Thread.GetApartmentState%2A>método e o <xref:System.Threading.Thread.SetApartmentState%2A>substitui o método, o <xref:System.Threading.Thread.ApartmentState%2A>propriedade.</xref:System.Threading.Thread.ApartmentState%2A> </xref:System.Threading.Thread.SetApartmentState%2A> </xref:System.Threading.Thread.GetApartmentState%2A>"
  example:
  - "The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and TrySetApartmentState methods. The code example creates a thread. Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState?displayProperty=fullName> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState?displayProperty=fullName>. The TrySetApartmentState method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState?displayProperty=fullName> because the apartment state is already set. If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.  \n  \n After the thread is started, the TrySetApartmentState method is used again. This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.  \n  \n [!code-vb[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/visualbasic/m-system.threading.threa_26_1.vb)]\n [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/cpp/m-system.threading.threa_26_1.cpp)]\n [!code-cs[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/csharp/m-system.threading.threa_26_1.cs)]"
  syntax:
    content: public bool TrySetApartmentState (System.Threading.ApartmentState state);
    parameters:
    - id: state
      type: System.Threading.ApartmentState
      description: "O estado apartment de novo."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se estiver definido o estado de apartamento; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.TrySetApartmentState*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>state</code>Não é um estado apartment válido."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "O thread já foi iniciado."
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Byte@)
  id: VolatileRead(System.Byte@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Byte)
  nameWithType: Thread.VolatileRead(Byte)
  fullName: System.Threading.Thread.VolatileRead(Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lê o valor de um campo. O valor é mais recente escrito por qualquer processador no computador, independentemente do número de processadores ou o estado da cache do processador."
  remarks: "VolatileRead e <xref:System.Threading.Thread.VolatileWrite%2A>são para casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` declaração e o <xref:System.Threading.Monitor>classe fornecer alternativas mais fácil.</xref:System.Threading.Monitor>       Num sistema com multiprocessamento, VolatileRead obtém o valor muito mais recente escrito para uma localização de memória por qualquer processador. Isto pode requerer a Limpar caches do processador.       Mesmo num sistema uniprocessor, VolatileRead e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).</xref:System.Threading.Thread.VolatileWrite%2A> Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.       Chamar este método afeta apenas um único acesso à memória do. Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar VolatileRead ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A>      > [!NOTE] > Em c#, utilizando o `volatile` modificador num campo garante que todos os acessos a esse campo utiliza VolatileRead ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A>"
  syntax:
    content: public static byte VolatileRead (ref byte address);
    parameters:
    - id: address
      type: System.Byte
      description: "O campo de leitura."
    return:
      type: System.Byte
      description: "O valor mais recente escrito para o campo por qualquer processador."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Double@)
  id: VolatileRead(System.Double@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Double)
  nameWithType: Thread.VolatileRead(Double)
  fullName: System.Threading.Thread.VolatileRead(Double)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lê o valor de um campo. O valor é mais recente escrito por qualquer processador no computador, independentemente do número de processadores ou o estado da cache do processador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são para casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` declaração e o <xref:System.Threading.Monitor>classe fornecer alternativas mais fácil.</xref:System.Threading.Monitor>       Num sistema com multiprocessamento, <xref:System.Threading.Thread.VolatileRead%2A>obtém o valor muito mais recente escrito para uma localização de memória por qualquer processador.</xref:System.Threading.Thread.VolatileRead%2A> Isto pode requerer a Limpar caches do processador.       Mesmo num sistema uniprocessor, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.       Chamar este método afeta apenas um único acesso à memória do. Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > Em c#, utilizando o `volatile` modificador num campo garante que todos os acessos a esse campo utiliza <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static double VolatileRead (ref double address);
    parameters:
    - id: address
      type: System.Double
      description: "O campo de leitura."
    return:
      type: System.Double
      description: "O valor mais recente escrito para o campo por qualquer processador."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Int16@)
  id: VolatileRead(System.Int16@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Int16)
  nameWithType: Thread.VolatileRead(Int16)
  fullName: System.Threading.Thread.VolatileRead(Int16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lê o valor de um campo. O valor é mais recente escrito por qualquer processador no computador, independentemente do número de processadores ou o estado da cache do processador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são para casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` declaração e o <xref:System.Threading.Monitor>classe fornecer alternativas mais fácil.</xref:System.Threading.Monitor>       Num sistema com multiprocessamento, <xref:System.Threading.Thread.VolatileRead%2A>obtém o valor muito mais recente escrito para uma localização de memória por qualquer processador.</xref:System.Threading.Thread.VolatileRead%2A> Isto pode requerer a Limpar caches do processador.       Mesmo num sistema uniprocessor, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.       Chamar este método afeta apenas um único acesso à memória do. Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > Em c#, utilizando o `volatile` modificador num campo garante que todos os acessos a esse campo utiliza <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static short VolatileRead (ref short address);
    parameters:
    - id: address
      type: System.Int16
      description: "O campo de leitura."
    return:
      type: System.Int16
      description: "O valor mais recente escrito para o campo por qualquer processador."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Int32@)
  id: VolatileRead(System.Int32@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Int32)
  nameWithType: Thread.VolatileRead(Int32)
  fullName: System.Threading.Thread.VolatileRead(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lê o valor de um campo. O valor é mais recente escrito por qualquer processador no computador, independentemente do número de processadores ou o estado da cache do processador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são para casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` declaração e o <xref:System.Threading.Monitor>classe fornecer alternativas mais fácil.</xref:System.Threading.Monitor>       Num sistema com multiprocessamento, <xref:System.Threading.Thread.VolatileRead%2A>obtém o valor muito mais recente escrito para uma localização de memória por qualquer processador.</xref:System.Threading.Thread.VolatileRead%2A> Isto pode requerer a Limpar caches do processador.       Mesmo num sistema uniprocessor, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.       Chamar este método afeta apenas um único acesso à memória do. Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > Em c#, utilizando o `volatile` modificador num campo garante que todos os acessos a esse campo utiliza <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static int VolatileRead (ref int address);
    parameters:
    - id: address
      type: System.Int32
      description: "O campo de leitura."
    return:
      type: System.Int32
      description: "O valor mais recente escrito para o campo por qualquer processador."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Int64@)
  id: VolatileRead(System.Int64@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Int64)
  nameWithType: Thread.VolatileRead(Int64)
  fullName: System.Threading.Thread.VolatileRead(Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lê o valor de um campo. O valor é mais recente escrito por qualquer processador no computador, independentemente do número de processadores ou o estado da cache do processador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são para casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` declaração e o <xref:System.Threading.Monitor>classe fornecer alternativas mais fácil.</xref:System.Threading.Monitor>       Num sistema com multiprocessamento, <xref:System.Threading.Thread.VolatileRead%2A>obtém o valor muito mais recente escrito para uma localização de memória por qualquer processador.</xref:System.Threading.Thread.VolatileRead%2A> Isto pode requerer a Limpar caches do processador.       Mesmo num sistema uniprocessor, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.       Chamar este método afeta apenas um único acesso à memória do. Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > Em c#, utilizando o `volatile` modificador num campo garante que todos os acessos a esse campo utiliza <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static long VolatileRead (ref long address);
    parameters:
    - id: address
      type: System.Int64
      description: "O campo de leitura."
    return:
      type: System.Int64
      description: "O valor mais recente escrito para o campo por qualquer processador."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.IntPtr@)
  id: VolatileRead(System.IntPtr@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(IntPtr)
  nameWithType: Thread.VolatileRead(IntPtr)
  fullName: System.Threading.Thread.VolatileRead(IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lê o valor de um campo. O valor é mais recente escrito por qualquer processador no computador, independentemente do número de processadores ou o estado da cache do processador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são para casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` declaração e o <xref:System.Threading.Monitor>classe fornecer alternativas mais fácil.</xref:System.Threading.Monitor>       Num sistema com multiprocessamento, <xref:System.Threading.Thread.VolatileRead%2A>obtém o valor muito mais recente escrito para uma localização de memória por qualquer processador.</xref:System.Threading.Thread.VolatileRead%2A> Isto pode requerer a Limpar caches do processador.       Mesmo num sistema uniprocessor, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.       Chamar este método afeta apenas um único acesso à memória do. Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > Em c#, utilizando o `volatile` modificador num campo garante que todos os acessos a esse campo utiliza <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static IntPtr VolatileRead (ref IntPtr address);
    parameters:
    - id: address
      type: System.IntPtr
      description: "O campo de leitura."
    return:
      type: System.IntPtr
      description: "O valor mais recente escrito para o campo por qualquer processador."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Object@)
  id: VolatileRead(System.Object@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Object)
  nameWithType: Thread.VolatileRead(Object)
  fullName: System.Threading.Thread.VolatileRead(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lê o valor de um campo. O valor é mais recente escrito por qualquer processador no computador, independentemente do número de processadores ou o estado da cache do processador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são para casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` declaração e o <xref:System.Threading.Monitor>classe fornecer alternativas mais fácil.</xref:System.Threading.Monitor>       Num sistema com multiprocessamento, <xref:System.Threading.Thread.VolatileRead%2A>obtém o valor muito mais recente escrito para uma localização de memória por qualquer processador.</xref:System.Threading.Thread.VolatileRead%2A> Isto pode requerer a Limpar caches do processador.       Mesmo num sistema uniprocessor, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.       Chamar este método afeta apenas um único acesso à memória do. Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > Em c#, utilizando o `volatile` modificador num campo garante que todos os acessos a esse campo utiliza <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static object VolatileRead (ref object address);
    parameters:
    - id: address
      type: System.Object
      description: "O campo de leitura."
    return:
      type: System.Object
      description: "O valor mais recente escrito para o campo por qualquer processador."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.SByte@)
  id: VolatileRead(System.SByte@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(SByte)
  nameWithType: Thread.VolatileRead(SByte)
  fullName: System.Threading.Thread.VolatileRead(SByte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lê o valor de um campo. O valor é mais recente escrito por qualquer processador no computador, independentemente do número de processadores ou o estado da cache do processador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são para casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` declaração e o <xref:System.Threading.Monitor>classe fornecer alternativas mais fácil.</xref:System.Threading.Monitor>       Num sistema com multiprocessamento, <xref:System.Threading.Thread.VolatileRead%2A>obtém o valor muito mais recente escrito para uma localização de memória por qualquer processador.</xref:System.Threading.Thread.VolatileRead%2A> Isto pode requerer a Limpar caches do processador.       Mesmo num sistema uniprocessor, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.       Chamar este método afeta apenas um único acesso à memória do. Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > Em c#, utilizando o `volatile` modificador num campo garante que todos os acessos a esse campo utiliza <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static sbyte VolatileRead (ref sbyte address);
    parameters:
    - id: address
      type: System.SByte
      description: "O campo de leitura."
    return:
      type: System.SByte
      description: "O valor mais recente escrito para o campo por qualquer processador."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Single@)
  id: VolatileRead(System.Single@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Single)
  nameWithType: Thread.VolatileRead(Single)
  fullName: System.Threading.Thread.VolatileRead(Single)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lê o valor de um campo. O valor é mais recente escrito por qualquer processador no computador, independentemente do número de processadores ou o estado da cache do processador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são para casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` declaração e o <xref:System.Threading.Monitor>classe fornecer alternativas mais fácil.</xref:System.Threading.Monitor>       Num sistema com multiprocessamento, <xref:System.Threading.Thread.VolatileRead%2A>obtém o valor muito mais recente escrito para uma localização de memória por qualquer processador.</xref:System.Threading.Thread.VolatileRead%2A> Isto pode requerer a Limpar caches do processador.       Mesmo num sistema uniprocessor, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.       Chamar este método afeta apenas um único acesso à memória do. Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > Em c#, utilizando o `volatile` modificador num campo garante que todos os acessos a esse campo utiliza <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static float VolatileRead (ref float address);
    parameters:
    - id: address
      type: System.Single
      description: "O campo de leitura."
    return:
      type: System.Single
      description: "O valor mais recente escrito para o campo por qualquer processador."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UInt16@)
  id: VolatileRead(System.UInt16@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UInt16)
  nameWithType: Thread.VolatileRead(UInt16)
  fullName: System.Threading.Thread.VolatileRead(UInt16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lê o valor de um campo. O valor é mais recente escrito por qualquer processador no computador, independentemente do número de processadores ou o estado da cache do processador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são para casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` declaração e o <xref:System.Threading.Monitor>classe fornecer alternativas mais fácil.</xref:System.Threading.Monitor>       Num sistema com multiprocessamento, <xref:System.Threading.Thread.VolatileRead%2A>obtém o valor muito mais recente escrito para uma localização de memória por qualquer processador.</xref:System.Threading.Thread.VolatileRead%2A> Isto pode requerer a Limpar caches do processador.       Mesmo num sistema uniprocessor, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.       Chamar este método afeta apenas um único acesso à memória do. Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > Em c#, utilizando o `volatile` modificador num campo garante que todos os acessos a esse campo utiliza <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static ushort VolatileRead (ref ushort address);
    parameters:
    - id: address
      type: System.UInt16
      description: "O campo de leitura."
    return:
      type: System.UInt16
      description: "O valor mais recente escrito para o campo por qualquer processador."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UInt32@)
  id: VolatileRead(System.UInt32@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UInt32)
  nameWithType: Thread.VolatileRead(UInt32)
  fullName: System.Threading.Thread.VolatileRead(UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lê o valor de um campo. O valor é mais recente escrito por qualquer processador no computador, independentemente do número de processadores ou o estado da cache do processador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são para casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` declaração e o <xref:System.Threading.Monitor>classe fornecer alternativas mais fácil.</xref:System.Threading.Monitor>       Num sistema com multiprocessamento, <xref:System.Threading.Thread.VolatileRead%2A>obtém o valor muito mais recente escrito para uma localização de memória por qualquer processador.</xref:System.Threading.Thread.VolatileRead%2A> Isto pode requerer a Limpar caches do processador.       Mesmo num sistema uniprocessor, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.       Chamar este método afeta apenas um único acesso à memória do. Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > Em c#, utilizando o `volatile` modificador num campo garante que todos os acessos a esse campo utiliza <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static uint VolatileRead (ref uint address);
    parameters:
    - id: address
      type: System.UInt32
      description: "O campo de leitura."
    return:
      type: System.UInt32
      description: "O valor mais recente escrito para o campo por qualquer processador."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UInt64@)
  id: VolatileRead(System.UInt64@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UInt64)
  nameWithType: Thread.VolatileRead(UInt64)
  fullName: System.Threading.Thread.VolatileRead(UInt64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lê o valor de um campo. O valor é mais recente escrito por qualquer processador no computador, independentemente do número de processadores ou o estado da cache do processador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são para casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` declaração e o <xref:System.Threading.Monitor>classe fornecer alternativas mais fácil.</xref:System.Threading.Monitor>       Num sistema com multiprocessamento, <xref:System.Threading.Thread.VolatileRead%2A>obtém o valor muito mais recente escrito para uma localização de memória por qualquer processador.</xref:System.Threading.Thread.VolatileRead%2A> Isto pode requerer a Limpar caches do processador.       Mesmo num sistema uniprocessor, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.       Chamar este método afeta apenas um único acesso à memória do. Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > Em c#, utilizando o `volatile` modificador num campo garante que todos os acessos a esse campo utiliza <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static ulong VolatileRead (ref ulong address);
    parameters:
    - id: address
      type: System.UInt64
      description: "O campo de leitura."
    return:
      type: System.UInt64
      description: "O valor mais recente escrito para o campo por qualquer processador."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UIntPtr@)
  id: VolatileRead(System.UIntPtr@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UIntPtr)
  nameWithType: Thread.VolatileRead(UIntPtr)
  fullName: System.Threading.Thread.VolatileRead(UIntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Lê o valor de um campo. O valor é mais recente escrito por qualquer processador no computador, independentemente do número de processadores ou o estado da cache do processador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são para casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` declaração e o <xref:System.Threading.Monitor>classe fornecer alternativas mais fácil.</xref:System.Threading.Monitor>       Num sistema com multiprocessamento, <xref:System.Threading.Thread.VolatileRead%2A>obtém o valor muito mais recente escrito para uma localização de memória por qualquer processador.</xref:System.Threading.Thread.VolatileRead%2A> Isto pode requerer a Limpar caches do processador.       Mesmo num sistema uniprocessor, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.       Chamar este método afeta apenas um único acesso à memória do. Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > Em c#, utilizando o `volatile` modificador num campo garante que todos os acessos a esse campo utiliza <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static UIntPtr VolatileRead (ref UIntPtr address);
    parameters:
    - id: address
      type: System.UIntPtr
      description: "O campo de leitura."
    return:
      type: System.UIntPtr
      description: "O valor mais recente escrito para o campo por qualquer processador."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)
  id: VolatileWrite(System.Byte@,System.Byte)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Byte,Byte)
  nameWithType: Thread.VolatileWrite(Byte,Byte)
  fullName: System.Threading.Thread.VolatileWrite(Byte,Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Escreve um valor de um campo imediatamente, para que o valor é visível para todos os processadores do computador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e VolatileWrite para casos especiais de sincronização.</xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` declaração e o <xref:System.Threading.Monitor>classe fornecer alternativas mais fácil.</xref:System.Threading.Monitor>       Num sistema com multiprocessamento, VolatileWrite garante que um valor escrito para uma localização de memória é imediatamente visível para todos os processadores. Isto pode requerer a Limpar caches do processador.       Mesmo num sistema uniprocessor, <xref:System.Threading.Thread.VolatileRead%2A>e VolatileWrite Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).</xref:System.Threading.Thread.VolatileRead%2A> Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.       Chamar este método afeta apenas um único acesso à memória do. Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar <xref:System.Threading.Thread.VolatileRead%2A>ou VolatileWrite.</xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > Em c#, utilizando o `volatile` modificador num campo garante que todos os acessos a esse campo utiliza <xref:System.Threading.Thread.VolatileRead%2A>ou VolatileWrite.</xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref byte address, byte value);
    parameters:
    - id: address
      type: System.Byte
      description: "O campo ao qual o valor está a ser escrito."
    - id: value
      type: System.Byte
      description: "O valor a ser escrito."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Double@,System.Double)
  id: VolatileWrite(System.Double@,System.Double)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Double,Double)
  nameWithType: Thread.VolatileWrite(Double,Double)
  fullName: System.Threading.Thread.VolatileWrite(Double,Double)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Escreve um valor de um campo imediatamente, para que o valor é visível para todos os processadores do computador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são para casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` declaração e o <xref:System.Threading.Monitor>classe fornecer alternativas mais fácil.</xref:System.Threading.Monitor>       Num sistema com multiprocessamento, <xref:System.Threading.Thread.VolatileWrite%2A>garante que um valor escrito para uma localização de memória é imediatamente visível para todos os processadores.</xref:System.Threading.Thread.VolatileWrite%2A> Isto pode requerer a Limpar caches do processador.       Mesmo num sistema uniprocessor, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.       Chamar este método afeta apenas um único acesso à memória do. Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > Em c#, utilizando o `volatile` modificador num campo garante que todos os acessos a esse campo utiliza <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref double address, double value);
    parameters:
    - id: address
      type: System.Double
      description: "O campo ao qual o valor está a ser escrito."
    - id: value
      type: System.Double
      description: "O valor a ser escrito."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)
  id: VolatileWrite(System.Int16@,System.Int16)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Int16,Int16)
  nameWithType: Thread.VolatileWrite(Int16,Int16)
  fullName: System.Threading.Thread.VolatileWrite(Int16,Int16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Escreve um valor de um campo imediatamente, para que o valor é visível para todos os processadores do computador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são para casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` declaração e o <xref:System.Threading.Monitor>classe fornecer alternativas mais fácil.</xref:System.Threading.Monitor>       Num sistema com multiprocessamento, <xref:System.Threading.Thread.VolatileWrite%2A>garante que um valor escrito para uma localização de memória é imediatamente visível para todos os processadores.</xref:System.Threading.Thread.VolatileWrite%2A> Isto pode requerer a Limpar caches do processador.       Mesmo num sistema uniprocessor, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.       Chamar este método afeta apenas um único acesso à memória do. Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > Em c#, utilizando o `volatile` modificador num campo garante que todos os acessos a esse campo utiliza <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref short address, short value);
    parameters:
    - id: address
      type: System.Int16
      description: "O campo ao qual o valor está a ser escrito."
    - id: value
      type: System.Int16
      description: "O valor a ser escrito."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)
  id: VolatileWrite(System.Int32@,System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Int32,Int32)
  nameWithType: Thread.VolatileWrite(Int32,Int32)
  fullName: System.Threading.Thread.VolatileWrite(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Escreve um valor de um campo imediatamente, para que o valor é visível para todos os processadores do computador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são para casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` declaração e o <xref:System.Threading.Monitor>classe fornecer alternativas mais fácil.</xref:System.Threading.Monitor>       Num sistema com multiprocessamento, <xref:System.Threading.Thread.VolatileWrite%2A>garante que um valor escrito para uma localização de memória é imediatamente visível para todos os processadores.</xref:System.Threading.Thread.VolatileWrite%2A> Isto pode requerer a Limpar caches do processador.       Mesmo num sistema uniprocessor, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.       Chamar este método afeta apenas um único acesso à memória do. Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > Em c#, utilizando o `volatile` modificador num campo garante que todos os acessos a esse campo utiliza <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref int address, int value);
    parameters:
    - id: address
      type: System.Int32
      description: "O campo ao qual o valor está a ser escrito."
    - id: value
      type: System.Int32
      description: "O valor a ser escrito."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)
  id: VolatileWrite(System.Int64@,System.Int64)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Int64,Int64)
  nameWithType: Thread.VolatileWrite(Int64,Int64)
  fullName: System.Threading.Thread.VolatileWrite(Int64,Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Escreve um valor de um campo imediatamente, para que o valor é visível para todos os processadores do computador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são para casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` declaração e o <xref:System.Threading.Monitor>classe fornecer alternativas mais fácil.</xref:System.Threading.Monitor>       Num sistema com multiprocessamento, <xref:System.Threading.Thread.VolatileWrite%2A>garante que um valor escrito para uma localização de memória é imediatamente visível para todos os processadores.</xref:System.Threading.Thread.VolatileWrite%2A> Isto pode requerer a Limpar caches do processador.       Mesmo num sistema uniprocessor, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.       Chamar este método afeta apenas um único acesso à memória do. Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > Em c#, utilizando o `volatile` modificador num campo garante que todos os acessos a esse campo utiliza <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref long address, long value);
    parameters:
    - id: address
      type: System.Int64
      description: "O campo ao qual o valor está a ser escrito."
    - id: value
      type: System.Int64
      description: "O valor a ser escrito."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)
  id: VolatileWrite(System.IntPtr@,System.IntPtr)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(IntPtr,IntPtr)
  nameWithType: Thread.VolatileWrite(IntPtr,IntPtr)
  fullName: System.Threading.Thread.VolatileWrite(IntPtr,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Escreve um valor de um campo imediatamente, para que o valor é visível para todos os processadores do computador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são para casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` declaração e o <xref:System.Threading.Monitor>classe fornecer alternativas mais fácil.</xref:System.Threading.Monitor>       Num sistema com multiprocessamento, <xref:System.Threading.Thread.VolatileWrite%2A>garante que um valor escrito para uma localização de memória é imediatamente visível para todos os processadores.</xref:System.Threading.Thread.VolatileWrite%2A> Isto pode requerer a Limpar caches do processador.       Mesmo num sistema uniprocessor, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.       Chamar este método afeta apenas um único acesso à memória do. Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > Em c#, utilizando o `volatile` modificador num campo garante que todos os acessos a esse campo utiliza <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref IntPtr address, IntPtr value);
    parameters:
    - id: address
      type: System.IntPtr
      description: "O campo ao qual o valor está a ser escrito."
    - id: value
      type: System.IntPtr
      description: "O valor a ser escrito."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Object@,System.Object)
  id: VolatileWrite(System.Object@,System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Object,Object)
  nameWithType: Thread.VolatileWrite(Object,Object)
  fullName: System.Threading.Thread.VolatileWrite(Object,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Escreve um valor de um campo imediatamente, para que o valor é visível para todos os processadores do computador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são para casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` declaração e o <xref:System.Threading.Monitor>classe fornecer alternativas mais fácil.</xref:System.Threading.Monitor>       Num sistema com multiprocessamento, <xref:System.Threading.Thread.VolatileWrite%2A>garante que um valor escrito para uma localização de memória é imediatamente visível para todos os processadores.</xref:System.Threading.Thread.VolatileWrite%2A> Isto pode requerer a Limpar caches do processador.       Mesmo num sistema uniprocessor, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.       Chamar este método afeta apenas um único acesso à memória do. Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > Em c#, utilizando o `volatile` modificador num campo garante que todos os acessos a esse campo utiliza <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref object address, object value);
    parameters:
    - id: address
      type: System.Object
      description: "O campo ao qual o valor está a ser escrito."
    - id: value
      type: System.Object
      description: "O valor a ser escrito."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)
  id: VolatileWrite(System.SByte@,System.SByte)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(SByte,SByte)
  nameWithType: Thread.VolatileWrite(SByte,SByte)
  fullName: System.Threading.Thread.VolatileWrite(SByte,SByte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Escreve um valor de um campo imediatamente, para que o valor é visível para todos os processadores do computador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são para casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` declaração e o <xref:System.Threading.Monitor>classe fornecer alternativas mais fácil.</xref:System.Threading.Monitor>       Num sistema com multiprocessamento, <xref:System.Threading.Thread.VolatileWrite%2A>garante que um valor escrito para uma localização de memória é imediatamente visível para todos os processadores.</xref:System.Threading.Thread.VolatileWrite%2A> Isto pode requerer a Limpar caches do processador.       Mesmo num sistema uniprocessor, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.       Chamar este método afeta apenas um único acesso à memória do. Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > Em c#, utilizando o `volatile` modificador num campo garante que todos os acessos a esse campo utiliza <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref sbyte address, sbyte value);
    parameters:
    - id: address
      type: System.SByte
      description: "O campo ao qual o valor está a ser escrito."
    - id: value
      type: System.SByte
      description: "O valor a ser escrito."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Single@,System.Single)
  id: VolatileWrite(System.Single@,System.Single)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Single,Single)
  nameWithType: Thread.VolatileWrite(Single,Single)
  fullName: System.Threading.Thread.VolatileWrite(Single,Single)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Escreve um valor de um campo imediatamente, para que o valor é visível para todos os processadores do computador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são para casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` declaração e o <xref:System.Threading.Monitor>classe fornecer alternativas mais fácil.</xref:System.Threading.Monitor>       Num sistema com multiprocessamento, <xref:System.Threading.Thread.VolatileWrite%2A>garante que um valor escrito para uma localização de memória é imediatamente visível para todos os processadores.</xref:System.Threading.Thread.VolatileWrite%2A> Isto pode requerer a Limpar caches do processador.       Mesmo num sistema uniprocessor, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.       Chamar este método afeta apenas um único acesso à memória do. Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > Em c#, utilizando o `volatile` modificador num campo garante que todos os acessos a esse campo utiliza <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref float address, float value);
    parameters:
    - id: address
      type: System.Single
      description: "O campo ao qual o valor está a ser escrito."
    - id: value
      type: System.Single
      description: "O valor a ser escrito."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)
  id: VolatileWrite(System.UInt16@,System.UInt16)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UInt16,UInt16)
  nameWithType: Thread.VolatileWrite(UInt16,UInt16)
  fullName: System.Threading.Thread.VolatileWrite(UInt16,UInt16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Escreve um valor de um campo imediatamente, para que o valor é visível para todos os processadores do computador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são para casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` declaração e o <xref:System.Threading.Monitor>classe fornecer alternativas mais fácil.</xref:System.Threading.Monitor>       Num sistema com multiprocessamento, <xref:System.Threading.Thread.VolatileWrite%2A>garante que um valor escrito para uma localização de memória é imediatamente visível para todos os processadores.</xref:System.Threading.Thread.VolatileWrite%2A> Isto pode requerer a Limpar caches do processador.       Mesmo num sistema uniprocessor, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.       Chamar este método afeta apenas um único acesso à memória do. Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > Em c#, utilizando o `volatile` modificador num campo garante que todos os acessos a esse campo utiliza <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref ushort address, ushort value);
    parameters:
    - id: address
      type: System.UInt16
      description: "O campo ao qual o valor está a ser escrito."
    - id: value
      type: System.UInt16
      description: "O valor a ser escrito."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)
  id: VolatileWrite(System.UInt32@,System.UInt32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UInt32,UInt32)
  nameWithType: Thread.VolatileWrite(UInt32,UInt32)
  fullName: System.Threading.Thread.VolatileWrite(UInt32,UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Escreve um valor de um campo imediatamente, para que o valor é visível para todos os processadores do computador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são para casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` declaração e o <xref:System.Threading.Monitor>classe fornecer alternativas mais fácil.</xref:System.Threading.Monitor>       Num sistema com multiprocessamento, <xref:System.Threading.Thread.VolatileWrite%2A>garante que um valor escrito para uma localização de memória é imediatamente visível para todos os processadores.</xref:System.Threading.Thread.VolatileWrite%2A> Isto pode requerer a Limpar caches do processador.       Mesmo num sistema uniprocessor, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.       Chamar este método afeta apenas um único acesso à memória do. Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > Em c#, utilizando o `volatile` modificador num campo garante que todos os acessos a esse campo utiliza <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref uint address, uint value);
    parameters:
    - id: address
      type: System.UInt32
      description: "O campo ao qual o valor está a ser escrito."
    - id: value
      type: System.UInt32
      description: "O valor a ser escrito."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)
  id: VolatileWrite(System.UInt64@,System.UInt64)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UInt64,UInt64)
  nameWithType: Thread.VolatileWrite(UInt64,UInt64)
  fullName: System.Threading.Thread.VolatileWrite(UInt64,UInt64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Escreve um valor de um campo imediatamente, para que o valor é visível para todos os processadores do computador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são para casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` declaração e o <xref:System.Threading.Monitor>classe fornecer alternativas mais fácil.</xref:System.Threading.Monitor>       Num sistema com multiprocessamento, <xref:System.Threading.Thread.VolatileWrite%2A>garante que um valor escrito para uma localização de memória é imediatamente visível para todos os processadores.</xref:System.Threading.Thread.VolatileWrite%2A> Isto pode requerer a Limpar caches do processador.       Mesmo num sistema uniprocessor, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.       Chamar este método afeta apenas um único acesso à memória do. Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > Em c#, utilizando o `volatile` modificador num campo garante que todos os acessos a esse campo utiliza <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref ulong address, ulong value);
    parameters:
    - id: address
      type: System.UInt64
      description: "O campo ao qual o valor está a ser escrito."
    - id: value
      type: System.UInt64
      description: "O valor a ser escrito."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)
  id: VolatileWrite(System.UIntPtr@,System.UIntPtr)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UIntPtr,UIntPtr)
  nameWithType: Thread.VolatileWrite(UIntPtr,UIntPtr)
  fullName: System.Threading.Thread.VolatileWrite(UIntPtr,UIntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Escreve um valor de um campo imediatamente, para que o valor é visível para todos os processadores do computador."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>são para casos especiais de sincronização.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` declaração e o <xref:System.Threading.Monitor>classe fornecer alternativas mais fácil.</xref:System.Threading.Monitor>       Num sistema com multiprocessamento, <xref:System.Threading.Thread.VolatileWrite%2A>garante que um valor escrito para uma localização de memória é imediatamente visível para todos os processadores.</xref:System.Threading.Thread.VolatileWrite%2A> Isto pode requerer a Limpar caches do processador.       Mesmo num sistema uniprocessor, <xref:System.Threading.Thread.VolatileRead%2A>e <xref:System.Threading.Thread.VolatileWrite%2A>Certifique-se que um valor de leitura ou escrita na memória e não colocadas em cache (por exemplo, no registo de processador).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Assim, pode utilizá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou por hardware.       Chamar este método afeta apenas um único acesso à memória do. Para fornecer sincronização efetiva de um campo, todo o acesso ao campo tem de utilizar <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > Em c#, utilizando o `volatile` modificador num campo garante que todos os acessos a esse campo utiliza <xref:System.Threading.Thread.VolatileRead%2A>ou <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref UIntPtr address, UIntPtr value);
    parameters:
    - id: address
      type: System.UIntPtr
      description: "O campo ao qual o valor está a ser escrito."
    - id: value
      type: System.UIntPtr
      description: "O valor a ser escrito."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Yield
  id: Yield
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Yield()
  nameWithType: Thread.Yield()
  fullName: System.Threading.Thread.Yield()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Faz com que o thread de chamada produzir a execução de outro thread que está pronto para executar o processador atual. O sistema operativo seleciona o thread para produzir para."
  remarks: "Se este método é concluída com êxito, é geraram o resto do setor de hora actual do thread. O sistema operativo agenda o thread de chamada de outro intervalo de tempo, em conformidade com a sua prioridade e o estado de outros threads que estão disponíveis para executar.       Gerar resultados está limitada para o processador que está a executar o thread de chamada. O sistema operativo não muda execução a outro processador, mesmo que esse processador está inativo ou está a executar um thread de menor prioridade. Se não existem não existem outros threads que estão prontos para executar o processador atual, o sistema operativo não produzir execução e este método devolve `false`.       Este método é equivalente ao utilizar plataforma invocar para chamar a Win32 nativo `SwitchToThread` função. Deve chamar Yield de invocação do método em vez de utilizar a plataforma, porque a plataforma invocar omissões qualquer comportamento thread personalizado, que o anfitrião está a ser pedido."
  syntax:
    content: public static bool Yield ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o sistema operativo execução de mudar para outro thread; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.Yield*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  isExternal: false
  name: System.Runtime.ConstrainedExecution.CriticalFinalizerObject
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.Threading.ThreadStateException
  parent: System.Threading
  isExternal: false
  name: ThreadStateException
  nameWithType: ThreadStateException
  fullName: System.Threading.ThreadStateException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Threading.ThreadInterruptedException
  parent: System.Threading
  isExternal: false
  name: ThreadInterruptedException
  nameWithType: ThreadInterruptedException
  fullName: System.Threading.ThreadInterruptedException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.NotImplementedException
  isExternal: true
  name: System.NotImplementedException
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ParameterizedThreadStart)
  nameWithType: Thread.Thread(ParameterizedThreadStart)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart)
- uid: System.Threading.ParameterizedThreadStart
  parent: System.Threading
  isExternal: false
  name: ParameterizedThreadStart
  nameWithType: ParameterizedThreadStart
  fullName: System.Threading.ParameterizedThreadStart
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ThreadStart)
  nameWithType: Thread.Thread(ThreadStart)
  fullName: System.Threading.Thread.Thread(ThreadStart)
- uid: System.Threading.ThreadStart
  parent: System.Threading
  isExternal: false
  name: ThreadStart
  nameWithType: ThreadStart
  fullName: System.Threading.ThreadStart
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ParameterizedThreadStart,Int32)
  nameWithType: Thread.Thread(ParameterizedThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ThreadStart,Int32)
  nameWithType: Thread.Thread(ThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ThreadStart,Int32)
- uid: System.Threading.Thread.Abort
  parent: System.Threading.Thread
  isExternal: false
  name: Abort()
  nameWithType: Thread.Abort()
  fullName: System.Threading.Thread.Abort()
- uid: System.Threading.Thread.Abort(System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: Abort(Object)
  nameWithType: Thread.Abort(Object)
  fullName: System.Threading.Thread.Abort(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Threading.Thread.AllocateDataSlot
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateDataSlot()
  nameWithType: Thread.AllocateDataSlot()
  fullName: System.Threading.Thread.AllocateDataSlot()
- uid: System.LocalDataStoreSlot
  parent: System
  isExternal: false
  name: LocalDataStoreSlot
  nameWithType: LocalDataStoreSlot
  fullName: System.LocalDataStoreSlot
- uid: System.Threading.Thread.AllocateNamedDataSlot(System.String)
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateNamedDataSlot(String)
  nameWithType: Thread.AllocateNamedDataSlot(String)
  fullName: System.Threading.Thread.AllocateNamedDataSlot(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Threading.Thread.ApartmentState
  parent: System.Threading.Thread
  isExternal: false
  name: ApartmentState
  nameWithType: Thread.ApartmentState
  fullName: System.Threading.Thread.ApartmentState
- uid: System.Threading.ApartmentState
  parent: System.Threading
  isExternal: false
  name: ApartmentState
  nameWithType: ApartmentState
  fullName: System.Threading.ApartmentState
- uid: System.Threading.Thread.BeginCriticalRegion
  parent: System.Threading.Thread
  isExternal: false
  name: BeginCriticalRegion()
  nameWithType: Thread.BeginCriticalRegion()
  fullName: System.Threading.Thread.BeginCriticalRegion()
- uid: System.Threading.Thread.BeginThreadAffinity
  parent: System.Threading.Thread
  isExternal: false
  name: BeginThreadAffinity()
  nameWithType: Thread.BeginThreadAffinity()
  fullName: System.Threading.Thread.BeginThreadAffinity()
- uid: System.Threading.Thread.CurrentContext
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentContext
  nameWithType: Thread.CurrentContext
  fullName: System.Threading.Thread.CurrentContext
- uid: System.Runtime.Remoting.Contexts.Context
  parent: System.Runtime.Remoting.Contexts
  isExternal: false
  name: Context
  nameWithType: Context
  fullName: System.Runtime.Remoting.Contexts.Context
- uid: System.Threading.Thread.CurrentCulture
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentCulture
  nameWithType: Thread.CurrentCulture
  fullName: System.Threading.Thread.CurrentCulture
- uid: System.Globalization.CultureInfo
  parent: System.Globalization
  isExternal: true
  name: CultureInfo
  nameWithType: CultureInfo
  fullName: System.Globalization.CultureInfo
- uid: System.Threading.Thread.CurrentPrincipal
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentPrincipal
  nameWithType: Thread.CurrentPrincipal
  fullName: System.Threading.Thread.CurrentPrincipal
- uid: System.Security.Principal.IPrincipal
  parent: System.Security.Principal
  isExternal: true
  name: IPrincipal
  nameWithType: IPrincipal
  fullName: System.Security.Principal.IPrincipal
- uid: System.Threading.Thread.CurrentThread
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentThread
  nameWithType: Thread.CurrentThread
  fullName: System.Threading.Thread.CurrentThread
- uid: System.Threading.Thread
  parent: System.Threading
  isExternal: false
  name: Thread
  nameWithType: Thread
  fullName: System.Threading.Thread
- uid: System.Threading.Thread.CurrentUICulture
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentUICulture
  nameWithType: Thread.CurrentUICulture
  fullName: System.Threading.Thread.CurrentUICulture
- uid: System.Threading.Thread.DisableComObjectEagerCleanup
  parent: System.Threading.Thread
  isExternal: false
  name: DisableComObjectEagerCleanup()
  nameWithType: Thread.DisableComObjectEagerCleanup()
  fullName: System.Threading.Thread.DisableComObjectEagerCleanup()
- uid: System.Threading.Thread.EndCriticalRegion
  parent: System.Threading.Thread
  isExternal: false
  name: EndCriticalRegion()
  nameWithType: Thread.EndCriticalRegion()
  fullName: System.Threading.Thread.EndCriticalRegion()
- uid: System.Threading.Thread.EndThreadAffinity
  parent: System.Threading.Thread
  isExternal: false
  name: EndThreadAffinity()
  nameWithType: Thread.EndThreadAffinity()
  fullName: System.Threading.Thread.EndThreadAffinity()
- uid: System.Threading.Thread.ExecutionContext
  parent: System.Threading.Thread
  isExternal: false
  name: ExecutionContext
  nameWithType: Thread.ExecutionContext
  fullName: System.Threading.Thread.ExecutionContext
- uid: System.Threading.ExecutionContext
  parent: System.Threading
  isExternal: true
  name: ExecutionContext
  nameWithType: ExecutionContext
  fullName: System.Threading.ExecutionContext
- uid: System.Threading.Thread.Finalize
  parent: System.Threading.Thread
  isExternal: false
  name: Finalize()
  nameWithType: Thread.Finalize()
  fullName: System.Threading.Thread.Finalize()
- uid: System.Threading.Thread.FreeNamedDataSlot(System.String)
  parent: System.Threading.Thread
  isExternal: false
  name: FreeNamedDataSlot(String)
  nameWithType: Thread.FreeNamedDataSlot(String)
  fullName: System.Threading.Thread.FreeNamedDataSlot(String)
- uid: System.Threading.Thread.GetApartmentState
  parent: System.Threading.Thread
  isExternal: false
  name: GetApartmentState()
  nameWithType: Thread.GetApartmentState()
  fullName: System.Threading.Thread.GetApartmentState()
- uid: System.Threading.Thread.GetCompressedStack
  parent: System.Threading.Thread
  isExternal: false
  name: GetCompressedStack()
  nameWithType: Thread.GetCompressedStack()
  fullName: System.Threading.Thread.GetCompressedStack()
- uid: System.Threading.CompressedStack
  parent: System.Threading
  isExternal: false
  name: CompressedStack
  nameWithType: CompressedStack
  fullName: System.Threading.CompressedStack
- uid: System.Threading.Thread.GetData(System.LocalDataStoreSlot)
  parent: System.Threading.Thread
  isExternal: false
  name: GetData(LocalDataStoreSlot)
  nameWithType: Thread.GetData(LocalDataStoreSlot)
  fullName: System.Threading.Thread.GetData(LocalDataStoreSlot)
- uid: System.Threading.Thread.GetDomain
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomain()
  nameWithType: Thread.GetDomain()
  fullName: System.Threading.Thread.GetDomain()
- uid: System.AppDomain
  parent: System
  isExternal: false
  name: AppDomain
  nameWithType: AppDomain
  fullName: System.AppDomain
- uid: System.Threading.Thread.GetDomainID
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomainID()
  nameWithType: Thread.GetDomainID()
  fullName: System.Threading.Thread.GetDomainID()
- uid: System.Threading.Thread.GetHashCode
  parent: System.Threading.Thread
  isExternal: false
  name: GetHashCode()
  nameWithType: Thread.GetHashCode()
  fullName: System.Threading.Thread.GetHashCode()
- uid: System.Threading.Thread.GetNamedDataSlot(System.String)
  parent: System.Threading.Thread
  isExternal: false
  name: GetNamedDataSlot(String)
  nameWithType: Thread.GetNamedDataSlot(String)
  fullName: System.Threading.Thread.GetNamedDataSlot(String)
- uid: System.Threading.Thread.Interrupt
  parent: System.Threading.Thread
  isExternal: false
  name: Interrupt()
  nameWithType: Thread.Interrupt()
  fullName: System.Threading.Thread.Interrupt()
- uid: System.Threading.Thread.IsAlive
  parent: System.Threading.Thread
  isExternal: false
  name: IsAlive
  nameWithType: Thread.IsAlive
  fullName: System.Threading.Thread.IsAlive
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.Thread.IsBackground
  parent: System.Threading.Thread
  isExternal: false
  name: IsBackground
  nameWithType: Thread.IsBackground
  fullName: System.Threading.Thread.IsBackground
- uid: System.Threading.Thread.IsThreadPoolThread
  parent: System.Threading.Thread
  isExternal: false
  name: IsThreadPoolThread
  nameWithType: Thread.IsThreadPoolThread
  fullName: System.Threading.Thread.IsThreadPoolThread
- uid: System.Threading.Thread.Join
  parent: System.Threading.Thread
  isExternal: false
  name: Join()
  nameWithType: Thread.Join()
  fullName: System.Threading.Thread.Join()
- uid: System.Threading.Thread.Join(System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Join(Int32)
  nameWithType: Thread.Join(Int32)
  fullName: System.Threading.Thread.Join(Int32)
- uid: System.Threading.Thread.Join(System.TimeSpan)
  parent: System.Threading.Thread
  isExternal: false
  name: Join(TimeSpan)
  nameWithType: Thread.Join(TimeSpan)
  fullName: System.Threading.Thread.Join(TimeSpan)
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Threading.Thread.ManagedThreadId
  parent: System.Threading.Thread
  isExternal: false
  name: ManagedThreadId
  nameWithType: Thread.ManagedThreadId
  fullName: System.Threading.Thread.ManagedThreadId
- uid: System.Threading.Thread.MemoryBarrier
  parent: System.Threading.Thread
  isExternal: false
  name: MemoryBarrier()
  nameWithType: Thread.MemoryBarrier()
  fullName: System.Threading.Thread.MemoryBarrier()
- uid: System.Threading.Thread.Name
  parent: System.Threading.Thread
  isExternal: false
  name: Name
  nameWithType: Thread.Name
  fullName: System.Threading.Thread.Name
- uid: System.Threading.Thread.Priority
  parent: System.Threading.Thread
  isExternal: false
  name: Priority
  nameWithType: Thread.Priority
  fullName: System.Threading.Thread.Priority
- uid: System.Threading.ThreadPriority
  parent: System.Threading
  isExternal: false
  name: ThreadPriority
  nameWithType: ThreadPriority
  fullName: System.Threading.ThreadPriority
- uid: System.Threading.Thread.ResetAbort
  parent: System.Threading.Thread
  isExternal: false
  name: ResetAbort()
  nameWithType: Thread.ResetAbort()
  fullName: System.Threading.Thread.ResetAbort()
- uid: System.Threading.Thread.Resume
  parent: System.Threading.Thread
  isExternal: false
  name: Resume()
  nameWithType: Thread.Resume()
  fullName: System.Threading.Thread.Resume()
- uid: System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  isExternal: false
  name: SetApartmentState(ApartmentState)
  nameWithType: Thread.SetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.SetApartmentState(ApartmentState)
- uid: System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)
  parent: System.Threading.Thread
  isExternal: false
  name: SetCompressedStack(CompressedStack)
  nameWithType: Thread.SetCompressedStack(CompressedStack)
  fullName: System.Threading.Thread.SetCompressedStack(CompressedStack)
- uid: System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: SetData(LocalDataStoreSlot,Object)
  nameWithType: Thread.SetData(LocalDataStoreSlot,Object)
  fullName: System.Threading.Thread.SetData(LocalDataStoreSlot,Object)
- uid: System.Threading.Thread.Sleep(System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Sleep(Int32)
  nameWithType: Thread.Sleep(Int32)
  fullName: System.Threading.Thread.Sleep(Int32)
- uid: System.Threading.Thread.Sleep(System.TimeSpan)
  parent: System.Threading.Thread
  isExternal: false
  name: Sleep(TimeSpan)
  nameWithType: Thread.Sleep(TimeSpan)
  fullName: System.Threading.Thread.Sleep(TimeSpan)
- uid: System.Threading.Thread.SpinWait(System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: SpinWait(Int32)
  nameWithType: Thread.SpinWait(Int32)
  fullName: System.Threading.Thread.SpinWait(Int32)
- uid: System.Threading.Thread.Start
  parent: System.Threading.Thread
  isExternal: false
  name: Start()
  nameWithType: Thread.Start()
  fullName: System.Threading.Thread.Start()
- uid: System.Threading.Thread.Start(System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: Start(Object)
  nameWithType: Thread.Start(Object)
  fullName: System.Threading.Thread.Start(Object)
- uid: System.Threading.Thread.Suspend
  parent: System.Threading.Thread
  isExternal: false
  name: Suspend()
  nameWithType: Thread.Suspend()
  fullName: System.Threading.Thread.Suspend()
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
- uid: System.Guid
  parent: System
  isExternal: true
  name: Guid
  nameWithType: Guid
  fullName: System.Guid
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.UInt32
  parent: System
  isExternal: true
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: System.Threading.Thread.ThreadState
  parent: System.Threading.Thread
  isExternal: false
  name: ThreadState
  nameWithType: Thread.ThreadState
  fullName: System.Threading.Thread.ThreadState
- uid: System.Threading.ThreadState
  parent: System.Threading
  isExternal: false
  name: ThreadState
  nameWithType: ThreadState
  fullName: System.Threading.ThreadState
- uid: System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  isExternal: false
  name: TrySetApartmentState(ApartmentState)
  nameWithType: Thread.TrySetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.TrySetApartmentState(ApartmentState)
- uid: System.Threading.Thread.VolatileRead(System.Byte@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Byte)
  nameWithType: Thread.VolatileRead(Byte)
  fullName: System.Threading.Thread.VolatileRead(Byte)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.Threading.Thread.VolatileRead(System.Double@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Double)
  nameWithType: Thread.VolatileRead(Double)
  fullName: System.Threading.Thread.VolatileRead(Double)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.Threading.Thread.VolatileRead(System.Int16@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Int16)
  nameWithType: Thread.VolatileRead(Int16)
  fullName: System.Threading.Thread.VolatileRead(Int16)
- uid: System.Threading.Thread.VolatileRead(System.Int32@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Int32)
  nameWithType: Thread.VolatileRead(Int32)
  fullName: System.Threading.Thread.VolatileRead(Int32)
- uid: System.Threading.Thread.VolatileRead(System.Int64@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Int64)
  nameWithType: Thread.VolatileRead(Int64)
  fullName: System.Threading.Thread.VolatileRead(Int64)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Threading.Thread.VolatileRead(System.IntPtr@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(IntPtr)
  nameWithType: Thread.VolatileRead(IntPtr)
  fullName: System.Threading.Thread.VolatileRead(IntPtr)
- uid: System.Threading.Thread.VolatileRead(System.Object@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Object)
  nameWithType: Thread.VolatileRead(Object)
  fullName: System.Threading.Thread.VolatileRead(Object)
- uid: System.Threading.Thread.VolatileRead(System.SByte@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(SByte)
  nameWithType: Thread.VolatileRead(SByte)
  fullName: System.Threading.Thread.VolatileRead(SByte)
- uid: System.SByte
  parent: System
  isExternal: true
  name: SByte
  nameWithType: SByte
  fullName: System.SByte
- uid: System.Threading.Thread.VolatileRead(System.Single@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Single)
  nameWithType: Thread.VolatileRead(Single)
  fullName: System.Threading.Thread.VolatileRead(Single)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: System.Threading.Thread.VolatileRead(System.UInt16@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UInt16)
  nameWithType: Thread.VolatileRead(UInt16)
  fullName: System.Threading.Thread.VolatileRead(UInt16)
- uid: System.UInt16
  parent: System
  isExternal: true
  name: UInt16
  nameWithType: UInt16
  fullName: System.UInt16
- uid: System.Threading.Thread.VolatileRead(System.UInt32@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UInt32)
  nameWithType: Thread.VolatileRead(UInt32)
  fullName: System.Threading.Thread.VolatileRead(UInt32)
- uid: System.Threading.Thread.VolatileRead(System.UInt64@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UInt64)
  nameWithType: Thread.VolatileRead(UInt64)
  fullName: System.Threading.Thread.VolatileRead(UInt64)
- uid: System.UInt64
  parent: System
  isExternal: true
  name: UInt64
  nameWithType: UInt64
  fullName: System.UInt64
- uid: System.Threading.Thread.VolatileRead(System.UIntPtr@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UIntPtr)
  nameWithType: Thread.VolatileRead(UIntPtr)
  fullName: System.Threading.Thread.VolatileRead(UIntPtr)
- uid: System.UIntPtr
  parent: System
  isExternal: true
  name: UIntPtr
  nameWithType: UIntPtr
  fullName: System.UIntPtr
- uid: System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Byte,Byte)
  nameWithType: Thread.VolatileWrite(Byte,Byte)
  fullName: System.Threading.Thread.VolatileWrite(Byte,Byte)
- uid: System.Threading.Thread.VolatileWrite(System.Double@,System.Double)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Double,Double)
  nameWithType: Thread.VolatileWrite(Double,Double)
  fullName: System.Threading.Thread.VolatileWrite(Double,Double)
- uid: System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Int16,Int16)
  nameWithType: Thread.VolatileWrite(Int16,Int16)
  fullName: System.Threading.Thread.VolatileWrite(Int16,Int16)
- uid: System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Int32,Int32)
  nameWithType: Thread.VolatileWrite(Int32,Int32)
  fullName: System.Threading.Thread.VolatileWrite(Int32,Int32)
- uid: System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Int64,Int64)
  nameWithType: Thread.VolatileWrite(Int64,Int64)
  fullName: System.Threading.Thread.VolatileWrite(Int64,Int64)
- uid: System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(IntPtr,IntPtr)
  nameWithType: Thread.VolatileWrite(IntPtr,IntPtr)
  fullName: System.Threading.Thread.VolatileWrite(IntPtr,IntPtr)
- uid: System.Threading.Thread.VolatileWrite(System.Object@,System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Object,Object)
  nameWithType: Thread.VolatileWrite(Object,Object)
  fullName: System.Threading.Thread.VolatileWrite(Object,Object)
- uid: System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(SByte,SByte)
  nameWithType: Thread.VolatileWrite(SByte,SByte)
  fullName: System.Threading.Thread.VolatileWrite(SByte,SByte)
- uid: System.Threading.Thread.VolatileWrite(System.Single@,System.Single)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Single,Single)
  nameWithType: Thread.VolatileWrite(Single,Single)
  fullName: System.Threading.Thread.VolatileWrite(Single,Single)
- uid: System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UInt16,UInt16)
  nameWithType: Thread.VolatileWrite(UInt16,UInt16)
  fullName: System.Threading.Thread.VolatileWrite(UInt16,UInt16)
- uid: System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UInt32,UInt32)
  nameWithType: Thread.VolatileWrite(UInt32,UInt32)
  fullName: System.Threading.Thread.VolatileWrite(UInt32,UInt32)
- uid: System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UInt64,UInt64)
  nameWithType: Thread.VolatileWrite(UInt64,UInt64)
  fullName: System.Threading.Thread.VolatileWrite(UInt64,UInt64)
- uid: System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UIntPtr,UIntPtr)
  nameWithType: Thread.VolatileWrite(UIntPtr,UIntPtr)
  fullName: System.Threading.Thread.VolatileWrite(UIntPtr,UIntPtr)
- uid: System.Threading.Thread.Yield
  parent: System.Threading.Thread
  isExternal: false
  name: Yield()
  nameWithType: Thread.Yield()
  fullName: System.Threading.Thread.Yield()
- uid: System.Threading.Thread.#ctor*
  parent: System.Threading.Thread
  isExternal: false
  name: Thread
  nameWithType: Thread.Thread
- uid: System.Threading.Thread.Abort*
  parent: System.Threading.Thread
  isExternal: false
  name: Abort
  nameWithType: Thread.Abort
- uid: System.Threading.Thread.AllocateDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateDataSlot
  nameWithType: Thread.AllocateDataSlot
- uid: System.Threading.Thread.AllocateNamedDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateNamedDataSlot
  nameWithType: Thread.AllocateNamedDataSlot
- uid: System.Threading.Thread.ApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: ApartmentState
  nameWithType: Thread.ApartmentState
- uid: System.Threading.Thread.BeginCriticalRegion*
  parent: System.Threading.Thread
  isExternal: false
  name: BeginCriticalRegion
  nameWithType: Thread.BeginCriticalRegion
- uid: System.Threading.Thread.BeginThreadAffinity*
  parent: System.Threading.Thread
  isExternal: false
  name: BeginThreadAffinity
  nameWithType: Thread.BeginThreadAffinity
- uid: System.Threading.Thread.CurrentContext*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentContext
  nameWithType: Thread.CurrentContext
- uid: System.Threading.Thread.CurrentCulture*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentCulture
  nameWithType: Thread.CurrentCulture
- uid: System.Threading.Thread.CurrentPrincipal*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentPrincipal
  nameWithType: Thread.CurrentPrincipal
- uid: System.Threading.Thread.CurrentThread*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentThread
  nameWithType: Thread.CurrentThread
- uid: System.Threading.Thread.CurrentUICulture*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentUICulture
  nameWithType: Thread.CurrentUICulture
- uid: System.Threading.Thread.DisableComObjectEagerCleanup*
  parent: System.Threading.Thread
  isExternal: false
  name: DisableComObjectEagerCleanup
  nameWithType: Thread.DisableComObjectEagerCleanup
- uid: System.Threading.Thread.EndCriticalRegion*
  parent: System.Threading.Thread
  isExternal: false
  name: EndCriticalRegion
  nameWithType: Thread.EndCriticalRegion
- uid: System.Threading.Thread.EndThreadAffinity*
  parent: System.Threading.Thread
  isExternal: false
  name: EndThreadAffinity
  nameWithType: Thread.EndThreadAffinity
- uid: System.Threading.Thread.ExecutionContext*
  parent: System.Threading.Thread
  isExternal: false
  name: ExecutionContext
  nameWithType: Thread.ExecutionContext
- uid: System.Threading.Thread.Finalize*
  parent: System.Threading.Thread
  isExternal: false
  name: Finalize
  nameWithType: Thread.Finalize
- uid: System.Threading.Thread.FreeNamedDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: FreeNamedDataSlot
  nameWithType: Thread.FreeNamedDataSlot
- uid: System.Threading.Thread.GetApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: GetApartmentState
  nameWithType: Thread.GetApartmentState
- uid: System.Threading.Thread.GetCompressedStack*
  parent: System.Threading.Thread
  isExternal: false
  name: GetCompressedStack
  nameWithType: Thread.GetCompressedStack
- uid: System.Threading.Thread.GetData*
  parent: System.Threading.Thread
  isExternal: false
  name: GetData
  nameWithType: Thread.GetData
- uid: System.Threading.Thread.GetDomain*
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomain
  nameWithType: Thread.GetDomain
- uid: System.Threading.Thread.GetDomainID*
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomainID
  nameWithType: Thread.GetDomainID
- uid: System.Threading.Thread.GetHashCode*
  parent: System.Threading.Thread
  isExternal: false
  name: GetHashCode
  nameWithType: Thread.GetHashCode
- uid: System.Threading.Thread.GetNamedDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: GetNamedDataSlot
  nameWithType: Thread.GetNamedDataSlot
- uid: System.Threading.Thread.Interrupt*
  parent: System.Threading.Thread
  isExternal: false
  name: Interrupt
  nameWithType: Thread.Interrupt
- uid: System.Threading.Thread.IsAlive*
  parent: System.Threading.Thread
  isExternal: false
  name: IsAlive
  nameWithType: Thread.IsAlive
- uid: System.Threading.Thread.IsBackground*
  parent: System.Threading.Thread
  isExternal: false
  name: IsBackground
  nameWithType: Thread.IsBackground
- uid: System.Threading.Thread.IsThreadPoolThread*
  parent: System.Threading.Thread
  isExternal: false
  name: IsThreadPoolThread
  nameWithType: Thread.IsThreadPoolThread
- uid: System.Threading.Thread.Join*
  parent: System.Threading.Thread
  isExternal: false
  name: Join
  nameWithType: Thread.Join
- uid: System.Threading.Thread.ManagedThreadId*
  parent: System.Threading.Thread
  isExternal: false
  name: ManagedThreadId
  nameWithType: Thread.ManagedThreadId
- uid: System.Threading.Thread.MemoryBarrier*
  parent: System.Threading.Thread
  isExternal: false
  name: MemoryBarrier
  nameWithType: Thread.MemoryBarrier
- uid: System.Threading.Thread.Name*
  parent: System.Threading.Thread
  isExternal: false
  name: Name
  nameWithType: Thread.Name
- uid: System.Threading.Thread.Priority*
  parent: System.Threading.Thread
  isExternal: false
  name: Priority
  nameWithType: Thread.Priority
- uid: System.Threading.Thread.ResetAbort*
  parent: System.Threading.Thread
  isExternal: false
  name: ResetAbort
  nameWithType: Thread.ResetAbort
- uid: System.Threading.Thread.Resume*
  parent: System.Threading.Thread
  isExternal: false
  name: Resume
  nameWithType: Thread.Resume
- uid: System.Threading.Thread.SetApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: SetApartmentState
  nameWithType: Thread.SetApartmentState
- uid: System.Threading.Thread.SetCompressedStack*
  parent: System.Threading.Thread
  isExternal: false
  name: SetCompressedStack
  nameWithType: Thread.SetCompressedStack
- uid: System.Threading.Thread.SetData*
  parent: System.Threading.Thread
  isExternal: false
  name: SetData
  nameWithType: Thread.SetData
- uid: System.Threading.Thread.Sleep*
  parent: System.Threading.Thread
  isExternal: false
  name: Sleep
  nameWithType: Thread.Sleep
- uid: System.Threading.Thread.SpinWait*
  parent: System.Threading.Thread
  isExternal: false
  name: SpinWait
  nameWithType: Thread.SpinWait
- uid: System.Threading.Thread.Start*
  parent: System.Threading.Thread
  isExternal: false
  name: Start
  nameWithType: Thread.Start
- uid: System.Threading.Thread.Suspend*
  parent: System.Threading.Thread
  isExternal: false
  name: Suspend
  nameWithType: Thread.Suspend
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetIDsOfNames
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfo
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfo
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfoCount
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.Invoke
  nameWithType: Thread.System.Runtime.InteropServices._Thread.Invoke
- uid: System.Threading.Thread.ThreadState*
  parent: System.Threading.Thread
  isExternal: false
  name: ThreadState
  nameWithType: Thread.ThreadState
- uid: System.Threading.Thread.TrySetApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: TrySetApartmentState
  nameWithType: Thread.TrySetApartmentState
- uid: System.Threading.Thread.VolatileRead*
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead
  nameWithType: Thread.VolatileRead
- uid: System.Threading.Thread.VolatileWrite*
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite
  nameWithType: Thread.VolatileWrite
- uid: System.Threading.Thread.Yield*
  parent: System.Threading.Thread
  isExternal: false
  name: Yield
  nameWithType: Thread.Yield
