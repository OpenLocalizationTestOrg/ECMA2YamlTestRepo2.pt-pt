### YamlMime:ManagedReference
items:
- uid: System.Diagnostics.Process
  id: Process
  children:
  - System.Diagnostics.Process.#ctor
  - System.Diagnostics.Process.BasePriority
  - System.Diagnostics.Process.BeginErrorReadLine
  - System.Diagnostics.Process.BeginOutputReadLine
  - System.Diagnostics.Process.CancelErrorRead
  - System.Diagnostics.Process.CancelOutputRead
  - System.Diagnostics.Process.Close
  - System.Diagnostics.Process.CloseMainWindow
  - System.Diagnostics.Process.Dispose(System.Boolean)
  - System.Diagnostics.Process.EnableRaisingEvents
  - System.Diagnostics.Process.EnterDebugMode
  - System.Diagnostics.Process.ErrorDataReceived
  - System.Diagnostics.Process.ExitCode
  - System.Diagnostics.Process.Exited
  - System.Diagnostics.Process.ExitTime
  - System.Diagnostics.Process.GetCurrentProcess
  - System.Diagnostics.Process.GetProcessById(System.Int32)
  - System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  - System.Diagnostics.Process.GetProcesses
  - System.Diagnostics.Process.GetProcesses(System.String)
  - System.Diagnostics.Process.GetProcessesByName(System.String)
  - System.Diagnostics.Process.GetProcessesByName(System.String,System.String)
  - System.Diagnostics.Process.Handle
  - System.Diagnostics.Process.HandleCount
  - System.Diagnostics.Process.HasExited
  - System.Diagnostics.Process.Id
  - System.Diagnostics.Process.Kill
  - System.Diagnostics.Process.LeaveDebugMode
  - System.Diagnostics.Process.MachineName
  - System.Diagnostics.Process.MainModule
  - System.Diagnostics.Process.MainWindowHandle
  - System.Diagnostics.Process.MainWindowTitle
  - System.Diagnostics.Process.MaxWorkingSet
  - System.Diagnostics.Process.MinWorkingSet
  - System.Diagnostics.Process.Modules
  - System.Diagnostics.Process.NonpagedSystemMemorySize
  - System.Diagnostics.Process.NonpagedSystemMemorySize64
  - System.Diagnostics.Process.OnExited
  - System.Diagnostics.Process.OutputDataReceived
  - System.Diagnostics.Process.PagedMemorySize
  - System.Diagnostics.Process.PagedMemorySize64
  - System.Diagnostics.Process.PagedSystemMemorySize
  - System.Diagnostics.Process.PagedSystemMemorySize64
  - System.Diagnostics.Process.PeakPagedMemorySize
  - System.Diagnostics.Process.PeakPagedMemorySize64
  - System.Diagnostics.Process.PeakVirtualMemorySize
  - System.Diagnostics.Process.PeakVirtualMemorySize64
  - System.Diagnostics.Process.PeakWorkingSet
  - System.Diagnostics.Process.PeakWorkingSet64
  - System.Diagnostics.Process.PriorityBoostEnabled
  - System.Diagnostics.Process.PriorityClass
  - System.Diagnostics.Process.PrivateMemorySize
  - System.Diagnostics.Process.PrivateMemorySize64
  - System.Diagnostics.Process.PrivilegedProcessorTime
  - System.Diagnostics.Process.ProcessName
  - System.Diagnostics.Process.ProcessorAffinity
  - System.Diagnostics.Process.Refresh
  - System.Diagnostics.Process.Responding
  - System.Diagnostics.Process.SafeHandle
  - System.Diagnostics.Process.SessionId
  - System.Diagnostics.Process.StandardError
  - System.Diagnostics.Process.StandardInput
  - System.Diagnostics.Process.StandardOutput
  - System.Diagnostics.Process.Start
  - System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  - System.Diagnostics.Process.Start(System.String)
  - System.Diagnostics.Process.Start(System.String,System.String)
  - System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)
  - System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  - System.Diagnostics.Process.StartInfo
  - System.Diagnostics.Process.StartTime
  - System.Diagnostics.Process.SynchronizingObject
  - System.Diagnostics.Process.Threads
  - System.Diagnostics.Process.ToString
  - System.Diagnostics.Process.TotalProcessorTime
  - System.Diagnostics.Process.UserProcessorTime
  - System.Diagnostics.Process.VirtualMemorySize
  - System.Diagnostics.Process.VirtualMemorySize64
  - System.Diagnostics.Process.WaitForExit
  - System.Diagnostics.Process.WaitForExit(System.Int32)
  - System.Diagnostics.Process.WaitForInputIdle
  - System.Diagnostics.Process.WaitForInputIdle(System.Int32)
  - System.Diagnostics.Process.WorkingSet
  - System.Diagnostics.Process.WorkingSet64
  langs:
  - csharp
  name: Process
  nameWithType: Process
  fullName: System.Diagnostics.Process
  type: Class
  summary: "Fornece acesso a processos locais e remotos e permite-lhe iniciar e parar processos do sistema local.       Para procurar o código de origem do .NET Framework para este tipo, consulte o [referência origem](http://referencesource.microsoft.com/#System/services/monitoring/system/diagnosticts/Process.cs#f8b2e604d6f1fe04)."
  remarks: "> [!NOTE]\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#System/services/monitoring/system/diagnosticts/Process.cs#f8b2e604d6f1fe04). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \n  \n A Process component provides access to a process that is running on a computer. A process, in the simplest terms, is a running app. A thread is the basic unit to which the operating system allocates processor time. A thread can execute any part of the code of the process, including parts currently being executed by another thread.  \n  \n The Process component is a useful tool for starting, stopping, controlling, and monitoring apps. You can use the Process component, to obtain a list of the processes that are running, or you can start a new process. A Process component is used to access system processes. After a Process component has been initialized, it can be used to obtain information about the running process. Such information includes the set of threads, the loaded modules (.dll and .exe files), and performance information such as the amount of memory the process is using.  \n  \n This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  \n  \n> [!NOTE]\n>  32-bit processes cannot access the modules of a 64-bit process. If you try to get information about a 64-bit process from a 32-bit process, you will get a <xref:System.ComponentModel.Win32Exception> exception. A 64-bit process, on the other hand, can access the modules of a 32-bit process.  \n  \n The process component obtains information about a group of properties all at once. After the Process component has obtained information about one member of any group, it will cache the values for the other properties in that group and not obtain new information about the other members of the group until you call the <xref:System.Diagnostics.Process.Refresh%2A> method. Therefore, a property value is not guaranteed to be any newer than the last call to the <xref:System.Diagnostics.Process.Refresh%2A> method. The group breakdowns are operating-system dependent.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n A system process is uniquely identified on the system by its process identifier. Like many Windows resources, a process is also identified by its handle, which might not be unique on the computer. A handle is the generic term for an identifier of a resource. The operating system persists the process handle, which is accessed through the <xref:System.Diagnostics.Process.Handle%2A> property of the Process component, even when the process has exited. Thus, you can get the process's administrative information, such as the <xref:System.Diagnostics.Process.ExitCode%2A> (usually either zero for success or a nonzero error code) and the <xref:System.Diagnostics.Process.ExitTime%2A>. Handles are an extremely valuable resource, so leaking handles is more virulent than leaking memory.  \n  \n> [!NOTE]\n>  This class contains a link demand and an inheritance demand at the class level that applies to all members. A <xref:System.Security.SecurityException> is thrown when either the immediate caller or the derived class does not have full-trust permission. For details about security demands, see [Link Demands](~/add/includes/ajax-current-ext-md.md).  \n  \n<a name=\"Core\"></a>   \n## [!INCLUDE[net_core](~/add/includes/net-core-md.md)] Notes  \n In the .NET Framework on the desktop, the Process class by default uses <xref:System.Console> encodings, which are typically code page encodings, for the input, output, and error streams. For example code, on systems whose culture is English (United States), code page 437 is the default encoding for the <xref:System.Console> class. However, [!INCLUDE[net_core](~/add/includes/net-core-md.md)] may make only a limited subset of these encodings available. If this is the case, it uses <xref:System.Text.Encoding.UTF8%2A?displayProperty=fullName> as the default encoding.  \n  \n If a Process object depends on specific code page encodings, you can still make them available by doing the following *before* you call any Process methods:  \n  \n1.  Add a reference to the System.Text.Encoding.CodePages.dll assembly to your project.  \n  \n2.  Retrieve the <xref:System.Text.EncodingProvider> object from the <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=fullName> property.  \n  \n3.  Pass the <xref:System.Text.EncodingProvider> object to the <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=fullName> method to make the additional encodings supported by the encoding provider available.  \n  \n The Process class will then automatically use the default system encoding rather than UTF8, provided that you have registered the encoding provider before calling any Process methods."
  example:
  - "The following example uses an instance of the Process class to start a process.  \n  \n [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/t-system.diagnostics.pro_1_1.cpp)]\n [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/t-system.diagnostics.pro_1_1.vb)]\n [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/t-system.diagnostics.pro_1_1.cs)]  \n  \n The following example uses the Process class itself and a static <xref:System.Diagnostics.Process.Start%2A> method to start a process.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/t-system.diagnostics.pro_1_2.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/t-system.diagnostics.pro_1_2.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/t-system.diagnostics.pro_1_2.cpp)]  \n  \n The following F# example defines a `runProc` function that starts a process, captures all output and error information, and records the number of milliseconds that the process has run.  The `runProc` function has three parameters: the name of application to launch, the arguments to supply to the application, and the starting directory.  \n  \n [!code-fs[System.Diagnostics.Process#1](~/add/codesnippet/fsharp/t-system.diagnostics.pro_1_3.fs)]  \n  \n The code for the `runProc` function was written by [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) and is available under the [Microsoft Public License](http://opensource.org/licenses/ms-pl)."
  syntax:
    content: >-
      [System.ComponentModel.DefaultEvent("Exited")]

      [System.ComponentModel.DefaultProperty("StartInfo")]

      [System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      [System.Diagnostics.MonitoringDescription("ProcessDesc")]

      public class Process : System.ComponentModel.Component
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements: []
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.Site
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Diagnostics.Process.#ctor
  id: '#ctor'
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Process()
  nameWithType: Process.Process()
  fullName: System.Diagnostics.Process.Process()
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Diagnostics.Process&quot;> </xref> classe."
  remarks: "Se não especificar o <xref:System.Diagnostics.Process.MachineName%2A>propriedade, a predefinição é o computador local, (&quot;.&quot;).</xref:System.Diagnostics.Process.MachineName%2A>       Tem duas opções para associar um novo <xref:System.Diagnostics.Process>componente com um processo no computador.</xref:System.Diagnostics.Process> A primeira opção consiste em utilizar o construtor para criar o <xref:System.Diagnostics.Process>componente, definir os membros adequados a <xref:System.Diagnostics.Process.StartInfo%2A>propriedade e chamada <xref:System.Diagnostics.Process.Start%2A>para associar o <xref:System.Diagnostics.Process>com um novo processo de sistema.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A> </xref:System.Diagnostics.Process> É a segunda opção para associar o <xref:System.Diagnostics.Process>com um processo em execução do sistema utilizando <xref:System.Diagnostics.Process.GetProcessById%2A>ou um do <xref:System.Diagnostics.Process.GetProcesses%2A>valores de retorno.</xref:System.Diagnostics.Process.GetProcesses%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> </xref:System.Diagnostics.Process>       Se utilizar um `static` sobrecarga do <xref:System.Diagnostics.Process.Start%2A>método para iniciar um novo processo de sistema, o método cria uma nova <xref:System.Diagnostics.Process>componente e associa-a com o processo.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A>       Quando o <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>propriedade está definida como valor predefinido, `true`, pode começar a aplicações e os documentos de forma semelhante à utilização de `Run` caixa de diálogo das janelas da `Start` menu.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>é `false`, pode iniciar apenas executáveis.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>       Qualquer ficheiro executável que pode ligar a partir da linha de comando pode ser iniciado de duas maneiras: através da definição adequados membros do <xref:System.Diagnostics.Process.StartInfo%2A>propriedade e chamar a <xref:System.Diagnostics.Process.Start%2A>método sem parâmetros ou passando o parâmetro adequado para o `static` <xref:System.Diagnostics.Process.Start%2A>Membro.</xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A>       Pode criar um <xref:System.Diagnostics.Process>componente utilizando o construtor, uma da estática <xref:System.Diagnostics.Process.Start%2A>sobrecargas ou qualquer uma do <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcesses%2A>, ou <xref:System.Diagnostics.Process.GetProcessesByName%2A>métodos.</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcesses%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process> Depois de o ter feito, tem uma vista para o processo associado. Não se trata de uma Vista dinâmica que atualiza-se automaticamente quando as propriedades de processo foram alterados na memória. Em vez disso, tem de chamar <xref:System.Diagnostics.Process.Refresh%2A>para o componente a atualizar o <xref:System.Diagnostics.Process>informações de propriedade na sua aplicação.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Refresh%2A>"
  syntax:
    content: public Process ();
    parameters: []
  overload: System.Diagnostics.Process.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.BasePriority
  id: BasePriority
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: BasePriority
  nameWithType: Process.BasePriority
  fullName: System.Diagnostics.Process.BasePriority
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a prioridade base do processo associado."
  remarks: "BasePriority do processo é a prioridade inicial de threads criados dentro do processo associado. Pode ver informações sobre a prioridade base através do Monitor de sistema prioridade Base contador.       Baseia-se na hora boosts decorridos ou outros, o sistema operativo podem alterar a prioridade base quando um processo deve ser colocado à frente das outras pessoas.       A propriedade BasePriority permite-lhe ver a prioridade inicial atribuída a um processo. No entanto, porque é só de leitura, não é possível utilizar o BasePriority para definir a prioridade do processo. Para alterar a prioridade, utilize o <xref:System.Diagnostics.Process.PriorityClass%2A>propriedade.</xref:System.Diagnostics.Process.PriorityClass%2A> O BasePriority é visualizável utilizando o Monitor de sistema, enquanto o <xref:System.Diagnostics.Process.PriorityClass%2A>não é.</xref:System.Diagnostics.Process.PriorityClass%2A> Tanto o BasePriority e <xref:System.Diagnostics.Process.PriorityClass%2A>podem ser visualizados através de programação.</xref:System.Diagnostics.Process.PriorityClass%2A> A tabela seguinte mostra a relação entre os valores de BasePriority e <xref:System.Diagnostics.Process.PriorityClass%2A>valores.</xref:System.Diagnostics.Process.PriorityClass%2A>      | BasePriority | PriorityClass |   |------------------|-------------------|   |&4; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&8; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&13; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&24; | <xref:System.Diagnostics.ProcessPriorityClass>|</xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_3_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_3_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_3_1.vb)]"
  syntax:
    content: public int BasePriority { get; }
    return:
      type: System.Int32
      description: "A prioridade base, o que é calculada a partir de <xref:System.Diagnostics.Process.PriorityClass*>do processo associado.</xref:System.Diagnostics.Process.PriorityClass*>"
  overload: System.Diagnostics.Process.BasePriority*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é Windows 98 ou Windows Millennium edição (Windows-Me); definir o &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; propriedade <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para aceder a esta propriedade em 98 do Windows e Windows Me."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo foi terminado.       - ou - o processo não foi iniciada, pelo que não existe nenhum ID de processo."
  platform:
  - net462
- uid: System.Diagnostics.Process.BeginErrorReadLine
  id: BeginErrorReadLine
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: BeginErrorReadLine()
  nameWithType: Process.BeginErrorReadLine()
  fullName: System.Diagnostics.Process.BeginErrorReadLine()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Começa operações de leitura assíncrona no redirecionada <xref:System.Diagnostics.Process.StandardError*>fluxo da aplicação.</xref:System.Diagnostics.Process.StandardError*>"
  remarks: "O <xref:System.Diagnostics.Process.StandardError%2A>fluxo pode ser lidos de forma síncrona ou assíncrona.</xref:System.Diagnostics.Process.StandardError%2A> Métodos, tais como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A>efetuar operações de leitura síncronas no fluxo de saída de erro do processo.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Estes síncrona ler operações não concluída até associada <xref:System.Diagnostics.Process>escreve o <xref:System.Diagnostics.Process.StandardError%2A>transmitir ou fecha o fluxo.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.Diagnostics.Process>       Em contrapartida, inicia BeginErrorReadLine assíncrona operações de leitura no <xref:System.Diagnostics.Process.StandardError%2A>stream.</xref:System.Diagnostics.Process.StandardError%2A> Este método permite que o processador de eventos designado para a saída de fluxo e devolve imediatamente para o emissor, o que pode efetuar outras tarefas enquanto a saída de fluxo é direcionada para o processador de eventos.       Siga estes passos para efetuar operações de leitura assíncrona no <xref:System.Diagnostics.Process.StandardError%2A>para um <xref:System.Diagnostics.Process>: 1.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardError%2A>  Set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> to `false`.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>      2.  Set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> to `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A>      3.  Adicionar o processador de eventos para o <xref:System.Diagnostics.Process.ErrorDataReceived>eventos.</xref:System.Diagnostics.Process.ErrorDataReceived> O processador de eventos tem de corresponder a <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>assinatura delegado.</xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>      4.  Iniciar <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process>      5.  Chamada BeginErrorReadLine para <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process> Esta chamada inicia operações de leitura assíncrona no <xref:System.Diagnostics.Process.StandardError%2A>.</xref:System.Diagnostics.Process.StandardError%2A>       Quando é chamado o início de operações de leitura assíncrona, o processador de eventos de cada vez associada <xref:System.Diagnostics.Process>escreve uma linha de texto ao respetivo <xref:System.Diagnostics.Process.StandardError%2A>stream.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.Diagnostics.Process>       Pode cancelar uma operação de leitura assíncrona chamando <xref:System.Diagnostics.Process.CancelErrorRead%2A>.</xref:System.Diagnostics.Process.CancelErrorRead%2A> A operação de leitura pode ser cancelada pelo chamador ou pelo processador de eventos. Após Cancelar, pode chamar BeginErrorReadLine novamente para retomar as operações de leitura assíncrona.      > [!NOTE] > Não é possível misturar assíncronas e síncronas as operações de leitura numa sequência redirecionado. Uma vez a transmissão de redirecionada um <xref:System.Diagnostics.Process>é aberto no modo assíncrono ou síncrono, todas mais leitura operações nesse fluxo tem de ser o mesmo modo.</xref:System.Diagnostics.Process> Por exemplo, não siga BeginErrorReadLine através de uma chamada para <xref:System.IO.StreamReader.ReadLine%2A>no <xref:System.Diagnostics.Process.StandardError%2A>stream, ou vice versa.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.IO.StreamReader.ReadLine%2A> No entanto, pode ler dois fluxos diferentes em modos diferentes. Por exemplo, pode chamar BeginErrorReadLine e, em seguida, chame <xref:System.IO.StreamReader.ReadLine%2A>para o <xref:System.Diagnostics.Process.StandardOutput%2A>stream.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.IO.StreamReader.ReadLine%2A>"
  example:
  - "The following example uses the `net view` command to list the available network resources on a remote computer. The user supplies the target computer name as a command-line argument. The user can also supply a file name for error output. The example collects the output of the net command, waits for the process to finish, and then writes the output results to the console. If the user supplies the optional error file, the example writes errors to the file.  \n  \n [!code-cpp[Process_AsyncStreams#2](~/add/codesnippet/cpp/m-system.diagnostics.pro_4_1.cpp)]\n [!code-cs[Process_AsyncStreams#2](~/add/codesnippet/csharp/m-system.diagnostics.pro_4_1.cs)]\n [!code-vb[Process_AsyncStreams#2](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_4_1.vb)]"
  syntax:
    content: public void BeginErrorReadLine ();
    parameters: []
  overload: System.Diagnostics.Process.BeginErrorReadLine*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName&gt; property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n An asynchronous read operation is already in progress on the <xref:System.Diagnostics.Process.StandardError*> stream.  \n  \n \\- or -  \n  \n The <xref:System.Diagnostics.Process.StandardError*> stream has been used by a synchronous read operation."
  platform:
  - net462
- uid: System.Diagnostics.Process.BeginOutputReadLine
  id: BeginOutputReadLine
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: BeginOutputReadLine()
  nameWithType: Process.BeginOutputReadLine()
  fullName: System.Diagnostics.Process.BeginOutputReadLine()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Começa operações de leitura assíncrona no redirecionada <xref:System.Diagnostics.Process.StandardOutput*>fluxo da aplicação.</xref:System.Diagnostics.Process.StandardOutput*>"
  remarks: "O <xref:System.Diagnostics.Process.StandardOutput%2A>fluxo pode ser lidos de forma síncrona ou assíncrona.</xref:System.Diagnostics.Process.StandardOutput%2A> Métodos, tais como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A>efetuar operações de leitura síncronas no fluxo de saída do processo.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Estes síncrona ler operações não concluída até associada <xref:System.Diagnostics.Process>escreve o <xref:System.Diagnostics.Process.StandardOutput%2A>transmitir ou fecha o fluxo.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process>       Em contrapartida, inicia BeginOutputReadLine assíncrona operações de leitura no <xref:System.Diagnostics.Process.StandardOutput%2A>stream.</xref:System.Diagnostics.Process.StandardOutput%2A> Este método permite que um processador de eventos designado para a saída de fluxo e devolve imediatamente para o emissor, o que pode efetuar outras tarefas enquanto a saída de fluxo é direcionada para o processador de eventos.       Siga estes passos para efetuar operações de leitura assíncrona no <xref:System.Diagnostics.Process.StandardOutput%2A>para um <xref:System.Diagnostics.Process>: 1.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardOutput%2A>  Set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> to `false`.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>      2.  Set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> to `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A>      3.  Adicionar o processador de eventos para o <xref:System.Diagnostics.Process.OutputDataReceived>eventos.</xref:System.Diagnostics.Process.OutputDataReceived> O processador de eventos tem de corresponder a <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>assinatura delegado.</xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>      4.  Iniciar <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process>      5.  Chamada BeginOutputReadLine para <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process> Esta chamada inicia operações de leitura assíncrona no <xref:System.Diagnostics.Process.StandardOutput%2A>.</xref:System.Diagnostics.Process.StandardOutput%2A>       Quando é chamado o início de operações de leitura assíncrona, o processador de eventos de cada vez associada <xref:System.Diagnostics.Process>escreve uma linha de texto ao respetivo <xref:System.Diagnostics.Process.StandardOutput%2A>stream.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process>       Pode cancelar uma operação de leitura assíncrona chamando <xref:System.Diagnostics.Process.CancelOutputRead%2A>.</xref:System.Diagnostics.Process.CancelOutputRead%2A> A operação de leitura pode ser cancelada pelo chamador ou pelo processador de eventos. Após Cancelar, pode chamar BeginOutputReadLine novamente para retomar as operações de leitura assíncrona.      > [!NOTE] > Não é possível misturar assíncronas e síncronas as operações de leitura numa sequência redirecionado. Uma vez a transmissão de redirecionada um <xref:System.Diagnostics.Process>é aberto no modo assíncrono ou síncrono, todas mais leitura operações nesse fluxo tem de ser o mesmo modo.</xref:System.Diagnostics.Process> Por exemplo, não siga BeginOutputReadLine com uma chamada para <xref:System.IO.StreamReader.ReadLine%2A>no <xref:System.Diagnostics.Process.StandardOutput%2A>stream, ou vice versa.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.IO.StreamReader.ReadLine%2A> No entanto, pode ler dois fluxos diferentes em modos diferentes. Por exemplo, pode chamar BeginOutputReadLine e, em seguida, chame <xref:System.IO.StreamReader.ReadLine%2A>para o <xref:System.Diagnostics.Process.StandardError%2A>stream.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.IO.StreamReader.ReadLine%2A>"
  example:
  - "The following example illustrates how to perform asynchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream of the `sort` command. The `sort` command is a console application that reads and sorts text input.  \n  \n The example creates an event delegate for the `SortOutputHandler` event handler and associates it with the <xref:System.Diagnostics.Process.OutputDataReceived> event. The event handler receives text lines from the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, formats the text, and writes the text to the screen.  \n  \n [!code-cpp[Process_AsyncStreams#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_13_1.cpp)]\n [!code-vb[Process_AsyncStreams#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_13_1.vb)]\n [!code-cs[Process_AsyncStreams#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_13_1.cs)]"
  syntax:
    content: public void BeginOutputReadLine ();
    parameters: []
  overload: System.Diagnostics.Process.BeginOutputReadLine*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName&gt; property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n An asynchronous read operation is already in progress on the <xref:System.Diagnostics.Process.StandardOutput*> stream.  \n  \n \\- or -  \n  \n The <xref:System.Diagnostics.Process.StandardOutput*> stream has been used by a synchronous read operation."
  platform:
  - net462
- uid: System.Diagnostics.Process.CancelErrorRead
  id: CancelErrorRead
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: CancelErrorRead()
  nameWithType: Process.CancelErrorRead()
  fullName: System.Diagnostics.Process.CancelErrorRead()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Cancela a assíncrona operação de leitura no redirecionada <xref:System.Diagnostics.Process.StandardError*>transmissão de uma aplicação.</xref:System.Diagnostics.Process.StandardError*>"
  remarks: "<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>inicia um assíncrona operação de leitura no <xref:System.Diagnostics.Process.StandardError%2A>stream.</xref:System.Diagnostics.Process.StandardError%2A></xref:System.Diagnostics.Process.BeginErrorReadLine%2A> CancelErrorRead termina a operação de leitura assíncrona.       Após Cancelar, pode retomar a operação de leitura assíncrona chamando <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>novamente.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A>       Quando chamar CancelErrorRead, todos os em curso operações de leitura de para <xref:System.Diagnostics.Process.StandardError%2A>estão concluídas e, em seguida, o processador de eventos está desativado.</xref:System.Diagnostics.Process.StandardError%2A> Todos os redirecionado ainda mais o resultado para <xref:System.Diagnostics.Process.StandardError%2A>é guardado numa memória intermédia.</xref:System.Diagnostics.Process.StandardError%2A> Se voltar a ativar o processador de eventos com uma chamada para <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>, a saída guardada é enviada para o processador de eventos e retomar as operações de leitura assíncronas.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> Se pretender alterar o processador de eventos antes de a retomar as operações de leitura assíncronas, tem de remover o processador de eventos existente antes de adicionar o processador de eventos novos: ```   // At this point the DataReceivedEventHandler(ErrorHandler1)    // has executed a CancelErrorRead.      // Remove the prior event handler.   process.ErrorDataReceived -=        new DataReceivedEventHandler(ErrorHandler1);      // Register a new event handler.   process.ErrorDataReceived +=        new DataReceivedEventHandler(ErrorHandler2);      // Call the corresponding BeginErrorReadLine.   process.BeginErrorReadLine();   ```       >  [!NOTE] > não é possível misturar assíncronas e síncronas as operações de leitura no redirecionada <xref:System.Diagnostics.Process.StandardError%2A>stream.</xref:System.Diagnostics.Process.StandardError%2A> Uma vez a transmissão de redirecionada um <xref:System.Diagnostics.Process>é aberto no modo assíncrono ou síncrono, todas mais leitura operações nesse fluxo tem de ser o mesmo modo.</xref:System.Diagnostics.Process> Se cancelar uma assíncrona operação de leitura no <xref:System.Diagnostics.Process.StandardError%2A>e, em seguida, precisa de ler a partir do fluxo de novamente, tem de utilizar <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>para retomar as operações de leitura assíncrona.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> </xref:System.Diagnostics.Process.StandardError%2A> Não siga CancelErrorRead com uma chamada para os métodos síncronos de leitura de <xref:System.Diagnostics.Process.StandardError%2A>como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, ou <xref:System.IO.StreamReader.ReadToEnd%2A>.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> </xref:System.Diagnostics.Process.StandardError%2A>"
  example:
  - "The following example starts the `nmake` command with user supplied arguments. The error and output streams are read asynchronously; the collected text lines are displayed to the console as well as written to a log file. If the command output exceeds a specified number of lines, the asynchronous read operations are canceled.  \n  \n [!code-cpp[Process_AsyncStreams#3](~/add/codesnippet/cpp/m-system.diagnostics.pro_7_1.cpp)]\n [!code-cs[Process_AsyncStreams#3](~/add/codesnippet/csharp/m-system.diagnostics.pro_7_1.cs)]\n [!code-vb[Process_AsyncStreams#3](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_7_1.vb)]"
  syntax:
    content: public void CancelErrorRead ();
    parameters: []
  overload: System.Diagnostics.Process.CancelErrorRead*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O <xref:System.Diagnostics.Process.StandardError*>sequência não está ativada para operações de leitura assíncrona.</xref:System.Diagnostics.Process.StandardError*>"
  platform:
  - net462
- uid: System.Diagnostics.Process.CancelOutputRead
  id: CancelOutputRead
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: CancelOutputRead()
  nameWithType: Process.CancelOutputRead()
  fullName: System.Diagnostics.Process.CancelOutputRead()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Cancela a assíncrona operação de leitura no redirecionada <xref:System.Diagnostics.Process.StandardOutput*>transmissão de uma aplicação.</xref:System.Diagnostics.Process.StandardOutput*>"
  remarks: "<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>inicia um assíncrona operação de leitura no <xref:System.Diagnostics.Process.StandardOutput%2A>stream.</xref:System.Diagnostics.Process.StandardOutput%2A></xref:System.Diagnostics.Process.BeginOutputReadLine%2A> CancelOutputRead termina a operação de leitura assíncrona.       Após Cancelar, pode retomar as operações de leitura assíncronas chamando <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>novamente.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A>       Quando chamar CancelOutputRead, todos os em curso operações de leitura de para <xref:System.Diagnostics.Process.StandardOutput%2A>estão concluídas e, em seguida, o processador de eventos está desativado.</xref:System.Diagnostics.Process.StandardOutput%2A> Todos os redirecionado ainda mais o resultado para <xref:System.Diagnostics.Process.StandardOutput%2A>é guardado numa memória intermédia.</xref:System.Diagnostics.Process.StandardOutput%2A> Se voltar a ativar o processador de eventos com uma chamada para <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, a saída guardada é enviada para o processador de eventos e retomar as operações de leitura assíncronas.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> Se pretender alterar o processador de eventos antes de a retomar as operações de leitura assíncronas, tem de remover o processador de eventos existente antes de adicionar o processador de eventos novos: ```   // At this point the DataReceivedEventHandler(OutputHandler1)    // has executed a CancelOutputRead.      // Remove the prior event handler.   process.OutputDataReceived -=        new DataReceivedEventHandler(OutputHandler1);      // Register a new event handler.   process.OutputDataReceived +=        new DataReceivedEventHandler(OutputHandler2);      // Call the corresponding BeginOutputReadLine.   process.BeginOutputReadLine();   ```       >  [!NOTE] > não é possível misturar assíncronas e síncronas as operações de leitura no redirecionada <xref:System.Diagnostics.Process.StandardOutput%2A>stream.</xref:System.Diagnostics.Process.StandardOutput%2A> Uma vez a transmissão de redirecionada um <xref:System.Diagnostics.Process>é aberto no modo assíncrono ou síncrono, todas mais leitura operações nesse fluxo tem de ser o mesmo modo.</xref:System.Diagnostics.Process> Se cancelar uma assíncrona operação de leitura no <xref:System.Diagnostics.Process.StandardOutput%2A>e, em seguida, precisa de ler a partir do fluxo de novamente, tem de utilizar <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>para retomar as operações de leitura assíncrona.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> </xref:System.Diagnostics.Process.StandardOutput%2A> Não siga CancelOutputRead com uma chamada para os métodos síncronos de leitura de <xref:System.Diagnostics.Process.StandardOutput%2A>como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, ou <xref:System.IO.StreamReader.ReadToEnd%2A>.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> </xref:System.Diagnostics.Process.StandardOutput%2A>"
  example:
  - "The following example starts the `nmake` command with user supplied arguments. The error and output streams are read asynchronously; the collected text lines are displayed to the console as well as written to a log file. If the command output exceeds a specified number of lines, the asynchronous read operations are canceled.  \n  \n [!code-cpp[Process_AsyncStreams#3](~/add/codesnippet/cpp/m-system.diagnostics.pro_3_1.cpp)]\n [!code-cs[Process_AsyncStreams#3](~/add/codesnippet/csharp/m-system.diagnostics.pro_3_1.cs)]\n [!code-vb[Process_AsyncStreams#3](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_3_1.vb)]"
  syntax:
    content: public void CancelOutputRead ();
    parameters: []
  overload: System.Diagnostics.Process.CancelOutputRead*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O <xref:System.Diagnostics.Process.StandardOutput*>sequência não está ativada para operações de leitura assíncrona.</xref:System.Diagnostics.Process.StandardOutput*>"
  platform:
  - net462
- uid: System.Diagnostics.Process.Close
  id: Close
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Close()
  nameWithType: Process.Close()
  fullName: System.Diagnostics.Process.Close()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Liberta os recursos que estão associados este componente."
  remarks: "O método Fechar faz com que o processo parar a aguardar a saída se estava a aguardar, fecha o identificador de processo e limpa propriedades específicos de processos. Feche não fechar a leitores de erro, de entrada e de saída standard escritores caso estão a ser referenciados externamente.      > [!NOTE] > O <xref:System.Diagnostics.Process.Dispose%2A>chama o método de fecho.</xref:System.Diagnostics.Process.Dispose%2A> Colocar o <xref:System.Diagnostics.Process>objeto um `using` bloco disposes dos recursos sem a necessidade de chamar feche.</xref:System.Diagnostics.Process>"
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2-second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_0_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_0_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_0_1.vb)]"
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Diagnostics.Process.Close*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.CloseMainWindow
  id: CloseMainWindow
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: CloseMainWindow()
  nameWithType: Process.CloseMainWindow()
  fullName: System.Diagnostics.Process.CloseMainWindow()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Fecha um processo que tem uma interface de utilizador enviando uma mensagem de fecho para a janela principal."
  remarks: "Quando um processo está a executar, o respetivo ciclo de mensagens está num Estado de espera. O ciclo de mensagem executa sempre que é enviada uma mensagem do Windows para o processo pelo sistema operativo. Chamar CloseMainWindow envia um pedido para a próximo da janela principal, que, numa aplicação formada, fecha janelas subordinadas e revoga execução todos os ciclos de mensagem para a aplicação. O pedido para sair do processo ao chamar CloseMainWindow não forçar a aplicação para sair. A aplicação pode fazer para a verificação do utilizador antes de quitting ou pode refuse sair. Para forçar a aplicação para sair, utilize o <xref:System.Diagnostics.Process.Kill%2A>método.</xref:System.Diagnostics.Process.Kill%2A> O comportamento de CloseMainWindow é idêntico ao de um utilizador a fechar a janela principal de uma aplicação utilizando o menu de sistema. Por conseguinte, o pedido para sair do processo ao fechar a janela principal não forçar a aplicação para sair imediatamente.       Editado pelo processo de dados ou recursos atribuídos ao processo podem ser perdidos se chamar <xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> <xref:System.Diagnostics.Process.Kill%2A>faz com que um encerramento do processo anormal e deve ser utilizado apenas quando necessário.</xref:System.Diagnostics.Process.Kill%2A> CloseMainWindow permite a um encerramento do processo de ordenada e fecha todos os windows, pelo que é preferível para as aplicações com uma interface. Se CloseMainWindow falhar, pode utilizar <xref:System.Diagnostics.Process.Kill%2A>terminar o processo.</xref:System.Diagnostics.Process.Kill%2A> <xref:System.Diagnostics.Process.Kill%2A>é a única forma de terminar os processos que não dispõe de interfaces gráficas.</xref:System.Diagnostics.Process.Kill%2A>       Pode chamar <xref:System.Diagnostics.Process.Kill%2A>e CloseMainWindow apenas para processos em execução no computador local.</xref:System.Diagnostics.Process.Kill%2A> Não é possível fazer com que os processos em computadores remotos para sair. Só pode ver informações de processos em execução em computadores remotos."
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_18_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_18_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_18_1.vb)]"
  syntax:
    content: public bool CloseMainWindow ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a mensagem de fecho foi enviada com êxito; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> se o processo associado não possui uma janela principal ou se a janela principal está desativada (por exemplo, se estiver a ser mostrada uma caixa de diálogo modal)."
  overload: System.Diagnostics.Process.CloseMainWindow*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é Windows 98 ou Windows Millennium edição (Windows-Me); definir o &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; propriedade <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para aceder a esta propriedade em 98 do Windows e Windows Me."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo já terminou.       - ou - nenhum processo está associado a este <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objeto."
  platform:
  - net462
- uid: System.Diagnostics.Process.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: Process.Dispose(Boolean)
  fullName: System.Diagnostics.Process.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Liberte todos os recursos utilizados por este processo."
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Para libertar recursos geridos e; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para libertar recursos apenas não geridos."
  overload: System.Diagnostics.Process.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.EnableRaisingEvents
  id: EnableRaisingEvents
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: EnableRaisingEvents
  nameWithType: Process.EnableRaisingEvents
  fullName: System.Diagnostics.Process.EnableRaisingEvents
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define se a <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref> o evento deve ser gerado quando o processo termina."
  remarks: "A propriedade EnableRaisingEvents indica se o componente deve ser notificado quando o sistema operativo foi encerrado por um processo. A propriedade EnableRaisingEvents é utilizada no processamento assíncrono para notificar a aplicação que um processo foi terminado. Para forçar a aplicação de forma síncrona aguardar por um evento de saída (que interrupções processamento da aplicação até que ocorreu o evento de saída), utilize o <xref:System.Diagnostics.Process.WaitForExit%2A>método.</xref:System.Diagnostics.Process.WaitForExit%2A>      > [!NOTE] > Se estiver a utilizar o Visual Studio e faça duplo clique num <xref:System.Diagnostics.Process>componente no seu projeto, um <xref:System.Diagnostics.Process.Exited>delegado de evento e o processador de eventos que são geradas automaticamente.</xref:System.Diagnostics.Process.Exited> </xref:System.Diagnostics.Process> Código adicional define a propriedade de EnableRaisingEvents como `false`. Tem de alterar esta propriedade para `true` para o processador de eventos ser executada quando o processo associado termina.       Quando um processo associado termina após a ser encerrado pelo sistema operativo, quer através de terminação anormal ou normal, o sistema operativo notifica cada componente do processo para o qual o processo foi associado, desde que o valor de EnableRaisingEvents o componente é `true`. Se um componente iniciado o processo, o componente, em seguida, pode aceder as informações administrativas para o processo associado, que ainda está a ser armazenado pelo sistema operativo. Estas informações incluem o <xref:System.Diagnostics.Process.ExitTime%2A>e <xref:System.Diagnostics.Process.ExitCode%2A>.</xref:System.Diagnostics.Process.ExitCode%2A> </xref:System.Diagnostics.Process.ExitTime%2A>       Depois do processo associado termina, o <xref:System.Diagnostics.Process.Handle%2A>do componente já não aponta para um recurso de processo existente.</xref:System.Diagnostics.Process.Handle%2A> Em vez disso, pode ser utilizado apenas para aceder às informações do sistema operativo sobre o recurso de processo. O sistema operativo está ciente de que existem identificadores fechadas processos que não tenham sido publicadas por <xref:System.Diagnostics.Process>componentes, pelo que mantém o <xref:System.Diagnostics.Process.ExitTime%2A>e <xref:System.Diagnostics.Process.Handle%2A>informações na memória.</xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process>       Não há um custo associado observar um processo sair. Se for EnableRaisingEvents `true`, a <xref:System.Diagnostics.Process.Exited>evento é gerado quando o processo associado termina.</xref:System.Diagnostics.Process.Exited> Os procedimentos que tenha especificado para o <xref:System.Diagnostics.Process.Exited>eventos executados a essa hora.</xref:System.Diagnostics.Process.Exited>       Por vezes, a aplicação inicia um processo, mas não tem de ser notificados o fecho. Por exemplo, a aplicação pode iniciar o bloco de notas para permitir ao utilizador efetuar a edição de texto, mas não são necessárias mais tornar utilização da aplicação de bloco de notas. Pode optar por não ser notificado quando o processo sai, porque não é relevante para a operação contínua da aplicação. Definição EnableRaisingEvents `false` guarda os recursos do sistema."
  example:
  - "The following code example creates a process that prints a file. It sets the EnableRaisingEvents property to cause the process to raise the <xref:System.Diagnostics.Process.Exited> event when it exits. The <xref:System.Diagnostics.Process.Exited> event handler displays process information.  \n  \n [!code-vb[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_38_1.vb)]\n [!code-cs[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_38_1.cs)]"
  syntax:
    content: public bool EnableRaisingEvents { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref> o evento deve ser gerado quando o processo associado foi terminado (através de uma saída ou de uma chamada para <xref:System.Diagnostics.Process.Kill*>); caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.Kill*> A predefinição é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.EnableRaisingEvents*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.EnterDebugMode
  id: EnterDebugMode
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: EnterDebugMode()
  nameWithType: Process.EnterDebugMode()
  fullName: System.Diagnostics.Process.EnterDebugMode()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Coloca um <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente no Estado a interagir com o sistema operativo processos que são executados num modo especial, Ativando a propriedade nativa <xref uid=&quot;langword_csharp_SeDebugPrivilege&quot; name=&quot;SeDebugPrivilege&quot; href=&quot;&quot;> </xref> no thread atual."
  remarks: "Alguns processos de sistema operativo executam num modo especial. A tentar ler as propriedades de ou ligar a estes processos não for possível, a menos que tenha chamado EnterDebugMode no componente. Chamar <xref:System.Diagnostics.Process.LeaveDebugMode%2A>quando já não necessita de acesso a estes processos que são executados num modo especial.</xref:System.Diagnostics.Process.LeaveDebugMode%2A>"
  syntax:
    content: public static void EnterDebugMode ();
    parameters: []
  overload: System.Diagnostics.Process.EnterDebugMode*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.ErrorDataReceived
  id: ErrorDataReceived
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ErrorDataReceived
  nameWithType: Process.ErrorDataReceived
  fullName: System.Diagnostics.Process.ErrorDataReceived
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ocorre quando uma aplicação escreve o redirecionada <xref:System.Diagnostics.Process.StandardError*>stream.</xref:System.Diagnostics.Process.StandardError*>"
  remarks: "O evento ErrorDataReceived indica que o processo associado escritos na respetiva redirecionada <xref:System.Diagnostics.Process.StandardError%2A>stream.</xref:System.Diagnostics.Process.StandardError%2A>       O evento só ocorre durante as operações de leitura assíncronas no <xref:System.Diagnostics.Process.StandardError%2A>.</xref:System.Diagnostics.Process.StandardError%2A> Para iniciar as operações de leitura assíncrona, tem de redirecionar o <xref:System.Diagnostics.Process.StandardError%2A>fluxo de um <xref:System.Diagnostics.Process>, adicione o processador de eventos para o evento de ErrorDataReceived e chamar <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> </xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardError%2A> Depois disso, sinais de evento ErrorDataReceived sempre que o processo escreve uma linha ao redirecionada <xref:System.Diagnostics.Process.StandardError%2A>stream, até que o processo é terminado ou chamadas <xref:System.Diagnostics.Process.CancelErrorRead%2A>.</xref:System.Diagnostics.Process.CancelErrorRead%2A> </xref:System.Diagnostics.Process.StandardError%2A>      > [!NOTE] > A aplicação que está a processar o resultado assíncrono deverá chamar o <xref:System.Diagnostics.Process.WaitForExit%2A>método para se certificar de que a memória intermédia de saída foram descarregada.</xref:System.Diagnostics.Process.WaitForExit%2A>"
  example:
  - "The following example uses the `net view` command to list the available network resources on a remote computer. The user supplies the target computer name as a command-line argument. The user can also supply a file name for error output. The example collects the output of the net command, waits for the process to finish, and then writes the output results to the console. If the user supplies the optional error file, the example writes errors to the file.  \n  \n [!code-cpp[Process_AsyncStreams#2](~/add/codesnippet/cpp/e-system.diagnostics.pro_0_1.cpp)]\n [!code-cs[Process_AsyncStreams#2](~/add/codesnippet/csharp/e-system.diagnostics.pro_0_1.cs)]\n [!code-vb[Process_AsyncStreams#2](~/add/codesnippet/visualbasic/e-system.diagnostics.pro_0_1.vb)]"
  syntax:
    content: public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;
    return:
      type: System.Diagnostics.DataReceivedEventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.ExitCode
  id: ExitCode
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ExitCode
  nameWithType: Process.ExitCode
  fullName: System.Diagnostics.Process.ExitCode
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o valor que o processo associado especificado quando este termina."
  remarks: "Utilize ExitCode para obter o estado de que o processo de sistema devolvido quando este foi terminado. Pode utilizar o código de saída muito como um número inteiro devolver valor de um `main()` procedimento.       O valor de ExitCode para um processo reflete a convenção específica implementada pelo programador da aplicação para esse processo. Se utilizar o valor do código de saída para tomar decisões no seu código, lembre-se de que conhece a Convenção de código de saída utilizada pelo processo de aplicação.       Os programadores normalmente indicam uma saída com êxito por um valor de ExitCode igual a zero e designar erros por valores diferentes de zero, que pode utilizar o método de chamada para identificar a causa de um encerramento do processo anormal. Não é necessário seguir estas diretrizes, mas estão a Convenção.       Se tentar obter o ExitCode antes do processo foi terminado, a tentativa de emite uma exceção. Examine o <xref:System.Diagnostics.Process.HasExited%2A>propriedade primeiro para verificar se o processo associado foi terminada.</xref:System.Diagnostics.Process.HasExited%2A>      > [!NOTE] > Quando a saída padrão foi redirecionada para processadores de eventos assíncrona, é possível que o processamento de saída serão não ter sido concluída quando <xref:System.Diagnostics.Process.HasExited%2A>devolve `true`.</xref:System.Diagnostics.Process.HasExited%2A> Para garantir que o processamento de eventos assíncrona foi concluído, chame a <xref:System.Diagnostics.Process.WaitForExit>sobrecarga que não assume nenhum parâmetro antes de a verificar <xref:System.Diagnostics.Process.HasExited%2A>.</xref:System.Diagnostics.Process.HasExited%2A> </xref:System.Diagnostics.Process.WaitForExit>       Pode utilizar o <xref:System.Diagnostics.Process.CloseMainWindow%2A>ou <xref:System.Diagnostics.Process.Kill%2A>método para fazer com que um processo associado termina.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A>       Existem duas formas de que está a ser notificado quando o processo associado termina: forma síncrona e assíncrona. Notificação síncrona depende de chamar o <xref:System.Diagnostics.Process.WaitForExit%2A>método para colocar em pausa o processamento da sua aplicação até que o componente associado sai.</xref:System.Diagnostics.Process.WaitForExit%2A> Notificação assíncrona depende o <xref:System.Diagnostics.Process.Exited>eventos.</xref:System.Diagnostics.Process.Exited> Ao utilizar a notificação assíncrona, <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>deve ser definido como `true` para o <xref:System.Diagnostics.Process>componente para receber a notificação a indicar que o processo foi terminado.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.EnableRaisingEvents%2A>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_6_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_6_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_6_1.vb)]"
  syntax:
    content: public int ExitCode { get; }
    return:
      type: System.Int32
      description: "O código que o processo associado especificado quando este termina."
  overload: System.Diagnostics.Process.ExitCode*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo não terminou.       - ou - o processo <xref:System.Diagnostics.Process.Handle*>não é válido.</xref:System.Diagnostics.Process.Handle*>"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Está a tentar aceder a propriedade ExitCode para um processo que está em execução num computador remoto. Esta propriedade só está disponível para processos em execução no computador local."
  platform:
  - net462
- uid: System.Diagnostics.Process.Exited
  id: Exited
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Exited
  nameWithType: Process.Exited
  fullName: System.Diagnostics.Process.Exited
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ocorre quando um processo é terminado."
  remarks: "O evento Exited indica que o processo associado foi terminado. Esta ocorrência o que significa que o processo terminada (abortada) ou fechado com êxito. Este evento pode ocorrer apenas se o valor da <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>propriedade é `true`.</xref:System.Diagnostics.Process.EnableRaisingEvents%2A>       Existem duas formas de que está a ser notificado quando o processo associado termina: forma síncrona e assíncrona. Notificação síncrona significa chamar o <xref:System.Diagnostics.Process.WaitForExit%2A>método para bloquear o thread atual até que o processo é terminado.</xref:System.Diagnostics.Process.WaitForExit%2A> Notificação assíncrona utiliza o evento Exited, que permite que o thread de chamada continuar a execução entretanto. No caso desta última opção, <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>deve ser definido como `true` para a aplicação de chamada receber o evento Exited.</xref:System.Diagnostics.Process.EnableRaisingEvents%2A>       Quando o sistema operativo será encerrado a um processo, notifica todos os outros processos que registou processadores para o evento Exited. Neste momento, o identificador do processo que saiu apenas pode ser utilizado para aceder a algumas propriedades, tais como <xref:System.Diagnostics.Process.ExitTime%2A>e <xref:System.Diagnostics.Process.HasExited%2A>que o sistema operativo mantém até que a liberta completamente esse identificador.</xref:System.Diagnostics.Process.HasExited%2A> </xref:System.Diagnostics.Process.ExitTime%2A>      > [!NOTE] >, Mesmo se tiver um identificador de um processo fechadas, não é possível chamar <xref:System.Diagnostics.Process.Start%2A>novamente para restabelecer a ligação para o mesmo processo.</xref:System.Diagnostics.Process.Start%2A> Chamar <xref:System.Diagnostics.Process.Start%2A>automaticamente disponibiliza o processo associado e estabelece ligação a um processo com o mesmo ficheiro, mas um <xref:System.Diagnostics.Process.Handle%2A>.</xref:System.Diagnostics.Process.Handle%2A> completamente nova</xref:System.Diagnostics.Process.Start%2A>       Para obter mais informações sobre a utilização do evento Exited em aplicações do Windows Forms, consulte o <xref:System.Diagnostics.Process.SynchronizingObject%2A>propriedade.</xref:System.Diagnostics.Process.SynchronizingObject%2A>"
  example:
  - "The following code example creates a process that prints a file. It raises the Exited event when the process exits because the <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property was set when the process was created. The Exited event handler displays process information.  \n  \n [!code-vb[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/visualbasic/e-system.diagnostics.pro_1_1.vb)]\n [!code-cs[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/csharp/e-system.diagnostics.pro_1_1.cs)]"
  syntax:
    content: public event EventHandler Exited;
    return:
      type: System.EventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.ExitTime
  id: ExitTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ExitTime
  nameWithType: Process.ExitTime
  fullName: System.Diagnostics.Process.ExitTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a hora de fim do processo associado."
  remarks: "Se o processo não foi terminada, tentar obter a propriedade ExitTime emite uma exceção. Utilize <xref:System.Diagnostics.Process.HasExited%2A>antes de obter a propriedade ExitTime para determinar se o processo associado foi terminada.</xref:System.Diagnostics.Process.HasExited%2A>"
  example:
  - "The following code example creates a process that prints a file. The process raises the <xref:System.Diagnostics.Process.Exited> event when it exits, and the event handler displays the ExitTime property and other process information.  \n  \n [!code-vb[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_14_1.vb)]\n [!code-cs[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_14_1.cs)]"
  syntax:
    content: public DateTime ExitTime { get; }
    return:
      type: System.DateTime
      description: "A <xref:System.DateTime>que indica quando o processo associado foi terminado.</xref:System.DateTime>"
  overload: System.Diagnostics.Process.ExitTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "É a plataforma Windows 98 ou Millennium edição do Windows (Windows-Me), que não suporta esta propriedade."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Está a tentar aceder a propriedade ExitTime para um processo que está em execução num computador remoto. Esta propriedade só está disponível para processos em execução no computador local."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetCurrentProcess
  id: GetCurrentProcess
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetCurrentProcess()
  nameWithType: Process.GetCurrentProcess()
  fullName: System.Diagnostics.Process.GetCurrentProcess()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém um novo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente e associa-a com o processo atualmente ativo."
  remarks: "Utilize este método para criar um novo <xref:System.Diagnostics.Process>instância e associá-lo com o recurso de processo no computador local.</xref:System.Diagnostics.Process>       Como o semelhante <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>, e <xref:System.Diagnostics.Process.GetProcesses%2A>métodos, GetCurrentProcess associa um recurso existente com uma nova <xref:System.Diagnostics.Process>componente.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcesses%2A> </xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_10_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_10_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_10_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process GetCurrentProcess ();
    parameters: []
    return:
      type: System.Diagnostics.Process
      description: "Um novo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente associado ao recurso de processo que está a executar a aplicação de chamada."
  overload: System.Diagnostics.Process.GetCurrentProcess*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessById(System.Int32)
  id: GetProcessById(System.Int32)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessById(Int32)
  nameWithType: Process.GetProcessById(Int32)
  fullName: System.Diagnostics.Process.GetProcessById(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Devolve um novo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente, dado o identificador de um processo no computador local."
  remarks: "Utilize este método para criar um novo <xref:System.Diagnostics.Process>componente e associá-la um recurso de processo no computador local.</xref:System.Diagnostics.Process> O recurso de processo já deve existir no computador, porque GetProcessById não cria um recurso de sistema, mas em vez disso, associa um recurso com uma aplicação gerados pelo <xref:System.Diagnostics.Process>componente.</xref:System.Diagnostics.Process> Um processo <xref:System.Diagnostics.Process.Id%2A>podem ser obtidos apenas para um processo que está atualmente em execução no computador.</xref:System.Diagnostics.Process.Id%2A> Depois do processo termina, o GetProcessById emite uma exceção se obtiver um identificador expirado.       Em qualquer computador específico, o identificador de um processo é exclusivo. GetProcessById devolve um processo no máximo. Se pretender obter todos os processos em execução uma aplicação específica, utilize <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>.</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> Se existirem vários processos no computador que executa a aplicação especificada, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>devolve uma matriz que contém todos os processos associados.</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> Pode consultar cada estes processos por sua vez para o respetivo identificador. O identificador do processo pode ser visualizado no `Processes` painel do Gestor de tarefas do Windows. O `PID` coluna apresenta o identificador de processo que é atribuído a um processo."
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_19_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_19_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_19_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process GetProcessById (int processId);
    parameters:
    - id: processId
      type: System.Int32
      description: "O identificador exclusivo para o sistema de um recurso de processo."
    return:
      type: System.Diagnostics.Process
      description: "A <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente que está associado ao recurso de processo local identificado pelo <code> processId </code> parâmetro."
  overload: System.Diagnostics.Process.GetProcessById*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O processo especificado pelo <code> processId </code> parâmetro não está em execução. O identificador pode estar expirado."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo não foi iniciado por este objeto."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  id: GetProcessById(System.Int32,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessById(Int32,String)
  nameWithType: Process.GetProcessById(Int32,String)
  fullName: System.Diagnostics.Process.GetProcessById(Int32,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Devolve um novo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente, de acordo com um identificador de processo e o nome de um computador na rede."
  remarks: "Utilize este método para criar um novo <xref:System.Diagnostics.Process>componente e associá-la um recurso de processo num computador remoto na rede.</xref:System.Diagnostics.Process> O recurso de processo já deve existir no computador especificado, porque GetProcessById não cria um recurso de sistema, mas em vez disso, associa um recurso com uma aplicação gerados pelo <xref:System.Diagnostics.Process>componente.</xref:System.Diagnostics.Process> Um processo <xref:System.Diagnostics.Process.Id%2A>podem ser obtidos apenas para um processo que está atualmente em execução no computador.</xref:System.Diagnostics.Process.Id%2A> Depois do processo termina, o GetProcessById emite uma exceção se obtiver um identificador expirado.       Em qualquer computador específico, o identificador de um processo é exclusivo. GetProcessById devolve um processo no máximo. Se pretender obter todos os processos em execução uma aplicação específica, utilize <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>.</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> Se existirem vários processos no computador que executa a aplicação especificada, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>devolve uma matriz que contém todos os processos associados.</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> Pode consultar cada estes processos por sua vez para o respetivo identificador. O identificador do processo pode ser visualizado no `Processes` painel do Gestor de tarefas do Windows. O `PID` coluna apresenta o identificador de processo que é atribuído a um processo.       Se não especificar um `machineName`, é utilizado no computador local. Em alternativa, pode especificar o computador local através da definição `machineName` para o valor &quot;.&quot; ou como uma cadeia vazia (&quot;&quot;)."
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_8_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_8_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_8_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process GetProcessById (int processId, string machineName);
    parameters:
    - id: processId
      type: System.Int32
      description: "O identificador exclusivo para o sistema de um recurso de processo."
    - id: machineName
      type: System.String
      description: "O nome de um computador na rede."
    return:
      type: System.Diagnostics.Process
      description: "A <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente que está associado a um recurso de um processo remoto identificado pelo <code> processId </code> parâmetro."
  overload: System.Diagnostics.Process.GetProcessById*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O processo especificado pelo <code> processId </code> parâmetro não está em execução. O identificador pode estar expirado.       - ou - <code> machineName </code> sintaxe do parâmetro é inválido. O nome poderá ter de comprimento zero (0)."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>machineName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo não foi iniciado por este objeto."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcesses
  id: GetProcesses
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcesses()
  nameWithType: Process.GetProcesses()
  fullName: System.Diagnostics.Process.GetProcesses()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Cria uma nova <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente para cada recurso de processo no computador local."
  remarks: "Utilize este método para criar uma matriz de novos <xref:System.Diagnostics.Process>componentes e associá-las a todos os recursos de processo no computador local.</xref:System.Diagnostics.Process> Os recursos de processo já devem existir no computador local, porque GetProcesses não criar recursos do sistema, mas em vez disso associa recursos gerados por aplicações <xref:System.Diagnostics.Process>componentes.</xref:System.Diagnostics.Process> Porque o sistema operativo está a executar processos em segundo plano, esta matriz nunca está vazio.       Se não pretender obter todos os processos em execução no computador, pode restringir o respetivo número utilizando o <xref:System.Diagnostics.Process.GetProcessById%2A>ou <xref:System.Diagnostics.Process.GetProcessesByName%2A>método.</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessById%2A>cria um <xref:System.Diagnostics.Process>componente que está associado com o processo identificado no sistema pelo identificador de processo que passa para o método.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessesByName%2A>cria uma matriz de <xref:System.Diagnostics.Process>componentes cujos recursos de processo associado partilhar o ficheiro executável passar para o método.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessesByName%2A>      > [!NOTE] > Serviços Windows vários podem ser carregados na mesma instância do processo de anfitrião do serviço (svchost.exe). GetProcesses não identifica esses serviços individuais; Para tal, consulte <xref:System.ServiceProcess.ServiceController.GetServices%2A>.</xref:System.ServiceProcess.ServiceController.GetServices%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_15_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_15_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_15_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcesses ();
    parameters: []
    return:
      type: System.Diagnostics.Process[]
      description: "Uma matriz do tipo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> que representa todos os recursos de processo em execução no computador local."
  overload: System.Diagnostics.Process.GetProcesses*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcesses(System.String)
  id: GetProcesses(System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcesses(String)
  nameWithType: Process.GetProcesses(String)
  fullName: System.Diagnostics.Process.GetProcesses(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Cria uma nova <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente para cada recurso de processo no computador especificado."
  remarks: "Utilize este método para criar uma matriz de novos <xref:System.Diagnostics.Process>componentes e associá-las a todos os recursos de processo no computador (normalmente, remoto) especificado.</xref:System.Diagnostics.Process> Os recursos de processo já devem existir no computador local, porque <xref:System.Diagnostics.Process.GetProcesses%2A>não criar recursos do sistema, mas em vez disso associa recursos gerados por aplicações <xref:System.Diagnostics.Process>componentes.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcesses%2A> Porque o sistema operativo está a executar processos em segundo plano, esta matriz nunca está vazio.       Se não pretender obter todos os processos em execução no computador, pode restringir o respetivo número utilizando o <xref:System.Diagnostics.Process.GetProcessById%2A>ou <xref:System.Diagnostics.Process.GetProcessesByName%2A>método.</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessById%2A>cria um <xref:System.Diagnostics.Process>componente que está associado com o processo identificado no sistema pelo identificador de processo que passa para o método.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessesByName%2A>cria uma matriz de <xref:System.Diagnostics.Process>componentes cujos recursos de processo associado partilhar o ficheiro executável passar para o método.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessesByName%2A>       Esta sobrecarga do <xref:System.Diagnostics.Process.GetProcesses%2A>método é geralmente utilizado para obter a lista de recursos do processo em execução num computador remoto na rede, mas pode especificar o computador local através da transmissão &quot;.&quot;.</xref:System.Diagnostics.Process.GetProcesses%2A>      > [!NOTE] > Serviços Windows vários podem ser carregados na mesma instância do processo de anfitrião do serviço (svchost.exe). GetProcesses não identifica esses serviços individuais; Para tal, consulte <xref:System.ServiceProcess.ServiceController.GetServices%2A>.</xref:System.ServiceProcess.ServiceController.GetServices%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_11_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_11_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_11_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcesses (string machineName);
    parameters:
    - id: machineName
      type: System.String
      description: "O computador a partir da qual é possível ler a lista de processos."
    return:
      type: System.Diagnostics.Process[]
      description: "Uma matriz do tipo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> que representa todos os recursos de processo em execução no computador especificado."
  overload: System.Diagnostics.Process.GetProcesses*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O <code> machineName </code> sintaxe do parâmetro é inválido. Poderá ter comprimento zero (0)."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>machineName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma do sistema operativo não suporta esta operação em computadores remotos."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Existem problemas de acesso ao contador de desempenho que API utilizado para obter informações sobre o processo. Esta exceção é específica do Windows NT, Windows 2000 e o Windows XP."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Ocorreu um problema ao aceder a um API de sistema subjacente."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessesByName(System.String)
  id: GetProcessesByName(System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessesByName(String)
  nameWithType: Process.GetProcessesByName(String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Cria uma matriz de novos <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componentes e associa-los com todos os recursos processo no computador local que partilham o nome de processo especificado."
  remarks: "Utilize este método para criar uma matriz de novos <xref:System.Diagnostics.Process>componentes e associá-las a todos os recursos de processo que estejam a executar o mesmo ficheiro executável no computador local.</xref:System.Diagnostics.Process> Os recursos de processo já devem existir no computador, porque GetProcessesByName não criar recursos do sistema, mas associa em vez disso que gerados por aplicações <xref:System.Diagnostics.Process>componentes.</xref:System.Diagnostics.Process> A `processName` pode ser especificado para um ficheiro executável que não está atualmente em execução no computador local, pelo que a matriz o método devolve pode estar vazia.       O nome do processo é um nome amigável para o processo, como o Outlook, o que não inclua o caminho ou a extensão de .exe. GetProcessesByName é útil para obter e manipulação de todos os processos que estão associados ao mesmo ficheiro executável. Por exemplo, um nome de ficheiro executável que pode passar o `processName` parâmetro, para poder Encerre todas as instâncias em execução desse ficheiro executável.       Embora um processo <xref:System.Diagnostics.Process.Id%2A>é exclusivo para um recurso único processo no sistema, vários processos no computador local podem estar a executar a aplicação especificada pelo `processName` parâmetro.</xref:System.Diagnostics.Process.Id%2A> Por conseguinte, <xref:System.Diagnostics.Process.GetProcessById%2A>devolve um processo no máximo, mas GetProcessesByName devolve uma matriz que contém todos os processos associados.</xref:System.Diagnostics.Process.GetProcessById%2A> Se precisar de manipular o processo utilizando chamadas de API padrão, pode consultar cada estes processos por sua vez para o respetivo identificador. Não é possível aceder a recursos de processo através do nome do processo individualmente, mas, depois de ter de obter uma matriz de <xref:System.Diagnostics.Process>componentes que foram associados com os recursos do processo, pode iniciar, terminar e, caso contrário, manipular os recursos do sistema.</xref:System.Diagnostics.Process>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_6_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_6_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_6_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcessesByName (string processName);
    parameters:
    - id: processName
      type: System.String
      description: "O nome amigável do processo."
    return:
      type: System.Diagnostics.Process[]
      description: "Uma matriz do tipo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> que representa os recursos de processo com o ficheiro ou a aplicação especificada."
  overload: System.Diagnostics.Process.GetProcessesByName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Existem problemas de acesso ao contador de desempenho que API utilizado para obter informações sobre o processo. Esta exceção é específica do Windows NT, Windows 2000 e o Windows XP."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessesByName(System.String,System.String)
  id: GetProcessesByName(System.String,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessesByName(String,String)
  nameWithType: Process.GetProcessesByName(String,String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Cria uma matriz de novos <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componentes e associa-los com todos os recursos processo num computador remoto que partilham o nome de processo especificado."
  remarks: "Utilize este método para criar uma matriz de novos <xref:System.Diagnostics.Process>componentes e associá-las a todos os recursos de processo que estejam a executar o mesmo ficheiro executável no computador especificado.</xref:System.Diagnostics.Process> Os recursos de processo já devem existir no computador, porque <xref:System.Diagnostics.Process.GetProcessesByName%2A>não criar recursos do sistema, mas associa em vez disso que gerados por aplicações <xref:System.Diagnostics.Process>componentes.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcessesByName%2A> A `processName` pode ser especificado para um ficheiro executável que não está atualmente em execução no computador local, pelo que a matriz o método devolve pode estar vazia.       O nome do processo é um nome amigável para o processo, como o Outlook, o que não inclua o caminho ou a extensão de .exe. <xref:System.Diagnostics.Process.GetProcessesByName%2A>é útil para obter e manipulação de todos os processos que estão associados ao mesmo ficheiro executável.</xref:System.Diagnostics.Process.GetProcessesByName%2A> Por exemplo, um nome de ficheiro executável que pode passar o `processName` parâmetro, para poder Encerre todas as instâncias em execução desse ficheiro executável.       Embora um processo <xref:System.Diagnostics.Process.Id%2A>é exclusivo para um recurso único processo no sistema, vários processos no computador local podem estar a executar a aplicação especificada pelo `processName` parâmetro.</xref:System.Diagnostics.Process.Id%2A> Por conseguinte, <xref:System.Diagnostics.Process.GetProcessById%2A>devolve um processo no máximo, mas <xref:System.Diagnostics.Process.GetProcessesByName%2A>devolve uma matriz que contém todos os processos associados.</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> Se precisar de manipular o processo utilizando chamadas de API padrão, pode consultar cada estes processos por sua vez para o respetivo identificador. Não é possível aceder a recursos de processo através do nome do processo individualmente, mas, depois de ter de obter uma matriz de <xref:System.Diagnostics.Process>componentes que foram associados com os recursos do processo, pode iniciar, terminar e, caso contrário, manipular os recursos do sistema.</xref:System.Diagnostics.Process>       Pode utilizar esta sobrecarga para obter os processos no computador local, bem como num computador remoto. Utilize &quot;.&quot; para especificar o computador local. Outra sobrecarga existe que utiliza o computador local por predefinição.       Pode aceder a processos em computadores remotos apenas para ver informações, tais como, estatísticas sobre os processos. Não é possível fechar, terminar (utilizando <xref:System.Diagnostics.Process.Kill%2A>), ou começar processos em computadores remotos.</xref:System.Diagnostics.Process.Kill%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_14_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_14_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_14_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);
    parameters:
    - id: processName
      type: System.String
      description: "O nome amigável do processo."
    - id: machineName
      type: System.String
      description: "O nome de um computador na rede."
    return:
      type: System.Diagnostics.Process[]
      description: "Uma matriz do tipo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> que representa os recursos de processo com o ficheiro ou a aplicação especificada."
  overload: System.Diagnostics.Process.GetProcessesByName*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O <code> machineName </code> sintaxe do parâmetro é inválido. Poderá ter comprimento zero (0)."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>machineName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma do sistema operativo não suporta esta operação em computadores remotos."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Existem problemas de acesso ao contador de desempenho que API utilizado para obter informações sobre o processo. Esta exceção é específica do Windows NT, Windows 2000 e o Windows XP."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Ocorreu um problema ao aceder a um API de sistema subjacente."
  platform:
  - net462
- uid: System.Diagnostics.Process.Handle
  id: Handle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Handle
  nameWithType: Process.Handle
  fullName: System.Diagnostics.Process.Handle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o identificador nativo do processo associado."
  remarks: "Uma aplicação pode obter um identificador a um processo que pode ser utilizado como parâmetro para muitas funções de informações do processo e controlo. Pode utilizar este identificador para inicializar uma <xref:System.Threading.WaitHandle>ou para chamar os métodos nativos com a plataforma de invocam.</xref:System.Threading.WaitHandle>       Este identificador de processo é privado para uma aplicação - por outras palavras, processo identificadores não podem ser partilhados. Um processo também tem um processo <xref:System.Diagnostics.Process.Id%2A>que, ao contrário do identificador é exclusivo e, por conseguinte, válido em todo o sistema.</xref:System.Diagnostics.Process.Id%2A>       Apenas os processos iniciado através de uma chamada para <xref:System.Diagnostics.Process.Start%2A>defina a propriedade identificador correspondente <xref:System.Diagnostics.Process>instâncias.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A>"
  syntax:
    content: public IntPtr Handle { get; }
    return:
      type: System.IntPtr
      description: "O identificador de que o sistema operativo atribuído para o processo associado quando o processo foi iniciado. O sistema utiliza este identificador para controlar os atributos de processo."
  overload: System.Diagnostics.Process.Handle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo não foi iniciado ou foi terminado. Não é possível ler a propriedade identificador porque não há nenhum processo associado a este <xref href=&quot;System.Diagnostics.Process&quot;> </xref> instância.       - ou - <xref href=&quot;System.Diagnostics.Process&quot;> </xref> instância tem foi ligada a um processo em execução, mas não tem as permissões necessárias para obter um identificador com direitos de acesso total."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Está a tentar aceder a propriedade identificador de um processo que está em execução num computador remoto. Esta propriedade só está disponível para processos em execução no computador local."
  platform:
  - net462
- uid: System.Diagnostics.Process.HandleCount
  id: HandleCount
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: HandleCount
  nameWithType: Process.HandleCount
  fullName: System.Diagnostics.Process.HandleCount
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o número de identificadores abertos pelo processo."
  remarks: "Identificadores fornecem uma forma de um processo fazer referência aos objetos. Um processo pode obter os identificadores de ficheiros, recursos, filas de mensagens e muitos outros objetos de sistema operativo. O sistema operativo da memória reclama memória associada ao processo apenas quando a contagem de identificador é zero."
  syntax:
    content: public int HandleCount { get; }
    return:
      type: System.Int32
      description: "O número de identificadores de sistema operativo, que o processo foi aberta."
  overload: System.Diagnostics.Process.HandleCount*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é Windows 98 ou Windows Millennium edição (Windows-Me); definir o &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; propriedade <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para aceder a esta propriedade em 98 do Windows e Windows Me."
  platform:
  - net462
- uid: System.Diagnostics.Process.HasExited
  id: HasExited
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: HasExited
  nameWithType: Process.HasExited
  fullName: System.Diagnostics.Process.HasExited
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém um valor que indica se o processo associado foi terminado."
  remarks: "Um valor de `true` para HasExited indica que o processo associado foi terminada, normalmente ou anormalmente. Pode pedir ou forçar o processo associado termina chamando <xref:System.Diagnostics.Process.CloseMainWindow%2A>ou <xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> Se um identificador aberto para o processo, o sistema operativo disponibiliza a memória de processo quando o processo foi terminado, mas mantém as informações administrativas sobre o processo, tal como o identificador, o código de saída e a hora de saída. Para obter estas informações, pode utilizar o <xref:System.Diagnostics.Process.ExitCode%2A>e <xref:System.Diagnostics.Process.ExitTime%2A>Propriedades.</xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process.ExitCode%2A> Estas propriedades são povoadas automaticamente para os processos que foram iniciados por este componente. As informações administrativas for lançadas quando todos os o <xref:System.Diagnostics.Process>componentes que estão associados com o processo de sistema serão destruídos sem soltar não mais identificadores para o processo de saída.</xref:System.Diagnostics.Process>       Pode terminar um processo independentemente do seu código. Se tiver iniciado o processo com este componente, o sistema de atualizações do valor de HasExited automaticamente, mesmo que o processo associado termina de forma independente.      > [!NOTE] > Quando a saída padrão foi redirecionada para processadores de eventos assíncrona, é possível que o processamento de saída serão não ter sido concluída quando esta propriedade devolve `true`. Para garantir que o processamento de eventos assíncrona foi concluído, invoque o <xref:System.Diagnostics.Process.WaitForExit>sobrecarga que não recebe nenhum parâmetro antes de a verificar HasExited.</xref:System.Diagnostics.Process.WaitForExit>"
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_33_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_33_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_33_1.vb)]"
  syntax:
    content: public bool HasExited { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o processo de sistema operativo referenciado pelo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente terminou; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.HasExited*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não há nenhum processo associado ao objeto."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Não foi possível obter o código de saída para o processo."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Está a tentar aceder a propriedade HasExited para um processo que está em execução num computador remoto. Esta propriedade só está disponível para processos em execução no computador local."
  platform:
  - net462
- uid: System.Diagnostics.Process.Id
  id: Id
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Id
  nameWithType: Process.Id
  fullName: System.Diagnostics.Process.Id
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o identificador exclusivo para o processo associado."
  remarks: "O processo de Id não é válido se o processo associado não está em execução. Por conseguinte, deve garantir que o processo está em execução antes de tentar obter a propriedade de Id. Até que o processo termina, o identificador de processo identifica exclusivamente o processo em todo o sistema.       Pode ligar-se de um processo que está em execução no computador local ou remoto para um novo <xref:System.Diagnostics.Process>instância transferindo o identificador de processo para o <xref:System.Diagnostics.Process.GetProcessById%2A>método.</xref:System.Diagnostics.Process.GetProcessById%2A> </xref:System.Diagnostics.Process> <xref:System.Diagnostics.Process.GetProcessById%2A>é um `static` método que cria um novo componente e define a propriedade de Id para a nova <xref:System.Diagnostics.Process>instância automaticamente.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessById%2A>       Identificadores do processo podem ser reutilizados pelo sistema. O valor da propriedade de Id é exclusivo apenas enquanto está a executar o processo associado. Depois do processo foi terminada, o sistema pode reutilizar o valor da propriedade para um processo relacionado com o Id.       Porque o identificador é exclusivo no sistema, pode passá-lo para outros threads como uma alternativa ao transmitir um <xref:System.Diagnostics.Process>instância.</xref:System.Diagnostics.Process> Esta ação pode poupar recursos de sistema ainda garantir que o processo é corretamente identificado."
  example:
  - "The following example demonstrates how to obtain the Id for all running instances of an application. The code creates a new instance of Notepad, lists all the instances of Notepad, and then allows the user to enter the Id number to remove a specific instance.  \n  \n [!code-cs[System.Diagnostics.Process.Id#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_36_1.cs)]\n [!code-vb[System.Diagnostics.Process.Id#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_36_1.vb)]"
  syntax:
    content: public int Id { get; }
    return:
      type: System.Int32
      description: "O identificador exclusivo gerado pelo sistema do processo que é referenciado por esta <xref href=&quot;System.Diagnostics.Process&quot;> </xref> instância."
  overload: System.Diagnostics.Process.Id*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Propriedade de Id do processo não foi definida.       - ou - não existe nenhum processo associado a este <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objeto."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é Windows 98 ou Windows Millennium edição (Windows-Me); definir o &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; propriedade <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para aceder a esta propriedade em 98 do Windows e Windows Me."
  platform:
  - net462
- uid: System.Diagnostics.Process.Kill
  id: Kill
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Kill()
  nameWithType: Process.Kill()
  fullName: System.Diagnostics.Process.Kill()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Imediatamente interrompe o processo associado."
  remarks: "Kill força um encerramento do processo, enquanto <xref:System.Diagnostics.Process.CloseMainWindow%2A>pedidos apenas um término.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Quando está a executar um processo com uma interface gráfica, o respetivo ciclo de mensagens está num Estado de espera. O ciclo de mensagem executa sempre que é enviada uma mensagem do Windows para o processo pelo sistema operativo. Chamar <xref:System.Diagnostics.Process.CloseMainWindow%2A>envia um pedido para o próximo da janela principal, que, numa aplicação formada, fecha janelas subordinadas e revoga execução todos os ciclos de mensagem para a aplicação.</xref:System.Diagnostics.Process.CloseMainWindow%2A> O pedido para sair do processo ao chamar <xref:System.Diagnostics.Process.CloseMainWindow%2A>não forçar a aplicação para sair.</xref:System.Diagnostics.Process.CloseMainWindow%2A> A aplicação pode fazer para a verificação do utilizador antes de quitting ou pode refuse sair. Para forçar a aplicação para sair, utilize o método de eliminação. O comportamento de <xref:System.Diagnostics.Process.CloseMainWindow%2A>é idêntica de um utilizador a fechar a janela principal de uma aplicação utilizando o menu de sistema.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Por conseguinte, o pedido para sair do processo ao fechar a janela principal não forçar a aplicação para sair imediatamente.      > [!NOTE] > Kill o método executa no modo assíncrono. Depois de chamar o método de eliminação, chame o <xref:System.Diagnostics.Process.WaitForExit%2A>método deve aguardar para que o processo para sair, ou consulte o <xref:System.Diagnostics.Process.HasExited%2A>propriedade para determinar se o processo foi terminado.</xref:System.Diagnostics.Process.HasExited%2A> </xref:System.Diagnostics.Process.WaitForExit%2A>       Editado pelo processo de dados ou recursos atribuídos ao processo podem ser perdidos se chamar Kill. Kill faz com que um encerramento do processo anormal e deve ser utilizado apenas quando necessário. <xref:System.Diagnostics.Process.CloseMainWindow%2A>permite a um encerramento do processo de ordenada e fecha todos os windows, pelo que é preferível para as aplicações com uma interface.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Se <xref:System.Diagnostics.Process.CloseMainWindow%2A>falhar, é possível utilizar Kill para terminar o processo.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Kill é a única forma de terminar os processos que não dispõe de interfaces gráficas.       Pode chamar Kill e <xref:System.Diagnostics.Process.CloseMainWindow%2A>apenas para processos em execução no computador local.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Não é possível fazer com que os processos em computadores remotos para sair. Só pode ver informações de processos em execução em computadores remotos.      > [!NOTE] > Se a chamada do método Kill for efetuada enquanto o processo atualmente está a terminar, um <xref:System.ComponentModel.Win32Exception>é emitida para acesso negado.</xref:System.ComponentModel.Win32Exception>"
  syntax:
    content: public void Kill ();
    parameters: []
  overload: System.Diagnostics.Process.Kill*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Não foi possível terminar o processo associado.       - ou - está a terminar o processo.       - ou - o processo associado seja um executável de Win16."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Está a tentar chamar Kill para um processo que está em execução num computador remoto. O método só está disponível para processos em execução no computador local."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo já terminou.       - ou - não existe nenhum processo associado a este <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objeto."
  platform:
  - net462
- uid: System.Diagnostics.Process.LeaveDebugMode
  id: LeaveDebugMode
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: LeaveDebugMode()
  nameWithType: Process.LeaveDebugMode()
  fullName: System.Diagnostics.Process.LeaveDebugMode()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Assume um <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente fora do Estado que permita que interagem com processos de sistema operativo que são executados num modo especial."
  remarks: "Alguns processos de sistema operativo executam num modo especial. A tentar ler as propriedades de ou ligar a estes processos não for possível, a menos que tenha chamado <xref:System.Diagnostics.Process.EnterDebugMode%2A>no componente.</xref:System.Diagnostics.Process.EnterDebugMode%2A> É possível chame LeaveDebugMode quando já não necessita de acesso a estes processos que são executados num modo especial."
  syntax:
    content: public static void LeaveDebugMode ();
    parameters: []
  overload: System.Diagnostics.Process.LeaveDebugMode*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.MachineName
  id: MachineName
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MachineName
  nameWithType: Process.MachineName
  fullName: System.Diagnostics.Process.MachineName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o nome do processo associado está em execução no computador."
  remarks: "Pode ver dados estatísticos e informações do processo para processos em execução em computadores remotos, mas não é possível chamar <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>, ou <xref:System.Diagnostics.Process.Kill%2A>em computadores remotos.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> </xref:System.Diagnostics.Process.Start%2A>      > [!NOTE] > Quando o processo associado está em execução no computador local, esta propriedade devolve um período (&quot;.&quot;) para o nome da máquina. Deve utilizar o <xref:System.Environment.MachineName%2A?displayProperty=fullName>propriedade para obter o nome do computador correto.</xref:System.Environment.MachineName%2A?displayProperty=fullName>"
  example:
  - "To use the following example you must first start at least one instance of Notepad on a remote computer. The example requests the name of the remote computer on which Notepad is running, and then displays the respective <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, and MachineName properties for each instance.  \n  \n [!code-cs[process_GetProcessesByName2_2#2](~/add/codesnippet/csharp/p-system.diagnostics.pro_26_1.cs)]\n [!code-cpp[process_GetProcessesByName2_2#2](~/add/codesnippet/cpp/p-system.diagnostics.pro_26_1.cpp)]\n [!code-vb[process_GetProcessesByName2_2#2](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_26_1.vb)]"
  syntax:
    content: public string MachineName { get; }
    return:
      type: System.String
      description: "O nome do computador que o processo associado está em execução."
  overload: System.Diagnostics.Process.MachineName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não há nenhum processo associado a este <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objeto."
  platform:
  - net462
- uid: System.Diagnostics.Process.MainModule
  id: MainModule
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MainModule
  nameWithType: Process.MainModule
  fullName: System.Diagnostics.Process.MainModule
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o módulo principal do processo associado."
  remarks: "Um módulo de processo representa a.dll ou .exe ficheiro que é carregado para um determinado processo. A propriedade MainModule permite-lhe ver informações sobre o executável utilizada para iniciar o processo, incluindo o nome do módulo, nome de ficheiro e detalhes de memória de módulos."
  syntax:
    content: public System.Diagnostics.ProcessModule MainModule { get; }
    return:
      type: System.Diagnostics.ProcessModule
      description: "O <xref href=&quot;System.Diagnostics.ProcessModule&quot;> </xref> que foi utilizada para iniciar o processo."
  overload: System.Diagnostics.Process.MainModule*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Está a tentar aceder a propriedade MainModule para um processo que está em execução num computador remoto. Esta propriedade só está disponível para processos em execução no computador local."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Um processo de 32 bits está a tentar aceder a módulos de um processo de 64 bits."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é Windows 98 ou Windows Millennium edição (Windows-Me); definir &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; para <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para aceder a esta propriedade em 98 do Windows e Windows Me."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo <xref:System.Diagnostics.Process.Id*>não está disponível.</xref:System.Diagnostics.Process.Id*>       - ou - o processo foi terminado."
  platform:
  - net462
- uid: System.Diagnostics.Process.MainWindowHandle
  id: MainWindowHandle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MainWindowHandle
  nameWithType: Process.MainWindowHandle
  fullName: System.Diagnostics.Process.MainWindowHandle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o identificador de janela da janela principal do processo associado."
  remarks: "A janela principal é a janela aberta pelo processo que tem actualmente o foco (o <xref:System.Windows.Forms.Form.TopLevel%2A>formulário).</xref:System.Windows.Forms.Form.TopLevel%2A> Tem de utilizar o <xref:System.Diagnostics.Process.Refresh%2A>método para atualizar o <xref:System.Diagnostics.Process>objeto para obter o identificador de janela principal atual se foi alterada.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Refresh%2A> Em geral, uma vez que o identificador de janela é colocado em cache, utilize <xref:System.Diagnostics.Process.Refresh%2A>porta antecipadamente para garantir que irá obter o identificador atual.</xref:System.Diagnostics.Process.Refresh%2A>       Pode obter a propriedade MainWindowHandle apenas para processos em execução no computador local. A propriedade MainWindowHandle é um valor que identifica exclusivamente a janela que estão associada com o processo.       Um processo tenha uma janela principal associada ao mesmo apenas se o processo tem uma interface gráfica. Se o processo associado não tiver uma janela principal, o valor de MainWindowHandle é zero. O valor é também zero para os processos que foram ocultados, ou seja, processos que não estão visíveis na barra de tarefas. Isto pode ser o caso dos processos que são apresentadas como ícones na área de notificação, na extremidade direita da barra de tarefas.       Se tiver iniciado um processo e pretender utilizar o respetivo identificador de janela principal, considere utilizar o <xref:System.Diagnostics.Process.WaitForInputIdle%2A>método para permitir que o processo concluir a partir de, garantindo que o identificador de janela principal foi criado.</xref:System.Diagnostics.Process.WaitForInputIdle%2A> Caso contrário, será emitida uma exceção."
  syntax:
    content: public IntPtr MainWindowHandle { get; }
    return:
      type: System.IntPtr
      description: "O identificador de janela gerado pelo sistema da janela principal do processo associado."
  overload: System.Diagnostics.Process.MainWindowHandle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O MainWindowHandle não está definido porque o processo foi terminado."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Está a tentar aceder a propriedade MainWindowHandle para um processo que está em execução num computador remoto. Esta propriedade só está disponível para processos em execução no computador local."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é Windows 98 ou Windows Millennium edição (Windows-Me); definir &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; para <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para aceder a esta propriedade em 98 do Windows e Windows Me."
  platform:
  - net462
- uid: System.Diagnostics.Process.MainWindowTitle
  id: MainWindowTitle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MainWindowTitle
  nameWithType: Process.MainWindowTitle
  fullName: System.Diagnostics.Process.MainWindowTitle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a legenda da janela principal do processo."
  remarks: "Um processo tenha uma janela principal associada ao mesmo apenas se o processo tem uma interface gráfica. Se o processo associado não tiver uma janela principal (para que <xref:System.Diagnostics.Process.MainWindowHandle%2A>é zero), MainWindowTitle é uma cadeia vazia (&quot;&quot;).</xref:System.Diagnostics.Process.MainWindowHandle%2A> Se tiver iniciado um processo e pretender utilizar o título da janela principal, considere utilizar o <xref:System.Diagnostics.Process.WaitForInputIdle%2A>método para permitir que o processo concluir a partir de, garantindo que o identificador de janela principal foi criado.</xref:System.Diagnostics.Process.WaitForInputIdle%2A> Caso contrário, o sistema emite uma exceção.      > [!NOTE] > Janela principal é a janela de que tem actualmente o foco; tenha em atenção que isto poderá não ser a janela principal do processo. Tem de utilizar o <xref:System.Diagnostics.Process.Refresh%2A>método para atualizar o <xref:System.Diagnostics.Process>objeto para obter o identificador de janela principal atual se foi alterada.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Refresh%2A>"
  example:
  - "The following example starts an instance of Notepad and retrieves the caption of the main window of the process.  \n  \n [!code-cpp[process_MainWindowTitle#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_45_1.cpp)]\n [!code-cs[process_MainWindowTitle#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_45_1.cs)]\n [!code-vb[process_MainWindowTitle#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_45_1.vb)]"
  syntax:
    content: public string MainWindowTitle { get; }
    return:
      type: System.String
      description: "O título da janela principal do processo."
  overload: System.Diagnostics.Process.MainWindowTitle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A propriedade MainWindowTitle não está definida porque o processo foi terminado."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Está a tentar aceder a propriedade MainWindowTitle para um processo que está em execução num computador remoto. Esta propriedade só está disponível para processos em execução no computador local."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é Windows 98 ou Windows Millennium edição (Windows-Me); definir &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; para <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para aceder a esta propriedade em 98 do Windows e Windows Me."
  platform:
  - net462
- uid: System.Diagnostics.Process.MaxWorkingSet
  id: MaxWorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MaxWorkingSet
  nameWithType: Process.MaxWorkingSet
  fullName: System.Diagnostics.Process.MaxWorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define o tamanho máximo admissível trabalho conjunto, em bytes, para o processo associado."
  remarks: "O conjunto de trabalho de um processo é o conjunto de páginas de memória atualmente visíveis para o processo na memória RAM física. Estas páginas são residente e disponíveis para uma aplicação a utilizar sem acionar uma falhas de paginação.       O conjunto de trabalho inclui dados partilhados e privados. Os dados partilhados incluem as páginas que contêm as instruções que executa a sua aplicação, incluindo as páginas nos seus ficheiros. dll e os ficheiros system.dll. Como o de trabalho aumenta de tamanho, aumenta a pedido de memória.       Um processo tem tamanhos de conjunto de trabalho mínimo e máximo. Sempre que um recurso do processo for criado, o sistema de reserva-se uma quantidade de memória igual para o tamanho mínimo do trabalho conjunto para o processo. O Gestor de memória virtual tenta manter, pelo menos, a quantidade mínima de memória residente quando o processo estiver ativo, mas nunca continua mais do que o tamanho máximo.       O sistema define a predefinição trabalhar tamanhos de conjunto. Pode modificar estas tamanhos utilizando o MaxWorkingSet e <xref:System.Diagnostics.Process.MinWorkingSet%2A>Membros.</xref:System.Diagnostics.Process.MinWorkingSet%2A> No entanto, definir estes valores não garante que a memória será reservado ou residente.      > [!NOTE] > Quando aumenta o tamanho do conjunto de trabalho de um processo, tomar memória física na direção oposta ao resto do sistema. Certifique-se de que não pedem um tamanho de conjunto de trabalho mínimo ou máximo é demasiado grande, porque fazê-lo pode degradar o desempenho do sistema."
  syntax:
    content: public IntPtr MaxWorkingSet { get; set; }
    return:
      type: System.IntPtr
      description: "O máximo de trabalho definir tamanho permitido na memória para o processo, em bytes."
  overload: System.Diagnostics.Process.MaxWorkingSet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O máximo de tamanho do conjunto de trabalho é inválido. Tem de ser igual ou superior para o tamanho mínimo do trabalho conjunto."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Não é possível obter informações do conjunto de trabalho do recurso de processo associado.       - ou - o identificador de processo ou o identificador do processo for zero, porque o processo não foi iniciado."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Está a tentar aceder a propriedade MaxWorkingSet para um processo que está em execução num computador remoto. Esta propriedade só está disponível para processos em execução no computador local."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo <xref:System.Diagnostics.Process.Id*>não está disponível.</xref:System.Diagnostics.Process.Id*>       - ou - o processo foi terminado."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "É a plataforma Windows 98 ou Millennium edição do Windows (Windows-Me), que não suporta esta propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.MinWorkingSet
  id: MinWorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MinWorkingSet
  nameWithType: Process.MinWorkingSet
  fullName: System.Diagnostics.Process.MinWorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define o tamanho mínimo de permitido trabalho conjunto, em bytes, para o processo associado."
  remarks: "O conjunto de trabalho de um processo é o conjunto de páginas de memória atualmente visíveis para o processo na memória RAM física. Estas páginas são residente e disponíveis para uma aplicação a utilizar sem acionar uma falhas de paginação.       O conjunto de trabalho inclui dados partilhados e privados. Os dados partilhados incluem as páginas que contêm as instruções que executa a sua aplicação, incluindo as páginas nos seus ficheiros. dll e os ficheiros system.dll. Como o de trabalho aumenta de tamanho, aumenta a pedido de memória.       Um processo tem tamanhos de conjunto de trabalho mínimo e máximo. Sempre que um recurso do processo for criado, o sistema de reserva-se uma quantidade de memória igual para o tamanho mínimo do trabalho conjunto para o processo. O Gestor de memória virtual tenta manter, pelo menos, a quantidade mínima de memória residente quando o processo estiver ativo, mas nunca continua mais do que o tamanho máximo.       O sistema define a predefinição trabalhar tamanhos de conjunto. Pode modificar estas tamanhos utilizando o <xref:System.Diagnostics.Process.MaxWorkingSet%2A>e membros de MinWorkingSet.</xref:System.Diagnostics.Process.MaxWorkingSet%2A> No entanto, definir estes valores não garante que a memória será reservado ou residente.      > [!NOTE] > Quando aumenta o tamanho do conjunto de trabalho de um processo, tomar memória física na direção oposta ao resto do sistema. Certifique-se de que não pedem um tamanho de conjunto de trabalho mínimo ou máximo é demasiado grande, porque fazê-lo pode degradar o desempenho do sistema."
  syntax:
    content: public IntPtr MinWorkingSet { get; set; }
    return:
      type: System.IntPtr
      description: "O mínimo de trabalho definir tamanho que é necessário na memória para o processo, em bytes."
  overload: System.Diagnostics.Process.MinWorkingSet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O tamanho mínimo do trabalho conjunto é inválido. Tem de ser menor ou igual ao máximo o tamanho do conjunto de trabalho."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Não é possível obter informações do conjunto de trabalho do recurso de processo associado.       - ou - o identificador de processo ou o identificador do processo for zero, porque o processo não foi iniciado."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Está a tentar aceder a propriedade MinWorkingSet para um processo que está em execução num computador remoto. Esta propriedade só está disponível para processos em execução no computador local."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo <xref:System.Diagnostics.Process.Id*>não está disponível.</xref:System.Diagnostics.Process.Id*>       - ou - o processo foi terminado."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "É a plataforma Windows 98 ou Millennium edição do Windows (Windows-Me), que não suporta esta propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.Modules
  id: Modules
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Modules
  nameWithType: Process.Modules
  fullName: System.Diagnostics.Process.Modules
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém os módulos que tenham sido carregados pelo processo associado."
  remarks: "Um módulo de processo representa a.dll ou .exe ficheiro que é carregado para um determinado processo. A <xref:System.Diagnostics.ProcessModule>instância permite-lhe ver informações sobre um módulo, incluindo o nome do módulo, nome de ficheiro e detalhes de memória de módulos.</xref:System.Diagnostics.ProcessModule>       Um processo pode carregar vários módulos na memória. Por exemplo, ficheiros de .exe que carregar ficheiros. dll adicionais tem vários módulos.       Depois de iniciar o processo, esta coleção está vazia até que o processo carregou o sistema. Se o processo tiver uma janela principal, pode chamar <xref:System.Diagnostics.Process.WaitForInputIdle%2A>antes de obter esta propriedade para se certificar de que a coleção não está vazio quando obtiver a lista.</xref:System.Diagnostics.Process.WaitForInputIdle%2A>"
  syntax:
    content: public System.Diagnostics.ProcessModuleCollection Modules { get; }
    return:
      type: System.Diagnostics.ProcessModuleCollection
      description: "Uma matriz do tipo <xref href=&quot;System.Diagnostics.ProcessModule&quot;> </xref> que representa os módulos que tenham sido carregados pelo processo associado."
  overload: System.Diagnostics.Process.Modules*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Está a tentar aceder a propriedade de módulos de um processo que está em execução num computador remoto. Esta propriedade só está disponível para processos em execução no computador local."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo <xref:System.Diagnostics.Process.Id*>não está disponível.</xref:System.Diagnostics.Process.Id*>"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é Windows 98 ou Windows Millennium edição (Windows-Me); definir &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; para <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para aceder a esta propriedade em 98 do Windows e Windows Me."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Está a tentar aceder a propriedade de módulos para o processo de sistema ou o processo de inatividade. Estes processos não dispõe de módulos."
  platform:
  - net462
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize
  id: NonpagedSystemMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: NonpagedSystemMemorySize
  nameWithType: Process.NonpagedSystemMemorySize
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a quantidade de memória não paginável do sistema, em bytes, alocados para o processo associado."
  syntax:
    content: public int NonpagedSystemMemorySize { get; }
    return:
      type: System.Int32
      description: "A quantidade de memória, em bytes, o sistema tem atribuída para o processo associado que não é possível escrever no ficheiro de paginação de memória virtual."
  overload: System.Diagnostics.Process.NonpagedSystemMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "É a plataforma Windows 98 ou Millennium edição do Windows (Windows-Me), que não suporta esta propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize64
  id: NonpagedSystemMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: NonpagedSystemMemorySize64
  nameWithType: Process.NonpagedSystemMemorySize64
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a quantidade de memória não paginável do sistema, em bytes, alocados para o processo associado."
  remarks: "O valor devolvido por esta propriedade representa o tamanho atual de memória não paginável do sistema utilizada pelo processo de, em bytes. Memória do sistema é a memória física utilizada pelo sistema operativo e está dividida em paginada e na memória não paginável agrupamentos. As alocações de memória não paginável permanecem na memória de sistema e não são paginadas enviados para o ficheiro de paginação de memória virtual.       Esta propriedade pode ser utilizada para monitorizar a utilização de memória em computadores com processadores de 32 bits ou 64 bits processadores. O valor da propriedade é equivalente à **conjunto não paginável** contador de desempenho para o processo."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_28_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_28_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_28_1.vb)]"
  syntax:
    content: public long NonpagedSystemMemorySize64 { get; }
    return:
      type: System.Int64
      description: "A quantidade de memória do sistema, em bytes, alocado para o processo associado que não é possível escrever no ficheiro de paginação de memória virtual."
  overload: System.Diagnostics.Process.NonpagedSystemMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "É a plataforma Windows 98 ou Millennium edição do Windows (Windows-Me), que não suporta esta propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.OnExited
  id: OnExited
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: OnExited()
  nameWithType: Process.OnExited()
  fullName: System.Diagnostics.Process.OnExited()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Gera o <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref> eventos."
  remarks: "OnExited é o método de API que desencadeia a <xref:System.Diagnostics.Process.Exited>eventos.</xref:System.Diagnostics.Process.Exited> Chamar OnExited causas o <xref:System.Diagnostics.Process.Exited>ocorrência de evento e é a única forma para aumentar o evento utilizando o <xref:System.Diagnostics.Process>componente.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Exited> OnExited é principalmente utilizada ao efetuar a derivação de classes do componente do.       Como alternativa à OnExited, pode escrever o seu próprio processador de eventos. Crie o seu próprio delegado de processador de eventos e o seu próprio método de processamento de eventos.      > [!NOTE] > Se estiver a utilizar o ambiente do Visual Studio, um delegado de processador de eventos (AddOnExited) e um método de processamento de eventos (Process1_Exited) são criados por si quando arrasta uma <xref:System.Diagnostics.Process>componente para um formulário e faça duplo clique no ícone.</xref:System.Diagnostics.Process> O código cria para executar quando o <xref:System.Diagnostics.Process.Exited>evento ocorre é introduzido para o procedimento Process1_Exited.</xref:System.Diagnostics.Process.Exited> Não é necessário criar o membro OnExited, porque está implementado para si.       Gerar um evento invoca o processador de eventos através de um delegado. Para obter uma descrição geral, consulte [eventos](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example shows how to use the OnExited method in a derived class.  \n  \n [!code-cs[OnExitSample#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_9_1.cs)]\n [!code-vb[OnExitSample#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_9_1.vb)]"
  syntax:
    content: protected void OnExited ();
    parameters: []
  overload: System.Diagnostics.Process.OnExited*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.OutputDataReceived
  id: OutputDataReceived
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: OutputDataReceived
  nameWithType: Process.OutputDataReceived
  fullName: System.Diagnostics.Process.OutputDataReceived
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ocorre sempre que uma aplicação escreve uma linha para o respetivo redirecionada <xref:System.Diagnostics.Process.StandardOutput*>stream.</xref:System.Diagnostics.Process.StandardOutput*>"
  remarks: "O evento OutputDataReceived indica que associada <xref:System.Diagnostics.Process>ter escrito uma linha, terminar com um caráter de nova linha, para o respetivo redirecionada <xref:System.Diagnostics.Process.StandardOutput%2A>stream.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process>       O evento é ativado durante operações de leitura assíncrona no <xref:System.Diagnostics.Process.StandardOutput%2A>.</xref:System.Diagnostics.Process.StandardOutput%2A> Para iniciar as operações de leitura assíncrona, tem de redirecionar o <xref:System.Diagnostics.Process.StandardOutput%2A>fluxo de um <xref:System.Diagnostics.Process>, adicione o processador de eventos para o evento de OutputDataReceived e chamar <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> </xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardOutput%2A> Depois disso, sinais de evento OutputDataReceived sempre que o processo escreve uma linha ao redirecionada <xref:System.Diagnostics.Process.StandardOutput%2A>stream, até que o processo de sai ou chamadas <xref:System.Diagnostics.Process.CancelOutputRead%2A>.</xref:System.Diagnostics.Process.CancelOutputRead%2A> </xref:System.Diagnostics.Process.StandardOutput%2A>      > [!NOTE] > A aplicação que está a processar o resultado assíncrono deverá chamar o <xref:System.Diagnostics.Process.WaitForExit%2A>método para se certificar de que a memória intermédia de saída foram descarregada.</xref:System.Diagnostics.Process.WaitForExit%2A>"
  example:
  - "The following example illustrates how to perform asynchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream of the `ipconfig` command.  \n  \n The example creates an event delegate for the `OutputHandler` event handler and associates it with the OutputDataReceived event. The event handler receives text lines from the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, formats the text, and saves it in an output string that’s later shown in the example’s console window.  \n  \n [!code-cpp[Process_AsyncStreams#4](~/add/codesnippet/cpp/e-system.diagnostics.pro_2_1.cpp)]\n [!code-cs[Process_AsyncStreams#4](~/add/codesnippet/csharp/e-system.diagnostics.pro_2_1.cs)]\n [!code-vb[Process_AsyncStreams#4](~/add/codesnippet/visualbasic/e-system.diagnostics.pro_2_1.vb)]"
  syntax:
    content: public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;
    return:
      type: System.Diagnostics.DataReceivedEventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedMemorySize
  id: PagedMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedMemorySize
  nameWithType: Process.PagedMemorySize
  fullName: System.Diagnostics.Process.PagedMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a quantidade de memória paginada, em bytes, alocados para o processo associado."
  syntax:
    content: public int PagedMemorySize { get; }
    return:
      type: System.Int32
      description: "A quantidade de memória, em bytes, atribuído pelo processo associado que pode ser escrito para o ficheiro de paginação de memória virtual."
  overload: System.Diagnostics.Process.PagedMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "É a plataforma Windows 98 ou Millennium edição do Windows (Windows-Me), que não suporta esta propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedMemorySize64
  id: PagedMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedMemorySize64
  nameWithType: Process.PagedMemorySize64
  fullName: System.Diagnostics.Process.PagedMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a quantidade de memória paginada, em bytes, alocados para o processo associado."
  remarks: "O valor devolvido por esta propriedade representa o tamanho atual da memória no ficheiro de paginação de memória virtual utilizada pelo processo de, em bytes. O sistema operativo utiliza o ficheiro de paginação de memória virtual em conjunto com a memória física para gerir o espaço de endereço virtual para cada processo. Quando a memória paginável não está a ser utilizado, pode ser transferido para o ficheiro de paginação de memória virtual no disco. Para obter o tamanho de memória utilizada pelo sistema operativo para o processo, utilize o <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A>propriedade.</xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A>       Esta propriedade pode ser utilizada para monitorizar a utilização de memória em computadores com processadores de 32 bits ou 64 bits processadores. O valor da propriedade é equivalente à **Bytes do ficheiro de página** contador de desempenho para o processo."
  example:
  - "The following code example starts an instance of the Notepad application, and then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_12_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_12_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_12_1.vb)]"
  syntax:
    content: public long PagedMemorySize64 { get; }
    return:
      type: System.Int64
      description: "A quantidade de memória, em bytes, alocado no ficheiro de paginação de memória virtual para o processo associado."
  overload: System.Diagnostics.Process.PagedMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "É a plataforma Windows 98 ou Millennium edição do Windows (Windows-Me), que não suporta esta propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedSystemMemorySize
  id: PagedSystemMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedSystemMemorySize
  nameWithType: Process.PagedSystemMemorySize
  fullName: System.Diagnostics.Process.PagedSystemMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a quantidade de memória paginável do sistema, em bytes, alocados para o processo associado."
  syntax:
    content: public int PagedSystemMemorySize { get; }
    return:
      type: System.Int32
      description: "A quantidade de memória, em bytes, o sistema tem atribuída para o processo associado que pode ser escrito para o ficheiro de paginação de memória virtual."
  overload: System.Diagnostics.Process.PagedSystemMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "É a plataforma Windows 98 ou Millennium edição do Windows (Windows-Me), que não suporta esta propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedSystemMemorySize64
  id: PagedSystemMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedSystemMemorySize64
  nameWithType: Process.PagedSystemMemorySize64
  fullName: System.Diagnostics.Process.PagedSystemMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a quantidade de memória paginável do sistema, em bytes, alocados para o processo associado."
  remarks: "O valor devolvido por este valor da propriedade representa o tamanho atual da memória paginável do sistema utilizada pelo processo de, em bytes. Memória do sistema é a memória física utilizada pelo sistema operativo e está dividida em paginada e na memória não paginável agrupamentos. Quando a memória paginável não está a ser utilizado, pode ser transferido para o ficheiro de paginação de memória virtual no disco. Para obter o tamanho da memória utilizada pelo processo de aplicação, utilize o <xref:System.Diagnostics.Process.PagedMemorySize64%2A>propriedade.</xref:System.Diagnostics.Process.PagedMemorySize64%2A>       Esta propriedade pode ser utilizada para monitorizar a utilização de memória em computadores com processadores de 32 bits ou 64 bits processadores. O valor da propriedade é equivalente à **paginável conjunto** contador de desempenho para o processo."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_18_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_18_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_18_1.vb)]"
  syntax:
    content: public long PagedSystemMemorySize64 { get; }
    return:
      type: System.Int64
      description: "A quantidade de memória do sistema, em bytes, alocado para o processo associado que pode ser escrito para o ficheiro de paginação de memória virtual."
  overload: System.Diagnostics.Process.PagedSystemMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "É a plataforma Windows 98 ou Millennium edição do Windows (Windows-Me), que não suporta esta propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakPagedMemorySize
  id: PeakPagedMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakPagedMemorySize
  nameWithType: Process.PeakPagedMemorySize
  fullName: System.Diagnostics.Process.PeakPagedMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a quantidade máxima de memória no ficheiro de paginação de memória virtual, em bytes, utilizada pelo processo associado."
  syntax:
    content: public int PeakPagedMemorySize { get; }
    return:
      type: System.Int32
      description: "A quantidade máxima de memória, em bytes, atribuído pelo processo associado que foi possível escrever o ficheiro de paginação de memória virtual."
  overload: System.Diagnostics.Process.PeakPagedMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "É a plataforma Windows 98 ou Millennium edição do Windows (Windows-Me), que não suporta esta propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakPagedMemorySize64
  id: PeakPagedMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakPagedMemorySize64
  nameWithType: Process.PeakPagedMemorySize64
  fullName: System.Diagnostics.Process.PeakPagedMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a quantidade máxima de memória no ficheiro de paginação de memória virtual, em bytes, utilizada pelo processo associado."
  remarks: "O valor devolvido por este valor da propriedade representa o tamanho máximo da memória no ficheiro de paginação de memória virtual utilizada pelo processo desde que foi iniciado, em bytes. O sistema operativo utiliza o ficheiro de paginação de memória virtual em conjunto com a memória física para gerir o espaço de endereço virtual para cada processo. Quando a memória paginável não está a ser utilizado, pode ser transferido para o ficheiro de paginação de memória virtual no disco.       Esta propriedade pode ser utilizada para monitorizar a utilização de memória em computadores com processadores de 32 bits ou 64 bits processadores. O valor da propriedade é equivalente à **pico de Bytes do ficheiro de página** contador de desempenho para o processo."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_24_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_24_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_24_1.vb)]"
  syntax:
    content: public long PeakPagedMemorySize64 { get; }
    return:
      type: System.Int64
      description: "A quantidade máxima de memória, em bytes, alocado no ficheiro de paginação de memória virtual para o processo associado, desde que foi iniciado."
  overload: System.Diagnostics.Process.PeakPagedMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "É a plataforma Windows 98 ou Millennium edição do Windows (Windows-Me), que não suporta esta propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakVirtualMemorySize
  id: PeakVirtualMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakVirtualMemorySize
  nameWithType: Process.PeakVirtualMemorySize
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a quantidade máxima de memória virtual, em bytes, utilizadas pelo processo associado."
  syntax:
    content: public int PeakVirtualMemorySize { get; }
    return:
      type: System.Int32
      description: "A quantidade máxima de memória virtual, em bytes, o que pediu o processo associado."
  overload: System.Diagnostics.Process.PeakVirtualMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "É a plataforma Windows 98 ou Millennium edição do Windows (Windows-Me), que não suporta esta propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakVirtualMemorySize64
  id: PeakVirtualMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakVirtualMemorySize64
  nameWithType: Process.PeakVirtualMemorySize64
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a quantidade máxima de memória virtual, em bytes, utilizadas pelo processo associado."
  remarks: "O valor devolvido por esta propriedade representa o tamanho máximo de memória virtual utilizada pelo processo desde que foi iniciado, em bytes. O sistema operativo mapeia o espaço de endereço virtual para cada processo a páginas carregada na memória física ou a páginas armazenadas no ficheiro de paginação de memória virtual no disco.       Esta propriedade pode ser utilizada para monitorizar a utilização de memória em computadores com processadores de 32 bits ou 64 bits processadores. O valor da propriedade é equivalente à **Virtual Bytes pico** contador de desempenho para o processo."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_23_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_23_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_23_1.vb)]"
  syntax:
    content: public long PeakVirtualMemorySize64 { get; }
    return:
      type: System.Int64
      description: "A quantidade máxima de memória virtual, em bytes, alocado para o processo associado, desde que foi iniciado."
  overload: System.Diagnostics.Process.PeakVirtualMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "É a plataforma Windows 98 ou Millennium edição do Windows (Windows-Me), que não suporta esta propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakWorkingSet
  id: PeakWorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakWorkingSet
  nameWithType: Process.PeakWorkingSet
  fullName: System.Diagnostics.Process.PeakWorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a tamanho do conjunto para o processo associado, a funcionar em bytes das horas de ponta."
  remarks: "O conjunto de trabalho de um processo é o conjunto de páginas de memória atualmente visíveis para o processo na memória RAM física. Estas páginas são residente e disponíveis para uma aplicação a utilizar sem acionar uma falhas de paginação.       O conjunto de trabalho inclui dados partilhados e privados. Os dados partilhados incluem as páginas que contêm as instruções que executa o processo, incluindo módulos do processo e as bibliotecas de sistema."
  syntax:
    content: public int PeakWorkingSet { get; }
    return:
      type: System.Int32
      description: "A quantidade máxima de memória física que o processo associado necessárias ao mesmo tempo, em bytes."
  overload: System.Diagnostics.Process.PeakWorkingSet*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "É a plataforma Windows 98 ou Millennium edição do Windows (Windows-Me), que não suporta esta propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakWorkingSet64
  id: PeakWorkingSet64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakWorkingSet64
  nameWithType: Process.PeakWorkingSet64
  fullName: System.Diagnostics.Process.PeakWorkingSet64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a quantidade máxima de memória física, em bytes, utilizadas pelo processo associado."
  remarks: "O valor devolvido por esta propriedade representa o tamanho máximo do conjunto de memória utilizada pelo processo desde que foi iniciado, em bytes a funcionar. O conjunto de trabalho de um processo é o conjunto de páginas de memória atualmente visíveis para o processo na memória RAM física. Estas páginas são residente e disponíveis para uma aplicação a utilizar sem acionar uma falhas de paginação.       O conjunto de trabalho inclui dados partilhados e privados. Os dados partilhados incluem as páginas que contêm as instruções que executa o processo, incluindo instruções dos módulos do processo e as bibliotecas de sistema.       Esta propriedade pode ser utilizada para monitorizar a utilização de memória em computadores com processadores de 32 bits ou 64 bits processadores. O valor da propriedade é equivalente à **utilização máxima do conjunto de trabalho** contador de desempenho para o processo."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_34_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_34_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_34_1.vb)]"
  syntax:
    content: public long PeakWorkingSet64 { get; }
    return:
      type: System.Int64
      description: "A quantidade máxima de memória física, em bytes, alocado para o processo associado, desde que foi iniciado."
  overload: System.Diagnostics.Process.PeakWorkingSet64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "É a plataforma Windows 98 ou Millennium edição do Windows (Windows-Me), que não suporta esta propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.PriorityBoostEnabled
  id: PriorityBoostEnabled
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PriorityBoostEnabled
  nameWithType: Process.PriorityBoostEnabled
  fullName: System.Diagnostics.Process.PriorityBoostEnabled
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define um valor que indica se a prioridade de processo associado temporariamente deve ser elevada pelo sistema operativo quando a janela principal tem o foco."
  remarks: "Quando um thread é executada num processo para a qual a classe de prioridade tem um dos valores de enumeração prioridade dinâmico (<xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, ou <xref:System.Diagnostics.ProcessPriorityClass>), o sistema boosts temporariamente prioridade do thread quando é retirado do Estado de espera.</xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> Esta ação impede que outros processos interromper o processamento do thread atual. A definição de PriorityBoostEnabled afeta todos os threads existentes e qualquer threads subsequentemente criados pelo processo. Para restaurar o comportamento normal, defina a propriedade de PriorityBoostEnabled como `false`.      > [!NOTE] > Os aumentos prioridade demasiado elevada podem drenar recursos do sistema de operativo essencial e funções de rede, a causar problemas com outras tarefas de sistema operativo."
  syntax:
    content: public bool PriorityBoostEnabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se for dinâmico, os aumentos da prioridade de processo deve ocorrer para um processo quando é retirado do Estado de espera; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. A predefinição é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.PriorityBoostEnabled*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Não foi possível obter as informações de aumento de prioridade do recurso de processo associado."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "É a plataforma Windows 98 ou Millennium edição do Windows (Windows-Me), que não suporta esta propriedade.       - ou - o identificador de processo ou o identificador de processo é zero. (Não foi iniciado o processo.)"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Está a tentar aceder a propriedade PriorityBoostEnabled para um processo que está em execução num computador remoto. Esta propriedade só está disponível para processos em execução no computador local."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo <xref:System.Diagnostics.Process.Id*>não está disponível.</xref:System.Diagnostics.Process.Id*>"
  platform:
  - net462
- uid: System.Diagnostics.Process.PriorityClass
  id: PriorityClass
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PriorityClass
  nameWithType: Process.PriorityClass
  fullName: System.Diagnostics.Process.PriorityClass
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define a categoria de prioridade geral do processo associado."
  remarks: "Uma classe de prioridade de processo abrange uma série de níveis de prioridade do thread. Threads com prioridades diferentes que estão em execução no processo de executam relativo para a classe de prioridade do processo. Win32 utiliza classes de prioridade quatro com níveis de prioridade base sete por classe. Estas classes de prioridade de processo são capturadas no <xref:System.Diagnostics.ProcessPriorityClass>enumeração, que lhe permite definir a prioridade de processo <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, ou <xref:System.Diagnostics.ProcessPriorityClass>.</xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> Com base no tempo decorridos ou outros boosts, o nível de prioridade base podem ser alterados pelo sistema operativo quando um processo tem de ser colocado à frente das outras pessoas para acesso para o processador. Além disso, pode definir o <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>para temporariamente melhorar o nível de prioridade de threads que foram efetuadas fora do Estado de espera.</xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> A prioridade é reposta quando o processo devolve para o estado de espera.       O <xref:System.Diagnostics.Process.BasePriority%2A>propriedade permite-lhe ver a prioridade inicial que é atribuída a um processo.</xref:System.Diagnostics.Process.BasePriority%2A> No entanto, porque é só de leitura, não é possível utilizar o <xref:System.Diagnostics.Process.BasePriority%2A>propriedade para definir a prioridade de um processo.</xref:System.Diagnostics.Process.BasePriority%2A> Para alterar a prioridade, utilize a propriedade de PriorityClass, que obtém ou define a categoria de prioridade geral para o processo.       A classe de prioridade não pode ser visualizada utilizando o Monitor de sistema. A tabela seguinte mostra a relação entre o <xref:System.Diagnostics.Process.BasePriority%2A>e valores de PriorityClass.</xref:System.Diagnostics.Process.BasePriority%2A>      | BasePriority | PriorityClass |   |------------------|-------------------|   |&4; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&8; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&13; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&24; | <xref:System.Diagnostics.ProcessPriorityClass>|</xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_29_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_29_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_29_1.vb)]"
  syntax:
    content: public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }
    return:
      type: System.Diagnostics.ProcessPriorityClass
      description: "A categoria de prioridade para o processo associado, de que o <xref:System.Diagnostics.Process.BasePriority*>do processo é calculado.</xref:System.Diagnostics.Process.BasePriority*>"
  overload: System.Diagnostics.Process.PriorityClass*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "As informações de prioridade do processo não foi possível definir ou obtidas a partir do recurso de processo associado.       - ou - o identificador de processo ou o identificador de processo é zero. (Não foi iniciado o processo.)"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Está a tentar aceder a propriedade PriorityClass para um processo que está em execução num computador remoto. Esta propriedade só está disponível para processos em execução no computador local."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo <xref:System.Diagnostics.Process.Id*>não está disponível.</xref:System.Diagnostics.Process.Id*>"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Definiu o PriorityClass para <xref uid=&quot;langword_csharp_AboveNormal&quot; name=&quot;AboveNormal&quot; href=&quot;&quot;> </xref> ou <xref uid=&quot;langword_csharp_BelowNormal&quot; name=&quot;BelowNormal&quot; href=&quot;&quot;> </xref> quando utilizar Windows 98 ou Windows Millennium edição (Windows-Me). Estas plataformas não suportam esses valores para a classe de prioridade."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "Classe de prioridade não pode ser definida porque esta não utilize um valor válido, tal como definido no <xref href=&quot;System.Diagnostics.ProcessPriorityClass&quot;> </xref> enumeração."
  platform:
  - net462
- uid: System.Diagnostics.Process.PrivateMemorySize
  id: PrivateMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PrivateMemorySize
  nameWithType: Process.PrivateMemorySize
  fullName: System.Diagnostics.Process.PrivateMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a quantidade de memória privada, em bytes, alocados para o processo associado."
  syntax:
    content: public int PrivateMemorySize { get; }
    return:
      type: System.Int32
      description: "O número de bytes atribuído pelo processo associado que não pode ser partilhado com outros processos."
  overload: System.Diagnostics.Process.PrivateMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "É a plataforma Windows 98 ou Millennium edição do Windows (Windows-Me), que não suporta esta propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.PrivateMemorySize64
  id: PrivateMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PrivateMemorySize64
  nameWithType: Process.PrivateMemorySize64
  fullName: System.Diagnostics.Process.PrivateMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a quantidade de memória privada, em bytes, alocados para o processo associado."
  remarks: "O valor devolvido por esta propriedade representa o tamanho atual de memória utilizada pelo processo, em bytes, o que não pode ser partilhada com outros processos.       Esta propriedade pode ser utilizada para monitorizar a utilização de memória em computadores com processadores de 32 bits ou 64 bits processadores. O valor da propriedade é equivalente à **Bytes privados** contador de desempenho para o processo."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_17_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_17_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_17_1.vb)]"
  syntax:
    content: public long PrivateMemorySize64 { get; }
    return:
      type: System.Int64
      description: "A quantidade de memória, em bytes, alocado para o processo associado que não pode ser partilhado com outros processos."
  overload: System.Diagnostics.Process.PrivateMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "É a plataforma Windows 98 ou Millennium edição do Windows (Windows-Me), que não suporta esta propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.PrivilegedProcessorTime
  id: PrivilegedProcessorTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PrivilegedProcessorTime
  nameWithType: Process.PrivilegedProcessorTime
  fullName: System.Diagnostics.Process.PrivilegedProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o tempo de processador com privilégios deste processo."
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_37_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_37_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_37_1.vb)]"
  syntax:
    content: public TimeSpan PrivilegedProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "A <xref:System.TimeSpan>que indica a quantidade de tempo que o processo tem despende a executar um código no núcleo do sistema operativo.</xref:System.TimeSpan>"
  overload: System.Diagnostics.Process.PrivilegedProcessorTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "É a plataforma Windows 98 ou Millennium edição do Windows (Windows-Me), que não suporta esta propriedade."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Está a tentar aceder a propriedade PrivilegedProcessorTime para um processo que está em execução num computador remoto. Esta propriedade só está disponível para processos em execução no computador local."
  platform:
  - net462
- uid: System.Diagnostics.Process.ProcessName
  id: ProcessName
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ProcessName
  nameWithType: Process.ProcessName
  fullName: System.Diagnostics.Process.ProcessName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o nome do processo."
  remarks: "A propriedade ProcessName contém um nome de ficheiro executável, como o Outlook, o que não inclua o caminho ou a extensão de .exe. É útil para obter e manipulação de todos os processos que estão associados ao mesmo ficheiro executável.      > [!NOTE] > No [!INCLUDE[Win2kFamily](~/add/includes/win2kfamily-md.md)] sistemas operativos, a propriedade ProcessName poderá ser truncada de acordo com 15 carateres se não não possível obter as informações do módulo de processo.       Pode chamar <xref:System.Diagnostics.Process.GetProcessesByName%2A>, transmitir um nome de ficheiro executável, para obter uma matriz que contém todas as instâncias em execução no computador especificado.</xref:System.Diagnostics.Process.GetProcessesByName%2A> Pode utilizar esta matriz, por exemplo, para encerrar todas as instâncias em execução do ficheiro executável."
  syntax:
    content: public string ProcessName { get; }
    return:
      type: System.String
      description: "O nome que o sistema utiliza para identificar o processo para o utilizador."
  overload: System.Diagnostics.Process.ProcessName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo não tem um identificador, ou nenhum processo está associado a <xref href=&quot;System.Diagnostics.Process&quot;> </xref>.       - ou - o processo associado foi terminado."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é Windows 98 ou Windows Millennium edição (Windows-Me); definir &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; para <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para aceder a esta propriedade em 98 do Windows e Windows Me."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O processo não está neste computador."
  platform:
  - net462
- uid: System.Diagnostics.Process.ProcessorAffinity
  id: ProcessorAffinity
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ProcessorAffinity
  nameWithType: Process.ProcessorAffinity
  fullName: System.Diagnostics.Process.ProcessorAffinity
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define os processadores nos quais os threads neste processo podem ser agendados para ser executada."
  remarks: "No Windows 2000 ou posterior, um thread num processo pode migrar de processador para processador, com cada migração recarregar a cache do processador. Sob cargas pesadas de sistema, especificar que processador deve executar um thread específico pode melhorar o desempenho ao reduzir o número de vezes que a cache do processador é recarregar. A associação entre um processador e um thread denomina-se a afinidade do processador.       Cada processador é representada como um pouco. Bit 0 é o processador de um, o bit 1 é processador dois e assim sucessivamente. Se definir um pouco para o valor de 1, o processador correspondente é selecionado para a atribuição de thread. Quando definir o valor de ProcessorAffinity para zero, algoritmos de agendamento do sistema operativo definir a afinidade do thread. Quando o valor de ProcessorAffinity está definido como qualquer valor diferente de zero, o valor é interpretado como uma máscara de bits que especifica os processadores elegíveis para seleção.       A tabela seguinte mostra uma seleção de valores de ProcessorAffinity para um sistema de oito processadores.      | Máscara de bits | Valor binário | Processadores elegíveis |   |-------------|------------------|-------------------------|   | 0x0001 | 00000000 00000001 | 1 |   | 0x0003 | 00000000 00000011 | 1 e 2 |   | 0x0007 | 00000000 00000111 | 1, 2 e 3 |   | 0x0009 | 00000000 00001001 | 1 e 4 |   | 0x007F | 00000000 01111111 | 1, 2, 3, 4, 5, 6 e 7 |"
  syntax:
    content: public IntPtr ProcessorAffinity { get; set; }
    return:
      type: System.IntPtr
      description: "Uma máscara de bits que representa os processadores que podem ser executada em threads no processo associado. A predefinição depende o número de processadores no computador. O valor predefinido é 2 <sup>n</sup> -1, em que n é o número de processadores."
  overload: System.Diagnostics.Process.ProcessorAffinity*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Informações de ProcessorAffinity não foi possível definir ou obtidas a partir do recurso de processo associado.       - ou - o identificador de processo ou o identificador de processo é zero. (Não foi iniciado o processo.)"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Está a tentar aceder a propriedade ProcessorAffinity para um processo que está em execução num computador remoto. Esta propriedade só está disponível para processos em execução no computador local."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo <xref:System.Diagnostics.Process.Id*>não estava disponível.</xref:System.Diagnostics.Process.Id*>       - ou - o processo foi terminado."
  platform:
  - net462
- uid: System.Diagnostics.Process.Refresh
  id: Refresh
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Refresh()
  nameWithType: Process.Refresh()
  fullName: System.Diagnostics.Process.Refresh()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Elimina todas as informações sobre o processo associado que tenha foi colocado em cache dentro do componente do processo."
  remarks: "Após a atualização é denominada, o primeiro pedido para obter informações sobre cada propriedade faz com que o componente de processo obter um novo valor de processo associado.       Quando um <xref:System.Diagnostics.Process>componente está associado um recurso do processo, os valores de propriedade do <xref:System.Diagnostics.Process>imediatamente são povoadas de acordo com o estado do processo associado.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process> Se posteriormente alterar as informações sobre o processo associado, essas alterações não serão refletidas no <xref:System.Diagnostics.Process>do componente em cache valores.</xref:System.Diagnostics.Process> O <xref:System.Diagnostics.Process>componente é um instantâneo do recurso processo no momento estão associados.</xref:System.Diagnostics.Process> Para ver os valores atuais para o processo associado, chame o método de atualização."
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_1_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_1_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_1_1.vb)]"
  syntax:
    content: public void Refresh ();
    parameters: []
  overload: System.Diagnostics.Process.Refresh*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.Responding
  id: Responding
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Responding
  nameWithType: Process.Responding
  fullName: System.Diagnostics.Process.Responding
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém um valor que indica se a interface de utilizador do processo está a responder."
  remarks: "Se um processo tem uma interface de utilizador, a propriedade de responder entra em contacto com a interface de utilizador para determinar se o processo está a responder a intervenção do utilizador. Se a interface não responder imediatamente, devolve de propriedade responder `false`. Utilize esta propriedade para determinar se a interface do processo associado deixou de responder.       Se o processo não tem um <xref:System.Diagnostics.Process.MainWindowHandle%2A>, esta propriedade devolve `true`.</xref:System.Diagnostics.Process.MainWindowHandle%2A>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_39_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_39_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_39_1.vb)]"
  syntax:
    content: public bool Responding { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a interface de utilizador do processo associado está a responder ao sistema; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.Responding*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é Windows 98 ou Windows Millennium edição (Windows-Me); definir &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; para <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para aceder a esta propriedade em 98 do Windows e Windows Me."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não há nenhum processo associado a este <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objeto."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Está a tentar aceder a propriedade de responder para um processo que está em execução num computador remoto. Esta propriedade só está disponível para processos em execução no computador local."
  platform:
  - net462
- uid: System.Diagnostics.Process.SafeHandle
  id: SafeHandle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: SafeHandle
  nameWithType: Process.SafeHandle
  fullName: System.Diagnostics.Process.SafeHandle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o identificador nativo deste processo."
  remarks: "O identificador só está disponível se o componente chamado iniciou o processo."
  syntax:
    content: public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }
    return:
      type: Microsoft.Win32.SafeHandles.SafeProcessHandle
      description: "O identificador nativo deste processo."
  overload: System.Diagnostics.Process.SafeHandle*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.SessionId
  id: SessionId
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: SessionId
  nameWithType: Process.SessionId
  fullName: System.Diagnostics.Process.SessionId
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o identificador de sessão de serviços de Terminal para o processo associado."
  remarks: "A propriedade SessionId identifica a sessão no qual a aplicação está em execução."
  syntax:
    content: public int SessionId { get; }
    return:
      type: System.Int32
      description: "O identificador de sessão de serviços de Terminal para o processo associado."
  overload: System.Diagnostics.Process.SessionId*
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Não há nenhuma sessão associado a este processo."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Não há nenhum processo associado este identificador de sessão.       - ou - o processo associado não nesta máquina."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A propriedade SessionId não é suportada no Windows 98."
  platform:
  - net462
- uid: System.Diagnostics.Process.StandardError
  id: StandardError
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StandardError
  nameWithType: Process.StandardError
  fullName: System.Diagnostics.Process.StandardError
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém um fluxo utilizado para ler a saída de erro da aplicação."
  remarks: "Quando um <xref:System.Diagnostics.Process>escreve o texto a respetiva sequência de erro padrão, que o texto normalmente é apresentado na consola.</xref:System.Diagnostics.Process> Redirecionar a sequência StandardError, pode manipular ou suprimir a saída de erro de um processo. Por exemplo, pode filtrar o texto, formate-o de forma diferente ou escrever a saída para a consola e um ficheiro de registo designado.      > [!NOTE] > Para utilizar StandardError, tem de definir <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>para `false`, e tem de definir <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName>para `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> Caso contrário, a leitura da sequência StandardError emite uma exceção.       A sequência StandardError redirecionada pode ser lidos de forma síncrona ou assíncrona. Métodos, tais como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A>efetuar operações de leitura síncronas no fluxo de saída de erro do processo.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Estes síncrona ler operações não concluída até associada <xref:System.Diagnostics.Process>escreve a respetiva sequência StandardError ou fecha o fluxo.</xref:System.Diagnostics.Process>       Em contrapartida, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>inicia assíncrona ler operações na sequência StandardError.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> Este método permite que um processador de eventos designado para a saída de fluxo e devolve imediatamente para o emissor, o que pode efetuar outras tarefas enquanto a saída de fluxo é direcionada para o processador de eventos.       As operações de leitura síncronas introduzem uma dependência entre o autor da chamada ler a partir da sequência StandardError e o processo subordinado ao escrever a esse fluxo. Estas dependências podem resultar em condições de impasse. Quando o autor da chamada lê do fluxo de um processo subordinado redirecionado, está dependente da subordinada. O autor da chamada aguarda sobre a operação de leitura até o subordinado escreve no fluxo ou fecha o fluxo. Quando o processo subordinado escreve dados suficientes para preencher o fluxo redirecionado, está dependente de principal. O processo subordinado aguarda na próxima operação de escrita até que o elemento principal lê a partir da sequência de completa ou fecha o fluxo. A condição de impasse resulta quando o autor da chamada e Subprocesso esperar por si para concluir uma operação e não pode continuar. Pode evitar impasses através da avaliação de dependências entre o emissor e o processo subordinado.       O seguinte código c#, por exemplo, mostra como ler a partir de um fluxo redirecionado e aguarde que o processo de subordinados sair.      ```   // Start the child process.    Process p = new Process();    // Redirect the error stream of the child process.    p.StartInfo.UseShellExecute = false;    p.StartInfo.RedirectStandardError = true;    p.StartInfo.FileName = &quot;Write500Lines.exe&quot;;    p.Start();    // Do not wait for the child process to exit before    // reading to the end of its redirected error stream.    // p.WaitForExit();    // Read the error stream first and then wait.    string error = p.StandardError.ReadToEnd();    p.WaitForExit();   ```O exemplo de código evita uma condição de impasse ao chamar `p.StandardError.ReadToEnd` antes `p.WaitForExit`. Uma condição de impasse pode resultar se principal processar chamadas `p.WaitForExit` antes `p.StandardError.ReadToEnd` e o processo subordinado escreve suficiente texto para preencher o fluxo redirecionado. O processo de principal seria aguardar indefinidamente o processo de subordinados sair. O processo subordinado seria aguardar indefinidamente principal ler a partir da sequência StandardError completa.       Não há um problema semelhante quando Leia todo o texto do resultado padrão e fluxos de erro padrão. O seguinte código c#, por exemplo, executa uma operação de leitura em ambos os fluxos.      ```   // Do not perform a synchronous read to the end of both    // redirected streams.   // string output = p.StandardOutput.ReadToEnd();   // string error = p.StandardError.ReadToEnd();   // p.WaitForExit();   // Use asynchronous read operations on at least one of the streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```O exemplo de código evita a condição de impasse efetuando assíncrona operações de leitura no <xref:System.Diagnostics.Process.StandardOutput%2A>stream.</xref:System.Diagnostics.Process.StandardOutput%2A> Uma condição de impasse resulta se principal processar chamadas `p.StandardOutput.ReadToEnd` seguido `p.StandardError.ReadToEnd` e o processo subordinado escreve suficiente texto para preencher a sequência de erro. O processo de principal seria aguardar indefinidamente o processo de subordinados fechar o <xref:System.Diagnostics.Process.StandardOutput%2A>stream.</xref:System.Diagnostics.Process.StandardOutput%2A> O processo subordinado seria aguardar indefinidamente principal ler a partir da sequência StandardError completa.       Pode utilizar operações de leitura assíncrona para evitar estas dependências e as respetivas impasse potencial. Em alternativa, pode evitar a condição de impasse ao criar dois threads e ao ler a saída de cada fluxo num thread separado.      > [!NOTE] > Não é possível misturar assíncronas e síncronas as operações de leitura numa sequência redirecionado. Uma vez a transmissão de redirecionada um <xref:System.Diagnostics.Process>é aberto no modo assíncrono ou síncrono, todas mais leitura operações nesse fluxo tem de ser o mesmo modo.</xref:System.Diagnostics.Process> Por exemplo, não siga <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>com uma chamada para <xref:System.IO.StreamReader.ReadLine%2A>na sequência StandardError, ou vice versa.</xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginErrorReadLine%2A> No entanto, pode ler dois fluxos diferentes em modos diferentes. Por exemplo, pode chamar <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>e, em seguida, chame <xref:System.IO.StreamReader.ReadLine%2A>para a sequência StandardError.</xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginOutputReadLine%2A>"
  example:
  - "The following example uses the `net use` command together with a user supplied argument to map a network resource. It then reads the standard error stream of the net command and writes it to console.  \n  \n [!code-cs[Process_StandardError#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_41_1.cs)]\n [!code-cpp[Process_StandardError#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_41_1.cpp)]\n [!code-vb[Process_StandardError#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_41_1.vb)]"
  syntax:
    content: public System.IO.StreamReader StandardError { get; }
    return:
      type: System.IO.StreamReader
      description: "A <xref:System.IO.StreamReader>que podem ser utilizados para ler a transmissão de erros padrão da aplicação.</xref:System.IO.StreamReader>"
  overload: System.Diagnostics.Process.StandardError*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The StandardError stream has not been defined for redirection; ensure &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> and &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The StandardError stream has been opened for asynchronous read operations with <xref:System.Diagnostics.Process.BeginErrorReadLine*>."
  platform:
  - net462
- uid: System.Diagnostics.Process.StandardInput
  id: StandardInput
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StandardInput
  nameWithType: Process.StandardInput
  fullName: System.Diagnostics.Process.StandardInput
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém um fluxo utilizado para escrever a entrada da aplicação."
  remarks: "A <xref:System.Diagnostics.Process>pode ler o texto de entrada do seu fluxo de entrada padrão, normalmente, o teclado.</xref:System.Diagnostics.Process> Redirecionar o fluxo de StandardInput, pode especificar programaticamente a entrada. Por exemplo, em vez de utilizar introdução por teclado, pode fornecer texto o conteúdo de um ficheiro designado ou um resultado de outra aplicação.      > [!NOTE] > Para utilizar StandardInput, tem de definir <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>para `false`, e tem de definir <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName>para `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> Caso contrário, o fluxo ao escrever o StandardInput emite uma exceção."
  example:
  - "The following example illustrates how to redirect the StandardInput stream of a process. The example starts the `sort` command with redirected input. It then prompts the user for text, and passes that to the `sort` process by means of the redirected StandardInput stream. The `sort` results are displayed to the user on the console.  \n  \n [!code-cs[Process_StandardInput#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_0_1.cs)]\n [!code-cpp[Process_StandardInput#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_0_1.cpp)]\n [!code-vb[Process_StandardInput#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_0_1.vb)]"
  syntax:
    content: public System.IO.StreamWriter StandardInput { get; }
    return:
      type: System.IO.StreamWriter
      description: "A <xref:System.IO.StreamWriter>que pode ser utilizada para escrever o fluxo de entrada padrão da aplicação.</xref:System.IO.StreamWriter>"
  overload: System.Diagnostics.Process.StandardInput*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O fluxo de StandardInput não foi definido porque &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName&gt; está definido como <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Diagnostics.Process.StandardOutput
  id: StandardOutput
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StandardOutput
  nameWithType: Process.StandardOutput
  fullName: System.Diagnostics.Process.StandardOutput
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém um fluxo utilizado para ler a saída textual da aplicação."
  remarks: "Quando um <xref:System.Diagnostics.Process>escreve o texto para o padrão de transmissão, se o texto normalmente é apresentado na consola do.</xref:System.Diagnostics.Process> Redirecionar o fluxo de StandardOutput, pode manipular ou suprimir a saída de um processo. Por exemplo, pode filtrar o texto, formate-o de forma diferente ou escrever a saída para a consola e um ficheiro de registo designado.      > [!NOTE] > Para utilizar StandardOutput, tem de definir <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>para `false`, e tem de definir <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName>para `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> Caso contrário, a leitura do fluxo de StandardOutput emite uma exceção.       O fluxo de StandardOutput redirecionado pode ser lidos de forma síncrona ou assíncrona. Métodos, tais como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A>efetuar operações de leitura síncronas no fluxo de saída do processo.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Estes síncrona ler operações não concluída até associada <xref:System.Diagnostics.Process>escreve o respetivo fluxo StandardOutput ou fecha o fluxo.</xref:System.Diagnostics.Process>       Em contrapartida, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>inicia assíncrona ler operações no fluxo StandardOutput.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> Este método permite que um processador de eventos designado para a saída de fluxo e devolve imediatamente para o emissor, o que pode efetuar outras tarefas enquanto a saída de fluxo é direcionada para o processador de eventos.       As operações de leitura síncronas introduzem uma dependência entre o autor da chamada leitura a partir do fluxo de StandardOutput e o processo de subordinados ao escrever a esse fluxo. Estas dependências podem resultar em condições de impasse. Quando o autor da chamada lê do fluxo de um processo subordinado redirecionado, está dependente da subordinada. O autor da chamada aguarda sobre a operação de leitura até o subordinado escreve no fluxo ou fecha o fluxo. Quando o processo subordinado escreve dados suficientes para preencher o fluxo redirecionado, está dependente de principal. O processo subordinado aguarda na próxima operação de escrita até que o elemento principal lê a partir da sequência de completa ou fecha o fluxo. A condição de impasse resulta quando o autor da chamada e Subprocesso esperar por si para concluir uma operação e não pode continuar. Pode evitar impasses através da avaliação de dependências entre o emissor e o processo subordinado.       O seguinte código c#, por exemplo, mostra como ler a partir de um fluxo redirecionado e aguarde que o processo de subordinados sair.      ```   Process p = new Process();   p.StartInfo.UseShellExecute = false;   p.StartInfo.RedirectStandardOutput = true;   p.StartInfo.FileName = &quot;Write500Lines.exe&quot;;   p.Start();      // To avoid deadlocks, always read the output stream first and then wait.   string output = p.StandardOutput.ReadToEnd();   p.WaitForExit();   ```O exemplo de código evita uma condição de impasse ao chamar `p.StandardOutput.ReadToEnd` antes `p.WaitForExit`. Uma condição de impasse pode resultar se principal processar chamadas `p.WaitForExit` antes `p.StandardOutput.ReadToEnd` e o processo subordinado escreve suficiente texto para preencher o fluxo redirecionado. O processo de principal seria aguardar indefinidamente o processo de subordinados sair. O processo subordinado seria aguardar indefinidamente principal ler a partir do fluxo de StandardOutput completo.       Não há um problema semelhante quando Leia todo o texto do resultado padrão e fluxos de erro padrão. O seguinte código c#, por exemplo, executa uma operação de leitura em ambos os fluxos.      ```   // To avoid deadlocks, use asynchronous read operations on at least one of the streams.   // Do not perform a synchronous read to the end of both redirected streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```O exemplo de código evita a condição de impasse ao efetuar operações de leitura assíncrona no fluxo StandardOutput. Uma condição de impasse resulta se principal processar chamadas `p.StandardOutput.ReadToEnd` seguido `p.StandardError.ReadToEnd` e o processo subordinado escreve suficiente texto para preencher a sequência de erro. O processo de principal seria aguardar indefinidamente o processo de subordinados para fechar a respetiva sequência StandardOutput. O processo subordinado seria aguardar indefinidamente principal ler a partir de completo <xref:System.Diagnostics.Process.StandardError%2A>stream.</xref:System.Diagnostics.Process.StandardError%2A>       Pode utilizar operações de leitura assíncrona para evitar estas dependências e as respetivas impasse potencial. Em alternativa, pode evitar a condição de impasse ao criar dois threads e ao ler a saída de cada fluxo num thread separado.      > [!NOTE] > Não é possível misturar assíncronas e síncronas as operações de leitura numa sequência redirecionado. Uma vez a transmissão de redirecionada um <xref:System.Diagnostics.Process>é aberto no modo assíncrono ou síncrono, todas mais leitura operações nesse fluxo tem de ser o mesmo modo.</xref:System.Diagnostics.Process> Por exemplo, não siga <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>com uma chamada para <xref:System.IO.StreamReader.ReadLine%2A>no fluxo StandardOutput, ou vice versa.</xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginOutputReadLine%2A> No entanto, pode ler dois fluxos diferentes em modos diferentes. Por exemplo, pode chamar <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>e, em seguida, chame <xref:System.IO.StreamReader.ReadLine%2A>para o <xref:System.Diagnostics.Process.StandardError%2A>stream.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginOutputReadLine%2A>"
  example:
  - "The following example runs the ipconfig.exe command and redirects its standard output to the example’s console window.  \n  \n [!code-vb[Process_StandardOutput#2](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_11_1.vb)]\n [!code-cs[Process_StandardOutput#2](~/add/codesnippet/csharp/p-system.diagnostics.pro_11_1.cs)]\n [!code-cpp[Process_StandardOutput#2](~/add/codesnippet/cpp/p-system.diagnostics.pro_11_1.cpp)]"
  syntax:
    content: public System.IO.StreamReader StandardOutput { get; }
    return:
      type: System.IO.StreamReader
      description: "A <xref:System.IO.StreamReader>que podem ser utilizados para ler o fluxo de saída padrão da aplicação.</xref:System.IO.StreamReader>"
  overload: System.Diagnostics.Process.StandardOutput*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The StandardOutput stream has not been defined for redirection; ensure &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> and &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The StandardOutput stream has been opened for asynchronous read operations with <xref:System.Diagnostics.Process.BeginOutputReadLine*>."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start
  id: Start
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start()
  nameWithType: Process.Start()
  fullName: System.Diagnostics.Process.Start()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "É iniciado (ou reutiliza) no recurso de processo que é especificado pelo <xref:System.Diagnostics.Process.StartInfo*>propriedade deste <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente e associa-o componente.</xref:System.Diagnostics.Process.StartInfo*>"
  remarks: "Use this overload to start a process resource and associate it with the current <xref:System.Diagnostics.Process> component. The return value `true` indicates that a new process resource was started. If the process resource specified by the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property is already running on the computer, no additional process resource is started. Instead, the running process resource is reused and `false` is returned.  \n  \n You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.  \n  \n> [!NOTE]\n>  If you are using Visual Studio, this overload of the Start method is the one that you insert into your code after you drag a <xref:System.Diagnostics.Process> component onto the designer. Use the `Properties` window to expand the `StartInfo` category and write the appropriate value into the `FileName` property. Your changes will appear in the form's `InitializeComponent` procedure.  \n  \n This overload of Start is not a `static` method. You must call it from an instance of the <xref:System.Diagnostics.Process> class. Before calling Start, you must first specify <xref:System.Diagnostics.Process.StartInfo%2A> property information for this <xref:System.Diagnostics.Process> instance, because that information is used to determine the process resource to start.  \n  \n The other overloads of the Start method are `static` members. You do not need to create an instance of the <xref:System.Diagnostics.Process> component before you call those overloads of the method. Instead, you can call Start for the <xref:System.Diagnostics.Process> class itself, and a new <xref:System.Diagnostics.Process> component is created if the process was started. Or, `null` is returned if a process was reused. The process resource is automatically associated with the new <xref:System.Diagnostics.Process> component that is returned by the Start method.  \n  \n The <xref:System.Diagnostics.Process.StartInfo%2A> members can be used to duplicate the functionality of the `Run` dialog box of the Windows `Start` menu. Anything that can be typed into a command line can be started by setting the appropriate values in the <xref:System.Diagnostics.Process.StartInfo%2A> property. The only <xref:System.Diagnostics.Process.StartInfo%2A> property that must be set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property. The <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not have to be an executable file. It can be of any file type for which the extension has been associated with an application that is installed on the system. For example, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated.doc files with a word processing tool, such as Microsoft Word.  \n  \n In the command line, you can specify actions to take for certain types of files. For example, you can print documents or edit text files. Specify these actions using the <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property. For other types of files, you can specify command-line arguments when you start the file from the `Run` dialog box. For example, you can pass a URL as an argument if you specify your browser as the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. These arguments can be specified in the <xref:System.Diagnostics.Process.StartInfo%2A> property's <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> member.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use Start to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example uses an instance of the <xref:System.Diagnostics.Process> class to start a process.  \n  \n [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_16_1.cpp)]\n [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_16_1.vb)]\n [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_16_1.cs)]"
  syntax:
    content: public bool Start ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se um recurso de processo é iniciado; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> se nenhum recurso novo do processo for iniciado (por exemplo, se um processo existente é reutilizado)."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Foi especificado nenhum nome de ficheiro no <xref href=&quot;System.Diagnostics.Process&quot;> </xref> do componente <> </> *>.       - ou - &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; membro o <> </> *> propriedade é <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> enquanto &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName&gt;, &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName&gt;, ou &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName&gt; é <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Ocorreu um erro ao abrir o ficheiro associado."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O objeto de processo já foi eliminado."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  id: Start(System.Diagnostics.ProcessStartInfo)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(ProcessStartInfo)
  nameWithType: Process.Start(ProcessStartInfo)
  fullName: System.Diagnostics.Process.Start(ProcessStartInfo)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inicia o recurso de processo especificado pelo parâmetro que contém informações de início do processo (por exemplo, o nome de ficheiro do processo para iniciar) e associa o recurso de um novo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente."
  remarks: "Use this overload to start a process resource by specifying a <xref:System.Diagnostics.ProcessStartInfo> instance. The overload associates the resource with a new <xref:System.Diagnostics.Process> object.  \n  \n> [!NOTE]\n>  If the address of the executable file to start is a URL, the process is not started and `null` is returned.  \n  \n This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance. Using this overload with a <xref:System.Diagnostics.ProcessStartInfo> parameter is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting its <xref:System.Diagnostics.Process.StartInfo%2A> properties, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.  \n  \n Using a <xref:System.Diagnostics.ProcessStartInfo> instance as the parameter lets you call <xref:System.Diagnostics.Process.Start%2A> with the most control over what is passed into the call to start the process. If you need to pass only a file name or a file name and arguments, it is not necessary to create a new <xref:System.Diagnostics.ProcessStartInfo> instance, although that is an option. The only <xref:System.Diagnostics.Process.StartInfo%2A> property that must be set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property. The <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application that is installed on the system. For example, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated.doc files with a word processing tool, such as Microsoft Word.  \n  \n You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.  \n  \n If the <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> and <xref:System.Diagnostics.ProcessStartInfo.Password%2A> properties of the <xref:System.Diagnostics.Process.StartInfo%2A> instance are set, the unmanaged `CreateProcessWithLogonW` function is called, which starts the process in a new window even if the <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> property value is `true` or the <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> property value is <xref:System.Diagnostics.ProcessWindowStyle>.  \n  \n Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member. Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance. Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the start information for the process resource by using a <xref:System.Diagnostics.ProcessStartInfo> instance.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the `startInfo` parameter, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser. It then starts some other instances of Internet Explorer and displays some specific pages or sites. Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.  \n  \n For additional examples of other uses of this method, refer to the individual properties of the <xref:System.Diagnostics.ProcessStartInfo> class.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_17_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_17_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_17_1.cpp)]"
  syntax:
    content: public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);
    parameters:
    - id: startInfo
      type: System.Diagnostics.ProcessStartInfo
      description: "O <xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;> </xref> que contém as informações que são utilizadas para iniciar o processo, incluindo o nome de ficheiro e os argumentos da linha de comandos."
    return:
      type: System.Diagnostics.Process
      description: "Um novo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> que está associado ao recurso de processo ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se nenhum recurso do processo for iniciado. Tenha em atenção que um processo novo que esteja iniciado juntamente com a já em execução instâncias do processo mesmo será independente dos outros. Além disso, o início pode devolver um processo não nulo com o respetivo <xref:System.Diagnostics.Process.HasExited*>propriedade já definida <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> Neste caso, o processo iniciado pode ter ativado uma instância existente de si próprio e, em seguida, terminado."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Foi especificado nenhum nome de ficheiro no <code> startInfo </code> do parâmetro <> </> *> propriedade.       -or-       The <>*> property of the <code>startInfo</code> parameter is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref> and the <>*>, <>*>, or <>*> property is also <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>.       - ou - o <> </> *> propriedade o <code> startInfo </code> parâmetro é <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> e o <> </> *> propriedade não é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> ou está vazio ou o <> </> *> propriedade não é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>startInfo</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O objeto de processo já foi eliminado."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "O ficheiro especificado no <code> startInfo </code> do parâmetro <xref:System.Diagnostics.ProcessStartInfo.FileName*>não foi possível encontrar a propriedade.</xref:System.Diagnostics.ProcessStartInfo.FileName*>"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Ocorreu um erro ao abrir o ficheiro associado.       - ou - a soma de comprimento dos argumentos e o comprimento do caminho completo para o processo excede 2080. A mensagem de erro associada esta exceção pode ser um dos seguintes: &quot;a área de dados transmitida para uma chamada do sistema é demasiado pequena.&quot; ou &quot;Acesso negado.&quot;"
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String)
  id: Start(System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String)
  nameWithType: Process.Start(String)
  fullName: System.Diagnostics.Process.Start(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inicia um recurso de processo especificando o nome de um ficheiro de aplicação ou documento e associa o recurso de um novo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente."
  remarks: "Use this overload to start a process resource by specifying its file name. The overload associates the resource with a new <xref:System.Diagnostics.Process> object.  \n  \n> [!NOTE]\n>  If the address of the executable file to start is a URL, the process is not started and `null` is returned.  \n  \n This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance. The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.  \n  \n You can start a ClickOnce application by setting the `fileName` parameter to the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.  \n  \n Starting a process by specifying its file name is similar to typing the information in the `Run` dialog box of the Windows `Start` menu. Therefore, the file name does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application installed on the system. For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word. Similarly, in the same way that the `Run` dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter. For example, you can set the `fileName` parameter to either \"Notepad.exe\" or \"Notepad\".  \n  \n This overload does not allow command-line arguments for the process. If you need to specify one or more command-line arguments for the process, use the <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=fullName> or <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=fullName> overloads.  \n  \n Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member. Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance. Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser. It then starts some other instances of Internet Explorer and displays some specific pages or sites. Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_2_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_2_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_2_1.cpp)]"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "O nome de um ficheiro de aplicação ou documento para ser executada no processo."
    return:
      type: System.Diagnostics.Process
      description: "Um novo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> que está associado ao recurso de processo ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se nenhum recurso do processo for iniciado. Tenha em atenção que um processo novo que esteja iniciado juntamente com a já em execução instâncias do processo mesmo será independente dos outros. Além disso, o início pode devolver um processo não nulo com o respetivo <xref:System.Diagnostics.Process.HasExited*>propriedade já definida <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> Neste caso, o processo iniciado pode ter ativado uma instância existente de si próprio e, em seguida, terminado."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Ocorreu um erro ao abrir o ficheiro associado."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O objeto de processo já foi eliminado."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "A variável de ambiente PATH tem uma cadeia contendo as aspas."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String,System.String)
  id: Start(System.String,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String,String)
  nameWithType: Process.Start(String,String)
  fullName: System.Diagnostics.Process.Start(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inicia um recurso de processo especificando o nome de uma aplicação e um conjunto de argumentos da linha de comandos e associa o recurso de um novo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente."
  remarks: "Use this overload to start a process resource by specifying its file name and command-line arguments. The overload associates the resource with a new <xref:System.Diagnostics.Process> object.  \n  \n> [!NOTE]\n>  If the address of the executable file to start is a URL, the process is not started and `null` is returned.  \n  \n This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance. The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> and <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> members of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.  \n  \n Starting a process by specifying its file name and arguments is similar to typing the file name and command-line arguments in the `Run` dialog box of the Windows `Start` menu. Therefore, the file name does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application installed on the system. For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word. Similarly, in the same way that the `Run` dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter. For example, you can set the `fileName` parameter to either \"Notepad.exe\" or \"Notepad\". If the `fileName` parameter represents an executable file, the `arguments` parameter might represent a file to act upon, such as the text file in `Notepad.exe myfile.txt`. If the `fileName` parameter represents a command (.cmd) file, the `arguments` parameter must include either a \"`/c`\" or \"`/k`\" argument to specify whether the command window exits or remains after completion.  \n  \n Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member. Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance. Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start and command-line arguments to pass.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property..  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser. It then starts some other instances of Internet Explorer and displays some specific pages or sites. Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_20_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_20_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_20_1.cpp)]"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName, string arguments);
    parameters:
    - id: fileName
      type: System.String
      description: "O nome de um ficheiro de aplicação para ser executada no processo."
    - id: arguments
      type: System.String
      description: "Argumentos da linha de comandos transmitidos ao iniciar o processo."
    return:
      type: System.Diagnostics.Process
      description: "Um novo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> que está associado ao recurso de processo ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se nenhum recurso do processo for iniciado. Tenha em atenção que um processo novo que esteja iniciado juntamente com a já em execução instâncias do processo mesmo será independente dos outros. Além disso, o início pode devolver um processo não nulo com o respetivo <xref:System.Diagnostics.Process.HasExited*>propriedade já definida <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> Neste caso, o processo iniciado pode ter ativado uma instância existente de si próprio e, em seguida, terminado."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <code>fileName</code> or <code>arguments</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Ocorreu um erro ao abrir o ficheiro associado.       - ou - a soma de comprimento dos argumentos e o comprimento do caminho completo para o processo excede 2080. A mensagem de erro associada esta exceção pode ser um dos seguintes: &quot;a área de dados transmitida para uma chamada do sistema é demasiado pequena.&quot; ou &quot;Acesso negado.&quot;"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O objeto de processo já foi eliminado."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "A variável de ambiente PATH tem uma cadeia contendo as aspas."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)
  id: Start(System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String,String,SecureString,String)
  nameWithType: Process.Start(String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,SecureString,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inicia um recurso de processo especificando o nome de uma aplicação, um nome de utilizador, uma palavra-passe e um domínio e associa o recurso de um novo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente."
  remarks: "Utilize esta sobrecarga para criar um novo processo e o thread principal, especificando o nome de ficheiro, nome de utilizador, palavra-passe e domínio. O novo processo, em seguida, executa o ficheiro executável especificado no contexto de segurança das credenciais especificadas (utilizador, domínio e palavra-passe).      > [!NOTE] > Quando o ficheiro executável está localizado numa unidade remota, tem de identificar a partilha de rede através da utilização de um identificador de recurso uniforme (URI), não uma letra de unidade associado.      > [!NOTE] > Se o endereço do ficheiro executável para iniciar um URL, não iniciar o processo e `null` é devolvido.       Esta sobrecarga de permite-lhe iniciar um processo sem primeiro criar um novo <xref:System.Diagnostics.Process>instância.</xref:System.Diagnostics.Process> A sobrecarga é uma alternativa para os passos para criar um novo explícitas <xref:System.Diagnostics.Process>instância, a definição de <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, e <xref:System.Diagnostics.ProcessStartInfo.Domain%2A>Propriedades do <xref:System.Diagnostics.Process.StartInfo%2A>propriedade e chamar <xref:System.Diagnostics.Process.Start%2A>para o <xref:System.Diagnostics.Process>instância.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A> </xref:System.Diagnostics.ProcessStartInfo.Domain%2A> </xref:System.Diagnostics.ProcessStartInfo.Password%2A> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process>       Da mesma forma, na mesma forma que o **executar** caixa de diálogo pode aceitar um nome de ficheiro executável com ou sem a extensão de .exe, a extensão de .exe é opcional no `fileName` parâmetro. Por exemplo, pode definir o `fileName` parâmetro &quot;Notepad.exe&quot; ou &quot;Bloco de notas&quot;. Se o `fileName` parâmetro representa um ficheiro executável, o `arguments` parâmetro poderão representar um ficheiro para atuar, por exemplo, o ficheiro de texto no `Notepad.exe myfile.txt`.      > [!NOTE] > O nome do ficheiro tem de representar um ficheiro executável no <xref:System.Diagnostics.Process.Start%2A>sobrecargas que tenham `userName`, `password`, e `domain` parâmetros.</xref:System.Diagnostics.Process.Start%2A>       Sempre que utilizar <xref:System.Diagnostics.Process.Start%2A>para iniciar um processo, poderá necessitar de para fechá-lo ou o risco de perda de recursos do sistema.</xref:System.Diagnostics.Process.Start%2A> Fechar processos utilizando <xref:System.Diagnostics.Process.CloseMainWindow%2A>ou <xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> Pode verificar se um processo já foi fechado utilizando a respetiva <xref:System.Diagnostics.Process.HasExited%2A>propriedade …</xref:System.Diagnostics.Process.HasExited%2A>"
  example:
  - "The following code example shows the use of this overload to start an executable file and also demonstrates the throwing of a <xref:System.ComponentModel.Win32Exception> when an attempt is made to start an application associated with a nonexecutable file.  \n  \n [!code-cs[System.Diagnostics.Process.Start#1](~/add/codesnippet/csharp/fff1e658-5eee-484b-80e5-_1.cs)]\n [!code-vb[System.Diagnostics.Process.Start#1](~/add/codesnippet/visualbasic/fff1e658-5eee-484b-80e5-_1.vb)]"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);
    parameters:
    - id: fileName
      type: System.String
      description: "O nome de um ficheiro de aplicação para ser executada no processo."
    - id: userName
      type: System.String
      description: "O nome de utilizador a utilizar quando iniciar o processo."
    - id: password
      type: System.Security.SecureString
      description: "A <xref href=&quot;System.Security.SecureString&quot;> </xref> que contém a palavra-passe a utilizar quando iniciar o processo."
    - id: domain
      type: System.String
      description: "O domínio a utilizar quando iniciar o processo."
    return:
      type: System.Diagnostics.Process
      description: "Um novo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> que está associado ao recurso de processo ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se nenhum recurso do processo for iniciado. Tenha em atenção que um processo novo que esteja iniciado juntamente com a já em execução instâncias do processo mesmo será independente dos outros. Além disso, o início pode devolver um processo não nulo com o respetivo <xref:System.Diagnostics.Process.HasExited*>propriedade já definida <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> Neste caso, o processo iniciado pode ter ativado uma instância existente de si próprio e, em seguida, terminado."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Foi especificado nenhum nome de ficheiro."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Ocorreu um erro ao abrir o ficheiro associado."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O objeto de processo já foi eliminado."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  id: Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String,String,String,SecureString,String)
  nameWithType: Process.Start(String,String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,String,SecureString,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inicia um recurso de processo especificando o nome de uma aplicação, um conjunto de argumentos da linha de comandos, um nome de utilizador, uma palavra-passe e um domínio e associa o recurso de um novo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente."
  remarks: "Utilize esta sobrecarga para criar um novo processo e o thread principal, especificando o nome de ficheiro, argumentos da linha de comandos, nome de utilizador, palavra-passe e domínio. O novo processo, em seguida, executa o ficheiro executável especificado no contexto de segurança das credenciais especificadas (utilizador, domínio e palavra-passe).      > [!NOTE] > Quando o ficheiro executável está localizado numa unidade remota, tem de identificar a partilha de rede através da utilização de um identificador de recurso uniforme (URI), não uma letra de unidade associado.      > [!NOTE] > Se o endereço do ficheiro executável para iniciar um URL, não iniciar o processo e `null` é devolvido.       Esta sobrecarga de permite-lhe iniciar um processo sem primeiro criar um novo <xref:System.Diagnostics.Process>instância.</xref:System.Diagnostics.Process> A sobrecarga é uma alternativa para os passos para criar um novo explícitas <xref:System.Diagnostics.Process>instância, a definição de <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, e <xref:System.Diagnostics.ProcessStartInfo.Domain%2A>Propriedades do <xref:System.Diagnostics.Process.StartInfo%2A>propriedade e chamar <xref:System.Diagnostics.Process.Start%2A>para o <xref:System.Diagnostics.Process>instância.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A> </xref:System.Diagnostics.ProcessStartInfo.Domain%2A> </xref:System.Diagnostics.ProcessStartInfo.Password%2A> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A> </xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process>       Da mesma forma, na mesma forma que o **executar** caixa de diálogo pode aceitar um nome de ficheiro executável com ou sem a extensão de .exe, a extensão de .exe é opcional no `fileName` parâmetro. Por exemplo, pode definir o `fileName` parâmetro &quot;Notepad.exe&quot; ou &quot;Bloco de notas&quot;. Se o `fileName` parâmetro representa um ficheiro executável, o `arguments` parâmetro poderão representar um ficheiro para atuar, por exemplo, o ficheiro de texto no `Notepad.exe myfile.txt`.      > [!NOTE] > O nome do ficheiro tem de representar um ficheiro executável no <xref:System.Diagnostics.Process.Start%2A>sobrecargas que tenham `userName`, `password`, e `domain` parâmetros.</xref:System.Diagnostics.Process.Start%2A>       Sempre que utilizar <xref:System.Diagnostics.Process.Start%2A>para iniciar um processo, poderá necessitar de para fechá-lo ou o risco de perda de recursos do sistema.</xref:System.Diagnostics.Process.Start%2A> Fechar processos utilizando <xref:System.Diagnostics.Process.CloseMainWindow%2A>ou <xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> Pode verificar se um processo já foi fechado utilizando a respetiva <xref:System.Diagnostics.Process.HasExited%2A>propriedade …</xref:System.Diagnostics.Process.HasExited%2A>"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);
    parameters:
    - id: fileName
      type: System.String
      description: "O nome de um ficheiro de aplicação para ser executada no processo."
    - id: arguments
      type: System.String
      description: "Argumentos da linha de comandos transmitidos ao iniciar o processo."
    - id: userName
      type: System.String
      description: "O nome de utilizador a utilizar quando iniciar o processo."
    - id: password
      type: System.Security.SecureString
      description: "A <xref href=&quot;System.Security.SecureString&quot;> </xref> que contém a palavra-passe a utilizar quando iniciar o processo."
    - id: domain
      type: System.String
      description: "O domínio a utilizar quando iniciar o processo."
    return:
      type: System.Diagnostics.Process
      description: "Um novo <xref href=&quot;System.Diagnostics.Process&quot;> </xref> que está associado ao recurso de processo ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se nenhum recurso do processo for iniciado. Tenha em atenção que um processo novo que esteja iniciado juntamente com a já em execução instâncias do processo mesmo será independente dos outros. Além disso, o início pode devolver um processo não nulo com o respetivo <xref:System.Diagnostics.Process.HasExited*>propriedade já definida <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> Neste caso, o processo iniciado pode ter ativado uma instância existente de si próprio e, em seguida, terminado."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Foi especificado nenhum nome de ficheiro."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Ocorreu um erro ao abrir o ficheiro associado.       - ou - a soma de comprimento dos argumentos e o comprimento do caminho completo para o ficheiro associado excede 2080. A mensagem de erro associada esta exceção pode ser um dos seguintes: &quot;a área de dados transmitida para uma chamada do sistema é demasiado pequena.&quot; ou &quot;Acesso negado.&quot;"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O objeto de processo já foi eliminado."
  platform:
  - net462
- uid: System.Diagnostics.Process.StartInfo
  id: StartInfo
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StartInfo
  nameWithType: Process.StartInfo
  fullName: System.Diagnostics.Process.StartInfo
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define as propriedades para passar para o <xref:System.Diagnostics.Process.Start*>método o <xref href=&quot;System.Diagnostics.Process&quot;> </xref>.</xref:System.Diagnostics.Process.Start*>"
  remarks: "StartInfo representa o conjunto de parâmetros a utilizar para iniciar um processo. Quando <xref:System.Diagnostics.Process.Start%2A>é denominado, o StartInfo é utilizada para especificar o processo para iniciar.</xref:System.Diagnostics.Process.Start%2A> O membro StartInfo só é necessário definir o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>propriedade.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Iniciar um processo, especificando o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>propriedade é semelhante ao escrever as informações de **executar** caixa de diálogo das janelas da **iniciar** menu.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Por conseguinte, o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>propriedade não tem de representar um ficheiro executável.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Pode ser de qualquer tipo de ficheiro para o qual a extensão foi associada com uma aplicação instalada no sistema. Por exemplo o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>pode ter uma extensão. txt se associou ficheiros de texto com um editor, como o bloco de notas, ou pode ter um. doc se tiver os ficheiros de associated.doc com uma ferramenta de processamento do word, como o Microsoft Word.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Da mesma forma, na mesma forma que o **executar** caixa de diálogo pode aceitar um nome de ficheiro executável com ou sem a extensão de .exe, a extensão de .exe é opcional no <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>Membro.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Por exemplo, pode definir o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>propriedade como &quot;Notepad.exe&quot; ou &quot;Bloco de notas&quot;.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A>       Pode iniciar uma aplicação ClickOnce definindo a <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>propriedade para a localização (por exemplo, um endereço de Web) a partir do qual instalado originalmente a aplicação.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Não inicie uma aplicação ClickOnce especificando a localização instalada no disco rígido.       Se o nome de ficheiro envolve um ficheiro nonexecutable, tal como um ficheiro. doc, pode incluir um verbo especificar a ação a tomar no ficheiro. Por exemplo, pode definir o <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>para &quot;Print&quot; para um ficheiro que termine na extensão. doc.</xref:System.Diagnostics.ProcessStartInfo.Verb%2A> O nome de ficheiro especificado no <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>propriedade não precisa de ter uma extensão, se introduzir manualmente um valor para o <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>propriedade.</xref:System.Diagnostics.ProcessStartInfo.Verb%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> No entanto, se utilizar o <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>propriedade para determinar que verbos disponíveis, tem de incluir a extensão.</xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>       Pode alterar os parâmetros especificados na propriedade StartInfo até à hora que tem de chamar o <xref:System.Diagnostics.Process.Start%2A>método do processo.</xref:System.Diagnostics.Process.Start%2A> Depois de iniciar o processo, alterando os valores de StartInfo não afetar ou reinicie o processo associado. Se chama o <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29>método com o <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=fullName>e <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=fullName>conjunto de propriedades, a não gerido `CreateProcessWithLogonW` função é chamada, que inicia o processo num nova janela mesmo quando o <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A>valor da propriedade é `true` ou o <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A>valor da propriedade é <xref:System.Diagnostics.ProcessWindowStyle>.</xref:System.Diagnostics.ProcessWindowStyle> </xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> </xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> </xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=fullName> </xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29>       Se não utilizou o <xref:System.Diagnostics.Process.Start%2A>método para iniciar um processo, a propriedade StartInfo não reflete os parâmetros utilizados para iniciar o processo.</xref:System.Diagnostics.Process.Start%2A> Por exemplo, se utilizar <xref:System.Diagnostics.Process.GetProcesses%2A>para obter uma matriz de processos em execução no computador, a propriedade StartInfo de cada <xref:System.Diagnostics.Process>não contém o nome do ficheiro original ou os argumentos utilizados para iniciar o processo.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcesses%2A>       Quando o processo é iniciado, o nome de ficheiro é o ficheiro que preenche a (só de leitura) <xref:System.Diagnostics.Process.MainModule%2A>propriedade.</xref:System.Diagnostics.Process.MainModule%2A> Se pretender recuperar o ficheiro executável que estão associado com o processo depois de iniciado o processo, o <xref:System.Diagnostics.Process.MainModule%2A>propriedade.</xref:System.Diagnostics.Process.MainModule%2A> Se pretende definir o ficheiro executável de um <xref:System.Diagnostics.Process>instância para que um processo associado não foi iniciado, utilize a propriedade StartInfo <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>Membro.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process> Porque os membros da propriedade StartInfo argumentos que são transmitidos para o <xref:System.Diagnostics.Process.Start%2A>método de um processo, alterar o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>propriedade depois de iniciado o processo associado não irá repor a <xref:System.Diagnostics.Process.MainModule%2A>propriedade.</xref:System.Diagnostics.Process.MainModule%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process.Start%2A> Estas propriedades são utilizadas apenas para inicializar o processo associado."
  example:
  - "The following example populates a StartInfo with the file to execute, the action performed on it and whether it should displays a user interface. For additional examples, refer to the reference pages for properties of the <xref:System.Diagnostics.ProcessStartInfo> class.  \n  \n [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_10_1.cpp)]\n [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_10_1.vb)]\n [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_10_1.cs)]"
  syntax:
    content: public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }
    return:
      type: System.Diagnostics.ProcessStartInfo
      description: "O <xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;> </xref> que representa os dados com o qual pretende iniciar o processo. Estes argumentos incluem o nome do ficheiro executável ou documento utilizado para iniciar o processo."
  overload: System.Diagnostics.Process.StartInfo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "O valor que especifica o StartInfo é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Diagnostics.Process.StartTime
  id: StartTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StartTime
  nameWithType: Process.StartTime
  fullName: System.Diagnostics.Process.StartTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o tempo que o processo associado foi iniciado."
  syntax:
    content: public DateTime StartTime { get; }
    return:
      type: System.DateTime
      description: "Um objeto que indica quando o processo iniciado. Se o processo não está em execução, é emitida uma exceção."
  overload: System.Diagnostics.Process.StartTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "É a plataforma Windows 98 ou Millennium edição do Windows (Windows-Me), que não suporta esta propriedade."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Está a tentar aceder a propriedade de StartTime para um processo que está em execução num computador remoto. Esta propriedade só está disponível para processos em execução no computador local."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo foi terminado.       - ou - o processo não foi iniciado."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Ocorreu um erro na chamada para a função do Windows."
  platform:
  - net462
- uid: System.Diagnostics.Process.SynchronizingObject
  id: SynchronizingObject
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: SynchronizingObject
  nameWithType: Process.SynchronizingObject
  fullName: System.Diagnostics.Process.SynchronizingObject
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém ou define o objeto utilizado para empacotar referências das chamadas do processador de eventos que são emitidas como resultado de um evento de saída do processo."
  remarks: "Quando <xref:System.Diagnostics.EventLog.SynchronizingObject%2A>é `null`, métodos que processam o <xref:System.Diagnostics.Process.Exited>evento são chamado num thread de conjunto de threads de sistema.</xref:System.Diagnostics.Process.Exited> </xref:System.Diagnostics.EventLog.SynchronizingObject%2A> Para obter mais informações sobre agrupamentos de thread do sistema, consulte <xref:System.Threading.ThreadPool>.</xref:System.Threading.ThreadPool>       Quando o <xref:System.Diagnostics.Process.Exited>evento é processado por um componente do Windows Forms visual, tal como um <xref:System.Windows.Forms.Button>, aceder ao componente através do conjunto de threads de sistema poderão não funcionar, ou poderá resultar numa exceção.</xref:System.Windows.Forms.Button> </xref:System.Diagnostics.Process.Exited> Evitar o problema definindo SynchronizingObject como um componente do Windows Forms, o que faz com que os métodos de processamento de <xref:System.Diagnostics.Process.Exited>eventos ser chamado no mesmo thread em que o componente foi criado.</xref:System.Diagnostics.Process.Exited>       Se o <xref:System.Diagnostics.Process>é utilizado no interior [!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)] no designer de Windows Forms, SynchronizingObject é automaticamente definido para o controlo que contém o <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process> Por exemplo, se colocar um <xref:System.Diagnostics.Process>no designer para `Form1` (que herda de <xref:System.Windows.Forms.Form>) a propriedade SynchronizingObject <xref:System.Diagnostics.Process>está definido para a instância do `Form1`: [!code-cpp [Process_SynchronizingObject n. º&2;](~/add/codesnippet/cpp/p-system.diagnostics.pro_35_1.cpp)][!code-cs[Process_SynchronizingObject n. º&2;](~/add/codesnippet/csharp/p-system.diagnostics.pro_35_1.cs)][!code-vb[Process_SynchronizingObject n. º&2;](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_35_1.vb) ] normalmente, esta propriedade é definida quando o componente é colocado dentro de um controlo ou um formulário, porque esses componentes são vinculados a um thread específico.    </xref:System.Diagnostics.Process> </xref:System.Windows.Forms.Form> </xref:System.Diagnostics.Process>"
  example:
  - >-
    [!code-vb[Process_SynchronizingObject#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_35_2.vb)]
     [!code-cpp[Process_SynchronizingObject#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_35_2.cpp)]
     [!code-cs[Process_SynchronizingObject#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_35_2.cs)]
  syntax:
    content: public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }
    return:
      type: System.ComponentModel.ISynchronizeInvoke
      description: "O <xref href=&quot;System.ComponentModel.ISynchronizeInvoke&quot;> </xref> utilizado para empacotar referências das chamadas do processador de eventos que são emitidas como resultado de uma <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref> eventos do processo."
  overload: System.Diagnostics.Process.SynchronizingObject*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.Threads
  id: Threads
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Threads
  nameWithType: Process.Threads
  fullName: System.Diagnostics.Process.Threads
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o conjunto de threads que estão em execução no processo associado."
  remarks: "Um thread executa código num processo. Cada processo for iniciado com um único thread, o thread principal. Qualquer thread, pode criar threads adicionais. Threads dentro de um processo partilham o espaço de endereços do processo.       Utilize <xref:System.Diagnostics.ProcessThread>para obter todos os threads associados ao processo actual.</xref:System.Diagnostics.ProcessThread> O thread principal não é necessariamente no índice zero na matriz."
  syntax:
    content: public System.Diagnostics.ProcessThreadCollection Threads { get; }
    return:
      type: System.Diagnostics.ProcessThreadCollection
      description: "Uma matriz do tipo <xref href=&quot;System.Diagnostics.ProcessThread&quot;> </xref> que representa o sistema operativo threads atualmente em execução no processo associado."
  overload: System.Diagnostics.Process.Threads*
  exceptions:
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "O processo não tem um <xref:System.Diagnostics.Process.Id*>, ou nenhum processo está associado a <xref href=&quot;System.Diagnostics.Process&quot;> </xref> instância.</xref:System.Diagnostics.Process.Id*>       - ou - o processo associado foi terminado."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "A plataforma é Windows 98 ou Windows Millennium edição (Windows-Me); definir &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; para <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para aceder a esta propriedade em 98 do Windows e Windows Me."
  platform:
  - net462
- uid: System.Diagnostics.Process.ToString
  id: ToString
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ToString()
  nameWithType: Process.ToString()
  fullName: System.Diagnostics.Process.ToString()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Formatos de nome do processo como uma cadeia, combinada com o tipo de componente principal, se aplicável."
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_12_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_12_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_12_1.vb)]"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "O <> </> *>, combinado com o componente base <> </> *> devolve o valor."
  overload: System.Diagnostics.Process.ToString*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "ToString não é suportada no Windows 98."
  platform:
  - net462
- uid: System.Diagnostics.Process.TotalProcessorTime
  id: TotalProcessorTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: TotalProcessorTime
  nameWithType: Process.TotalProcessorTime
  fullName: System.Diagnostics.Process.TotalProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o tempo total do processador para este processo."
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_15_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_15_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_15_1.vb)]"
  syntax:
    content: public TimeSpan TotalProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "A <xref:System.TimeSpan>que indica a quantidade de tempo que o processo associado foi despendido a utilização de CPU.</xref:System.TimeSpan> Este valor é a soma do <> </> *> e <> </> *>."
  overload: System.Diagnostics.Process.TotalProcessorTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "É a plataforma Windows 98 ou Millennium edição do Windows (Windows-Me), que não suporta esta propriedade."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Está a tentar aceder a propriedade TotalProcessorTime para um processo que está em execução num computador remoto. Esta propriedade só está disponível para processos em execução no computador local."
  platform:
  - net462
- uid: System.Diagnostics.Process.UserProcessorTime
  id: UserProcessorTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: UserProcessorTime
  nameWithType: Process.UserProcessorTime
  fullName: System.Diagnostics.Process.UserProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o tempo de processador de utilizador para que este processo."
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_21_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_21_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_21_1.vb)]"
  syntax:
    content: public TimeSpan UserProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "A <xref:System.TimeSpan>que indica a quantidade de tempo que o processo associado tem despende a executar um código dentro a parte da aplicação do processo (não no núcleo do sistema operativo).</xref:System.TimeSpan>"
  overload: System.Diagnostics.Process.UserProcessorTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "É a plataforma Windows 98 ou Millennium edição do Windows (Windows-Me), que não suporta esta propriedade."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Está a tentar aceder a propriedade UserProcessorTime para um processo que está em execução num computador remoto. Esta propriedade só está disponível para processos em execução no computador local."
  platform:
  - net462
- uid: System.Diagnostics.Process.VirtualMemorySize
  id: VirtualMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: VirtualMemorySize
  nameWithType: Process.VirtualMemorySize
  fullName: System.Diagnostics.Process.VirtualMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém o tamanho da memória de virtuais do processo, em bytes."
  syntax:
    content: public int VirtualMemorySize { get; }
    return:
      type: System.Int32
      description: "A quantidade de memória virtual, em bytes, o que pediu o processo associado."
  overload: System.Diagnostics.Process.VirtualMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "É a plataforma Windows 98 ou Millennium edição do Windows (Windows-Me), que não suporta esta propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.VirtualMemorySize64
  id: VirtualMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: VirtualMemorySize64
  nameWithType: Process.VirtualMemorySize64
  fullName: System.Diagnostics.Process.VirtualMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a quantidade de memória virtual, em bytes, alocados para o processo associado."
  remarks: "O valor devolvido por esta propriedade representa o tamanho atual da memória virtual utilizada pelo processo, em bytes. O sistema operativo mapeia o espaço de endereço virtual para cada processo a páginas carregada na memória física ou a páginas armazenadas no ficheiro de paginação de memória virtual no disco.       Esta propriedade pode ser utilizada para monitorizar a utilização de memória em computadores com processadores de 32 bits ou 64 bits processadores. O valor da propriedade é equivalente à **Bytes virtuais** contador de desempenho para o processo."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_13_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_13_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_13_1.vb)]"
  syntax:
    content: public long VirtualMemorySize64 { get; }
    return:
      type: System.Int64
      description: "A quantidade de memória virtual, em bytes, alocado para o processo associado."
  overload: System.Diagnostics.Process.VirtualMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "É a plataforma Windows 98 ou Millennium edição do Windows (Windows-Me), que não suporta esta propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForExit
  id: WaitForExit
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForExit()
  nameWithType: Process.WaitForExit()
  fullName: System.Diagnostics.Process.WaitForExit()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Indica o <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente aguardar indefinidamente o processo associado sair."
  remarks: "WaitForExit faz com que o thread actual, aguarde até que o processo associado termina.  Deve ser chamado depois de todos os outros métodos são denominados do processo. Para evitar bloquear o thread atual, utilize o <xref:System.Diagnostics.Process.Exited>eventos.</xref:System.Diagnostics.Process.Exited>       Este método instrui a <xref:System.Diagnostics.Process>componente aguardar um período de tempo para os processadores de processo e eventos sair infinito.</xref:System.Diagnostics.Process> Isto pode provocar uma aplicação deixar de responder. Por exemplo, se chamar <xref:System.Diagnostics.Process.CloseMainWindow%2A>para um processo que tenha uma interface de utilizador, o pedido para o sistema operativo para terminar o processo associado poderá não ser processado se o processo é escrito nunca introduza o respetivo ciclo de mensagens.</xref:System.Diagnostics.Process.CloseMainWindow%2A>      > [!NOTE] > No [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)] e versões anteriores, a sobrecarga de WaitForExit aguardaram para <xref:System.Int32.MaxValue>milissegundos (aproximadamente 24 dias), não indefinidamente.</xref:System.Int32.MaxValue> Além disso, as versões anteriores não aguardar para os processadores de eventos sair se o completo <xref:System.Int32.MaxValue>foi atingida a hora.</xref:System.Int32.MaxValue>       Esta sobrecarga de garante que todo o processamento foi concluída, incluindo o processamento de eventos assíncronos para a saída padrão redirecionado. Deve utilizar esta sobrecarga de após uma chamada para o <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>sobrecarga quando a saída padrão foi redirecionada para processadores de eventos assíncronas.</xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>       Quando um processo associado termina (ou seja, quando é encerrado pelo sistema operativo através de um terminação anormal ou normal), o sistema armazena as informações administrativas sobre o processo e devolve o componente que invocasse WaitForExit. O <xref:System.Diagnostics.Process>componente, em seguida, pode aceder às informações, que inclui o <xref:System.Diagnostics.Process.ExitTime%2A>, utilizando o <xref:System.Diagnostics.Process.Handle%2A>ao processo de saída.</xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process>       Porque o processo associado foi terminado, a <xref:System.Diagnostics.Process.Handle%2A>propriedade do componente já não aponta para um recurso de processo existente.</xref:System.Diagnostics.Process.Handle%2A> Em vez disso, o identificador pode ser utilizado apenas para aceder às informações do sistema operativo sobre o recurso de processo. O sistema está ciente de identificadores de fechadas processos que não tenham sido publicados por <xref:System.Diagnostics.Process>componentes, pelo que mantém o <xref:System.Diagnostics.Process.ExitTime%2A>e <xref:System.Diagnostics.Process.Handle%2A>informações na memória até o <xref:System.Diagnostics.Process>componente especificamente liberta os recursos.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process> Por este motivo, qualquer altura, tem de chamar <xref:System.Diagnostics.Process.Start%2A>para uma <xref:System.Diagnostics.Process>instância, chamada <xref:System.Diagnostics.Process.Close%2A>quando o processo associado foi terminada e já não precisa de todas as informações administrativas sobre o mesmo.</xref:System.Diagnostics.Process.Close%2A> </xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> <xref:System.Diagnostics.Process.Close%2A>liberta a memória alocada para o processo de saída.</xref:System.Diagnostics.Process.Close%2A>"
  example:
  - See the Remarks section of the <xref:System.Diagnostics.Process.StandardError%2A> property reference page.
  syntax:
    content: public void WaitForExit ();
    parameters: []
  overload: System.Diagnostics.Process.WaitForExit*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Não foi possível aceder a definição de espera."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Nenhum processo <> </> *> foi definido e um <> </> *> partir do qual o <xref:System.Diagnostics.Process.Id*>propriedade pode ser determinada não existe.</xref:System.Diagnostics.Process.Id*>       - ou - não existe nenhum processo associado a este <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objeto.       - ou - está a tentar chamar WaitForExit para um processo que está em execução num computador remoto. Este método só está disponível para processos em execução no computador local."
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForExit(System.Int32)
  id: WaitForExit(System.Int32)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForExit(Int32)
  nameWithType: Process.WaitForExit(Int32)
  fullName: System.Diagnostics.Process.WaitForExit(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Indica o <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente a aguardar o número especificado de milissegundos para o processo associado sair."
  remarks: "WaitForExit faz com que o thread actual, aguarde até que o processo associado termina. Deve ser chamado depois de todos os outros métodos são denominados do processo. Para evitar bloquear o thread atual, utilize o <xref:System.Diagnostics.Process.Exited>eventos.</xref:System.Diagnostics.Process.Exited>       Este método instrui a <xref:System.Diagnostics.Process>componente a aguardar uma quantidade finita de tempo para o processo sair.</xref:System.Diagnostics.Process> Se o processo associado não for fechada no final do intervalo de porque é negado o pedido para terminar, `false` é devolvida ao chamar o procedimento. Pode especificar um número negativo (<xref:System.Threading.Timeout.Infinite>) para `milliseconds`, e WaitForExit irão comportar-se a mesma que a <xref:System.Diagnostics.Process.WaitForExit>de sobrecarga.</xref:System.Diagnostics.Process.WaitForExit> </xref:System.Threading.Timeout.Infinite> Se passar 0 (zero) para o método, devolve `true` apenas se o processo já terminou; caso contrário, devolve imediatamente `false`.      > [!NOTE] > No [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)] e versões anteriores, se `milliseconds` foi -1, WaitForExit sobrecarga aguardaram para <xref:System.Int32.MaxValue>milissegundos (aproximadamente 24 dias), não indefinidamente.</xref:System.Int32.MaxValue>       Quando a saída padrão foi redirecionada para processadores de eventos assíncrona, é possível que o processamento de saída serão não ter sido concluída quando este método devolve. Para garantir que o processamento de eventos assíncrona foi concluído, invoque o <xref:System.Diagnostics.Process.WaitForExit>sobrecarga que não recebe nenhum parâmetro após a receção um `true` desta sobrecarga de.</xref:System.Diagnostics.Process.WaitForExit> Para ajudar a garantir que o <xref:System.Diagnostics.Process.Exited>evento é processado corretamente em aplicações do Windows Forms, defina o <xref:System.Diagnostics.Process.SynchronizingObject%2A>propriedade.</xref:System.Diagnostics.Process.SynchronizingObject%2A> </xref:System.Diagnostics.Process.Exited>       Quando um processo associado sai (é encerrado pelo sistema operativo através de um terminação anormal ou normal), o sistema armazena as informações administrativas sobre o processo e devolve o componente que invocasse WaitForExit. O <xref:System.Diagnostics.Process>componente, em seguida, pode aceder às informações, que inclui o <xref:System.Diagnostics.Process.ExitTime%2A>, utilizando o <xref:System.Diagnostics.Process.Handle%2A>ao processo de saída.</xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process>       Porque o processo associado foi terminado, a <xref:System.Diagnostics.Process.Handle%2A>propriedade do componente já não aponta para um recurso de processo existente.</xref:System.Diagnostics.Process.Handle%2A> Em vez disso, o identificador pode ser utilizado apenas para aceder às informações do sistema operativo sobre o recurso de processo. O sistema está ciente de identificadores de fechadas processos que não tenham sido publicados por <xref:System.Diagnostics.Process>componentes, pelo que mantém o <xref:System.Diagnostics.Process.ExitTime%2A>e <xref:System.Diagnostics.Process.Handle%2A>informações na memória até o <xref:System.Diagnostics.Process>componente especificamente liberta os recursos.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process> Por este motivo, qualquer altura, tem de chamar <xref:System.Diagnostics.Process.Start%2A>para uma <xref:System.Diagnostics.Process>instância, chamada <xref:System.Diagnostics.Process.Close%2A>quando o processo associado foi terminada e já não precisa de todas as informações administrativas sobre o mesmo.</xref:System.Diagnostics.Process.Close%2A> </xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> <xref:System.Diagnostics.Process.Close%2A>liberta a memória alocada para o processo de saída.</xref:System.Diagnostics.Process.Close%2A>"
  example:
  - See the code example for the <xref:System.Diagnostics.Process.ExitCode%2A> property.
  syntax:
    content: public bool WaitForExit (int milliseconds);
    parameters:
    - id: milliseconds
      type: System.Int32
      description: "A quantidade de tempo, em milissegundos, a aguardar que o processo associado sair. O número máximo é o maior valor possíveis de um número inteiro de 32 bits, que representa o infinito para o sistema operativo."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o processo associado foi terminado; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.WaitForExit*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Não foi possível aceder a definição de espera."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Nenhum processo <> </> *> foi definido e um <> </> *> partir do qual o <xref:System.Diagnostics.Process.Id*>propriedade pode ser determinada não existe.</xref:System.Diagnostics.Process.Id*>       - ou - não existe nenhum processo associado a este <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objeto.       - ou - está a tentar chamar WaitForExit para um processo que está em execução num computador remoto. Este método só está disponível para processos em execução no computador local."
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForInputIdle
  id: WaitForInputIdle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForInputIdle()
  nameWithType: Process.WaitForInputIdle()
  fullName: System.Diagnostics.Process.WaitForInputIdle()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Faz com que o <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente aguardar indefinidamente o processo associado introduzir um estado inativo. Esta sobrecarga de aplica-se apenas a processos com uma interface de utilizador e, por conseguinte, um ciclo de mensagem."
  remarks: "Utilize WaitForInputIdle para forçar o processamento da sua aplicação a aguardar até o ciclo de mensagem devolveu o estado inativo. Quando um processo com uma interface de utilizador está a executar, o respetivo ciclo de mensagens executa sempre que é enviada uma mensagem do Windows para o processo pelo sistema operativo. O processo, em seguida, devolve ao ciclo de mensagens. Um processo possui correspondências é denominado num estado inativo quando está a aguardar para mensagens dentro de um ciclo de mensagem. Este estado é útil, por exemplo, quando a aplicação tem de aguardar ao iniciar o processo concluir a criação da janela principal antes da aplicação comunica com essa janela.       Se um processo não tem um ciclo de mensagem, WaitForInputIdle emite um <xref:System.InvalidOperationException>.</xref:System.InvalidOperationException>       A sobrecarga de WaitForInputIdle instrui a <xref:System.Diagnostics.Process>componente aguardar indefinidamente para o processo de tornar-se inativo no ciclo de mensagens.</xref:System.Diagnostics.Process> Esta instrução pode fazer com que uma aplicação deixar de responder. Por exemplo, se o processo é escrito sempre para sair do respetivo ciclo de mensagens imediatamente, como o fragmento de código `while(true)`."
  syntax:
    content: public bool WaitForInputIdle ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o processo associado atingiu um estado inativo."
  overload: System.Diagnostics.Process.WaitForInputIdle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo não tem uma interface gráfica.       - ou - Ocorreu um erro desconhecido. O processo não foi possível introduzir um estado inativo.       - ou - o processo já terminou.       - ou - nenhum processo está associado a este <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objeto."
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForInputIdle(System.Int32)
  id: WaitForInputIdle(System.Int32)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForInputIdle(Int32)
  nameWithType: Process.WaitForInputIdle(Int32)
  fullName: System.Diagnostics.Process.WaitForInputIdle(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Faz com que o <xref href=&quot;System.Diagnostics.Process&quot;> </xref> componente a aguardar o número especificado de milissegundos para o processo associado introduzir um estado inativo. Esta sobrecarga de aplica-se apenas a processos com uma interface de utilizador e, por conseguinte, um ciclo de mensagem."
  remarks: "Utilize WaitForInputIdle para forçar o processamento da sua aplicação a aguardar até o ciclo de mensagem devolveu o estado inativo. Quando um processo com uma interface de utilizador está a executar, o respetivo ciclo de mensagens executa sempre que é enviada uma mensagem do Windows para o processo pelo sistema operativo. O processo, em seguida, devolve ao ciclo de mensagens. Um processo possui correspondências é denominado num estado inativo quando está a aguardar para mensagens dentro de um ciclo de mensagem. Este estado é útil, por exemplo, quando a aplicação tem de aguardar ao iniciar o processo concluir a criação da janela principal antes da aplicação comunica com essa janela.       Se um processo não tem um ciclo de mensagem, WaitForInputIdle emite um <xref:System.InvalidOperationException>.</xref:System.InvalidOperationException>       A sobrecarga de WaitForInputIdle instrui a <xref:System.Diagnostics.Process>componente aguardar um período de tempo para o processo de tornar-se inativo no ciclo de mensagem finito.</xref:System.Diagnostics.Process> Se o processo associado não tornou-se inativo no final do intervalo de porque o ciclo ainda está a processar mensagens, `false` é devolvida ao chamar o procedimento.       Para obter mais informações sobre como lidar com eventos, consulte [eventos](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public bool WaitForInputIdle (int milliseconds);
    parameters:
    - id: milliseconds
      type: System.Int32
      description: "Um valor de 1 para <xref:System.Int32>que especifica a quantidade de tempo, em milissegundos, aguarde que o processo associado fiquem inativos.</xref:System.Int32> Um valor de 0 Especifica um retorno imediato e um valor de -1 especifica uma espera infinita."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o processo associado atingiu um estado inativo; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.WaitForInputIdle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O processo não tem uma interface gráfica.       - ou - Ocorreu um erro desconhecido. O processo não foi possível introduzir um estado inativo.       - ou - o processo já terminou.       - ou - nenhum processo está associado a este <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objeto."
  platform:
  - net462
- uid: System.Diagnostics.Process.WorkingSet
  id: WorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WorkingSet
  nameWithType: Process.WorkingSet
  fullName: System.Diagnostics.Process.WorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a utilização de memória física do processo associado, em bytes."
  remarks: "O valor devolvido por esta propriedade representa o tamanho atual do trabalho do conjunto de memória utilizada pelo processo de, em bytes. O conjunto de trabalho de um processo é o conjunto de páginas de memória atualmente visíveis para o processo na memória RAM física. Estas páginas são residente e disponíveis para uma aplicação a utilizar sem acionar uma falhas de paginação.       O conjunto de trabalho inclui dados partilhados e privados. Os dados partilhados incluem as páginas que contêm as instruções que executa o processo, incluindo os módulos do processo e as bibliotecas de sistema."
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process' exit code.  \n  \n [!code-vb[process_sample#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_40_1.vb)]\n [!code-cpp[process_sample#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_40_1.cpp)]\n [!code-cs[process_sample#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_40_1.cs)]"
  syntax:
    content: public int WorkingSet { get; }
    return:
      type: System.Int32
      description: "A quantidade total de memória física, o processo associado está a utilizar, em bytes."
  overload: System.Diagnostics.Process.WorkingSet*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "É a plataforma Windows 98 ou Millennium edição do Windows (Windows-Me), que não suporta esta propriedade."
  platform:
  - net462
- uid: System.Diagnostics.Process.WorkingSet64
  id: WorkingSet64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WorkingSet64
  nameWithType: Process.WorkingSet64
  fullName: System.Diagnostics.Process.WorkingSet64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Obtém a quantidade de memória física, em bytes, alocados para o processo associado."
  remarks: "O valor devolvido por esta propriedade representa o tamanho atual do trabalho do conjunto de memória utilizada pelo processo de, em bytes. O conjunto de trabalho de um processo é o conjunto de páginas de memória atualmente visíveis para o processo na memória RAM física. Estas páginas são residente e disponíveis para uma aplicação a utilizar sem acionar uma falhas de paginação.       O conjunto de trabalho inclui dados partilhados e privados. Os dados partilhados incluem as páginas que contêm as instruções que executa o processo, incluindo instruções os módulos do processo e as bibliotecas de sistema.       Esta propriedade pode ser utilizada para monitorizar a utilização de memória em computadores com processadores de 32 bits ou 64 bits processadores. O valor da propriedade é equivalente à **trabalhar definir** contador de desempenho para o processo."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_32_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_32_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_32_1.vb)]"
  syntax:
    content: public long WorkingSet64 { get; }
    return:
      type: System.Int64
      description: "A quantidade de memória física, em bytes, alocado para o processo associado."
  overload: System.Diagnostics.Process.WorkingSet64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "É a plataforma Windows 98 ou Millennium edição do Windows (Windows-Me), que não suporta esta propriedade."
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ComponentModel.Win32Exception
  parent: System.ComponentModel
  isExternal: false
  name: Win32Exception
  nameWithType: Win32Exception
  fullName: System.ComponentModel.Win32Exception
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.SystemException
  parent: System
  isExternal: false
  name: SystemException
  nameWithType: SystemException
  fullName: System.SystemException
- uid: System.Diagnostics.Process.#ctor
  parent: System.Diagnostics.Process
  isExternal: false
  name: Process()
  nameWithType: Process.Process()
  fullName: System.Diagnostics.Process.Process()
- uid: System.Diagnostics.Process.BasePriority
  parent: System.Diagnostics.Process
  isExternal: false
  name: BasePriority
  nameWithType: Process.BasePriority
  fullName: System.Diagnostics.Process.BasePriority
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Diagnostics.Process.BeginErrorReadLine
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginErrorReadLine()
  nameWithType: Process.BeginErrorReadLine()
  fullName: System.Diagnostics.Process.BeginErrorReadLine()
- uid: System.Diagnostics.Process.BeginOutputReadLine
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginOutputReadLine()
  nameWithType: Process.BeginOutputReadLine()
  fullName: System.Diagnostics.Process.BeginOutputReadLine()
- uid: System.Diagnostics.Process.CancelErrorRead
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelErrorRead()
  nameWithType: Process.CancelErrorRead()
  fullName: System.Diagnostics.Process.CancelErrorRead()
- uid: System.Diagnostics.Process.CancelOutputRead
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelOutputRead()
  nameWithType: Process.CancelOutputRead()
  fullName: System.Diagnostics.Process.CancelOutputRead()
- uid: System.Diagnostics.Process.Close
  parent: System.Diagnostics.Process
  isExternal: false
  name: Close()
  nameWithType: Process.Close()
  fullName: System.Diagnostics.Process.Close()
- uid: System.Diagnostics.Process.CloseMainWindow
  parent: System.Diagnostics.Process
  isExternal: false
  name: CloseMainWindow()
  nameWithType: Process.CloseMainWindow()
  fullName: System.Diagnostics.Process.CloseMainWindow()
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Diagnostics.Process.Dispose(System.Boolean)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: Process.Dispose(Boolean)
  fullName: System.Diagnostics.Process.Dispose(Boolean)
- uid: System.Diagnostics.Process.EnableRaisingEvents
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: Process.EnableRaisingEvents
  fullName: System.Diagnostics.Process.EnableRaisingEvents
- uid: System.Diagnostics.Process.EnterDebugMode
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnterDebugMode()
  nameWithType: Process.EnterDebugMode()
  fullName: System.Diagnostics.Process.EnterDebugMode()
- uid: System.Diagnostics.Process.ErrorDataReceived
  parent: System.Diagnostics.Process
  isExternal: false
  name: ErrorDataReceived
  nameWithType: Process.ErrorDataReceived
  fullName: System.Diagnostics.Process.ErrorDataReceived
- uid: System.Diagnostics.DataReceivedEventHandler
  parent: System.Diagnostics
  isExternal: false
  name: DataReceivedEventHandler
  nameWithType: DataReceivedEventHandler
  fullName: System.Diagnostics.DataReceivedEventHandler
- uid: System.Diagnostics.Process.ExitCode
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitCode
  nameWithType: Process.ExitCode
  fullName: System.Diagnostics.Process.ExitCode
- uid: System.Diagnostics.Process.Exited
  parent: System.Diagnostics.Process
  isExternal: false
  name: Exited
  nameWithType: Process.Exited
  fullName: System.Diagnostics.Process.Exited
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Diagnostics.Process.ExitTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitTime
  nameWithType: Process.ExitTime
  fullName: System.Diagnostics.Process.ExitTime
- uid: System.DateTime
  parent: System
  isExternal: true
  name: DateTime
  nameWithType: DateTime
  fullName: System.DateTime
- uid: System.Diagnostics.Process.GetCurrentProcess
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetCurrentProcess()
  nameWithType: Process.GetCurrentProcess()
  fullName: System.Diagnostics.Process.GetCurrentProcess()
- uid: System.Diagnostics.Process
  parent: System.Diagnostics
  isExternal: false
  name: Process
  nameWithType: Process
  fullName: System.Diagnostics.Process
- uid: System.Diagnostics.Process.GetProcessById(System.Int32)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessById(Int32)
  nameWithType: Process.GetProcessById(Int32)
  fullName: System.Diagnostics.Process.GetProcessById(Int32)
- uid: System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessById(Int32,String)
  nameWithType: Process.GetProcessById(Int32,String)
  fullName: System.Diagnostics.Process.GetProcessById(Int32,String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Diagnostics.Process.GetProcesses
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcesses()
  nameWithType: Process.GetProcesses()
  fullName: System.Diagnostics.Process.GetProcesses()
- uid: System.Diagnostics.Process[]
  parent: System.Diagnostics
  isExternal: false
  name: Process
  nameWithType: Process
  fullName: System.Diagnostics.Process[]
  spec.csharp:
  - uid: System.Diagnostics.Process
    name: Process
    nameWithType: Process
    fullName: Process[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.Process.GetProcesses(System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcesses(String)
  nameWithType: Process.GetProcesses(String)
  fullName: System.Diagnostics.Process.GetProcesses(String)
- uid: System.Diagnostics.Process.GetProcessesByName(System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessesByName(String)
  nameWithType: Process.GetProcessesByName(String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String)
- uid: System.Diagnostics.Process.GetProcessesByName(System.String,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessesByName(String,String)
  nameWithType: Process.GetProcessesByName(String,String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String,String)
- uid: System.Diagnostics.Process.Handle
  parent: System.Diagnostics.Process
  isExternal: false
  name: Handle
  nameWithType: Process.Handle
  fullName: System.Diagnostics.Process.Handle
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Diagnostics.Process.HandleCount
  parent: System.Diagnostics.Process
  isExternal: false
  name: HandleCount
  nameWithType: Process.HandleCount
  fullName: System.Diagnostics.Process.HandleCount
- uid: System.Diagnostics.Process.HasExited
  parent: System.Diagnostics.Process
  isExternal: false
  name: HasExited
  nameWithType: Process.HasExited
  fullName: System.Diagnostics.Process.HasExited
- uid: System.Diagnostics.Process.Id
  parent: System.Diagnostics.Process
  isExternal: false
  name: Id
  nameWithType: Process.Id
  fullName: System.Diagnostics.Process.Id
- uid: System.Diagnostics.Process.Kill
  parent: System.Diagnostics.Process
  isExternal: false
  name: Kill()
  nameWithType: Process.Kill()
  fullName: System.Diagnostics.Process.Kill()
- uid: System.Diagnostics.Process.LeaveDebugMode
  parent: System.Diagnostics.Process
  isExternal: false
  name: LeaveDebugMode()
  nameWithType: Process.LeaveDebugMode()
  fullName: System.Diagnostics.Process.LeaveDebugMode()
- uid: System.Diagnostics.Process.MachineName
  parent: System.Diagnostics.Process
  isExternal: false
  name: MachineName
  nameWithType: Process.MachineName
  fullName: System.Diagnostics.Process.MachineName
- uid: System.Diagnostics.Process.MainModule
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainModule
  nameWithType: Process.MainModule
  fullName: System.Diagnostics.Process.MainModule
- uid: System.Diagnostics.ProcessModule
  parent: System.Diagnostics
  isExternal: false
  name: ProcessModule
  nameWithType: ProcessModule
  fullName: System.Diagnostics.ProcessModule
- uid: System.Diagnostics.Process.MainWindowHandle
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowHandle
  nameWithType: Process.MainWindowHandle
  fullName: System.Diagnostics.Process.MainWindowHandle
- uid: System.Diagnostics.Process.MainWindowTitle
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowTitle
  nameWithType: Process.MainWindowTitle
  fullName: System.Diagnostics.Process.MainWindowTitle
- uid: System.Diagnostics.Process.MaxWorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: MaxWorkingSet
  nameWithType: Process.MaxWorkingSet
  fullName: System.Diagnostics.Process.MaxWorkingSet
- uid: System.Diagnostics.Process.MinWorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: MinWorkingSet
  nameWithType: Process.MinWorkingSet
  fullName: System.Diagnostics.Process.MinWorkingSet
- uid: System.Diagnostics.Process.Modules
  parent: System.Diagnostics.Process
  isExternal: false
  name: Modules
  nameWithType: Process.Modules
  fullName: System.Diagnostics.Process.Modules
- uid: System.Diagnostics.ProcessModuleCollection
  parent: System.Diagnostics
  isExternal: false
  name: ProcessModuleCollection
  nameWithType: ProcessModuleCollection
  fullName: System.Diagnostics.ProcessModuleCollection
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize
  nameWithType: Process.NonpagedSystemMemorySize
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize64
  nameWithType: Process.NonpagedSystemMemorySize64
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize64
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Diagnostics.Process.OnExited
  parent: System.Diagnostics.Process
  isExternal: false
  name: OnExited()
  nameWithType: Process.OnExited()
  fullName: System.Diagnostics.Process.OnExited()
- uid: System.Diagnostics.Process.OutputDataReceived
  parent: System.Diagnostics.Process
  isExternal: false
  name: OutputDataReceived
  nameWithType: Process.OutputDataReceived
  fullName: System.Diagnostics.Process.OutputDataReceived
- uid: System.Diagnostics.Process.PagedMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize
  nameWithType: Process.PagedMemorySize
  fullName: System.Diagnostics.Process.PagedMemorySize
- uid: System.Diagnostics.Process.PagedMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize64
  nameWithType: Process.PagedMemorySize64
  fullName: System.Diagnostics.Process.PagedMemorySize64
- uid: System.Diagnostics.Process.PagedSystemMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize
  nameWithType: Process.PagedSystemMemorySize
  fullName: System.Diagnostics.Process.PagedSystemMemorySize
- uid: System.Diagnostics.Process.PagedSystemMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize64
  nameWithType: Process.PagedSystemMemorySize64
  fullName: System.Diagnostics.Process.PagedSystemMemorySize64
- uid: System.Diagnostics.Process.PeakPagedMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize
  nameWithType: Process.PeakPagedMemorySize
  fullName: System.Diagnostics.Process.PeakPagedMemorySize
- uid: System.Diagnostics.Process.PeakPagedMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize64
  nameWithType: Process.PeakPagedMemorySize64
  fullName: System.Diagnostics.Process.PeakPagedMemorySize64
- uid: System.Diagnostics.Process.PeakVirtualMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize
  nameWithType: Process.PeakVirtualMemorySize
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize
- uid: System.Diagnostics.Process.PeakVirtualMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize64
  nameWithType: Process.PeakVirtualMemorySize64
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize64
- uid: System.Diagnostics.Process.PeakWorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet
  nameWithType: Process.PeakWorkingSet
  fullName: System.Diagnostics.Process.PeakWorkingSet
- uid: System.Diagnostics.Process.PeakWorkingSet64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet64
  nameWithType: Process.PeakWorkingSet64
  fullName: System.Diagnostics.Process.PeakWorkingSet64
- uid: System.Diagnostics.Process.PriorityBoostEnabled
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityBoostEnabled
  nameWithType: Process.PriorityBoostEnabled
  fullName: System.Diagnostics.Process.PriorityBoostEnabled
- uid: System.Diagnostics.Process.PriorityClass
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityClass
  nameWithType: Process.PriorityClass
  fullName: System.Diagnostics.Process.PriorityClass
- uid: System.Diagnostics.ProcessPriorityClass
  parent: System.Diagnostics
  isExternal: false
  name: ProcessPriorityClass
  nameWithType: ProcessPriorityClass
  fullName: System.Diagnostics.ProcessPriorityClass
- uid: System.Diagnostics.Process.PrivateMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize
  nameWithType: Process.PrivateMemorySize
  fullName: System.Diagnostics.Process.PrivateMemorySize
- uid: System.Diagnostics.Process.PrivateMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize64
  nameWithType: Process.PrivateMemorySize64
  fullName: System.Diagnostics.Process.PrivateMemorySize64
- uid: System.Diagnostics.Process.PrivilegedProcessorTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivilegedProcessorTime
  nameWithType: Process.PrivilegedProcessorTime
  fullName: System.Diagnostics.Process.PrivilegedProcessorTime
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Diagnostics.Process.ProcessName
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessName
  nameWithType: Process.ProcessName
  fullName: System.Diagnostics.Process.ProcessName
- uid: System.Diagnostics.Process.ProcessorAffinity
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessorAffinity
  nameWithType: Process.ProcessorAffinity
  fullName: System.Diagnostics.Process.ProcessorAffinity
- uid: System.Diagnostics.Process.Refresh
  parent: System.Diagnostics.Process
  isExternal: false
  name: Refresh()
  nameWithType: Process.Refresh()
  fullName: System.Diagnostics.Process.Refresh()
- uid: System.Diagnostics.Process.Responding
  parent: System.Diagnostics.Process
  isExternal: false
  name: Responding
  nameWithType: Process.Responding
  fullName: System.Diagnostics.Process.Responding
- uid: System.Diagnostics.Process.SafeHandle
  parent: System.Diagnostics.Process
  isExternal: false
  name: SafeHandle
  nameWithType: Process.SafeHandle
  fullName: System.Diagnostics.Process.SafeHandle
- uid: Microsoft.Win32.SafeHandles.SafeProcessHandle
  parent: Microsoft.Win32.SafeHandles
  isExternal: false
  name: SafeProcessHandle
  nameWithType: SafeProcessHandle
  fullName: Microsoft.Win32.SafeHandles.SafeProcessHandle
- uid: System.Diagnostics.Process.SessionId
  parent: System.Diagnostics.Process
  isExternal: false
  name: SessionId
  nameWithType: Process.SessionId
  fullName: System.Diagnostics.Process.SessionId
- uid: System.Diagnostics.Process.StandardError
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardError
  nameWithType: Process.StandardError
  fullName: System.Diagnostics.Process.StandardError
- uid: System.IO.StreamReader
  parent: System.IO
  isExternal: true
  name: StreamReader
  nameWithType: StreamReader
  fullName: System.IO.StreamReader
- uid: System.Diagnostics.Process.StandardInput
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardInput
  nameWithType: Process.StandardInput
  fullName: System.Diagnostics.Process.StandardInput
- uid: System.IO.StreamWriter
  parent: System.IO
  isExternal: true
  name: StreamWriter
  nameWithType: StreamWriter
  fullName: System.IO.StreamWriter
- uid: System.Diagnostics.Process.StandardOutput
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardOutput
  nameWithType: Process.StandardOutput
  fullName: System.Diagnostics.Process.StandardOutput
- uid: System.Diagnostics.Process.Start
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start()
  nameWithType: Process.Start()
  fullName: System.Diagnostics.Process.Start()
- uid: System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(ProcessStartInfo)
  nameWithType: Process.Start(ProcessStartInfo)
  fullName: System.Diagnostics.Process.Start(ProcessStartInfo)
- uid: System.Diagnostics.ProcessStartInfo
  parent: System.Diagnostics
  isExternal: false
  name: ProcessStartInfo
  nameWithType: ProcessStartInfo
  fullName: System.Diagnostics.ProcessStartInfo
- uid: System.Diagnostics.Process.Start(System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String)
  nameWithType: Process.Start(String)
  fullName: System.Diagnostics.Process.Start(String)
- uid: System.Diagnostics.Process.Start(System.String,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String,String)
  nameWithType: Process.Start(String,String)
  fullName: System.Diagnostics.Process.Start(String,String)
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String,String,SecureString,String)
  nameWithType: Process.Start(String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,SecureString,String)
- uid: System.Security.SecureString
  parent: System.Security
  isExternal: false
  name: SecureString
  nameWithType: SecureString
  fullName: System.Security.SecureString
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String,String,String,SecureString,String)
  nameWithType: Process.Start(String,String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,String,SecureString,String)
- uid: System.Diagnostics.Process.StartInfo
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartInfo
  nameWithType: Process.StartInfo
  fullName: System.Diagnostics.Process.StartInfo
- uid: System.Diagnostics.Process.StartTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartTime
  nameWithType: Process.StartTime
  fullName: System.Diagnostics.Process.StartTime
- uid: System.Diagnostics.Process.SynchronizingObject
  parent: System.Diagnostics.Process
  isExternal: false
  name: SynchronizingObject
  nameWithType: Process.SynchronizingObject
  fullName: System.Diagnostics.Process.SynchronizingObject
- uid: System.ComponentModel.ISynchronizeInvoke
  parent: System.ComponentModel
  isExternal: false
  name: ISynchronizeInvoke
  nameWithType: ISynchronizeInvoke
  fullName: System.ComponentModel.ISynchronizeInvoke
- uid: System.Diagnostics.Process.Threads
  parent: System.Diagnostics.Process
  isExternal: false
  name: Threads
  nameWithType: Process.Threads
  fullName: System.Diagnostics.Process.Threads
- uid: System.Diagnostics.ProcessThreadCollection
  parent: System.Diagnostics
  isExternal: false
  name: ProcessThreadCollection
  nameWithType: ProcessThreadCollection
  fullName: System.Diagnostics.ProcessThreadCollection
- uid: System.Diagnostics.Process.ToString
  parent: System.Diagnostics.Process
  isExternal: false
  name: ToString()
  nameWithType: Process.ToString()
  fullName: System.Diagnostics.Process.ToString()
- uid: System.Diagnostics.Process.TotalProcessorTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: TotalProcessorTime
  nameWithType: Process.TotalProcessorTime
  fullName: System.Diagnostics.Process.TotalProcessorTime
- uid: System.Diagnostics.Process.UserProcessorTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: UserProcessorTime
  nameWithType: Process.UserProcessorTime
  fullName: System.Diagnostics.Process.UserProcessorTime
- uid: System.Diagnostics.Process.VirtualMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize
  nameWithType: Process.VirtualMemorySize
  fullName: System.Diagnostics.Process.VirtualMemorySize
- uid: System.Diagnostics.Process.VirtualMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize64
  nameWithType: Process.VirtualMemorySize64
  fullName: System.Diagnostics.Process.VirtualMemorySize64
- uid: System.Diagnostics.Process.WaitForExit
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForExit()
  nameWithType: Process.WaitForExit()
  fullName: System.Diagnostics.Process.WaitForExit()
- uid: System.Diagnostics.Process.WaitForExit(System.Int32)
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForExit(Int32)
  nameWithType: Process.WaitForExit(Int32)
  fullName: System.Diagnostics.Process.WaitForExit(Int32)
- uid: System.Diagnostics.Process.WaitForInputIdle
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForInputIdle()
  nameWithType: Process.WaitForInputIdle()
  fullName: System.Diagnostics.Process.WaitForInputIdle()
- uid: System.Diagnostics.Process.WaitForInputIdle(System.Int32)
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForInputIdle(Int32)
  nameWithType: Process.WaitForInputIdle(Int32)
  fullName: System.Diagnostics.Process.WaitForInputIdle(Int32)
- uid: System.Diagnostics.Process.WorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet
  nameWithType: Process.WorkingSet
  fullName: System.Diagnostics.Process.WorkingSet
- uid: System.Diagnostics.Process.WorkingSet64
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet64
  nameWithType: Process.WorkingSet64
  fullName: System.Diagnostics.Process.WorkingSet64
- uid: System.Diagnostics.Process.#ctor*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Process
  nameWithType: Process.Process
- uid: System.Diagnostics.Process.BasePriority*
  parent: System.Diagnostics.Process
  isExternal: false
  name: BasePriority
  nameWithType: Process.BasePriority
- uid: System.Diagnostics.Process.BeginErrorReadLine*
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginErrorReadLine
  nameWithType: Process.BeginErrorReadLine
- uid: System.Diagnostics.Process.BeginOutputReadLine*
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginOutputReadLine
  nameWithType: Process.BeginOutputReadLine
- uid: System.Diagnostics.Process.CancelErrorRead*
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelErrorRead
  nameWithType: Process.CancelErrorRead
- uid: System.Diagnostics.Process.CancelOutputRead*
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelOutputRead
  nameWithType: Process.CancelOutputRead
- uid: System.Diagnostics.Process.Close*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Close
  nameWithType: Process.Close
- uid: System.Diagnostics.Process.CloseMainWindow*
  parent: System.Diagnostics.Process
  isExternal: false
  name: CloseMainWindow
  nameWithType: Process.CloseMainWindow
- uid: System.Diagnostics.Process.Dispose*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Dispose
  nameWithType: Process.Dispose
- uid: System.Diagnostics.Process.EnableRaisingEvents*
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: Process.EnableRaisingEvents
- uid: System.Diagnostics.Process.EnterDebugMode*
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnterDebugMode
  nameWithType: Process.EnterDebugMode
- uid: System.Diagnostics.Process.ExitCode*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitCode
  nameWithType: Process.ExitCode
- uid: System.Diagnostics.Process.ExitTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitTime
  nameWithType: Process.ExitTime
- uid: System.Diagnostics.Process.GetCurrentProcess*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetCurrentProcess
  nameWithType: Process.GetCurrentProcess
- uid: System.Diagnostics.Process.GetProcessById*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessById
  nameWithType: Process.GetProcessById
- uid: System.Diagnostics.Process.GetProcesses*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcesses
  nameWithType: Process.GetProcesses
- uid: System.Diagnostics.Process.GetProcessesByName*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessesByName
  nameWithType: Process.GetProcessesByName
- uid: System.Diagnostics.Process.Handle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Handle
  nameWithType: Process.Handle
- uid: System.Diagnostics.Process.HandleCount*
  parent: System.Diagnostics.Process
  isExternal: false
  name: HandleCount
  nameWithType: Process.HandleCount
- uid: System.Diagnostics.Process.HasExited*
  parent: System.Diagnostics.Process
  isExternal: false
  name: HasExited
  nameWithType: Process.HasExited
- uid: System.Diagnostics.Process.Id*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Id
  nameWithType: Process.Id
- uid: System.Diagnostics.Process.Kill*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Kill
  nameWithType: Process.Kill
- uid: System.Diagnostics.Process.LeaveDebugMode*
  parent: System.Diagnostics.Process
  isExternal: false
  name: LeaveDebugMode
  nameWithType: Process.LeaveDebugMode
- uid: System.Diagnostics.Process.MachineName*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MachineName
  nameWithType: Process.MachineName
- uid: System.Diagnostics.Process.MainModule*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainModule
  nameWithType: Process.MainModule
- uid: System.Diagnostics.Process.MainWindowHandle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowHandle
  nameWithType: Process.MainWindowHandle
- uid: System.Diagnostics.Process.MainWindowTitle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowTitle
  nameWithType: Process.MainWindowTitle
- uid: System.Diagnostics.Process.MaxWorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MaxWorkingSet
  nameWithType: Process.MaxWorkingSet
- uid: System.Diagnostics.Process.MinWorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MinWorkingSet
  nameWithType: Process.MinWorkingSet
- uid: System.Diagnostics.Process.Modules*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Modules
  nameWithType: Process.Modules
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize
  nameWithType: Process.NonpagedSystemMemorySize
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize64
  nameWithType: Process.NonpagedSystemMemorySize64
- uid: System.Diagnostics.Process.OnExited*
  parent: System.Diagnostics.Process
  isExternal: false
  name: OnExited
  nameWithType: Process.OnExited
- uid: System.Diagnostics.Process.PagedMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize
  nameWithType: Process.PagedMemorySize
- uid: System.Diagnostics.Process.PagedMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize64
  nameWithType: Process.PagedMemorySize64
- uid: System.Diagnostics.Process.PagedSystemMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize
  nameWithType: Process.PagedSystemMemorySize
- uid: System.Diagnostics.Process.PagedSystemMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize64
  nameWithType: Process.PagedSystemMemorySize64
- uid: System.Diagnostics.Process.PeakPagedMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize
  nameWithType: Process.PeakPagedMemorySize
- uid: System.Diagnostics.Process.PeakPagedMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize64
  nameWithType: Process.PeakPagedMemorySize64
- uid: System.Diagnostics.Process.PeakVirtualMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize
  nameWithType: Process.PeakVirtualMemorySize
- uid: System.Diagnostics.Process.PeakVirtualMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize64
  nameWithType: Process.PeakVirtualMemorySize64
- uid: System.Diagnostics.Process.PeakWorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet
  nameWithType: Process.PeakWorkingSet
- uid: System.Diagnostics.Process.PeakWorkingSet64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet64
  nameWithType: Process.PeakWorkingSet64
- uid: System.Diagnostics.Process.PriorityBoostEnabled*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityBoostEnabled
  nameWithType: Process.PriorityBoostEnabled
- uid: System.Diagnostics.Process.PriorityClass*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityClass
  nameWithType: Process.PriorityClass
- uid: System.Diagnostics.Process.PrivateMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize
  nameWithType: Process.PrivateMemorySize
- uid: System.Diagnostics.Process.PrivateMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize64
  nameWithType: Process.PrivateMemorySize64
- uid: System.Diagnostics.Process.PrivilegedProcessorTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivilegedProcessorTime
  nameWithType: Process.PrivilegedProcessorTime
- uid: System.Diagnostics.Process.ProcessName*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessName
  nameWithType: Process.ProcessName
- uid: System.Diagnostics.Process.ProcessorAffinity*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessorAffinity
  nameWithType: Process.ProcessorAffinity
- uid: System.Diagnostics.Process.Refresh*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Refresh
  nameWithType: Process.Refresh
- uid: System.Diagnostics.Process.Responding*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Responding
  nameWithType: Process.Responding
- uid: System.Diagnostics.Process.SafeHandle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: SafeHandle
  nameWithType: Process.SafeHandle
- uid: System.Diagnostics.Process.SessionId*
  parent: System.Diagnostics.Process
  isExternal: false
  name: SessionId
  nameWithType: Process.SessionId
- uid: System.Diagnostics.Process.StandardError*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardError
  nameWithType: Process.StandardError
- uid: System.Diagnostics.Process.StandardInput*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardInput
  nameWithType: Process.StandardInput
- uid: System.Diagnostics.Process.StandardOutput*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardOutput
  nameWithType: Process.StandardOutput
- uid: System.Diagnostics.Process.Start*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start
  nameWithType: Process.Start
- uid: System.Diagnostics.Process.StartInfo*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartInfo
  nameWithType: Process.StartInfo
- uid: System.Diagnostics.Process.StartTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartTime
  nameWithType: Process.StartTime
- uid: System.Diagnostics.Process.SynchronizingObject*
  parent: System.Diagnostics.Process
  isExternal: false
  name: SynchronizingObject
  nameWithType: Process.SynchronizingObject
- uid: System.Diagnostics.Process.Threads*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Threads
  nameWithType: Process.Threads
- uid: System.Diagnostics.Process.ToString*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ToString
  nameWithType: Process.ToString
- uid: System.Diagnostics.Process.TotalProcessorTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: TotalProcessorTime
  nameWithType: Process.TotalProcessorTime
- uid: System.Diagnostics.Process.UserProcessorTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: UserProcessorTime
  nameWithType: Process.UserProcessorTime
- uid: System.Diagnostics.Process.VirtualMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize
  nameWithType: Process.VirtualMemorySize
- uid: System.Diagnostics.Process.VirtualMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize64
  nameWithType: Process.VirtualMemorySize64
- uid: System.Diagnostics.Process.WaitForExit*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForExit
  nameWithType: Process.WaitForExit
- uid: System.Diagnostics.Process.WaitForInputIdle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForInputIdle
  nameWithType: Process.WaitForInputIdle
- uid: System.Diagnostics.Process.WorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet
  nameWithType: Process.WorkingSet
- uid: System.Diagnostics.Process.WorkingSet64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet64
  nameWithType: Process.WorkingSet64
