### YamlMime:ManagedReference
items:
- uid: System.Windows.FrameworkPropertyMetadata
  id: FrameworkPropertyMetadata
  children:
  - System.Windows.FrameworkPropertyMetadata.#ctor
  - System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)
  - System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)
  - System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)
  - System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)
  - System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)
  - System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)
  - System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)
  - System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)
  - System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)
  - System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)
  - System.Windows.FrameworkPropertyMetadata.AffectsArrange
  - System.Windows.FrameworkPropertyMetadata.AffectsMeasure
  - System.Windows.FrameworkPropertyMetadata.AffectsParentArrange
  - System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure
  - System.Windows.FrameworkPropertyMetadata.AffectsRender
  - System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault
  - System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger
  - System.Windows.FrameworkPropertyMetadata.Inherits
  - System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed
  - System.Windows.FrameworkPropertyMetadata.IsNotDataBindable
  - System.Windows.FrameworkPropertyMetadata.Journal
  - System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)
  - System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)
  - System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior
  - System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender
  langs:
  - csharp
  name: FrameworkPropertyMetadata
  nameWithType: FrameworkPropertyMetadata
  fullName: System.Windows.FrameworkPropertyMetadata
  type: Class
  summary: "Os relatórios ou se aplica metadados para uma propriedade de dependência, especificamente adicionar características de sistema específicos do framework propriedade."
  remarks: "Esta classe deriva de <xref:System.Windows.PropertyMetadata>(através de <xref:System.Windows.UIPropertyMetadata>).</xref:System.Windows.UIPropertyMetadata> </xref:System.Windows.PropertyMetadata> A maioria das WPF aplicação ao nível do framework para fins de desenvolvimento, FrameworkPropertyMetadata é o tipo utilizado para os metadados da propriedade de dependência, em vez dos metadados base tipos <xref:System.Windows.PropertyMetadata>ou <xref:System.Windows.UIPropertyMetadata>.</xref:System.Windows.UIPropertyMetadata> </xref:System.Windows.PropertyMetadata> Isto é verdade tanto para as propriedades de dependência existente para a maioria dos cenários de propriedade de dependência personalizado.       Os membros declarados por esta classe que complementam as <xref:System.Windows.PropertyMetadata>classe base incluir várias propriedades booleanos que especificarem ou comportamento do sistema de propriedade ao nível do framework WPF, tais como a herança de propriedade, o enlace de dados e o esquema de relatório.</xref:System.Windows.PropertyMetadata>       Vários assinaturas de construtor para criar uma instância de FrameworkPropertyMetadata demorar um <xref:System.Windows.FrameworkPropertyMetadataOptions>parâmetro.</xref:System.Windows.FrameworkPropertyMetadataOptions> O <xref:System.Windows.FrameworkPropertyMetadataOptions>enumeração é utilizada apenas para especificar o comportamento inicial no construtor e caso contrário, não é exposta depois FrameworkPropertyMetadata é construído.</xref:System.Windows.FrameworkPropertyMetadataOptions> A partir de uma instância construída, pode obter ou definir as informações através de várias propriedades que partilham o nome dos valores de enumeração utilizado na chamada de construtor correspondentes.      <a name=&quot;xamlTextUsage_FrameworkPropertyMetadata&quot;></a># # Utilização de texto de XAML esta classe não é normalmente utilizada em [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]."
  example:
  - "The following example gets metadata for a dependency property on a particular owner as the initial base <xref:System.Windows.PropertyMetadata> type. That metadata is cast to FrameworkPropertyMetadata. If the cast returned a valid FrameworkPropertyMetadata, then various FrameworkPropertyMetadata property values are reported through a simple UI (not shown).  \n  \n [!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  \n[!code-cs[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#fpmproperties)]\n[!code-vb[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]"
  syntax:
    content: 'public class FrameworkPropertyMetadata : System.Windows.UIPropertyMetadata'
  inheritance:
  - System.Object
  - System.Windows.PropertyMetadata
  - System.Windows.UIPropertyMetadata
  implements: []
  inheritedMembers:
  - System.Windows.PropertyMetadata.CoerceValueCallback
  - System.Windows.PropertyMetadata.DefaultValue
  - System.Windows.PropertyMetadata.IsSealed
  - System.Windows.PropertyMetadata.PropertyChangedCallback
  - System.Windows.UIPropertyMetadata.IsAnimationProhibited
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.#ctor
  id: '#ctor'
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: FrameworkPropertyMetadata()
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata()
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata()
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Windows.FrameworkPropertyMetadata&quot;> </xref> classe."
  remarks: "Esta assinatura inicializa todos os valores da FrameworkPropertyMetadata as predefinições de propriedade. <xref:System.Windows.PropertyMetadata.DefaultValue%2A>será `null`e a várias <xref:System.Windows.FrameworkPropertyMetadata>Propriedades booleanos será `false`.</xref:System.Windows.FrameworkPropertyMetadata></xref:System.Windows.PropertyMetadata.DefaultValue%2A>"
  syntax:
    content: public FrameworkPropertyMetadata ();
    parameters: []
  overload: System.Windows.FrameworkPropertyMetadata.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)
  id: '#ctor(System.Object)'
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: FrameworkPropertyMetadata(Object)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Windows.FrameworkPropertyMetadata&quot;> </xref> classe com o valor predefinido especificado."
  remarks: "O tipo do valor fornecido para `defaultValue` tem de corresponder ou ser relacionados com o tipo especificado no registo original da propriedade de dependência que estes metadados serão aplicados a. Correspondência entre o tipo de valor predefinido de metadados e o tipo da propriedade de dependência que está a ser aplicada para pode ser difícil de depuração, porque o erro de correspondência não é detetável durante a compilação. O sistema de propriedade não avalia o valor Efetivo de uma propriedade até que o tempo de execução, pelo que o resultado de uma incompatibilidade de tipos de propriedade do tipo de valor predefinido é um erro de tempo de execução.       O valor <xref:System.Windows.DependencyProperty.UnsetValue>têm um significado especial no sistema de propriedade e não pode ser utilizado como um valor de predefinido da propriedade de dependência.</xref:System.Windows.DependencyProperty.UnsetValue>"
  example:
  - "The following example calls this constructor signature:  \n  \n [!code-cs[PropertyMetadataAPIs#Initfpm](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#initfpm)]  \n[!code-cs[PropertyMetadataAPIs#FPMCtor1param](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#fpmctor1param)]"
  syntax:
    content: public FrameworkPropertyMetadata (object defaultValue);
    parameters:
    - id: defaultValue
      type: System.Object
      description: "O valor predefinido da propriedade de dependência, geralmente, fornecido como um valor de um tipo específico."
  overload: System.Windows.FrameworkPropertyMetadata.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>defaultValue</code>está definido como <xref href=&quot;System.Windows.DependencyProperty.UnsetValue&quot;> </xref>; Consulte observações."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)
  id: '#ctor(System.Windows.PropertyChangedCallback)'
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: FrameworkPropertyMetadata(PropertyChangedCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(PropertyChangedCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(PropertyChangedCallback)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Windows.FrameworkPropertyMetadata&quot;> </xref> classe com especificado <xref href=&quot;System.Windows.PropertyChangedCallback&quot;> </xref> chamada de retorno."
  remarks: ''
  example:
  - "The following example calls this constructor signature:  \n  \n [!code-cs[PropertyMetadataAPIs#Initfpm](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#initfpm)]  \n[!code-cs[PropertyMetadataAPIs#FPMCtor1paramcallback](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#fpmctor1paramcallback)]"
  syntax:
    content: public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);
    parameters:
    - id: propertyChangedCallback
      type: System.Windows.PropertyChangedCallback
      description: "Uma referência a uma implementação de processador que o sistema de propriedade irá chamar sempre que o valor efetivo da propriedade é alterado."
  overload: System.Windows.FrameworkPropertyMetadata.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)
  id: '#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)'
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Windows.FrameworkPropertyMetadata&quot;> </xref> classe com as opções de metadados de nível de framework e o valor predefinido fornecido."
  remarks: "O tipo do valor fornecido para `defaultValue` tem de corresponder ou ser relacionados com o tipo especificado no registo original da propriedade de dependência que estes metadados serão aplicados a. Correspondência entre o tipo de valor predefinido de metadados e o tipo da propriedade de dependência que está a ser aplicada para pode ser difícil de depuração, porque o erro de correspondência não é detetável durante a compilação. O sistema de propriedade não avalia o valor Efetivo de uma propriedade até que o tempo de execução, pelo que o resultado de uma incompatibilidade de tipos de propriedade do tipo de valor predefinido é um erro de tempo de execução.       O valor <xref:System.Windows.DependencyProperty.UnsetValue>têm um significado especial no sistema de propriedade e não pode ser utilizado como um valor de predefinido da propriedade de dependência.</xref:System.Windows.DependencyProperty.UnsetValue>       Valores marcado como conjunto de sinalizadores no `flags` parâmetro irá definir o valor de booleano <xref:System.Windows.FrameworkPropertyMetadata>propriedades que corresponde à <xref:System.Windows.FrameworkPropertyMetadataOptions>nome do sinalizador para `true`.</xref:System.Windows.FrameworkPropertyMetadataOptions> </xref:System.Windows.FrameworkPropertyMetadata> Pode alterar os valores das propriedades nos metadados, subsequentemente, desde que os metadados ainda não foram aplicados a uma operação do sistema de propriedade específica."
  example:
  - "The following example calls this constructor signature:  \n  \n [!code-cs[PropertyMetadataAPIs#Initfpm](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#initfpm)]  \n[!code-cs[PropertyMetadataAPIs#FPMCtor_DV_FPMO](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#fpmctor_dv_fpmo)]"
  syntax:
    content: public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags);
    parameters:
    - id: defaultValue
      type: System.Object
      description: "O valor predefinido da propriedade de dependência, geralmente, fornecido como um valor de um tipo específico."
    - id: flags
      type: System.Windows.FrameworkPropertyMetadataOptions
      description: "Os sinalizadores de opção de metadados (uma combinação de <xref href=&quot;System.Windows.FrameworkPropertyMetadataOptions&quot;> </xref> valores). Estas opções especificar características da propriedade de dependência que interagem com sistemas, tais como o esquema ou enlace de dados."
  overload: System.Windows.FrameworkPropertyMetadata.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>defaultValue</code>está definido como <xref href=&quot;System.Windows.DependencyProperty.UnsetValue&quot;> </xref>; Consulte observações."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)
  id: '#ctor(System.Object,System.Windows.PropertyChangedCallback)'
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: FrameworkPropertyMetadata(Object,PropertyChangedCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,PropertyChangedCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,PropertyChangedCallback)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Windows.FrameworkPropertyMetadata&quot;> </xref> classe com o valor predefinido fornecido e especificado <xref href=&quot;System.Windows.PropertyChangedCallback&quot;> </xref> chamada de retorno."
  remarks: "O tipo do valor fornecido para `defaultValue` tem de corresponder ou ser relacionados com o tipo especificado no registo original da propriedade de dependência que estes metadados serão aplicados a. Correspondência entre o tipo de valor predefinido de metadados e o tipo da propriedade de dependência que está a ser aplicada para pode ser difícil de depuração, porque o erro de correspondência não é detetável durante a compilação. O sistema de propriedade não avalia o valor Efetivo de uma propriedade até que o tempo de execução, pelo que o resultado de uma incompatibilidade de tipos de propriedade do tipo de valor predefinido é um erro de tempo de execução.       O valor <xref:System.Windows.DependencyProperty.UnsetValue>têm um significado especial no sistema de propriedade e não pode ser utilizado como um valor de predefinido da propriedade de dependência.</xref:System.Windows.DependencyProperty.UnsetValue>"
  example:
  - "The following example calls this constructor signature:  \n  \n [!code-cs[PropertyMetadataAPIs#Initfpm](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#initfpm)]  \n[!code-cs[PropertyMetadataAPIs#FPMCtor2param](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#fpmctor2param)]"
  syntax:
    content: public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);
    parameters:
    - id: defaultValue
      type: System.Object
      description: "O valor predefinido da propriedade de dependência, geralmente, fornecido como um valor de um tipo específico."
    - id: propertyChangedCallback
      type: System.Windows.PropertyChangedCallback
      description: "Uma referência a uma implementação de processador que o sistema de propriedade irá chamar sempre que o valor efetivo da propriedade é alterado."
  overload: System.Windows.FrameworkPropertyMetadata.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>defaultValue</code>está definido como <xref href=&quot;System.Windows.DependencyProperty.UnsetValue&quot;> </xref>; Consulte observações."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)
  id: '#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)'
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: FrameworkPropertyMetadata(PropertyChangedCallback,CoerceValueCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(PropertyChangedCallback,CoerceValueCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(PropertyChangedCallback,CoerceValueCallback)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Windows.FrameworkPropertyMetadata&quot;> </xref> classe com as chamadas de retorno especificadas."
  remarks: "Esta implementação chama um inicializador de base e, em seguida, adiciona o `coerceValueCallback` definindo a propriedade na instância de base."
  example:
  - "The following example calls this constructor signature:  \n  \n [!code-cs[PropertyMetadataAPIs#Initfpm](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#initfpm)]  \n[!code-cs[PropertyMetadataAPIs#FPMCtor_PCC_CVC](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#fpmctor_pcc_cvc)]"
  syntax:
    content: public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);
    parameters:
    - id: propertyChangedCallback
      type: System.Windows.PropertyChangedCallback
      description: "Uma referência a uma implementação de processador que o sistema de propriedade irá chamar sempre que o valor efetivo da propriedade é alterado."
    - id: coerceValueCallback
      type: System.Windows.CoerceValueCallback
      description: "Uma referência a uma implementação de processador será chamada sempre que o sistema de propriedade chama <xref:System.Windows.DependencyObject.CoerceValue*>para esta propriedade de dependência.</xref:System.Windows.DependencyObject.CoerceValue*>"
  overload: System.Windows.FrameworkPropertyMetadata.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)
  id: '#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)'
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Windows.FrameworkPropertyMetadata&quot;> </xref> classe com as opções de metadados de valor e framework predefinida fornecida e especificado <xref href=&quot;System.Windows.PropertyChangedCallback&quot;> </xref> chamada de retorno."
  remarks: "O tipo do valor fornecido para `defaultValue` tem de corresponder ou ser relacionados com o tipo especificado no registo original da propriedade de dependência que estes metadados serão aplicados a. Correspondência entre o tipo de valor predefinido de metadados e o tipo da propriedade de dependência que está a ser aplicada para pode ser difícil de depuração, porque o erro de correspondência não é detetável durante a compilação. O sistema de propriedade não avalia o valor Efetivo de uma propriedade até que o tempo de execução, pelo que o resultado de uma incompatibilidade de tipos de propriedade do tipo de valor predefinido é um erro de tempo de execução.       O valor <xref:System.Windows.DependencyProperty.UnsetValue>têm um significado especial no sistema de propriedade e não pode ser utilizado como um valor de predefinido da propriedade de dependência.</xref:System.Windows.DependencyProperty.UnsetValue>       Valores marcado como conjunto de sinalizadores no `flags` parâmetro irá definir o valor de booleano <xref:System.Windows.FrameworkPropertyMetadata>propriedades que corresponde à <xref:System.Windows.FrameworkPropertyMetadataOptions>nome do sinalizador para `true`.</xref:System.Windows.FrameworkPropertyMetadataOptions> </xref:System.Windows.FrameworkPropertyMetadata> Ainda pode alterar os valores das propriedades nos metadados, desde que os metadados ainda não foram aplicados a uma operação do sistema de propriedade específica."
  example:
  - "The following example calls this constructor signature:  \n  \n [!code-cs[PropertyMetadataAPIs#Initfpm](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#initfpm)]  \n[!code-cs[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#fpmctor_dv_fpmo_pcc)]"
  syntax:
    content: public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback);
    parameters:
    - id: defaultValue
      type: System.Object
      description: "O valor predefinido da propriedade de dependência, geralmente, fornecido como um valor de um tipo específico."
    - id: flags
      type: System.Windows.FrameworkPropertyMetadataOptions
      description: "Os sinalizadores de opção de metadados (uma combinação de <xref href=&quot;System.Windows.FrameworkPropertyMetadataOptions&quot;> </xref> valores). Estas opções especificar características da propriedade de dependência que interagem com sistemas, tais como o esquema ou enlace de dados."
    - id: propertyChangedCallback
      type: System.Windows.PropertyChangedCallback
      description: "Uma referência a uma implementação de processador que o sistema de propriedade irá chamar sempre que o valor efetivo da propriedade é alterado."
  overload: System.Windows.FrameworkPropertyMetadata.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>defaultValue</code>está definido como <xref href=&quot;System.Windows.DependencyProperty.UnsetValue&quot;> </xref>; Consulte observações."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)
  id: '#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)'
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: FrameworkPropertyMetadata(Object,PropertyChangedCallback,CoerceValueCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,PropertyChangedCallback,CoerceValueCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,PropertyChangedCallback,CoerceValueCallback)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Windows.FrameworkPropertyMetadata&quot;> </xref> classe com o valor predefinido fornecido e chamadas de retorno especificadas."
  remarks: "O tipo do valor fornecido para `defaultValue` tem de corresponder ou ser relacionados com o tipo especificado no registo original da propriedade de dependência que estes metadados serão aplicados a. Correspondência entre o tipo de valor predefinido de metadados e o tipo da propriedade de dependência que está a ser aplicada para pode ser difícil de depuração, porque o erro de correspondência não é detetável durante a compilação. O sistema de propriedade não avalia o valor Efetivo de uma propriedade até que o tempo de execução, pelo que o resultado de uma incompatibilidade de tipos de propriedade do tipo de valor predefinido é um erro de tempo de execução.       O valor <xref:System.Windows.DependencyProperty.UnsetValue>têm um significado especial no sistema de propriedade e não pode ser utilizado como um valor de predefinido da propriedade de dependência.</xref:System.Windows.DependencyProperty.UnsetValue>"
  example:
  - "The following example calls this constructor signature:  \n  \n [!code-cs[PropertyMetadataAPIs#Initfpm](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#initfpm)]  \n[!code-cs[PropertyMetadataAPIs#FPMCtor3param](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#fpmctor3param)]"
  syntax:
    content: public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);
    parameters:
    - id: defaultValue
      type: System.Object
      description: "O valor predefinido da propriedade de dependência, geralmente, fornecido como um tipo específico."
    - id: propertyChangedCallback
      type: System.Windows.PropertyChangedCallback
      description: "Uma referência a uma implementação de processador que o sistema de propriedade irá chamar sempre que o valor efetivo da propriedade é alterado."
    - id: coerceValueCallback
      type: System.Windows.CoerceValueCallback
      description: "Uma referência a uma implementação de processador que será chamada sempre que o sistema de propriedade chama <xref:System.Windows.DependencyObject.CoerceValue*>para esta propriedade de dependência.</xref:System.Windows.DependencyObject.CoerceValue*>"
  overload: System.Windows.FrameworkPropertyMetadata.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>defaultValue</code>está definido como <xref href=&quot;System.Windows.DependencyProperty.UnsetValue&quot;> </xref>; Consulte observações."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)
  id: '#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)'
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Windows.FrameworkPropertyMetadata&quot;> </xref> classe com o valor predefinido fornecido e opções de metadados do framework e chamadas de retorno especificadas."
  remarks: "O tipo do valor fornecido para `defaultValue` tem de corresponder ou ser relacionados com o tipo especificado no registo original da propriedade de dependência que estes metadados serão aplicados a. Correspondência entre o tipo de valor predefinido de metadados e o tipo da propriedade de dependência que está a ser aplicada para pode ser difícil de depuração, porque o erro de correspondência não é detetável durante a compilação. O sistema de propriedade não avalia o valor Efetivo de uma propriedade até que o tempo de execução, pelo que o resultado de uma incompatibilidade de tipos de propriedade do tipo de valor predefinido é um erro de tempo de execução.       O valor <xref:System.Windows.DependencyProperty.UnsetValue>têm um significado especial no sistema de propriedade e não pode ser utilizado como um valor de predefinido da propriedade de dependência.</xref:System.Windows.DependencyProperty.UnsetValue>       Valores marcado como conjunto de sinalizadores no `flags` parâmetro irá definir o valor de booleano <xref:System.Windows.FrameworkPropertyMetadata>propriedades que corresponde à <xref:System.Windows.FrameworkPropertyMetadataOptions>nome do sinalizador para `true`.</xref:System.Windows.FrameworkPropertyMetadataOptions> </xref:System.Windows.FrameworkPropertyMetadata> Ainda pode alterar os valores das propriedades nos metadados, desde que os metadados ainda não foram aplicados a uma operação do sistema de propriedade específica."
  example:
  - "The following example calls this constructor signature:  \n  \n [!code-cs[PropertyMetadataAPIs#Initfpm](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#initfpm)]  \n[!code-cs[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#fpmctor_dv_fpmo_pcc_cvc)]"
  syntax:
    content: public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);
    parameters:
    - id: defaultValue
      type: System.Object
      description: "O valor predefinido da propriedade de dependência, geralmente, fornecido como um tipo específico."
    - id: flags
      type: System.Windows.FrameworkPropertyMetadataOptions
      description: "Os sinalizadores de opção de metadados (uma combinação de <xref href=&quot;System.Windows.FrameworkPropertyMetadataOptions&quot;> </xref> valores). Estas opções especificar características da propriedade de dependência que interagem com sistemas, tais como o esquema ou enlace de dados."
    - id: propertyChangedCallback
      type: System.Windows.PropertyChangedCallback
      description: "Uma referência a uma implementação de processador que o sistema de propriedade irá chamar sempre que o valor efetivo da propriedade é alterado."
    - id: coerceValueCallback
      type: System.Windows.CoerceValueCallback
      description: "Uma referência a uma implementação de processador que será chamada sempre que o sistema de propriedade chama <xref:System.Windows.DependencyObject.CoerceValue*>em relação a esta propriedade.</xref:System.Windows.DependencyObject.CoerceValue*>"
  overload: System.Windows.FrameworkPropertyMetadata.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>defaultValue</code>está definido como <xref href=&quot;System.Windows.DependencyProperty.UnsetValue&quot;> </xref>; Consulte observações."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)
  id: '#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)'
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Windows.FrameworkPropertyMetadata&quot;> </xref> classe com as opções de metadados de valor e a arquitetura da predefinição fornecido, as chamadas de retorno especificadas e um valor boleano que pode ser utilizado para impedir a animação da propriedade."
  remarks: "O tipo do valor fornecido para `defaultValue` tem de corresponder ou ser relacionados com o tipo especificado no registo original da propriedade de dependência que estes metadados serão aplicados a. Correspondência entre o tipo de valor predefinido de metadados e o tipo da propriedade de dependência que está a ser aplicada para pode ser difícil de depuração, porque o erro de correspondência não é detetável durante a compilação. O sistema de propriedade não avalia o valor Efetivo de uma propriedade até que o tempo de execução, pelo que o resultado de uma incompatibilidade de tipos de propriedade do tipo de valor predefinido é um erro de tempo de execução.       O valor <xref:System.Windows.DependencyProperty.UnsetValue>têm um significado especial no sistema de propriedade e não pode ser utilizado como um valor de predefinido da propriedade de dependência.</xref:System.Windows.DependencyProperty.UnsetValue>       O `isAnimationProhibited` parâmetro define o valor inicial da <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>propriedade declarada pelo base imediata <xref:System.Windows.UIPropertyMetadata>classe.</xref:System.Windows.UIPropertyMetadata> </xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>       Valores marcado como conjunto de sinalizadores no `flags` parâmetro irá definir o valor de booleano <xref:System.Windows.FrameworkPropertyMetadata>propriedades que corresponde à <xref:System.Windows.FrameworkPropertyMetadataOptions>nome do sinalizador para `true`.</xref:System.Windows.FrameworkPropertyMetadataOptions> </xref:System.Windows.FrameworkPropertyMetadata> Ainda pode alterar os valores das propriedades nos metadados, desde que os metadados ainda não foram aplicados a uma operação do sistema de propriedade específica."
  example:
  - "The following example calls this constructor signature:  \n  \n [!code-cs[PropertyMetadataAPIs#Initfpm](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#initfpm)]  \n[!code-cs[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap)]"
  syntax:
    content: public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);
    parameters:
    - id: defaultValue
      type: System.Object
      description: "O valor predefinido da propriedade de dependência, geralmente, fornecido como um tipo específico."
    - id: flags
      type: System.Windows.FrameworkPropertyMetadataOptions
      description: "Os sinalizadores de opção de metadados (uma combinação de <xref href=&quot;System.Windows.FrameworkPropertyMetadataOptions&quot;> </xref> valores). Estas opções especificar características da propriedade de dependência que interagem com sistemas, tais como o esquema ou enlace de dados."
    - id: propertyChangedCallback
      type: System.Windows.PropertyChangedCallback
      description: "Uma referência a uma implementação de processador que o sistema de propriedade irá chamar sempre que o valor efetivo da propriedade é alterado."
    - id: coerceValueCallback
      type: System.Windows.CoerceValueCallback
      description: "Uma referência a uma implementação de processador que será chamada sempre que o sistema de propriedade chama <xref:System.Windows.DependencyObject.CoerceValue*>Esta propriedade de dependência.</xref:System.Windows.DependencyObject.CoerceValue*>"
    - id: isAnimationProhibited
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Para impedir que o sistema de propriedade animating a propriedade que estes metadados é aplicado. Propriedades irão emitir uma exceção de tempo de execução provenientes do sistema de propriedade se animações deles estão tentadas. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>para permitir animating a propriedade. A predefinição é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkPropertyMetadata.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>defaultValue</code>está definido como <xref href=&quot;System.Windows.DependencyProperty.UnsetValue&quot;> </xref>; Consulte observações."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)
  id: '#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)'
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean,UpdateSourceTrigger)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean,UpdateSourceTrigger)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean,UpdateSourceTrigger)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Windows.FrameworkPropertyMetadata&quot;> </xref> opções de classe com os metadados de valor e a arquitetura de predefinido fornecido, as chamadas de retorno especificadas, um valor boleano que pode ser utilizado para impedir a animação da propriedade e uma predefinição de Acionador de atualização de enlace de dados."
  remarks: "O tipo do valor fornecido para `defaultValue` tem de corresponder ou ser relacionados com o tipo especificado no registo original da propriedade de dependência que estes metadados serão aplicados a. Correspondência entre o tipo de valor predefinido de metadados e o tipo da propriedade de dependência que está a ser aplicada para pode ser difícil de depuração, porque o erro de correspondência não é detetável durante a compilação. O sistema de propriedade não avalia o valor Efetivo de uma propriedade até que o tempo de execução, pelo que o resultado de uma incompatibilidade de tipos de propriedade do tipo de valor predefinido é um erro de tempo de execução.       O valor <xref:System.Windows.DependencyProperty.UnsetValue>têm um significado especial no sistema de propriedade e não pode ser utilizado como um valor de predefinido da propriedade de dependência.</xref:System.Windows.DependencyProperty.UnsetValue>       O `isAnimationProhibited` parâmetro define o valor inicial da <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>propriedade declarada pelo base imediata <xref:System.Windows.UIPropertyMetadata>classe.</xref:System.Windows.UIPropertyMetadata> </xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>       Para mais informações sobre o comportamento de origem de atualização para enlaces, consulte [descrição geral de enlace de dados](~/add/includes/ajax-current-ext-md.md).       Valores marcado como conjunto de sinalizadores no `flags` parâmetro irá definir o valor de booleano <xref:System.Windows.FrameworkPropertyMetadata>propriedades que corresponde à <xref:System.Windows.FrameworkPropertyMetadataOptions>nome do sinalizador para `true`.</xref:System.Windows.FrameworkPropertyMetadataOptions> </xref:System.Windows.FrameworkPropertyMetadata> Ainda pode alterar os valores das propriedades nos metadados, desde que os metadados ainda não foram aplicados a uma operação do sistema de propriedade específica."
  example:
  - "[!code-cs[PropertyMetadataAPIs#Initfpm](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#initfpm)]  \n[!code-cs[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP_DUST](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap_dust)]"
  syntax:
    content: public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger);
    parameters:
    - id: defaultValue
      type: System.Object
      description: "O valor predefinido da propriedade de dependência, geralmente, fornecido como um tipo específico."
    - id: flags
      type: System.Windows.FrameworkPropertyMetadataOptions
      description: "Os sinalizadores de opção de metadados (uma combinação de <xref href=&quot;System.Windows.FrameworkPropertyMetadataOptions&quot;> </xref> valores). Estas opções especificar características da propriedade de dependência que interagem com sistemas, tais como o esquema ou enlace de dados."
    - id: propertyChangedCallback
      type: System.Windows.PropertyChangedCallback
      description: "Uma referência a uma implementação de processador que o sistema de propriedade irá chamar sempre que o valor efetivo da propriedade é alterado."
    - id: coerceValueCallback
      type: System.Windows.CoerceValueCallback
      description: "Uma referência a uma implementação de processador que será chamada sempre que o sistema de propriedade chama <xref:System.Windows.DependencyObject.CoerceValue*>em relação a esta propriedade.</xref:System.Windows.DependencyObject.CoerceValue*>"
    - id: isAnimationProhibited
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Para impedir que o sistema de propriedade animating a propriedade que estes metadados é aplicado. Propriedades irão emitir uma exceção de tempo de execução provenientes do sistema de propriedade se animações deles estão tentadas. A predefinição é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    - id: defaultUpdateSourceTrigger
      type: System.Windows.Data.UpdateSourceTrigger
      description: "O <xref href=&quot;System.Windows.Data.UpdateSourceTrigger&quot;> </xref> a utilizar quando enlaces para esta propriedade são aplicados com os respetivos <xref href=&quot;System.Windows.Data.UpdateSourceTrigger&quot;> </xref> definido como <xref href=&quot;System.Windows.Data.UpdateSourceTrigger&quot;> </xref>."
  overload: System.Windows.FrameworkPropertyMetadata.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>defaultValue</code>está definido como <xref href=&quot;System.Windows.DependencyProperty.UnsetValue&quot;> </xref>; Consulte observações."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.AffectsArrange
  id: AffectsArrange
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: AffectsArrange
  nameWithType: FrameworkPropertyMetadata.AffectsArrange
  fullName: System.Windows.FrameworkPropertyMetadata.AffectsArrange
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define um valor que indica se uma propriedade de dependência afetará potencialmente a passagem de dispor durante as operações de motor de esquema."
  remarks: "<xref:System.Windows.FrameworkElement>e <xref:System.Windows.FrameworkContentElement>incluem uma implementação de <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>que monitoriza o valor Efetivo as alterações a todas as propriedades de dependência que existe um elemento.</xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> </xref:System.Windows.FrameworkContentElement></xref:System.Windows.FrameworkElement> Como parte dessa lógica, propriedades de dependência que altere o valor Efetivo e possui os metadados de AffectsArrange defina `true` irá iniciar um pedido diferido para invalidar visuais para esse elemento (uma chamada para <xref:System.Windows.UIElement.InvalidateArrange%2A>).</xref:System.Windows.UIElement.InvalidateArrange%2A> Porque esta implementação de nível de framework WPF já se encontra no local, normalmente, não tem de procurar propriedades de dependência com AffectsArrange, a menos que são substancialmente substituir ou modificar o comportamento de esquema ao nível do framework WPF.       Personalizada <xref:System.Windows.DependencyObject.OnPropertyChanged%2A>implementações poderão optar por têm comportamento semelhante para as alterações de propriedade de dependência onde é AffectsArrange `true`.</xref:System.Windows.DependencyObject.OnPropertyChanged%2A>       As propriedades de classes derivadas de <xref:System.Windows.PropertyMetadata>são definidas habitualmente no modelo de objeto, como leitura / escrita.</xref:System.Windows.PropertyMetadata> Isto é, de modo pode ser ajustados após a inicialização da instância. No entanto, depois dos metadados é consumido como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedade irá selar essa instância de metadados e as propriedades que transmitir as especificações dos metadados são agora consideradas imutáveis.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> Tentativa de definir esta propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A>é `true` nestes metadados instância irá gerar uma exceção.</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_AffectsArrange&quot;></a># # Os membros de utilização de texto XAML desta classe: são não normalmente utilizados nas [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]."
  example:
  - "The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a \"metadata browser\".  \n  \n [!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  \n[!code-cs[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#fpmproperties)]\n[!code-vb[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]"
  syntax:
    content: public bool AffectsArrange { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a propriedade de dependência no qual estes metadados existe potencialmente afetar a passagem de dispor; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. A predefinição é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkPropertyMetadata.AffectsArrange*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Os metadados já foi aplicado a uma operação de propriedade de dependência, para que os metadados está selado e não não possível definir propriedades de metadados."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.AffectsMeasure
  id: AffectsMeasure
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: AffectsMeasure
  nameWithType: FrameworkPropertyMetadata.AffectsMeasure
  fullName: System.Windows.FrameworkPropertyMetadata.AffectsMeasure
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define um valor que indica se uma propriedade de dependência afetará potencialmente a passagem de medidas durante as operações de motor de esquema."
  remarks: "<xref:System.Windows.FrameworkElement>e <xref:System.Windows.FrameworkContentElement>incluem uma implementação de <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>que monitoriza o valor Efetivo as alterações a todas as propriedades de dependência que existe um elemento.</xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> </xref:System.Windows.FrameworkContentElement></xref:System.Windows.FrameworkElement> Como parte dessa lógica, as propriedades de dependência que altere o valor Efetivo e possui os metadados de AffectsMeasure definidas como `true` irá iniciar um pedido diferido para invalidar visuais para esse elemento. Porque esta implementação de nível de framework WPF já se encontra no local, normalmente, não tem de procurar propriedades de dependência com AffectsMeasure, a menos que são substancialmente substituir ou modificar o comportamento de esquema ao nível do framework WPF.       Personalizada <xref:System.Windows.DependencyObject.OnPropertyChanged%2A>implementações poderão optar por têm comportamento semelhante para as alterações de propriedade de dependência onde é AffectsMeasure `true`.</xref:System.Windows.DependencyObject.OnPropertyChanged%2A>       As propriedades de classes derivadas de <xref:System.Windows.PropertyMetadata>são definidas habitualmente no modelo de objeto, como leitura / escrita.</xref:System.Windows.PropertyMetadata> Isto é, de modo pode ser ajustados após a inicialização da instância. No entanto, depois dos metadados é consumido como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedade irá selar essa instância de metadados e as propriedades que transmitir as especificações dos metadados são agora consideradas imutáveis.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> Tentativa de definir esta propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A>é `true` nestes metadados instância irá gerar uma exceção.</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_AffectsMeasure&quot;></a># # Os membros de utilização de texto XAML desta classe não são normalmente utilizados nas [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]."
  example:
  - "The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a \"metadata browser\".  \n  \n [!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  \n[!code-cs[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#fpmproperties)]\n[!code-vb[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]"
  syntax:
    content: public bool AffectsMeasure { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a propriedade de dependência no qual estes metadados existe potencialmente afetar a passagem de medida; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. A predefinição é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkPropertyMetadata.AffectsMeasure*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Os metadados já foi aplicado a uma operação de propriedade de dependência, para que os metadados está selado e não não possível definir propriedades de metadados."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.AffectsParentArrange
  id: AffectsParentArrange
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: AffectsParentArrange
  nameWithType: FrameworkPropertyMetadata.AffectsParentArrange
  fullName: System.Windows.FrameworkPropertyMetadata.AffectsParentArrange
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define um valor que indica se uma propriedade de dependência afetará potencialmente a passagem de dispor de esquema do respetivo elemento principal durante as operações de motor de esquema."
  remarks: "<xref:System.Windows.FrameworkElement>e <xref:System.Windows.FrameworkContentElement>incluem uma implementação de <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>que monitoriza o valor Efetivo as alterações a todas as propriedades de dependência que existe um elemento.</xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> </xref:System.Windows.FrameworkContentElement></xref:System.Windows.FrameworkElement> Como parte dessa lógica, propriedades de dependência que altere o valor Efetivo e possui os metadados de AffectsParentArrange defina `true` irá iniciar um pedido diferido para invalidar visuais para o elemento principal.       Geralmente, não terá das alterações de relatório de um <xref:System.Windows.FrameworkElement>propriedade para um elemento principal utilizando AffectsParentArrange porque o próprio elemento seria já ter o seu próprio <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>como `true`.</xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> </xref:System.Windows.FrameworkElement> Que é normalmente suficiente, porque as alterações no elemento subordinado, geralmente, inicie um elemento principal dispor quando for adequado. AffectsParentArrange, por vezes, é utilizado para um <xref:System.Windows.FrameworkContentElement>derivados de classe.</xref:System.Windows.FrameworkContentElement> Neste caso, os conjuntos de elemento subordinado uma propriedade, mas a <xref:System.Windows.FrameworkContentElement>classe derivada não controla a suas próprias composição.</xref:System.Windows.FrameworkContentElement> A composição é processada por um <xref:System.Windows.FrameworkElement>elemento principal que funciona como o anfitrião de conteúdos.</xref:System.Windows.FrameworkElement> Por exemplo, uma alteração no valor da <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=fullName>propriedade anexada por um elemento subordinado invalida dispor de principal, porque a posição do subordinadas em principal tem de ser alterada.</xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=fullName> Por conseguinte, o <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=fullName>propriedade anexada tem metadados em que é AffectsParentArrange `true`.</xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=fullName> Outro exemplo é <xref:System.Windows.Controls.Control.Padding%2A>; Quando esta propriedade é alterado, o principal pode mudar o posicionamento dos subordinados, consoante o espaço disponível.</xref:System.Windows.Controls.Control.Padding%2A>       Porque esta implementação de nível de framework WPF já se encontra no local, normalmente, não tem de procurar propriedades de dependência com AffectsParentArrange, a menos que são substancialmente substituir ou modificar o comportamento de esquema ao nível do framework WPF.       Personalizada <xref:System.Windows.DependencyObject.OnPropertyChanged%2A>implementações poderão optar por têm comportamento semelhante para as alterações de propriedade de dependência onde é AffectsParentArrange `true`.</xref:System.Windows.DependencyObject.OnPropertyChanged%2A>       Propriedades em qualquer derivam classes de <xref:System.Windows.PropertyMetadata>são definidas habitualmente no modelo de objeto, como leitura / escrita.</xref:System.Windows.PropertyMetadata> Isto é, de modo pode ser ajustados após a inicialização da instância. No entanto, depois dos metadados é consumido como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedade irá selar essa instância de metadados e as propriedades que transmitir as especificações dos metadados são agora consideradas imutáveis.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> Tentativa de definir esta propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A>é `true` nestes metadados instância irá gerar uma exceção.</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_AffectsParentArrange&quot;></a># # Os membros de utilização de texto XAML desta classe não são normalmente utilizados nas [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]."
  syntax:
    content: public bool AffectsParentArrange { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a propriedade de dependência no qual estes metadados existe potencialmente afetar a passagem de dispor especificamente no respetivo elemento principal; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. A predefinição é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkPropertyMetadata.AffectsParentArrange*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Os metadados já foi aplicado a uma operação de propriedade de dependência, para que os metadados está selado e não não possível definir propriedades de metadados."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure
  id: AffectsParentMeasure
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: AffectsParentMeasure
  nameWithType: FrameworkPropertyMetadata.AffectsParentMeasure
  fullName: System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define um valor que indica se uma propriedade de dependência afetará potencialmente a passagem de medida do esquema do respetivo elemento principal do durante as operações de motor de esquema."
  remarks: "<xref:System.Windows.FrameworkElement>e <xref:System.Windows.FrameworkContentElement>incluem uma implementação de <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>que monitoriza o valor Efetivo as alterações a todas as propriedades de dependência que existe um elemento.</xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> </xref:System.Windows.FrameworkContentElement></xref:System.Windows.FrameworkElement> Como parte dessa lógica, as propriedades de dependência que altere o valor Efetivo e possui os metadados de AffectsParentMeasure definidas como `true` irá iniciar um pedido diferido para invalidar visuais para o elemento principal. Porque esta implementação de nível de framework WPF já se encontra no local, normalmente, não tem de procurar propriedades de dependência com AffectsParentMeasure, a menos que são substancialmente substituir ou modificar o comportamento de esquema ao nível do framework WPF.       Geralmente, não terá das alterações de relatório de um <xref:System.Windows.FrameworkElement>propriedade para um elemento principal utilizando AffectsParentMeasure porque o próprio elemento seria já ter o seu próprio <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>como `true`.</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement> Que é normalmente suficiente, porque as alterações no elemento subordinado iniciar normalmente uma passagem de medidas principal quando for adequado. AffectsParentMeasure, por vezes, é utilizado para um <xref:System.Windows.FrameworkContentElement>derivados de classe.</xref:System.Windows.FrameworkContentElement> Neste caso, os conjuntos de elemento subordinado uma propriedade, mas a <xref:System.Windows.FrameworkContentElement>classe derivada não controla a suas próprias composição.</xref:System.Windows.FrameworkContentElement> A composição é processada por um <xref:System.Windows.FrameworkElement>elemento principal que funciona como o anfitrião de conteúdos.</xref:System.Windows.FrameworkElement> Por exemplo, uma alteração no valor da <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=fullName>propriedade por um elemento subordinado invalida medidas de principal, porque o espaçamento relativo de parágrafos poderá alterar e pode aumentar ou diminuir o tamanho de anfitrião de conteúdos.</xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=fullName> Por conseguinte, o <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=fullName>propriedade tem metadados em que é AffectsParentMeasure `true`.</xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=fullName>       Elementos de anfitrião de conteúdos também frequentemente procurarem alterações efetuadas nas propriedades de dependência onde é AffectsParentMeasure `true`, como parte da lógica de composição de anfitrião de conteúdos. Por exemplo, o <xref:System.Windows.Controls.TextBox>elemento tem de responder para determinadas alterações dentro do texto que pode exigir que a caixa delimitadora do <xref:System.Windows.Controls.TextBox>próprio ser alterada.</xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.TextBox>       Personalizada <xref:System.Windows.DependencyObject.OnPropertyChanged%2A>implementações poderão optar por têm comportamento semelhante para as alterações de propriedade de dependência onde é AffectsParentMeasure `true`.</xref:System.Windows.DependencyObject.OnPropertyChanged%2A>       Propriedades em qualquer derivam classes de <xref:System.Windows.PropertyMetadata>são definidas habitualmente no modelo de objeto, como leitura / escrita.</xref:System.Windows.PropertyMetadata> Isto é, de modo pode ser ajustados após a inicialização da instância. No entanto, depois dos metadados é consumido como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedade irá selar essa instância de metadados e as propriedades que transmitir as especificações dos metadados são agora consideradas imutáveis.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> Tentativa de definir esta propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A>é `true` nestes metadados instância irá gerar uma exceção.</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_AffectsParentMeasure&quot;></a># # Os membros de utilização de texto XAML desta classe não são normalmente utilizados nas [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]."
  syntax:
    content: public bool AffectsParentMeasure { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a propriedade de dependência no qual estes metadados existe potencialmente afetar a passagem de medida especificamente no respetivo elemento principal; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. A predefinição é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Os metadados já foi aplicado a uma operação de propriedade de dependência, para que os metadados está selado e não não possível definir propriedades de metadados."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.AffectsRender
  id: AffectsRender
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: AffectsRender
  nameWithType: FrameworkPropertyMetadata.AffectsRender
  fullName: System.Windows.FrameworkPropertyMetadata.AffectsRender
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define um valor que indica se uma propriedade de dependência potencialmente afeta o esquema geral de alguma forma que não especificamente influenciar disposição ou medida, mas iria exigir uma redesenhar."
  remarks: "<xref:System.Windows.FrameworkElement>e <xref:System.Windows.FrameworkContentElement>incluem uma implementação de <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>que monitoriza o valor Efetivo as alterações a todas as propriedades de dependência que existe um elemento.</xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> </xref:System.Windows.FrameworkContentElement></xref:System.Windows.FrameworkElement> Como parte dessa lógica, as propriedades de dependência que altere o valor Efetivo e possui os metadados de AffectsRender definidas como `true` irá iniciar um pedido diferido para invalidar visuais para esse elemento. Porque esta implementação de nível de framework WPF já se encontra no local, normalmente, não tem de procurar propriedades de dependência com AffectsRender, a menos que são substancialmente substituir ou modificar o comportamento de esquema ao nível do framework WPF.       Personalizada <xref:System.Windows.DependencyObject.OnPropertyChanged%2A>implementações poderão optar por têm comportamento semelhante para as alterações de propriedade de dependência onde é AffectsRender `true`.</xref:System.Windows.DependencyObject.OnPropertyChanged%2A>       Propriedades em qualquer derivam classes de <xref:System.Windows.PropertyMetadata>são definidas habitualmente no modelo de objeto, como leitura / escrita.</xref:System.Windows.PropertyMetadata> Isto é, de modo pode ser ajustados após a inicialização da instância. No entanto, depois dos metadados é consumido como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedade irá selar essa instância de metadados e as propriedades que transmitir as especificações dos metadados são agora consideradas imutáveis.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> Tentativa de definir esta propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A>é `true` nestes metadados instância irá gerar uma exceção.</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_AffectsRender&quot;></a># # Os membros de utilização de texto XAML desta classe não são normalmente utilizados nas [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]."
  example:
  - "The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a \"metadata browser\".  \n  \n [!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  \n[!code-cs[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#fpmproperties)]\n[!code-vb[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]"
  syntax:
    content: public bool AffectsRender { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a propriedade de dependência no qual existe este metadados afeta composição; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. A predefinição é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkPropertyMetadata.AffectsRender*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Os metadados já foi aplicado a uma operação de propriedade de dependência, para que os metadados está selado e não não possível definir propriedades de metadados."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault
  id: BindsTwoWayByDefault
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: BindsTwoWayByDefault
  nameWithType: FrameworkPropertyMetadata.BindsTwoWayByDefault
  fullName: System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define um valor que indica se a propriedade tem um enlace bidirecional por predefinição."
  remarks: "Na ausência deste ser propriedade `true`, as atualizações de enlace estão unidirecionais por predefinição, com base no comportamento predefinido do <xref:System.Windows.Data.Binding>construtores ou equivalente [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] sintaxe.</xref:System.Windows.Data.Binding>       No elementos existentes, normalmente, irá encontrar esta propriedade definida como `true` dos metadados de propriedades de dependência que comunicar o estado e são modificável através da ação do utilizador, por exemplo <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=fullName>.</xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=fullName>       Esta propriedade é somente as características de atualização de enlace predefinido da propriedade de dependência em geral. Nenhum enlace de definir esta propriedade numa instância localmente pode definir o <xref:System.Windows.Data.Binding.Mode%2A>propriedade do enlace e alterar esta predefinição.</xref:System.Windows.Data.Binding.Mode%2A>       Propriedades em qualquer derivam classes de <xref:System.Windows.PropertyMetadata>são definidas habitualmente no modelo de objeto, como leitura / escrita.</xref:System.Windows.PropertyMetadata> Isto é, de modo pode ser ajustados após a inicialização da instância. No entanto, depois dos metadados é consumido como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedade irá selar essa instância de metadados e as propriedades que transmitir as especificações dos metadados são agora consideradas imutáveis.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> Tentativa de definir esta propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A>é `true` nestes metadados instância irá gerar uma exceção.</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_BindsTwoWayByDefault&quot;></a># # Os membros de utilização de texto XAML desta classe não são normalmente utilizados nas [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]."
  example:
  - "The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a \"metadata browser\".  \n  \n [!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  \n[!code-cs[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#fpmproperties)]\n[!code-vb[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]"
  syntax:
    content: public bool BindsTwoWayByDefault { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a propriedade de dependência no qual existe este metadados vincula bidirecional por predefinição; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. A predefinição é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Os metadados já foi aplicado a uma operação de propriedade de dependência, para que os metadados está selado e não não possível definir propriedades de metadados."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger
  id: DefaultUpdateSourceTrigger
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: DefaultUpdateSourceTrigger
  nameWithType: FrameworkPropertyMetadata.DefaultUpdateSourceTrigger
  fullName: System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define a predefinição para <xref href=&quot;System.Windows.Data.UpdateSourceTrigger&quot;> </xref> para utilizar quando enlaces para a propriedade com estes metadados são aplicados, que tem os respetivos <xref href=&quot;System.Windows.Data.UpdateSourceTrigger&quot;> </xref> definido como <xref href=&quot;System.Windows.Data.UpdateSourceTrigger&quot;> </xref>."
  remarks: "As propriedades de classes derivadas de <xref:System.Windows.PropertyMetadata>são definidas habitualmente no modelo de objeto, como leitura / escrita.</xref:System.Windows.PropertyMetadata> Isto é, de modo pode ser ajustados após a inicialização da instância. No entanto, depois dos metadados é consumido como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedade irá selar essa instância de metadados e as propriedades que transmitir as especificações dos metadados são agora consideradas imutáveis.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> Tentativa de definir esta propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A>é `true` nestes metadados instância irá gerar uma exceção.</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_DefaultUpdateSourceTrigger&quot;></a># # Os membros de utilização de texto XAML desta classe não são normalmente utilizados nas [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]."
  syntax:
    content: public System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger { get; set; }
    return:
      type: System.Windows.Data.UpdateSourceTrigger
      description: "Um valor de enumeração, exceto <xref href=&quot;System.Windows.Data.UpdateSourceTrigger&quot;> </xref>."
  overload: System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Esta propriedade está definida como <xref href=&quot;System.Windows.Data.UpdateSourceTrigger&quot;> </xref>; o valor definido deveria tornar-se a predefinição quando solicitado por enlaces."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Os metadados já foi aplicado a uma operação de propriedade de dependência, para que os metadados está selado e não não possível definir propriedades de metadados."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.Inherits
  id: Inherits
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: Inherits
  nameWithType: FrameworkPropertyMetadata.Inherits
  fullName: System.Windows.FrameworkPropertyMetadata.Inherits
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define um valor que indica se o valor da propriedade de dependência é herdável."
  remarks: "Herança de valor de propriedade é uma funcionalidade do [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] sistema propriedade ao nível do framework WPF, em determinadas propriedades de dependência podem ser localmente definidas num elemento ou perto a raiz de um [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] elemento árvore e, em seguida, ter o respetivo valor herdado por todos os elementos dentro da árvore lógica da elementos subordinados que também tenha essa propriedade. Herança de valor de propriedade não está ativada por predefinição e ativar a ter alguns implicações de desempenho. Para obter mais informações, consulte [herança de valor de propriedade](~/add/includes/ajax-current-ext-md.md).      > [!NOTE] > Apesar de herança de valor de propriedade pode aparecer funcionem em Propriedades de dependência nonattached, o comportamento de herança de uma propriedade nonattached através de determinados departamentos, o objeto de objeto na árvore de tempo de execução é indefinido. Utilize sempre <xref:System.Windows.DependencyProperty.RegisterAttached%2A>para registar de propriedades onde poderá Especifica Inherits nos metadados.</xref:System.Windows.DependencyProperty.RegisterAttached%2A>       As propriedades de classes derivadas de <xref:System.Windows.PropertyMetadata>são definidas habitualmente no modelo de objeto, como leitura / escrita.</xref:System.Windows.PropertyMetadata> Isto é, de modo pode ser ajustados após a inicialização da instância. No entanto, depois dos metadados é consumido como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedade irá selar essa instância de metadados e as propriedades que transmitir as especificações dos metadados são agora consideradas imutáveis.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> Tentativa de definir esta propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A>é `true` nestes metadados instância irá gerar uma exceção.</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_Inherits&quot;></a># # Os membros de utilização de texto XAML desta classe não são normalmente utilizados nas [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]."
  example:
  - "The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a \"metadata browser\".  \n  \n [!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  \n[!code-cs[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#fpmproperties)]\n[!code-vb[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]"
  syntax:
    content: public bool Inherits { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o valor da propriedade ser herdável; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. A predefinição é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkPropertyMetadata.Inherits*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Os metadados já foi aplicado a uma operação de propriedade de dependência, para que os metadados está selado e não não possível definir propriedades de metadados."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed
  id: IsDataBindingAllowed
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: IsDataBindingAllowed
  nameWithType: FrameworkPropertyMetadata.IsDataBindingAllowed
  fullName: System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém um valor que indica se o enlace de dados é suportado para a propriedade de dependência."
  remarks: "Esta propriedade relatórios `false` para uma das duas condições possíveis: o enlace de dados para uma propriedade de dependência não é permitido porque a propriedade de dependência é só de leitura (como comunicado no identificador de propriedade de dependência, não os metadados), ou o valor da propriedade de metadados outro, <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>, está definida como `true` nestes metadados.</xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> Esta propriedade está exposta para efeitos práticos, para que os chamadores não é necessário que verificar os dois <xref:System.Windows.DependencyProperty.ReadOnly%2A>e <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>.</xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> </xref:System.Windows.DependencyProperty.ReadOnly%2A>       Se está a tentar criar metadados que especifica a que uma propriedade de leitura/escrita, caso contrário não deve suportar o enlace de dados, especifique o sinalizador <xref:System.Windows.FrameworkPropertyMetadataOptions>(tenha em atenção a diferença de convenção nomenclatura ligeiras versus <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>).</xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> </xref:System.Windows.FrameworkPropertyMetadataOptions>      <a name=&quot;xamlTextUsage_IsDataBindingAllowed&quot;></a># # Os membros de utilização de texto XAML desta classe não são normalmente utilizados nas [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]."
  example:
  - "The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a \"metadata browser\".  \n  \n [!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  \n[!code-cs[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#fpmproperties)]\n[!code-vb[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]"
  syntax:
    content: public bool IsDataBindingAllowed { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o enlace de dados é suportado a propriedade de dependência aos quais se aplica estes metadados; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. A predefinição é <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.IsNotDataBindable
  id: IsNotDataBindable
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: IsNotDataBindable
  nameWithType: FrameworkPropertyMetadata.IsNotDataBindable
  fullName: System.Windows.FrameworkPropertyMetadata.IsNotDataBindable
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define um valor que indica se a propriedade de dependência suporta o enlace de dados."
  remarks: "Tenha em atenção que esta propriedade de metadados está definida como `true` especificamente para propriedades que não devem suportar o enlace de dados, apesar da propriedades de leitura e escrita. As expectativas são de que na maioria dos casos onde uma propriedade de dependência é declarada, enlace de dados, se pretendido, porque o enlace de dados é um dos principais cenários em que uma propriedade de dependência é útil. Ao contrário <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>, isso não altera simplesmente um predefinido que pode ser alterado posteriormente num enlace específico.</xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A> Definir esta propriedade `true` dos metadados de uma propriedade de dependência metadados irão desativar a todos os enlaces de aplicar os respetivos valores através de expressões a essa propriedade de dependência.       Propriedades de dependência só de leitura não suportam enlace de dados (porque não têm nenhum setter que pode aplicar-se valores alterados), mas ainda será relatório `false` para IsNotDataBindable. Isto acontece porque as propriedades que correspondem a uma <xref:System.Windows.FrameworkPropertyMetadataOptions>valores comunicará paridade com como metadados foi realmente estabelecido, em vez de relatórios sempre o comportamento de resultado de fim da propriedade de nomenclatura poderá implica.</xref:System.Windows.FrameworkPropertyMetadataOptions> Para determinar se uma propriedade de dependência fornecida permite o enlace de dados, normalmente, deve verificar <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A>em vez disso.</xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A>está para efeitos práticos para a verificação de ambos <xref:System.Windows.DependencyProperty.ReadOnly%2A>e IsNotDataBindable como uma única operação, a gerar resultados o resultado esperado.</xref:System.Windows.DependencyProperty.ReadOnly%2A></xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A>       As propriedades de classes derivadas de <xref:System.Windows.PropertyMetadata>são definidas habitualmente no modelo de objeto, como leitura / escrita.</xref:System.Windows.PropertyMetadata> Isto é, de modo pode ser ajustados após a inicialização da instância. No entanto, depois dos metadados é consumido como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedade irá selar essa instância de metadados e as propriedades que transmitir as especificações dos metadados são agora consideradas imutáveis.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> Tentativa de definir esta propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A>é `true` nestes metadados instância irá gerar uma exceção.</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_IsNotDataBindable&quot;></a># # Os membros de utilização de texto XAML desta classe não são normalmente utilizados nas [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]."
  syntax:
    content: public bool IsNotDataBindable { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a propriedade não suporta o enlace de dados caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. A predefinição é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkPropertyMetadata.IsNotDataBindable*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Os metadados já foi aplicado a uma operação de propriedade de dependência, para que os metadados está selado e não não possível definir propriedades de metadados."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.Journal
  id: Journal
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: Journal
  nameWithType: FrameworkPropertyMetadata.Journal
  fullName: System.Windows.FrameworkPropertyMetadata.Journal
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define um valor que indica se esta propriedade contém informações de registo em diário que as aplicações podem ou devem armazenar como parte de uma implementação de registo em diário."
  remarks: "As propriedades de classes derivadas de <xref:System.Windows.PropertyMetadata>são definidas habitualmente no modelo de objeto, como leitura / escrita.</xref:System.Windows.PropertyMetadata> Isto é, de modo pode ser ajustados após a inicialização da instância. No entanto, depois dos metadados é consumido como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedade irá selar essa instância de metadados e as propriedades que transmitir as especificações dos metadados são agora consideradas imutáveis.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> Tentativa de definir esta propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A>é `true` nestes metadados instância irá gerar uma exceção.</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_Journal&quot;></a># # Os membros de utilização de texto XAML desta classe não são normalmente utilizados nas [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]."
  syntax:
    content: public bool Journal { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o registo em diário deve ser efetuado na propriedade de dependência que estes metadados é aplicado a; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. A predefinição é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkPropertyMetadata.Journal*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Os metadados já foi aplicado a uma operação de propriedade de dependência, para que os metadados está selado e não não possível definir propriedades de metadados."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)
  id: Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: Merge(PropertyMetadata,DependencyProperty)
  nameWithType: FrameworkPropertyMetadata.Merge(PropertyMetadata,DependencyProperty)
  fullName: System.Windows.FrameworkPropertyMetadata.Merge(PropertyMetadata,DependencyProperty)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Permite uma intercalação dos metadados de origem com os metadados base."
  remarks: "Este método é utilizado internamente quando está a ser substituído metadados."
  syntax:
    content: protected override void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);
    parameters:
    - id: baseMetadata
      type: System.Windows.PropertyMetadata
      description: "Os metadados base para intercalação."
    - id: dp
      type: System.Windows.DependencyProperty
      description: "A propriedade de dependência que estes metadados estão a ser aplicado."
  overload: System.Windows.FrameworkPropertyMetadata.Merge*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)
  id: OnApply(System.Windows.DependencyProperty,System.Type)
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: OnApply(DependencyProperty,Type)
  nameWithType: FrameworkPropertyMetadata.OnApply(DependencyProperty,Type)
  fullName: System.Windows.FrameworkPropertyMetadata.OnApply(DependencyProperty,Type)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Chamado quando estes metadados tem sido aplicado a uma propriedade, o que indica que está a ser selado os metadados."
  remarks: "Qualquer mutability da estrutura de dados de um <xref:System.Windows.FrameworkPropertyMetadata>instância deverá ser marcada como imutável quando este método é invocado.</xref:System.Windows.FrameworkPropertyMetadata>"
  syntax:
    content: protected override void OnApply (System.Windows.DependencyProperty dp, Type targetType);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "A propriedade de dependência para o qual os metadados foi aplicado."
    - id: targetType
      type: System.Type
      description: "O tipo associado estes metadados se se tratar de metadados específicos do tipo. Se se tratar de metadados da predefinição, este valor pode ser <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkPropertyMetadata.OnApply*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior
  id: OverridesInheritanceBehavior
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: OverridesInheritanceBehavior
  nameWithType: FrameworkPropertyMetadata.OverridesInheritanceBehavior
  fullName: System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define um valor que indica se a avaliação de herança de valor de propriedade deve abranger através de determinados limites de conteúdo na árvore lógica de elementos."
  remarks: "Estes metadados relatórios uma modificação raramente aplicada ao comportamento de herança de valor de propriedade nos limites da elemento subordinado do elemento principal especial. O exemplo canónico de um limite esse é o conteúdo de um <xref:System.Windows.Controls.Frame>, onde o <xref:System.Windows.Controls.Frame>conteúdo poderá obter recarregado independentemente a existência de <xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Controls.Frame> </xref:System.Windows.Controls.Frame> O comportamento do sistema de propriedade pretendido está que herança de valor de propriedade não deverá percorrer para o conteúdo do <xref:System.Windows.Controls.Frame>, porque estes conteúdos poderão ser elementos que a aplicação que aloja a frame não detém ou controla.</xref:System.Windows.Controls.Frame> A especificação de metadados com OverridesInheritanceBehavior definido como `true`, bem como especificação <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>como `true`, fará com que a propriedade no qual os metadados é aplicado a ser herdável mesmo across o <xref:System.Windows.Controls.Frame>limites ou limites semelhantes.</xref:System.Windows.Controls.Frame> </xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>       As propriedades de classes derivadas de <xref:System.Windows.PropertyMetadata>são definidas habitualmente no modelo de objeto, como leitura / escrita.</xref:System.Windows.PropertyMetadata> Isto é, de modo pode ser ajustados após a inicialização da instância. No entanto, depois dos metadados é consumido como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedade irá selar essa instância de metadados e as propriedades que transmitir as especificações dos metadados são agora consideradas imutáveis.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> Tentativa de definir esta propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A>é `true` nestes metadados instância irá gerar uma exceção.</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_OverridesInheritanceBehavior&quot;></a># # Os membros de utilização de texto XAML desta classe não são normalmente utilizados nas [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]."
  syntax:
    content: public bool OverridesInheritanceBehavior { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a herança de valor de propriedade deve abranger através de determinados limites de conteúdo caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. A predefinição é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Os metadados já foi aplicado a uma operação de propriedade de dependência, para que os metadados está selado e não não possível definir propriedades de metadados."
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender
  id: SubPropertiesDoNotAffectRender
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: SubPropertiesDoNotAffectRender
  nameWithType: FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender
  fullName: System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define um valor que indica se as propriedades secundárias da propriedade de dependência não afetam a composição do objeto contentor."
  remarks: "Esta opção de metadados está pertinentes para propriedades de dependência que são tipos de referência, em que esse tipo tem valores de propriedade do seu próprio. Normalmente, a lógica de sistema de esquema é partem do princípio de que qualquer propriedade de dependência com propriedades secundárias potencialmente afetará esquema, porque a verificar se todas as propriedades secundárias para alterações é mais demorada que efetivamente em execução outra compor passagem. Definir esta opção para `true` é útil para otimizar o desempenho da implementação de sistema de nível de esquema do WPF framework.       As propriedades de classes derivadas de <xref:System.Windows.PropertyMetadata>são definidas habitualmente no modelo de objeto, como leitura / escrita.</xref:System.Windows.PropertyMetadata> Isto é, de modo pode ser ajustados após a inicialização da instância. No entanto, depois dos metadados é consumido como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedade irá selar essa instância de metadados e as propriedades que transmitir as especificações dos metadados são agora consideradas imutáveis.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> Tentativa de definir esta propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A>é `true` nestes metadados instância irá gerar uma exceção.</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_SubPropertiesDoNotAffectRender&quot;></a># # Os membros de utilização de texto XAML desta classe não são normalmente utilizados nas [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]."
  syntax:
    content: public bool SubPropertiesDoNotAffectRender { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se as alterações aos valores de propriedade secundárias não afetam a composição se tiver sido alterada; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. A predefinição é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Os metadados já foi aplicado a uma operação de propriedade de dependência, para que os metadados está selado e não não possível definir propriedades de metadados."
  platform:
  - net462
references:
- uid: System.Windows.UIPropertyMetadata
  isExternal: false
  name: System.Windows.UIPropertyMetadata
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Windows.FrameworkPropertyMetadata.#ctor
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata()
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata()
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata()
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata(Object)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata(PropertyChangedCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(PropertyChangedCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(PropertyChangedCallback)
- uid: System.Windows.PropertyChangedCallback
  parent: System.Windows
  isExternal: false
  name: PropertyChangedCallback
  nameWithType: PropertyChangedCallback
  fullName: System.Windows.PropertyChangedCallback
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions)
- uid: System.Windows.FrameworkPropertyMetadataOptions
  parent: System.Windows
  isExternal: false
  name: FrameworkPropertyMetadataOptions
  nameWithType: FrameworkPropertyMetadataOptions
  fullName: System.Windows.FrameworkPropertyMetadataOptions
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata(Object,PropertyChangedCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,PropertyChangedCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,PropertyChangedCallback)
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata(PropertyChangedCallback,CoerceValueCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(PropertyChangedCallback,CoerceValueCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(PropertyChangedCallback,CoerceValueCallback)
- uid: System.Windows.CoerceValueCallback
  parent: System.Windows
  isExternal: false
  name: CoerceValueCallback
  nameWithType: CoerceValueCallback
  fullName: System.Windows.CoerceValueCallback
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback)
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata(Object,PropertyChangedCallback,CoerceValueCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,PropertyChangedCallback,CoerceValueCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,PropertyChangedCallback,CoerceValueCallback)
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback)
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean,UpdateSourceTrigger)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean,UpdateSourceTrigger)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean,UpdateSourceTrigger)
- uid: System.Windows.Data.UpdateSourceTrigger
  parent: System.Windows.Data
  isExternal: false
  name: UpdateSourceTrigger
  nameWithType: UpdateSourceTrigger
  fullName: System.Windows.Data.UpdateSourceTrigger
- uid: System.Windows.FrameworkPropertyMetadata.AffectsArrange
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: AffectsArrange
  nameWithType: FrameworkPropertyMetadata.AffectsArrange
  fullName: System.Windows.FrameworkPropertyMetadata.AffectsArrange
- uid: System.Windows.FrameworkPropertyMetadata.AffectsMeasure
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: AffectsMeasure
  nameWithType: FrameworkPropertyMetadata.AffectsMeasure
  fullName: System.Windows.FrameworkPropertyMetadata.AffectsMeasure
- uid: System.Windows.FrameworkPropertyMetadata.AffectsParentArrange
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: AffectsParentArrange
  nameWithType: FrameworkPropertyMetadata.AffectsParentArrange
  fullName: System.Windows.FrameworkPropertyMetadata.AffectsParentArrange
- uid: System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: AffectsParentMeasure
  nameWithType: FrameworkPropertyMetadata.AffectsParentMeasure
  fullName: System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure
- uid: System.Windows.FrameworkPropertyMetadata.AffectsRender
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: AffectsRender
  nameWithType: FrameworkPropertyMetadata.AffectsRender
  fullName: System.Windows.FrameworkPropertyMetadata.AffectsRender
- uid: System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: BindsTwoWayByDefault
  nameWithType: FrameworkPropertyMetadata.BindsTwoWayByDefault
  fullName: System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault
- uid: System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: DefaultUpdateSourceTrigger
  nameWithType: FrameworkPropertyMetadata.DefaultUpdateSourceTrigger
  fullName: System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger
- uid: System.Windows.FrameworkPropertyMetadata.Inherits
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: Inherits
  nameWithType: FrameworkPropertyMetadata.Inherits
  fullName: System.Windows.FrameworkPropertyMetadata.Inherits
- uid: System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: IsDataBindingAllowed
  nameWithType: FrameworkPropertyMetadata.IsDataBindingAllowed
  fullName: System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed
- uid: System.Windows.FrameworkPropertyMetadata.IsNotDataBindable
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: IsNotDataBindable
  nameWithType: FrameworkPropertyMetadata.IsNotDataBindable
  fullName: System.Windows.FrameworkPropertyMetadata.IsNotDataBindable
- uid: System.Windows.FrameworkPropertyMetadata.Journal
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: Journal
  nameWithType: FrameworkPropertyMetadata.Journal
  fullName: System.Windows.FrameworkPropertyMetadata.Journal
- uid: System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: Merge(PropertyMetadata,DependencyProperty)
  nameWithType: FrameworkPropertyMetadata.Merge(PropertyMetadata,DependencyProperty)
  fullName: System.Windows.FrameworkPropertyMetadata.Merge(PropertyMetadata,DependencyProperty)
- uid: System.Windows.PropertyMetadata
  parent: System.Windows
  isExternal: false
  name: PropertyMetadata
  nameWithType: PropertyMetadata
  fullName: System.Windows.PropertyMetadata
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: OnApply(DependencyProperty,Type)
  nameWithType: FrameworkPropertyMetadata.OnApply(DependencyProperty,Type)
  fullName: System.Windows.FrameworkPropertyMetadata.OnApply(DependencyProperty,Type)
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: OverridesInheritanceBehavior
  nameWithType: FrameworkPropertyMetadata.OverridesInheritanceBehavior
  fullName: System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior
- uid: System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: SubPropertiesDoNotAffectRender
  nameWithType: FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender
  fullName: System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender
- uid: System.Windows.FrameworkPropertyMetadata.#ctor*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata
- uid: System.Windows.FrameworkPropertyMetadata.AffectsArrange*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: AffectsArrange
  nameWithType: FrameworkPropertyMetadata.AffectsArrange
- uid: System.Windows.FrameworkPropertyMetadata.AffectsMeasure*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: AffectsMeasure
  nameWithType: FrameworkPropertyMetadata.AffectsMeasure
- uid: System.Windows.FrameworkPropertyMetadata.AffectsParentArrange*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: AffectsParentArrange
  nameWithType: FrameworkPropertyMetadata.AffectsParentArrange
- uid: System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: AffectsParentMeasure
  nameWithType: FrameworkPropertyMetadata.AffectsParentMeasure
- uid: System.Windows.FrameworkPropertyMetadata.AffectsRender*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: AffectsRender
  nameWithType: FrameworkPropertyMetadata.AffectsRender
- uid: System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: BindsTwoWayByDefault
  nameWithType: FrameworkPropertyMetadata.BindsTwoWayByDefault
- uid: System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: DefaultUpdateSourceTrigger
  nameWithType: FrameworkPropertyMetadata.DefaultUpdateSourceTrigger
- uid: System.Windows.FrameworkPropertyMetadata.Inherits*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: Inherits
  nameWithType: FrameworkPropertyMetadata.Inherits
- uid: System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: IsDataBindingAllowed
  nameWithType: FrameworkPropertyMetadata.IsDataBindingAllowed
- uid: System.Windows.FrameworkPropertyMetadata.IsNotDataBindable*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: IsNotDataBindable
  nameWithType: FrameworkPropertyMetadata.IsNotDataBindable
- uid: System.Windows.FrameworkPropertyMetadata.Journal*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: Journal
  nameWithType: FrameworkPropertyMetadata.Journal
- uid: System.Windows.FrameworkPropertyMetadata.Merge*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: Merge
  nameWithType: FrameworkPropertyMetadata.Merge
- uid: System.Windows.FrameworkPropertyMetadata.OnApply*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: OnApply
  nameWithType: FrameworkPropertyMetadata.OnApply
- uid: System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: OverridesInheritanceBehavior
  nameWithType: FrameworkPropertyMetadata.OverridesInheritanceBehavior
- uid: System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: SubPropertiesDoNotAffectRender
  nameWithType: FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender
