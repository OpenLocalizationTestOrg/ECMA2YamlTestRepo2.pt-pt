### YamlMime:ManagedReference
items:
- uid: System.Windows.CoerceValueCallback
  id: CoerceValueCallback
  langs:
  - csharp
  name: CoerceValueCallback
  nameWithType: CoerceValueCallback
  fullName: System.Windows.CoerceValueCallback
  type: Delegate
  summary: "Fornece um modelo para um método que é chamado sempre que um valor de propriedade de dependência está a ser avaliado novamente, ou adesão especificamente é pedido."
  remarks: "As chamadas de retorno com base no CoerceValueCallback podem ser atribuídas a uma propriedade de dependência através de várias técnicas diferentes. Cada um destes técnicas requer que se crie primeiro um novo objeto de metadados da propriedade (<xref:System.Windows.PropertyMetadata>, ou uma classe derivada, tal como <xref:System.Windows.FrameworkPropertyMetadata>).</xref:System.Windows.FrameworkPropertyMetadata> </xref:System.Windows.PropertyMetadata> Criar o objeto de metadados com uma assinatura de construtor que assume o `coerceValueCallback` parâmetro e atribua esse parâmetro para o processador de chamada de retorno. Ou construir os metadados por qualquer assinatura e defina o <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>propriedade antes de colocar os metadados em utilização.</xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>       Quando tiver estes metadados, pode:-definir uma nova propriedade de dependência numa nova classe, utilizando a assinatura de <xref:System.Windows.DependencyProperty.Register%2A>, concedendo os metadados, como o `typeMetadata` valor.</xref:System.Windows.DependencyProperty.Register%2A>      -Ignorar os metadados (chamar <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>) para uma propriedade de dependência existente, quando deriva da classe que possui a propriedade de dependência.</xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>      -Adicionar uma propriedade de dependência existente para uma nova <xref:System.Windows.DependencyObject>classe, através de metadados de novo, chamando <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>.</xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29> </xref:System.Windows.DependencyObject>       As implementações desta chamada de retorno devem verificar o valor `baseValue` e determinar baseado no valor ou o tipo se este é um valor que tem de ser mais forçada.       O <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>para uma dependência de propriedade é invocada sempre que o sistema de propriedade ou quaisquer outro chamador chama <xref:System.Windows.DependencyObject.CoerceValue%2A>num <xref:System.Windows.DependencyObject>instância, especificar o identificador dessa propriedade como o `dp`.</xref:System.Windows.DependencyObject> </xref:System.Windows.DependencyObject.CoerceValue%2A> </xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>       As alterações para o valor da propriedade podem ter ter qualquer participante possível no sistema de propriedade. Isto inclui os estilos, invalidação genérica, acionadores, herança de valor de propriedade e definição de valor local.       Geralmente, deve evitar a especificação de mais do que um <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>para qualquer fornecido a propriedade de dependência (substituição ou adicionar com novos metadados para uma propriedade de dependência que já tinha um <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>).</xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> </xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> Apenas um das chamadas de retorno poderá funcionar. A chamada de retorno agir será que foi aplicada para a classe mais derivada na herança compared para o <xref:System.Windows.DependencyObject>autor da chamada.</xref:System.Windows.DependencyObject> Outras chamadas de retorno como atribuída aos metadados para a propriedade de dependência como que existia superior na hierarquia de proprietário são substituídas quando os metadados seja substituído."
  example:
  - "The following example includes an implementation of this callback to coerce the stored value of a dependency property based on other inputs, such as another property's value. In this case, the callback checks to see whether the `ShirtType` property corresponds to a type of shirt that has buttons; if so it establishes a starting default color for the `ButtonColor`, if the shirt type has no buttons, it coerces the `ButtonColor` value back to a starting value, which causes the [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] (not shown) to remove that dropdown from the effective choices.  \n  \n [!code-cs[DPCustom#CoerceValueCallback](~/add/codesnippet/csharp/DPCustom/default.xaml.cs#coercevaluecallback)]\n [!code-vb[DPCustom#CoerceValueCallback](~/add/codesnippet/visualbasic/dpcustom/default.xaml.vb#coercevaluecallback)]"
  syntax:
    content: public delegate object CoerceValueCallback(DependencyObject d, object baseValue);
  inheritance:
  - System.Delegate
  platform:
  - net462
references:
- uid: System.Delegate
  isExternal: false
  name: System.Delegate
