### YamlMime:ManagedReference
items:
- uid: System.Net.HttpListener
  id: HttpListener
  children:
  - System.Net.HttpListener.#ctor
  - System.Net.HttpListener.Abort
  - System.Net.HttpListener.AuthenticationSchemes
  - System.Net.HttpListener.AuthenticationSchemeSelectorDelegate
  - System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)
  - System.Net.HttpListener.Close
  - System.Net.HttpListener.DefaultServiceNames
  - System.Net.HttpListener.EndGetContext(System.IAsyncResult)
  - System.Net.HttpListener.ExtendedProtectionPolicy
  - System.Net.HttpListener.ExtendedProtectionSelectorDelegate
  - System.Net.HttpListener.GetContext
  - System.Net.HttpListener.GetContextAsync
  - System.Net.HttpListener.IgnoreWriteExceptions
  - System.Net.HttpListener.IsListening
  - System.Net.HttpListener.IsSupported
  - System.Net.HttpListener.Prefixes
  - System.Net.HttpListener.Realm
  - System.Net.HttpListener.Start
  - System.Net.HttpListener.Stop
  - System.Net.HttpListener.System#IDisposable#Dispose
  - System.Net.HttpListener.TimeoutManager
  - System.Net.HttpListener.UnsafeConnectionNtlmAuthentication
  langs:
  - csharp
  name: HttpListener
  nameWithType: HttpListener
  fullName: System.Net.HttpListener
  type: Class
  summary: "Fornece um simple, através de programação controlado protocolo serviço de escuta HTTP. Esta classe não pode ser herdada."
  remarks: "Using the HttpListener class, you can create a simple HTTP protocol listener that responds to HTTP requests. The listener is active for the lifetime of the HttpListener object and runs within your application with its permissions.  \n  \n> [!NOTE]\n>  This class is available only on computers running the Windows XP SP2 or Windows Server 2003 operating systems. If you attempt to create an HttpListener object on a computer that is running an earlier operating system, the constructor throws a <xref:System.PlatformNotSupportedException> exception.  \n  \n To use HttpListener, create a new instance of the class using the HttpListener constructor and use the <xref:System.Net.HttpListener.Prefixes%2A> property to gain access to the collection that holds the strings that specify which Uniform Resource Identifier (URI) prefixes the HttpListener should process.  \n  \n A URI prefix string is composed of a scheme (http or https), a host, an optional port, and an optional path. An example of a complete prefix string is \"`http://www.contoso.com:8080/customerData``/`\". Prefixes must end in a forward slash (\"/\"). The HttpListener object with the prefix that most closely matches a requested URI responds to the request. Multiple HttpListener objects cannot add the same prefix; a <xref:System.ComponentModel.Win32Exception> exception is thrown if a HttpListener adds a prefix that is already in use.  \n  \n When a port is specified, the host element can be replaced with \"*\" to indicate that the HttpListener accepts requests sent to the port if the requested URI does not match any other prefix. For example, to receive all requests sent to port 8080 when the requested URI is not handled by any HttpListener, the prefix is \"`http://*:8080``/`\". Similarly, to specify that the HttpListener accepts all requests sent to a port, replace the host element with the \"+\" character, \"`https://+:8080`\". The \"\\*\" and \"+\" characters can be present in prefixes that include paths.  \n  \n Starting with .NET 4.5.3 and Windows 10, wildcard subdomains are supported in URI prefixes that are managed by an HttpListener object. To specify a wildcard subdomain, use the \"*\" character as part of the hostname in a URI prefix: for example, `http://*.foo.com/`, and pass this as the argument to the HttpListenerPrefixCollection.Add method. This will work on .NET 4.5.3 and Windows 10; in earlier versions, this would generate an <xref:System.Net.HttpListenerException>  \n  \n To begin listening for requests from clients, add the URI prefixes to the collection and call the <xref:System.Net.HttpListener.Start%2A> method. HttpListener offers both synchronous and asynchronous models for processing client requests. Requests and their associated responses are accessed using the <xref:System.Net.HttpListenerContext> object returned by the <xref:System.Net.HttpListener.GetContext%2A> method or its asynchronous counterparts, the <xref:System.Net.HttpListener.BeginGetContext%2A> and <xref:System.Net.HttpListener.EndGetContext%2A> methods.  \n  \n The synchronous model is appropriate if your application should block while waiting for a client request and if you want to process only one request at a time. Using the synchronous model, call the <xref:System.Net.HttpListener.GetContext%2A> method, which waits for a client to send a request. The method returns an <xref:System.Net.HttpListenerContext> object to you for processing when one occurs.  \n  \n In the more complex asynchronous model, your application does not block while waiting for requests and each request is processed in its own execution thread. Use the <xref:System.Net.HttpListener.BeginGetContext%2A> method to specify an application-defined method to be called for each incoming request. Within that method, call the <xref:System.Net.HttpListener.EndGetContext%2A> method to obtain the request, process it, and respond.  \n  \n In either model, incoming requests are accessed using the <xref:System.Net.HttpListenerContext.Request%2A?displayProperty=fullName> property and are represented by <xref:System.Net.HttpListenerRequest> objects. Similarly, responses are accessed using the <xref:System.Net.HttpListenerContext.Response%2A?displayProperty=fullName> property and are represented by <xref:System.Net.HttpListenerResponse> objects. These objects share some functionality with the <xref:System.Net.HttpWebRequest> and <xref:System.Net.HttpWebResponse> objects, but the latter objects cannot be used in conjunction with HttpListener because they implement client, not server, behaviors.  \n  \n An HttpListener can require client authentication. You can either specify a particular scheme to use for authentication, or you can specify a delegate that determines the scheme to use. You must require some form of authentication to obtain information about the client's identity. For additional information, see the <xref:System.Net.HttpListenerContext.User%2A>, <xref:System.Net.HttpListener.AuthenticationSchemes%2A>, and <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A> properties.  \n  \n> [!NOTE]\n>  If you create an HttpListener using https, you must select a Server Certificate for that listener. Otherwise, an <xref:System.Net.HttpWebRequest> query of this HttpListener will fail with an unexpected close of the connection.  \n  \n> [!NOTE]\n>  You can configure Server Certificates and other listener options by using HttpCfg.exe. See [http://msdn.microsoft.com/library/default.asp?url=/library/en-us/http/http/httpcfg_exe.asp](http://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp) for more details. The executable is shipped with Windows Server 2003, or can be built from source code available in the Platform SDK.  \n  \n> [!NOTE]\n>  If you specify multiple authentication schemes for the HttpListener, the listener will challenge clients in the following order: `Negotiate`, `NTLM`, `Digest`, and then `Basic`."
  example:
  - "The following code example demonstrates using a HttpListener.  \n  \n [!code-cs[Net_Listener_Basic#2](~/add/codesnippet/csharp/t-system.net.httplistener_1.cs)]"
  syntax:
    content: 'public sealed class HttpListener : IDisposable'
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Net.HttpListener.#ctor
  id: '#ctor'
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: HttpListener()
  nameWithType: HttpListener.HttpListener()
  fullName: System.Net.HttpListener.HttpListener()
  type: Constructor
  assemblies:
  - System
  namespace: System.Net
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Net.HttpListener&quot;> </xref> classe."
  remarks: "Antes de utilizar a instância devolvida por este construtor, tem de invocar o <xref:System.Net.HttpListener.Start%2A>método.</xref:System.Net.HttpListener.Start%2A>"
  example:
  - "The following code example demonstrates using the <xref:System.Net.HttpListener> constructor to create a new <xref:System.Net.HttpListener> object. For the complete example, see the <xref:System.Net.HttpListener> class topic.  \n  \n [!code-cs[Net_listener_Basic#9](~/add/codesnippet/csharp/m-system.net.httplistene_20_1.cs)]"
  syntax:
    content: public HttpListener ();
    parameters: []
  overload: System.Net.HttpListener.#ctor*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Esta classe não é possível utilizar o sistema operativo atual. Windows Server 2003 ou Windows XP SP2, é necessário utilizar as instâncias desta classe."
  platform:
  - net462
- uid: System.Net.HttpListener.Abort
  id: Abort
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: Abort()
  nameWithType: HttpListener.Abort()
  fullName: System.Net.HttpListener.Abort()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Encerra o <xref href=&quot;System.Net.HttpListener&quot;> </xref> objeto imediatamente, atualmente a rejeitar todos os pedidos em fila de espera."
  remarks: "Este método disposes de todos os recursos contidos por este serviço de escuta. Quaisquer pedidos pendentes são não foi possível concluir.       Depois de chamar este método, receberá um <xref:System.ObjectDisposedException>se tentar utilizar este <xref:System.Net.HttpListener>.</xref:System.Net.HttpListener> </xref:System.ObjectDisposedException>"
  example:
  - "The following code example demonstrates calling this method.  \n  \n [!code-cs[Net_Listener_Basic#11](~/add/codesnippet/csharp/m-system.net.httplistene_4_1.cs)]"
  syntax:
    content: public void Abort ();
    parameters: []
  overload: System.Net.HttpListener.Abort*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.AuthenticationSchemes
  id: AuthenticationSchemes
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: AuthenticationSchemes
  nameWithType: HttpListener.AuthenticationSchemes
  fullName: System.Net.HttpListener.AuthenticationSchemes
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Obtém ou define o esquema utilizado para autenticar clientes."
  remarks: "O <xref:System.Net.HttpListener>utiliza o esquema especificado para autenticar todos os pedidos recebidos.</xref:System.Net.HttpListener> O <xref:System.Net.HttpListener.GetContext%2A>e <xref:System.Net.HttpListener.EndGetContext%2A>métodos devolvem um pedido de cliente recebidos, apenas se o <xref:System.Net.HttpListener>consiga autenticar o pedido.</xref:System.Net.HttpListener> </xref:System.Net.HttpListener.EndGetContext%2A> </xref:System.Net.HttpListener.GetContext%2A>       Pode interrogate a identidade de um cliente autenticado com êxito utilizando a <xref:System.Net.HttpListenerContext.User%2A?displayProperty=fullName>propriedade.</xref:System.Net.HttpListenerContext.User%2A?displayProperty=fullName>       Se pretender que um <xref:System.Net.HttpListener>objeto ao utilizar mecanismos de autenticação diferentes com base em caraterísticas dos pedidos recebe (por exemplo, o pedido <xref:System.Net.HttpListenerRequest.Url%2A>ou <xref:System.Net.HttpListenerRequest.UserHostName%2A>propriedade), tem de implementar um método que escolhe o esquema de autenticação.</xref:System.Net.HttpListenerRequest.UserHostName%2A> </xref:System.Net.HttpListenerRequest.Url%2A> </xref:System.Net.HttpListener> Para obter instruções sobre como fazê-lo, consulte o <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A>documentação de propriedade.</xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A>      > [!NOTE] > Para definir esta propriedade para ativar Digest, NTLM ou negociar requer a <xref:System.Security.Permissions.SecurityPermission> <xref:System.Security.Permissions.SecurityPermissionFlag>.</xref:System.Security.Permissions.SecurityPermissionFlag> </xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "The following code example demonstrates using the AuthenticationSchemes property to specify an authentication scheme.  \n  \n [!code-cs[Net_listener_Basic#14](~/add/codesnippet/csharp/p-system.net.httplistene_0_1.cs)]"
  syntax:
    content: public System.Net.AuthenticationSchemes AuthenticationSchemes { get; set; }
    return:
      type: System.Net.AuthenticationSchemes
      description: "Uma combinação bit a bit de <xref:System.Net.AuthenticationSchemes>valores de enumeração que indica como os clientes estão a ser autenticado.</xref:System.Net.AuthenticationSchemes> O valor predefinido é <xref:System.Net.AuthenticationSchemes>.</xref:System.Net.AuthenticationSchemes>"
  overload: System.Net.HttpListener.AuthenticationSchemes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Este objeto foi fechado."
  platform:
  - net462
- uid: System.Net.HttpListener.AuthenticationSchemeSelectorDelegate
  id: AuthenticationSchemeSelectorDelegate
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: AuthenticationSchemeSelectorDelegate
  nameWithType: HttpListener.AuthenticationSchemeSelectorDelegate
  fullName: System.Net.HttpListener.AuthenticationSchemeSelectorDelegate
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Obtém ou define o delegado chamado para determinar o protocolo utilizado para autenticar clientes."
  remarks: "> [!NOTE]> Se pretender que o mesmo protocolo de autenticação a ser utilizada para todos os pedidos processados por uma instância específica da <xref:System.Net.HttpListener>, não terá de definir esta propriedade.</xref:System.Net.HttpListener> Para especificar um protocolo a ser utilizada para todos os pedidos de cliente, utilize o <xref:System.Net.HttpListener.AuthenticationSchemes%2A>propriedade.</xref:System.Net.HttpListener.AuthenticationSchemes%2A>       Se o cliente não especificou as informações de autenticação no respetivos cabeçalhos, o <xref:System.Net.HttpListener>chama o delegado especificado para cada pedido de entrada não autenticado determinar que, se existirem, protocolo a utilizar para autenticar o cliente.</xref:System.Net.HttpListener> O <xref:System.Net.HttpListener.GetContext%2A>e <xref:System.Net.HttpListener.EndGetContext%2A>métodos devolvem uma entrada pedido apenas se for o <xref:System.Net.HttpListener>autenticadas com êxito o pedido.</xref:System.Net.HttpListener> </xref:System.Net.HttpListener.EndGetContext%2A> </xref:System.Net.HttpListener.GetContext%2A> Se um pedido não pode ser autenticado, o <xref:System.Net.HttpListener>crie automaticamente envia uma resposta 401.</xref:System.Net.HttpListener> Pode obter a identidade de um cliente autenticado com êxito utilizando a <xref:System.Web.HttpRequest.LogonUserIdentity%2A?displayProperty=fullName>propriedade.</xref:System.Web.HttpRequest.LogonUserIdentity%2A?displayProperty=fullName>       A capacidade para delegar a escolha de protocolo de autenticação para um método específicas da aplicação é útil se pretender que uma instância de <xref:System.Net.HttpListener>de utilizar protocolos de autenticação diferentes consoante as características dos pedidos recebe (por exemplo, o pedido <xref:System.Net.HttpListenerRequest.Url%2A>ou <xref:System.Net.HttpListenerRequest.UserHostAddress%2A>propriedade).</xref:System.Net.HttpListenerRequest.UserHostAddress%2A> </xref:System.Net.HttpListenerRequest.Url%2A> </xref:System.Net.HttpListener>      > [!NOTE] > Para definir esta propriedade para ativar Digest, NTLM ou negociar requer a <xref:System.Security.Permissions.SecurityPermission> <xref:System.Security.Permissions.SecurityPermissionFlag>.</xref:System.Security.Permissions.SecurityPermissionFlag> </xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "The following code example sets the value of this property.  \n  \n [!code-vb[NclListener#2](~/add/codesnippet/visualbasic/p-system.net.httplistene_2_1.vb)]\n [!code-cs[NclListener#2](~/add/codesnippet/csharp/p-system.net.httplistene_2_1.cs)]  \n  \n The following code example provides an implementation of a method invoked by an <xref:System.Net.AuthenticationSchemeSelector> delegate.  \n  \n [!code-vb[NclListener#1](~/add/codesnippet/visualbasic/p-system.net.httplistene_2_2.vb)]\n [!code-cs[NclListener#1](~/add/codesnippet/csharp/p-system.net.httplistene_2_2.cs)]"
  syntax:
    content: public System.Net.AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate { get; set; }
    return:
      type: System.Net.AuthenticationSchemeSelector
      description: "Um <xref href=&quot;System.Net.AuthenticationSchemeSelector&quot;> </xref> delegado que invoca o método utilizado para selecionar um protocolo de autenticação. O valor predefinido é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.HttpListener.AuthenticationSchemeSelectorDelegate*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Este objeto foi fechado."
  platform:
  - net462
- uid: System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)
  id: BeginGetContext(System.AsyncCallback,System.Object)
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: BeginGetContext(AsyncCallback,Object)
  nameWithType: HttpListener.BeginGetContext(AsyncCallback,Object)
  fullName: System.Net.HttpListener.BeginGetContext(AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "É iniciada no modo assíncrono obter pedido a receber."
  remarks: "O método BeginGetContext começa uma chamada assíncrona (não bloquear) para receber pedidos de cliente recebidos. Antes de chamar este método, tem de chamar o <xref:System.Net.HttpListener.Start%2A>método e adicione, pelo menos, um prefixo de Uniform Resource Identifier (URI) para escutar adicionando as cadeias de URI para o <xref:System.Net.HttpListenerPrefixCollection>devolvido pelo <xref:System.Net.HttpListener.Prefixes%2A>propriedade.</xref:System.Net.HttpListener.Prefixes%2A> </xref:System.Net.HttpListenerPrefixCollection> </xref:System.Net.HttpListener.Start%2A>       A operação assíncrona têm de ser concluída por chamar a <xref:System.Net.HttpListener.EndGetContext%2A>método.</xref:System.Net.HttpListener.EndGetContext%2A> Normalmente, o método é invocado pelo `callback` delegar.       Este método não bloqueia enquanto a operação for concluída. Para obter um pedido de entrada e de bloco enquanto a operação for concluída, chame o <xref:System.Net.HttpListener.GetContext%2A>método.</xref:System.Net.HttpListener.GetContext%2A>       Para obter informações detalhadas sobre como utilizar o modelo de programação assíncrono, consulte [chamada síncrona métodos de forma assíncrona](~/add/includes/ajax-current-ext-md.md)"
  example:
  - "The following code example demonstrates using the BeginGetContext method to specify a callback method that will handle incoming client requests.  \n  \n [!code-cs[Net_Listener_Basic#12](~/add/codesnippet/csharp/m-system.net.httplistene_13_1.cs)]  \n  \n The following code example implements a callback method.  \n  \n [!code-cs[Net_Listener_Basic#13](~/add/codesnippet/csharp/m-system.net.httplistene_13_2.cs)]"
  syntax:
    content: public IAsyncResult BeginGetContext (AsyncCallback callback, object state);
    parameters:
    - id: callback
      type: System.AsyncCallback
      description: "Um <xref:System.AsyncCallback>delegado que referencia o método a invocar quando um pedido de cliente se encontra disponível.</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "Um objeto definido pelo utilizador que contém informações sobre a operação. Este objeto é passado para o `callback` delegar ao concluir a operação."
    return:
      type: System.IAsyncResult
      description: "Um <xref:System.IAsyncResult>objeto que indica o estado da operação assíncrona.</xref:System.IAsyncResult>"
  overload: System.Net.HttpListener.BeginGetContext*
  exceptions:
  - type: System.Net.HttpListenerException
    commentId: T:System.Net.HttpListenerException
    description: "Falha de uma chamada de função Win32. Verificar a exceção <xref:System.Net.HttpListenerException.ErrorCode*>propriedade para determinar a causa da exceção.</xref:System.Net.HttpListenerException.ErrorCode*>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Este objeto não foi iniciado ou está parado."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Este objeto está fechado."
  platform:
  - net462
- uid: System.Net.HttpListener.Close
  id: Close
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: Close()
  nameWithType: HttpListener.Close()
  fullName: System.Net.HttpListener.Close()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Encerra o <xref href=&quot;System.Net.HttpListener&quot;> </xref>."
  remarks: "Depois de chamar este método, já não pode utilizar o <xref:System.Net.HttpListener>objeto.</xref:System.Net.HttpListener> Para interromper temporariamente um <xref:System.Net.HttpListener>objeto, utilize o <xref:System.Net.HttpListener.Stop%2A>método.</xref:System.Net.HttpListener.Stop%2A> </xref:System.Net.HttpListener>       Este método encerrar pendentes a <xref:System.Net.HttpListener>objeto sem processar os pedidos em fila.</xref:System.Net.HttpListener> Quaisquer pedidos pendentes são não foi possível concluir."
  example:
  - "The following code example demonstrates calling this method.  \n  \n [!code-cs[Net_Listener_Basic#2](~/add/codesnippet/csharp/m-system.net.httplistene_10_1.cs)]"
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Net.HttpListener.Close*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.DefaultServiceNames
  id: DefaultServiceNames
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: DefaultServiceNames
  nameWithType: HttpListener.DefaultServiceNames
  fullName: System.Net.HttpListener.DefaultServiceNames
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Obtém uma lista de predefinido dos nomes do fornecedor de serviço (SPNs), conforme determinado pela prefixos registados."
  remarks: "The DefaultServiceNames property is used with integrated Windows authentication to provide extended protection. The list of SPNs is initialized from the <xref:System.Net.HttpListener.Prefixes%2A> property when accessed and cleared when new prefixes are added to the <xref:System.Net.HttpListener.Prefixes%2A> property.  \n  \n The DefaultServiceNames property is used if an application doesn't set the <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames%2A> property on its extended protection policy.  \n  \n The <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection> that is retrieved with the DefaultServiceNames property is built from the <xref:System.Net.HttpListener.Prefixes%2A> property according to the following rules:  \n  \n1.  If the hostname is \"+\", \"*\", or an IPv4 or IPv6 literal (equivalent to \"\\*\" but restricted to a specific local interface), the following SPN is added:  \n  \n `\"HTTP/\"` plus the fully qualified domain name of the computer.  \n  \n1.  If the hostname contains no dots (no domains or subdomains), an attempt is made to resolve the fully-qualified domain name using DNS (the same behavior used by <xref:System.Net.HttpWebRequest>). If the fully-qualified domain name can be resolved, the following SPNs are added:  \n  \n `\"HTTP/\"` plus the hostname (the short name).  \n  \n `\"HTTP/\"` plus the fully qualified domain name for the hostname.  \n  \n1.  If the hostname contains not dots (no domains or subdomains) and a fully-qualified domain name can't be resolved, the following SPN is added:  \n  \n `\"HTTP/\"` plus the hostname.  \n  \n1.  If the hostname contains dots (domains or subdomains), the following SPN is added:  \n  \n `\"HTTP/\"` plus the hostname.  \n  \n The DefaultServiceNames property can be used by an application to review the list of default SPNs which will be used for authentication if no custom list is supplied. If other SPNs are needed, an application can add them using one of the <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection.Merge%2A> methods.  \n  \n It is not safe when using extended protection to make policy decisions based on the requested URL, since this can be spoofed. Rather, applications should rely on the <xref:System.Net.HttpListenerRequest.LocalEndPoint%2A> or <xref:System.Net.HttpListenerRequest.RemoteEndPoint%2A> properties to make such policy decisions."
  syntax:
    content: public System.Security.Authentication.ExtendedProtection.ServiceNameCollection DefaultServiceNames { get; }
    return:
      type: System.Security.Authentication.ExtendedProtection.ServiceNameCollection
      description: "A <xref href=&quot;System.Security.Authentication.ExtendedProtection.ServiceNameCollection&quot;> </xref> que contém uma lista de SPNs."
  overload: System.Net.HttpListener.DefaultServiceNames*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.EndGetContext(System.IAsyncResult)
  id: EndGetContext(System.IAsyncResult)
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: EndGetContext(IAsyncResult)
  nameWithType: HttpListener.EndGetContext(IAsyncResult)
  fullName: System.Net.HttpListener.EndGetContext(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Concluir uma operação assíncrona para obter um pedido recebido do cliente."
  remarks: "O método EndGetContext denomina-se, normalmente, dentro de um método de chamada de retorno definido pela aplicação invocado por um delegado, para obter o <xref:System.Net.HttpListenerContext>objeto que contém um pedido de cliente recebidos e a respetiva resposta associada.</xref:System.Net.HttpListenerContext> Este método concluir uma operação iniciada anteriormente ao chamar o <xref:System.Net.HttpListener.BeginGetContext%2A>método.</xref:System.Net.HttpListener.BeginGetContext%2A> Se não tiver sido concluída a operação, este método bloqueia até que o faz.       Como chamar o método EndGetContext requer o <xref:System.Net.HttpListener>objeto, este objeto é normalmente transmitido um método de chamada de retorno por utilizar o objeto de estado transmitido a <xref:System.Net.HttpListener.BeginGetContext%2A>método.</xref:System.Net.HttpListener.BeginGetContext%2A> </xref:System.Net.HttpListener> Pode obter este objeto de estado utilizando a <xref:System.IAsyncResult.AsyncState%2A>propriedade o `asyncResult` objeto.</xref:System.IAsyncResult.AsyncState%2A>       Para obter informações detalhadas sobre como utilizar o modelo de programação assíncrono, consulte [chamada síncrona métodos de forma assíncrona](~/add/includes/ajax-current-ext-md.md)"
  example:
  - "The following code example shows the implementation of a callback method that calls the EndGetContext method.  \n  \n [!code-cs[Net_Listener_Basic#13](~/add/codesnippet/csharp/m-system.net.httplistene_1_1.cs)]"
  syntax:
    content: public System.Net.HttpListenerContext EndGetContext (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "Um <xref:System.IAsyncResult>objeto foi obtido quando a operação assíncrona foi iniciada.</xref:System.IAsyncResult>"
    return:
      type: System.Net.HttpListenerContext
      description: "Um <xref href=&quot;System.Net.HttpListenerContext&quot;> </xref> objeto que representa o pedido do cliente."
  overload: System.Net.HttpListener.EndGetContext*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>asyncResult</code>Não foi obtida chamando a <xref:System.Net.HttpListener.BeginGetContext*> método."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O método de EndGetContext já foi chamado para especificado <code> asyncResult </code> objeto."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Este objeto está fechado."
  platform:
  - net462
- uid: System.Net.HttpListener.ExtendedProtectionPolicy
  id: ExtendedProtectionPolicy
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: ExtendedProtectionPolicy
  nameWithType: HttpListener.ExtendedProtectionPolicy
  fullName: System.Net.HttpListener.ExtendedProtectionPolicy
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Obter ou definir o <xref href=&quot;System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy&quot;> </xref> a utilizar para proteção expandida para uma sessão."
  remarks: "A propriedade de ExtendedProtectionPolicy é utilizada com a autenticação integrada do Windows para fornecer proteção expandida. A propriedade de ExtendedProtectionPolicy permite que a configuração da política de proteção expandida para a totalidade <xref:System.Net.HttpListener>sessão.</xref:System.Net.HttpListener> O <xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A>propriedade permite a configuração da política de proteção expandida para cada pedido individual.</xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A>       O <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A>propriedade tem de ser `null`.</xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A> O <xref:System.Net.HttpListener>instância obtém o canal de enlace Token (CBT) diretamente a partir da sua própria sessão TLS, se existir um.</xref:System.Net.HttpListener>"
  syntax:
    content: public System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy ExtendedProtectionPolicy { get; set; }
    return:
      type: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
      description: "A <xref href=&quot;System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy&quot;> </xref> que especifica a política a utilizar para a proteção expandida."
  overload: System.Net.HttpListener.ExtendedProtectionPolicy*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Foi efetuada uma tentativa para definir a propriedade de ExtendedProtectionPolicy, mas o <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding*>a propriedade não estava <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>.</xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding*>"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Foi efetuada uma tentativa para definir a propriedade de ExtendedProtectionPolicy <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Foi efetuada uma tentativa para definir a propriedade de ExtendedProtectionPolicy após o <xref:System.Net.HttpListener.Start*>método já foi chamado.</xref:System.Net.HttpListener.Start*>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Este objeto está fechado."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "O <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement*>propriedade foi definida como <xref href=&quot;System.Security.Authentication.ExtendedProtection.PolicyEnforcement&quot;> </xref> numa plataforma que não suporta protecção expandida.</xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement*>"
  platform:
  - net462
- uid: System.Net.HttpListener.ExtendedProtectionSelectorDelegate
  id: ExtendedProtectionSelectorDelegate
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: ExtendedProtectionSelectorDelegate
  nameWithType: HttpListener.ExtendedProtectionSelectorDelegate
  fullName: System.Net.HttpListener.ExtendedProtectionSelectorDelegate
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Obter ou definir o delegado chamado para determinar o <xref href=&quot;System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy&quot;> </xref> a utilizar para cada pedido."
  remarks: "O <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A>propriedade é utilizada com a autenticação integrada do Windows para fornecer proteção expandida.</xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> O <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A>propriedade permite a configuração da política de proteção expandida para a totalidade <xref:System.Net.HttpListener>sessão.</xref:System.Net.HttpListener> </xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> A propriedade ExtendedProtectionSelectorDelegate permite que a configuração da política de proteção expandida por pedido individual.       O <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A>propriedade tem de ser `null`.</xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A> O <xref:System.Net.HttpListener>instância obtém o canal de enlace Token (CBT) diretamente a partir da sua própria sessão TLS, se existir um.</xref:System.Net.HttpListener>       Para cada pedido, o delegado pode escolher as definições que o <xref:System.Net.HttpListener>instância irá utilizar para fornecer proteção expandida.</xref:System.Net.HttpListener>       Se um delegado devolve `null` para esta propriedade representa um <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy>que a <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A>propriedade definida como <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement>.</xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement> </xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> </xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy>"
  syntax:
    content: public System.Net.HttpListener.ExtendedProtectionSelector ExtendedProtectionSelectorDelegate { get; set; }
    return:
      type: System.Net.HttpListener.ExtendedProtectionSelector
      description: "A <xref href=&quot;System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy&quot;> </xref> que especifica a política a utilizar para a proteção expandida."
  overload: System.Net.HttpListener.ExtendedProtectionSelectorDelegate*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Foi efetuada uma tentativa para definir a propriedade ExtendedProtectionSelectorDelegate, mas o <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding*>propriedade tem de ser <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>.</xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding*>"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Foi efetuada uma tentativa para definir a propriedade de ExtendedProtectionSelectorDelegate <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Foi efetuada uma tentativa para definir a propriedade ExtendedProtectionSelectorDelegate depois do <xref:System.Net.HttpListener.Start*>método já foi chamado.</xref:System.Net.HttpListener.Start*>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Este objeto está fechado."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Foi efetuada uma tentativa para definir a propriedade de ExtendedProtectionSelectorDelegate numa plataforma que não suporta protecção expandida."
  platform:
  - net462
- uid: System.Net.HttpListener.GetContext
  id: GetContext
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: GetContext()
  nameWithType: HttpListener.GetContext()
  fullName: System.Net.HttpListener.GetContext()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Tem de aguardar durante um pedido recebido e devolve quando um é recebido."
  remarks: "Antes de chamar este método, tem de chamar o <xref:System.Net.HttpListener.Start%2A>método e adicione, pelo menos, um prefixo URI para escutar adicionando as cadeias de URI para o <xref:System.Net.HttpListenerPrefixCollection>devolvido pelo <xref:System.Net.HttpListener.Prefixes%2A>propriedade.</xref:System.Net.HttpListener.Prefixes%2A> </xref:System.Net.HttpListenerPrefixCollection> </xref:System.Net.HttpListener.Start%2A> Para obter uma descrição detalhada dos prefixos, consulte o <xref:System.Net.HttpListener>Descrição geral de classe.</xref:System.Net.HttpListener>       Blocos este método ao aguardar que um pedido recebido. Se pretender que os pedidos recebidos de serem processadas no modo assíncrono (no threads separados) para que a aplicação não bloqueia, utilize o <xref:System.Net.HttpListener.BeginGetContext%2A>método.</xref:System.Net.HttpListener.BeginGetContext%2A>"
  example:
  - "The following code example demonstrates calling this method.  \n  \n [!code-cs[Net_Listener_Basic#2](~/add/codesnippet/csharp/m-system.net.httplistene_19_1.cs)]"
  syntax:
    content: public System.Net.HttpListenerContext GetContext ();
    parameters: []
    return:
      type: System.Net.HttpListenerContext
      description: "Um <xref href=&quot;System.Net.HttpListenerContext&quot;> </xref> objeto que representa um pedido de cliente."
  overload: System.Net.HttpListener.GetContext*
  exceptions:
  - type: System.Net.HttpListenerException
    commentId: T:System.Net.HttpListenerException
    description: "Falha de uma chamada de função Win32. Verificar a exceção <xref:System.Net.HttpListenerException.ErrorCode*>propriedade para determinar a causa da exceção.</xref:System.Net.HttpListenerException.ErrorCode*>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Este objeto não foi iniciado ou está parado.       - ou - <xref href=&quot;System.Net.HttpListener&quot;> </xref> não tem quaisquer prefixos Uniform Resource Identifier (URI) para responder a. Consulte observações."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Este objeto está fechado."
  platform:
  - net462
- uid: System.Net.HttpListener.GetContextAsync
  id: GetContextAsync
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: GetContextAsync()
  nameWithType: HttpListener.GetContextAsync()
  fullName: System.Net.HttpListener.GetContextAsync()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Aguarda que um pedido recebido como uma operação assíncrona."
  remarks: "Não irá impedir que esta operação. O devolvido <xref:System.Threading.Tasks.Task%601>objeto será concluída quando o pedido de entrada foi recebido.</xref:System.Threading.Tasks.Task%601>       Antes de chamar este método, tem de chamar o <xref:System.Net.HttpListener.Start%2A>método e adicione, pelo menos, um prefixo URI para escutar adicionando as cadeias de URI para o <xref:System.Net.HttpListenerPrefixCollection>devolvido pelo <xref:System.Net.HttpListener.Prefixes%2A>propriedade.</xref:System.Net.HttpListener.Prefixes%2A> </xref:System.Net.HttpListenerPrefixCollection> </xref:System.Net.HttpListener.Start%2A> Para obter uma descrição detalhada dos prefixos, consulte o <xref:System.Net.HttpListener>Descrição geral de classe.</xref:System.Net.HttpListener>"
  syntax:
    content: public System.Threading.Tasks.Task<System.Net.HttpListenerContext> GetContextAsync ();
    parameters: []
    return:
      type: System.Threading.Tasks.Task{System.Net.HttpListenerContext}
      description: "Devolve &lt;xref:System.Threading.Tasks.Task%601&gt;.       O objeto de tarefa que representa a operação assíncrona. O &lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt; propriedade do objeto de tarefa devolve uma <xref href=&quot;System.Net.HttpListenerContext&quot;> </xref> objeto que representa um pedido de cliente."
  overload: System.Net.HttpListener.GetContextAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.IgnoreWriteExceptions
  id: IgnoreWriteExceptions
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: IgnoreWriteExceptions
  nameWithType: HttpListener.IgnoreWriteExceptions
  fullName: System.Net.HttpListener.IgnoreWriteExceptions
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Obtém ou define um <xref:System.Boolean>valor que especifica se a aplicação recebe as exceções que ocorrem quando uma <xref href=&quot;System.Net.HttpListener&quot;> </xref> envia a resposta ao cliente.</xref:System.Boolean>"
  remarks: "Defina esta propriedade como `true` se a aplicação não necessitar de uma enviada com êxito uma resposta para cada cliente."
  example:
  - "The following code example demonstrates setting this property.  \n  \n [!code-cs[Net_Listener_Basic#14](~/add/codesnippet/csharp/p-system.net.httplistene_31_1.cs)]"
  syntax:
    content: public bool IgnoreWriteExceptions { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se esta <xref href=&quot;System.Net.HttpListener&quot;> </xref> não deve devolver exceções que ocorrem quando for enviada a resposta ao cliente; caso contrário <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. O valor predefinido é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.HttpListener.IgnoreWriteExceptions*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Este objeto foi fechado."
  platform:
  - net462
- uid: System.Net.HttpListener.IsListening
  id: IsListening
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: IsListening
  nameWithType: HttpListener.IsListening
  fullName: System.Net.HttpListener.IsListening
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Obtém um valor que indica se <xref href=&quot;System.Net.HttpListener&quot;> </xref> foi iniciado."
  remarks: "Para iniciar um <xref:System.Net.HttpListener>, chame o <xref:System.Net.HttpListener.Start%2A>método.</xref:System.Net.HttpListener.Start%2A> </xref:System.Net.HttpListener>"
  example:
  - "The following code example demonstrates using this property to determine the listening state of an instance.  \n  \n [!code-cs[Net_Listener_Basic#1](~/add/codesnippet/csharp/p-system.net.httplistene_41_1.cs)]"
  syntax:
    content: public bool IsListening { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o <xref href=&quot;System.Net.HttpListener&quot;> </xref> foi iniciado; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.HttpListener.IsListening*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.IsSupported
  id: IsSupported
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: IsSupported
  nameWithType: HttpListener.IsSupported
  fullName: System.Net.HttpListener.IsSupported
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Obtém um valor que indica se <xref href=&quot;System.Net.HttpListener&quot;> </xref> pode ser utilizado com o sistema operativo atual."
  remarks: "Esta classe está disponível apenas em computadores com sistemas de operativos Windows XP SP2 ou Windows Server 2003."
  example:
  - "The following code example demonstrates the use of the IsSupported property to detect whether an <xref:System.Net.HttpListener> object can be used with the current operating system.  \n  \n [!code-cs[Net_Listener_Basic#2](~/add/codesnippet/csharp/p-system.net.httplistene_21_1.cs)]"
  syntax:
    content: public static bool IsSupported { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se <xref href=&quot;System.Net.HttpListener&quot;> </xref> é suportada; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.HttpListener.IsSupported*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.Prefixes
  id: Prefixes
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: Prefixes
  nameWithType: HttpListener.Prefixes
  fullName: System.Net.HttpListener.Prefixes
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Obtém os prefixos de Uniform Resource Identifier (URI) processados por este <xref href=&quot;System.Net.HttpListener&quot;> </xref> objeto."
  remarks: "Os prefixos estão no formato canónico. Para obter uma descrição detalhada dos prefixos, consulte o <xref:System.Net.HttpListener>Descrição geral de classe.</xref:System.Net.HttpListener>"
  example:
  - "The following code example demonstrates using the Prefixes property to obtain and print the URI prefixes that are handled.  \n  \n [!code-cs[Net_Listener_Basic#1](~/add/codesnippet/csharp/p-system.net.httplistene_24_1.cs)]"
  syntax:
    content: public System.Net.HttpListenerPrefixCollection Prefixes { get; }
    return:
      type: System.Net.HttpListenerPrefixCollection
      description: "Um <xref href=&quot;System.Net.HttpListenerPrefixCollection&quot;> </xref> que contém o URI prefixos que este <xref href=&quot;System.Net.HttpListener&quot;> </xref> objeto está configurado para processar."
  overload: System.Net.HttpListener.Prefixes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Este objeto foi fechado."
  platform:
  - net462
- uid: System.Net.HttpListener.Realm
  id: Realm
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: Realm
  nameWithType: HttpListener.Realm
  fullName: System.Net.HttpListener.Realm
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Obtém ou define o realm ou partição de recursos, associada a este <xref href=&quot;System.Net.HttpListener&quot;> </xref> objeto."
  remarks: "Os servidores utilizam realms para particionar a recursos protegidos; cada partição pode ter a sua própria base de dados do esquema de e/ou de autorização autenticação. Realms são utilizadas apenas para básica e autenticação resumida. Depois de um cliente com êxito efetua a autenticação, a autenticação é válida para todos os recursos num realm especificado. Para obter uma descrição detalhada de realms, consulte RFC 2617 em [http://www.ietf.org](http://www.ietf.org).       Uma instância de <xref:System.Net.HttpListener>tem apenas um realm associado.</xref:System.Net.HttpListener>"
  example:
  - "The following code example demonstrates setting the Realm property.  \n  \n [!code-cs[Net_Listener_Basic#10](~/add/codesnippet/csharp/p-system.net.httplistene_26_1.cs)]"
  syntax:
    content: public string Realm { get; set; }
    return:
      type: System.String
      description: "A <xref:System.String>valor que contém o nome do realm associado a <xref href=&quot;System.Net.HttpListener&quot;> </xref> objeto.</xref:System.String>"
  overload: System.Net.HttpListener.Realm*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Este objeto foi fechado."
  platform:
  - net462
- uid: System.Net.HttpListener.Start
  id: Start
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: Start()
  nameWithType: HttpListener.Start()
  fullName: System.Net.HttpListener.Start()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Permite que esta instância receber pedidos recebidos."
  remarks: "Este método tem de ser chamado antes de chamar o <xref:System.Net.HttpListener.GetContext%2A>ou <xref:System.Net.HttpListener.BeginGetContext%2A>método.</xref:System.Net.HttpListener.BeginGetContext%2A> </xref:System.Net.HttpListener.GetContext%2A>       Depois de iniciar um <xref:System.Net.HttpListener>objeto, pode utilizar o <xref:System.Net.HttpListener.Stop%2A>método para parar o mesmo.</xref:System.Net.HttpListener.Stop%2A> </xref:System.Net.HttpListener>      > [!NOTE] > Se esta instância de serviço de escuta utiliza https, tem de instalar e selecionar um certificado de servidor. Caso contrário, um <xref:System.Net.HttpWebRequest>consulta deste <xref:System.Net.HttpListener>irá falhar com um fecho inesperado da ligação.</xref:System.Net.HttpListener> </xref:System.Net.HttpWebRequest> Pode configurar certificados de servidor e outras opções do serviço de escuta utilizando HttpCfg.exe. Consulte [http://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp](http://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp) para obter mais detalhes."
  example:
  - "The following code example demonstrates using the Start method to begin processing incoming requests.  \n  \n [!code-cs[Net_Listener_Basic#12](~/add/codesnippet/csharp/m-system.net.httplistene_12_1.cs)]"
  syntax:
    content: public void Start ();
    parameters: []
  overload: System.Net.HttpListener.Start*
  exceptions:
  - type: System.Net.HttpListenerException
    commentId: T:System.Net.HttpListenerException
    description: "Falha de uma chamada de função Win32. Verificar a exceção <xref:System.Net.HttpListenerException.ErrorCode*>propriedade para determinar a causa da exceção.</xref:System.Net.HttpListenerException.ErrorCode*>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Este objeto está fechado."
  platform:
  - net462
- uid: System.Net.HttpListener.Stop
  id: Stop
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: Stop()
  nameWithType: HttpListener.Stop()
  fullName: System.Net.HttpListener.Stop()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Faz com que esta instância deixar de receber pedidos recebidos."
  remarks: "Se esta instância já está parada, chamar este método não tem qualquer efeito.       Depois de interromper a um <xref:System.Net.HttpListener>objeto, pode utilizar o <xref:System.Net.HttpListener.Start%2A>método para o reiniciar.</xref:System.Net.HttpListener.Start%2A> </xref:System.Net.HttpListener>"
  example:
  - "The following code example demonstrates using the Stop method to stop processing incoming requests.  \n  \n [!code-cs[Net_Listener_Basic#12](~/add/codesnippet/csharp/m-system.net.httplistene_5_1.cs)]"
  syntax:
    content: public void Stop ();
    parameters: []
  overload: System.Net.HttpListener.Stop*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Este objeto foi fechado."
  platform:
  - net462
- uid: System.Net.HttpListener.System#IDisposable#Dispose
  id: System#IDisposable#Dispose
  isEii: true
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: System.IDisposable.Dispose()
  nameWithType: HttpListener.System.IDisposable.Dispose()
  fullName: System.Net.HttpListener.System.IDisposable.Dispose()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Liberta os recursos contidos por este <xref href=&quot;System.Net.HttpListener&quot;> </xref> objeto."
  remarks: "As aplicações devem utilizar o <xref:System.Net.HttpListener.Close%2A>método em vez de chamar este método.</xref:System.Net.HttpListener.Close%2A>"
  syntax:
    content: void IDisposable.Dispose ();
    parameters: []
  overload: System.Net.HttpListener.System#IDisposable#Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.TimeoutManager
  id: TimeoutManager
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: TimeoutManager
  nameWithType: HttpListener.TimeoutManager
  fullName: System.Net.HttpListener.TimeoutManager
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "O Gestor de tempo limite para esta <xref href=&quot;System.Net.HttpListener&quot;> </xref> instância."
  remarks: "O Gestor de tempo limite define os limites de tempo limite de ligação para este <xref:System.Net.HttpListener>instância.</xref:System.Net.HttpListener>"
  syntax:
    content: public System.Net.HttpListenerTimeoutManager TimeoutManager { get; }
    return:
      type: System.Net.HttpListenerTimeoutManager
      description: "Returns <xref href=&quot;System.Net.HttpListenerTimeoutManager&quot;></xref>.       O Gestor de tempo limite para esta <xref href=&quot;System.Net.HttpListener&quot;> </xref> instância."
  overload: System.Net.HttpListener.TimeoutManager*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.UnsafeConnectionNtlmAuthentication
  id: UnsafeConnectionNtlmAuthentication
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: UnsafeConnectionNtlmAuthentication
  nameWithType: HttpListener.UnsafeConnectionNtlmAuthentication
  fullName: System.Net.HttpListener.UnsafeConnectionNtlmAuthentication
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Obtém ou define um <xref:System.Boolean>valor que controla se, quando é utilizado o NTLM, os pedidos adicionais utilizando a mesma ligação de protocolo de controlo de transmissão (TCP) são obrigados a autenticar.</xref:System.Boolean>"
  remarks: "Quando esta propriedade está definida como `true` e o primeiro pedido efetuado através de uma determinada ligação de TCP é autenticado utilizando NTLM, os pedidos subsequentes através da ligação de TCP mesmo são processados utilizando as informações de autenticação (<xref:System.Security.Principal.IIdentity>) do pedido inicial.</xref:System.Security.Principal.IIdentity>       Esta propriedade não tem efeito quando a NTLM não é o protocolo de autenticação. Quando negociar é especificado como o protocolo de autenticação, esta propriedade tem um efeito apenas se o NTLM é o protocolo real utilizado para autenticação.      > [!NOTE] > Ao definir esta propriedade `true` aumenta o desempenho porque o <xref:System.Net.HttpListener>não envie adicionais NTLM authentication desafios, existe um risco de segurança em que não necessitam de todos os pedidos para fornecer informações de autenticação.</xref:System.Net.HttpListener> Tem de determinar se o aumento do desempenho é, este risco."
  example:
  - "The following code example demonstrates setting this property.  \n  \n [!code-cs[Net_Listener_Basic#14](~/add/codesnippet/csharp/p-system.net.httplistene_34_1.cs)]"
  syntax:
    content: public bool UnsafeConnectionNtlmAuthentication { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o <xref:System.Security.Principal.IIdentity>do primeiro pedido será utilizado para pedidos subsequentes na mesma ligação; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Security.Principal.IIdentity> O valor predefinido é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.HttpListener.UnsafeConnectionNtlmAuthentication*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Este objeto foi fechado."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.Net.HttpListenerException
  parent: System.Net
  isExternal: false
  name: HttpListenerException
  nameWithType: HttpListenerException
  fullName: System.Net.HttpListenerException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.Net.HttpListener.#ctor
  parent: System.Net.HttpListener
  isExternal: false
  name: HttpListener()
  nameWithType: HttpListener.HttpListener()
  fullName: System.Net.HttpListener.HttpListener()
- uid: System.Net.HttpListener.Abort
  parent: System.Net.HttpListener
  isExternal: false
  name: Abort()
  nameWithType: HttpListener.Abort()
  fullName: System.Net.HttpListener.Abort()
- uid: System.Net.HttpListener.AuthenticationSchemes
  parent: System.Net.HttpListener
  isExternal: false
  name: AuthenticationSchemes
  nameWithType: HttpListener.AuthenticationSchemes
  fullName: System.Net.HttpListener.AuthenticationSchemes
- uid: System.Net.AuthenticationSchemes
  parent: System.Net
  isExternal: true
  name: AuthenticationSchemes
  nameWithType: AuthenticationSchemes
  fullName: System.Net.AuthenticationSchemes
- uid: System.Net.HttpListener.AuthenticationSchemeSelectorDelegate
  parent: System.Net.HttpListener
  isExternal: false
  name: AuthenticationSchemeSelectorDelegate
  nameWithType: HttpListener.AuthenticationSchemeSelectorDelegate
  fullName: System.Net.HttpListener.AuthenticationSchemeSelectorDelegate
- uid: System.Net.AuthenticationSchemeSelector
  parent: System.Net
  isExternal: false
  name: AuthenticationSchemeSelector
  nameWithType: AuthenticationSchemeSelector
  fullName: System.Net.AuthenticationSchemeSelector
- uid: System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)
  parent: System.Net.HttpListener
  isExternal: false
  name: BeginGetContext(AsyncCallback,Object)
  nameWithType: HttpListener.BeginGetContext(AsyncCallback,Object)
  fullName: System.Net.HttpListener.BeginGetContext(AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Net.HttpListener.Close
  parent: System.Net.HttpListener
  isExternal: false
  name: Close()
  nameWithType: HttpListener.Close()
  fullName: System.Net.HttpListener.Close()
- uid: System.Net.HttpListener.DefaultServiceNames
  parent: System.Net.HttpListener
  isExternal: false
  name: DefaultServiceNames
  nameWithType: HttpListener.DefaultServiceNames
  fullName: System.Net.HttpListener.DefaultServiceNames
- uid: System.Security.Authentication.ExtendedProtection.ServiceNameCollection
  parent: System.Security.Authentication.ExtendedProtection
  isExternal: false
  name: ServiceNameCollection
  nameWithType: ServiceNameCollection
  fullName: System.Security.Authentication.ExtendedProtection.ServiceNameCollection
- uid: System.Net.HttpListener.EndGetContext(System.IAsyncResult)
  parent: System.Net.HttpListener
  isExternal: false
  name: EndGetContext(IAsyncResult)
  nameWithType: HttpListener.EndGetContext(IAsyncResult)
  fullName: System.Net.HttpListener.EndGetContext(IAsyncResult)
- uid: System.Net.HttpListenerContext
  parent: System.Net
  isExternal: false
  name: HttpListenerContext
  nameWithType: HttpListenerContext
  fullName: System.Net.HttpListenerContext
- uid: System.Net.HttpListener.ExtendedProtectionPolicy
  parent: System.Net.HttpListener
  isExternal: false
  name: ExtendedProtectionPolicy
  nameWithType: HttpListener.ExtendedProtectionPolicy
  fullName: System.Net.HttpListener.ExtendedProtectionPolicy
- uid: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
  parent: System.Security.Authentication.ExtendedProtection
  isExternal: false
  name: ExtendedProtectionPolicy
  nameWithType: ExtendedProtectionPolicy
  fullName: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
- uid: System.Net.HttpListener.ExtendedProtectionSelectorDelegate
  parent: System.Net.HttpListener
  isExternal: false
  name: ExtendedProtectionSelectorDelegate
  nameWithType: HttpListener.ExtendedProtectionSelectorDelegate
  fullName: System.Net.HttpListener.ExtendedProtectionSelectorDelegate
- uid: System.Net.HttpListener.ExtendedProtectionSelector
  parent: System.Net
  isExternal: false
  name: HttpListener+ExtendedProtectionSelector
  nameWithType: HttpListener+ExtendedProtectionSelector
  fullName: System.Net.HttpListener+ExtendedProtectionSelector
- uid: System.Net.HttpListener.GetContext
  parent: System.Net.HttpListener
  isExternal: false
  name: GetContext()
  nameWithType: HttpListener.GetContext()
  fullName: System.Net.HttpListener.GetContext()
- uid: System.Net.HttpListener.GetContextAsync
  parent: System.Net.HttpListener
  isExternal: false
  name: GetContextAsync()
  nameWithType: HttpListener.GetContextAsync()
  fullName: System.Net.HttpListener.GetContextAsync()
- uid: System.Threading.Tasks.Task{System.Net.HttpListenerContext}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<HttpListenerContext>
  nameWithType: Task<HttpListenerContext>
  fullName: System.Threading.Tasks.Task<System.Net.HttpListenerContext>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Net.HttpListenerContext>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Net.HttpListenerContext
    name: HttpListenerContext
    nameWithType: HttpListenerContext
    fullName: HttpListenerContext
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Net.HttpListener.IgnoreWriteExceptions
  parent: System.Net.HttpListener
  isExternal: false
  name: IgnoreWriteExceptions
  nameWithType: HttpListener.IgnoreWriteExceptions
  fullName: System.Net.HttpListener.IgnoreWriteExceptions
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Net.HttpListener.IsListening
  parent: System.Net.HttpListener
  isExternal: false
  name: IsListening
  nameWithType: HttpListener.IsListening
  fullName: System.Net.HttpListener.IsListening
- uid: System.Net.HttpListener.IsSupported
  parent: System.Net.HttpListener
  isExternal: false
  name: IsSupported
  nameWithType: HttpListener.IsSupported
  fullName: System.Net.HttpListener.IsSupported
- uid: System.Net.HttpListener.Prefixes
  parent: System.Net.HttpListener
  isExternal: false
  name: Prefixes
  nameWithType: HttpListener.Prefixes
  fullName: System.Net.HttpListener.Prefixes
- uid: System.Net.HttpListenerPrefixCollection
  parent: System.Net
  isExternal: false
  name: HttpListenerPrefixCollection
  nameWithType: HttpListenerPrefixCollection
  fullName: System.Net.HttpListenerPrefixCollection
- uid: System.Net.HttpListener.Realm
  parent: System.Net.HttpListener
  isExternal: false
  name: Realm
  nameWithType: HttpListener.Realm
  fullName: System.Net.HttpListener.Realm
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Net.HttpListener.Start
  parent: System.Net.HttpListener
  isExternal: false
  name: Start()
  nameWithType: HttpListener.Start()
  fullName: System.Net.HttpListener.Start()
- uid: System.Net.HttpListener.Stop
  parent: System.Net.HttpListener
  isExternal: false
  name: Stop()
  nameWithType: HttpListener.Stop()
  fullName: System.Net.HttpListener.Stop()
- uid: System.Net.HttpListener.System#IDisposable#Dispose
  parent: System.Net.HttpListener
  isExternal: false
  name: System.IDisposable.Dispose()
  nameWithType: HttpListener.System.IDisposable.Dispose()
  fullName: System.Net.HttpListener.System.IDisposable.Dispose()
- uid: System.Net.HttpListener.TimeoutManager
  parent: System.Net.HttpListener
  isExternal: false
  name: TimeoutManager
  nameWithType: HttpListener.TimeoutManager
  fullName: System.Net.HttpListener.TimeoutManager
- uid: System.Net.HttpListenerTimeoutManager
  parent: System.Net
  isExternal: false
  name: HttpListenerTimeoutManager
  nameWithType: HttpListenerTimeoutManager
  fullName: System.Net.HttpListenerTimeoutManager
- uid: System.Net.HttpListener.UnsafeConnectionNtlmAuthentication
  parent: System.Net.HttpListener
  isExternal: false
  name: UnsafeConnectionNtlmAuthentication
  nameWithType: HttpListener.UnsafeConnectionNtlmAuthentication
  fullName: System.Net.HttpListener.UnsafeConnectionNtlmAuthentication
- uid: System.Net.HttpListener.#ctor*
  parent: System.Net.HttpListener
  isExternal: false
  name: HttpListener
  nameWithType: HttpListener.HttpListener
- uid: System.Net.HttpListener.Abort*
  parent: System.Net.HttpListener
  isExternal: false
  name: Abort
  nameWithType: HttpListener.Abort
- uid: System.Net.HttpListener.AuthenticationSchemes*
  parent: System.Net.HttpListener
  isExternal: false
  name: AuthenticationSchemes
  nameWithType: HttpListener.AuthenticationSchemes
- uid: System.Net.HttpListener.AuthenticationSchemeSelectorDelegate*
  parent: System.Net.HttpListener
  isExternal: false
  name: AuthenticationSchemeSelectorDelegate
  nameWithType: HttpListener.AuthenticationSchemeSelectorDelegate
- uid: System.Net.HttpListener.BeginGetContext*
  parent: System.Net.HttpListener
  isExternal: false
  name: BeginGetContext
  nameWithType: HttpListener.BeginGetContext
- uid: System.Net.HttpListener.Close*
  parent: System.Net.HttpListener
  isExternal: false
  name: Close
  nameWithType: HttpListener.Close
- uid: System.Net.HttpListener.DefaultServiceNames*
  parent: System.Net.HttpListener
  isExternal: false
  name: DefaultServiceNames
  nameWithType: HttpListener.DefaultServiceNames
- uid: System.Net.HttpListener.EndGetContext*
  parent: System.Net.HttpListener
  isExternal: false
  name: EndGetContext
  nameWithType: HttpListener.EndGetContext
- uid: System.Net.HttpListener.ExtendedProtectionPolicy*
  parent: System.Net.HttpListener
  isExternal: false
  name: ExtendedProtectionPolicy
  nameWithType: HttpListener.ExtendedProtectionPolicy
- uid: System.Net.HttpListener.ExtendedProtectionSelectorDelegate*
  parent: System.Net.HttpListener
  isExternal: false
  name: ExtendedProtectionSelectorDelegate
  nameWithType: HttpListener.ExtendedProtectionSelectorDelegate
- uid: System.Net.HttpListener.GetContext*
  parent: System.Net.HttpListener
  isExternal: false
  name: GetContext
  nameWithType: HttpListener.GetContext
- uid: System.Net.HttpListener.GetContextAsync*
  parent: System.Net.HttpListener
  isExternal: false
  name: GetContextAsync
  nameWithType: HttpListener.GetContextAsync
- uid: System.Net.HttpListener.IgnoreWriteExceptions*
  parent: System.Net.HttpListener
  isExternal: false
  name: IgnoreWriteExceptions
  nameWithType: HttpListener.IgnoreWriteExceptions
- uid: System.Net.HttpListener.IsListening*
  parent: System.Net.HttpListener
  isExternal: false
  name: IsListening
  nameWithType: HttpListener.IsListening
- uid: System.Net.HttpListener.IsSupported*
  parent: System.Net.HttpListener
  isExternal: false
  name: IsSupported
  nameWithType: HttpListener.IsSupported
- uid: System.Net.HttpListener.Prefixes*
  parent: System.Net.HttpListener
  isExternal: false
  name: Prefixes
  nameWithType: HttpListener.Prefixes
- uid: System.Net.HttpListener.Realm*
  parent: System.Net.HttpListener
  isExternal: false
  name: Realm
  nameWithType: HttpListener.Realm
- uid: System.Net.HttpListener.Start*
  parent: System.Net.HttpListener
  isExternal: false
  name: Start
  nameWithType: HttpListener.Start
- uid: System.Net.HttpListener.Stop*
  parent: System.Net.HttpListener
  isExternal: false
  name: Stop
  nameWithType: HttpListener.Stop
- uid: System.Net.HttpListener.System#IDisposable#Dispose*
  parent: System.Net.HttpListener
  isExternal: false
  name: System.IDisposable.Dispose
  nameWithType: HttpListener.System.IDisposable.Dispose
- uid: System.Net.HttpListener.TimeoutManager*
  parent: System.Net.HttpListener
  isExternal: false
  name: TimeoutManager
  nameWithType: HttpListener.TimeoutManager
- uid: System.Net.HttpListener.UnsafeConnectionNtlmAuthentication*
  parent: System.Net.HttpListener
  isExternal: false
  name: UnsafeConnectionNtlmAuthentication
  nameWithType: HttpListener.UnsafeConnectionNtlmAuthentication
