### YamlMime:ManagedReference
items:
- uid: System.Collections.Queue
  id: Queue
  children:
  - System.Collections.Queue.#ctor
  - System.Collections.Queue.#ctor(System.Collections.ICollection)
  - System.Collections.Queue.#ctor(System.Int32)
  - System.Collections.Queue.#ctor(System.Int32,System.Single)
  - System.Collections.Queue.Clear
  - System.Collections.Queue.Clone
  - System.Collections.Queue.Contains(System.Object)
  - System.Collections.Queue.CopyTo(System.Array,System.Int32)
  - System.Collections.Queue.Count
  - System.Collections.Queue.Dequeue
  - System.Collections.Queue.Enqueue(System.Object)
  - System.Collections.Queue.GetEnumerator
  - System.Collections.Queue.IsSynchronized
  - System.Collections.Queue.Peek
  - System.Collections.Queue.Synchronized(System.Collections.Queue)
  - System.Collections.Queue.SyncRoot
  - System.Collections.Queue.ToArray
  - System.Collections.Queue.TrimToSize
  langs:
  - csharp
  name: Queue
  nameWithType: Queue
  fullName: System.Collections.Queue
  type: Class
  summary: "Representa um first in, First Out de objetos."
  remarks: "Esta classe implementa uma fila como uma matriz de circular. Objetos armazenados numa fila são inseridos no final de uma e removidos do outro.       As filas e pilhas são úteis quando necessita de armazenamento temporário para informações; ou seja, quando poderá pretender eliminar um elemento depois de obter o respetivo valor. Utilize fila se precisar de aceder às informações pela mesma ordem que é armazenado na coleção. Utilize <xref:System.Collections.Stack>se precisa de aceder às informações na ordem inversa.</xref:System.Collections.Stack> Utilize <xref:System.Collections.Concurrent.ConcurrentQueue%601>ou <xref:System.Collections.Concurrent.ConcurrentStack%601>se precisa de aceder à colecção de vários threads em simultâneo.</xref:System.Collections.Concurrent.ConcurrentStack%601> </xref:System.Collections.Concurrent.ConcurrentQueue%601>       Três operações principais podem ser efetuadas numa fila e os respetivos elementos:- <xref:System.Collections.Queue.Enqueue%2A>adiciona um elemento de fim da fila.</xref:System.Collections.Queue.Enqueue%2A>      - <xref:System.Collections.Queue.Dequeue%2A>Remove o elemento antigo desde o início da fila.</xref:System.Collections.Queue.Dequeue%2A>      - <xref:System.Collections.Queue.Peek%2A>devolve o elemento mais antigo que está no início da fila, mas não o remover da fila.</xref:System.Collections.Queue.Peek%2A>       A capacidade de uma fila é o número de elementos que a fila pode conter. Elementos são adicionadas a uma fila, a capacidade é aumentada automaticamente conforme necessário, através da reatribuição.  A capacidade pode ser diminuída chamando <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>       O fator de crescimento é o número pelo qual a capacidade atual se multiplica quando não é necessária uma maior capacidade.  O fator de crescimento é determinado quando a fila é construída. O fator de crescimento predefinida é a 2.0. A capacidade da fila sempre aumentará por, pelo menos, um mínimo de quatro, independentemente do fator de crescimento. Por exemplo, uma fila com um fator de crescimento de 1.0 será sempre aumentar a capacidade por quatro quando não é necessária uma maior capacidade.       Fila aceita `null` como um valor válido e permite que os elementos duplicados.       Para a versão genérica desta coleção, consulte<xref:System.Collections.Generic.Queue%601?displayProperty=fullName></xref:System.Collections.Generic.Queue%601?displayProperty=fullName>"
  example:
  - "The following example shows how to create and add values to a Queue and how to print out its values.  \n  \n [!code-cs[Classic Queue Example#1](~/add/codesnippet/csharp/t-system.collections.queue_1.cs)]\n [!code-cpp[Classic Queue Example#1](~/add/codesnippet/cpp/t-system.collections.queue_1.cpp)]\n [!code-vb[Classic Queue Example#1](~/add/codesnippet/visualbasic/t-system.collections.queue_1.vb)]"
  syntax:
    content: >-
      [System.Diagnostics.DebuggerDisplay("Count = {Count}")]

      [System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Queue/QueueDebugView))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public class Queue : ICloneable, System.Collections.ICollection
  inheritance:
  - System.Object
  implements:
  - System.Collections.ICollection
  - System.ICloneable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Collections.Queue.#ctor
  id: '#ctor'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue()
  nameWithType: Queue.Queue()
  fullName: System.Collections.Queue.Queue()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Collections.Queue&quot;> </xref> classe que está vazia, tem a capacidade inicial predefinida e utiliza o fator de crescimento de predefinição."
  remarks: "A capacidade de um <xref:System.Collections.Queue>é o número de elementos a <xref:System.Collections.Queue>pode conter.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  Elementos são adicionadas a um <xref:System.Collections.Queue>, a capacidade é aumentada automaticamente conforme necessário, através da reatribuição.</xref:System.Collections.Queue>  A capacidade pode ser diminuída chamando <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>       O fator de crescimento é o número pelo qual a capacidade atual se multiplica quando não é necessária uma maior capacidade.  O fator de crescimento é determinado quando o <xref:System.Collections.Queue>é construído.</xref:System.Collections.Queue>       Este construtor é uma operação de O(1)."
  syntax:
    content: public Queue ();
    parameters: []
  overload: System.Collections.Queue.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.#ctor(System.Collections.ICollection)
  id: '#ctor(System.Collections.ICollection)'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue(ICollection)
  nameWithType: Queue.Queue(ICollection)
  fullName: System.Collections.Queue.Queue(ICollection)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Collections.Queue&quot;> </xref> classe que contém elementos copiados a partir da coleção especificada, tem a mesma capacidade inicial como o número de elementos copiados e utiliza o fator de crescimento de predefinição."
  remarks: "A capacidade de um <xref:System.Collections.Queue>é o número de elementos a <xref:System.Collections.Queue>pode conter.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  Elementos são adicionadas a um <xref:System.Collections.Queue>, a capacidade é aumentada automaticamente conforme necessário, através da reatribuição.</xref:System.Collections.Queue>  A capacidade pode ser diminuída chamando <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>       O fator de crescimento é o número pelo qual a capacidade atual se multiplica quando não é necessária uma maior capacidade.  O fator de crescimento é determinado quando o <xref:System.Collections.Queue>é construído.</xref:System.Collections.Queue>       Os elementos são copiados para o <xref:System.Collections.Queue>pela mesma ordem que são lidas <xref:System.Collections.IEnumerator>de <xref:System.Collections.ICollection>.</xref:System.Collections.ICollection> </xref:System.Collections.IEnumerator> </xref:System.Collections.Queue>       Este construtor é uma Nã (`n`) operação, onde `n` é o número de elementos na `col`."
  syntax:
    content: public Queue (System.Collections.ICollection col);
    parameters:
    - id: col
      type: System.Collections.ICollection
      description: "O <xref:System.Collections.ICollection>para copiar elementos da.</xref:System.Collections.ICollection>"
  overload: System.Collections.Queue.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>col</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Queue.#ctor(System.Int32)
  id: '#ctor(System.Int32)'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue(Int32)
  nameWithType: Queue.Queue(Int32)
  fullName: System.Collections.Queue.Queue(Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Collections.Queue&quot;> </xref> classe que está vazia, tem a capacidade inicial especificada e utiliza o fator de crescimento de predefinição."
  remarks: "A capacidade de um <xref:System.Collections.Queue>é o número de elementos a <xref:System.Collections.Queue>pode conter.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  Elementos são adicionadas a um <xref:System.Collections.Queue>, a capacidade é aumentada automaticamente conforme necessário, através da reatribuição.</xref:System.Collections.Queue>  A capacidade pode ser diminuída chamando <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>       O fator de crescimento é o número pelo qual a capacidade atual se multiplica quando não é necessária uma maior capacidade.  O fator de crescimento é determinado quando o <xref:System.Collections.Queue>é construído.</xref:System.Collections.Queue>       Se o tamanho da coleção pode ser estimado, especificando a capacidade inicial elimina a necessidade de executar um número de operações de redimensionamento durante a adição de elementos a <xref:System.Collections.Queue>.</xref:System.Collections.Queue>       Este construtor é uma Nã (`n`) operação, onde `n` é `capacity`."
  syntax:
    content: public Queue (int capacity);
    parameters:
    - id: capacity
      type: System.Int32
      description: "O número inicial de elementos que o <xref href=&quot;System.Collections.Queue&quot;> </xref> pode conter."
  overload: System.Collections.Queue.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>é menor que zero."
  platform:
  - net462
- uid: System.Collections.Queue.#ctor(System.Int32,System.Single)
  id: '#ctor(System.Int32,System.Single)'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue(Int32,Single)
  nameWithType: Queue.Queue(Int32,Single)
  fullName: System.Collections.Queue.Queue(Int32,Single)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Collections.Queue&quot;> </xref> classe que está vazia, tem a capacidade inicial especificada e utiliza o fator de crescimento especificado."
  remarks: "A capacidade de um <xref:System.Collections.Queue>é o número de elementos a <xref:System.Collections.Queue>pode conter.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  Elementos são adicionadas a um <xref:System.Collections.Queue>, a capacidade é aumentada automaticamente conforme necessário, através da reatribuição.</xref:System.Collections.Queue>  A capacidade pode ser diminuída chamando <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>       O fator de crescimento é o número pelo qual a capacidade atual se multiplica quando não é necessária uma maior capacidade.  O fator de crescimento é determinado quando o <xref:System.Collections.Queue>é construído.</xref:System.Collections.Queue> A capacidade dos <xref:System.Collections.Queue>sempre irá aumentar por um valor mínimo, independentemente do fator de crescimento; um fator de crescimento de 1.0 não irá impedir que o <xref:System.Collections.Queue>de aumentar de tamanho.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       Se o tamanho da coleção pode ser estimado, especificando a capacidade inicial elimina a necessidade de executar um número de operações de redimensionamento durante a adição de elementos a <xref:System.Collections.Queue>.</xref:System.Collections.Queue>       Este construtor é uma Nã (`n`) operação, onde `n` é `capacity`."
  syntax:
    content: public Queue (int capacity, float growFactor);
    parameters:
    - id: capacity
      type: System.Int32
      description: "O número inicial de elementos que o <xref href=&quot;System.Collections.Queue&quot;> </xref> pode conter."
    - id: growFactor
      type: System.Single
      description: "O fator através do qual a capacidade dos <xref href=&quot;System.Collections.Queue&quot;> </xref> é expandido."
  overload: System.Collections.Queue.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>é menor que zero.       - ou - <code>growFactor</code> é menor que 1,0 ou maior do que 10.0."
  platform:
  - net462
- uid: System.Collections.Queue.Clear
  id: Clear
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Clear()
  nameWithType: Queue.Clear()
  fullName: System.Collections.Queue.Clear()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Remove todos os objetos a partir de <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "<xref:System.Collections.Queue.Count%2A>está definido como zero e também são lançadas as referências a outros objetos de elementos da coleção.</xref:System.Collections.Queue.Count%2A>       A capacidade permanece inalterada. Para repor a capacidade do <xref:System.Collections.Queue>chamar <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A> </xref:System.Collections.Queue> Trimming vazio <xref:System.Collections.Queue>define a capacidade dos <xref:System.Collections.Queue>para a capacidade predefinida.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       Este método é um Nã (`n`) operação, onde `n` é <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to clear the values of the <xref:System.Collections.Queue>.  \n  \n [!code-cpp[Classic Queue.Clear Example#1](~/add/codesnippet/cpp/m-system.collections.que_6_1.cpp)]\n [!code-cs[Classic Queue.Clear Example#1](~/add/codesnippet/csharp/m-system.collections.que_6_1.cs)]\n [!code-vb[Classic Queue.Clear Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_6_1.vb)]"
  syntax:
    content: public virtual void Clear ();
    parameters: []
  overload: System.Collections.Queue.Clear*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Clone
  id: Clone
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Clone()
  nameWithType: Queue.Clone()
  fullName: System.Collections.Queue.Clone()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Cria uma cópia shallow o <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Uma cópia de uma coleção shallow copia apenas os elementos da coleção, se são tipos de referência ou tipos de valor, mas não copia os objetos que consulte as referências. As referências a nova coleção apontam para os objetos do mesmos que as referências na coleção original apontam para.       Em contrapartida, uma cópia profunda de uma coleção copia os elementos e tudo direta ou indiretamente referenciada pelos elementos.       Este método é um Nã (`n`) operação, onde `n` é <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  syntax:
    content: public virtual object Clone ();
    parameters: []
    return:
      type: System.Object
      description: "Uma cópia shallow o <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Contains(System.Object)
  id: Contains(System.Object)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Contains(Object)
  nameWithType: Queue.Contains(Object)
  fullName: System.Collections.Queue.Contains(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Determina se um elemento no <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Este método determina igualdade chamando <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>       Este método efetua uma pesquisa linear; Por conseguinte, este método é um Nã (`n`) operação, onde `n` é <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>       Começando com o .NET Framework 2.0, este método utiliza dos objetos da coleção <xref:System.Object.Equals%2A>e <xref:System.IComparable.CompareTo%2A>métodos em `obj` para determinar se `item` existe.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> Nas versões anteriores do .NET Framework, esta determinação foi efetuada utilizando o <xref:System.Object.Equals%2A>e <xref:System.IComparable.CompareTo%2A>métodos para o `obj` parâmetro nos objetos na coleção.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  syntax:
    content: public virtual bool Contains (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "O <xref:System.Object>Localizar no <xref href=&quot;System.Collections.Queue&quot;> </xref>.</xref:System.Object> O valor pode ser <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>if <code>obj</code> is found in the <xref href=&quot;System.Collections.Queue&quot;></xref>; otherwise, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>."
  overload: System.Collections.Queue.Contains*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.CopyTo(System.Array,System.Int32)
  id: CopyTo(System.Array,System.Int32)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: CopyTo(Array,Int32)
  nameWithType: Queue.CopyTo(Array,Int32)
  fullName: System.Collections.Queue.CopyTo(Array,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Copia o <xref href=&quot;System.Collections.Queue&quot;> </xref> elementos existente unidimensional <xref:System.Array>, começando no índice de matriz especificada.</xref:System.Array>"
  remarks: "Os elementos são copiados para o <xref:System.Array>pela mesma ordem na qual o enumerador itera através de <xref:System.Collections.Queue>.</xref:System.Collections.Queue> </xref:System.Array>       Este método é um Nã (`n`) operação, onde `n` é <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Queue> into a one-dimensional array.  \n  \n [!code-cpp[Classic Queue.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.que_4_1.cpp)]\n [!code-cs[Classic Queue.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.que_4_1.cs)]\n [!code-vb[Classic Queue.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_4_1.vb)]"
  syntax:
    content: public virtual void CopyTo (Array array, int index);
    parameters:
    - id: array
      type: System.Array
      description: "O unidimensional <xref:System.Array>que é o destino dos elementos copiados <xref href=&quot;System.Collections.Queue&quot;> </xref>.</xref:System.Array> O <xref:System.Array>tem de ter a indexação com base em zero.</xref:System.Array>"
    - id: index
      type: System.Int32
      description: "O índice baseado em zero `array` em que copiar começa."
  overload: System.Collections.Queue.CopyTo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>é menor que zero."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>é multidimensional.       - ou - o número de elementos na origem de <xref href=&quot;System.Collections.Queue&quot;> </xref> é superior ao espaço disponível desde o <code>index</code> ao fim do destino <code>array</code>."
  - type: System.ArrayTypeMismatchException
    commentId: T:System.ArrayTypeMismatchException
    description: "O tipo da origem de <xref href=&quot;System.Collections.Queue&quot;> </xref> não pode ser convertido automaticamente para o tipo de destino <code> array </code>."
  platform:
  - net462
- uid: System.Collections.Queue.Count
  id: Count
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Count
  nameWithType: Queue.Count
  fullName: System.Collections.Queue.Count
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Obtém o número de elementos contidos no <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "A capacidade de um <xref:System.Collections.Queue>é o número de elementos que o <xref:System.Collections.Queue>pode armazenar.</xref:System.Collections.Queue> </xref:System.Collections.Queue> Contagem é o número de elementos que estão realmente a ser <xref:System.Collections.Queue>.</xref:System.Collections.Queue>       A capacidade de um <xref:System.Collections.Queue>sempre é maior que ou igual à contagem.</xref:System.Collections.Queue> Se a contagem de excede a capacidade ao adicionar elementos, a capacidade é automaticamente aumentada por reallocating matriz interna antes de copiar os elementos antigos e adição de novos elementos. A nova capacidade é determinada pelo multiplicando a capacidade atual, o fator de crescimento, que é determinado quando o <xref:System.Collections.Queue>é construído.</xref:System.Collections.Queue> A capacidade dos <xref:System.Collections.Queue>sempre irá aumentar por um valor mínimo, independentemente do fator de crescimento; um fator de crescimento de 1.0 não irá impedir que o <xref:System.Collections.Queue>de aumentar de tamanho.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       A capacidade pode ser diminuída chamando <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>       Obter o valor desta propriedade é uma operação de O(1)."
  syntax:
    content: public virtual int Count { get; }
    return:
      type: System.Int32
      description: "O número de elementos contidos no <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.Count*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Dequeue
  id: Dequeue
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Dequeue()
  nameWithType: Queue.Dequeue()
  fullName: System.Collections.Queue.Dequeue()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Remove e devolve o objeto no início do <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Este método é semelhante para o <xref:System.Collections.Queue.Peek%2A>método, mas <xref:System.Collections.Queue.Peek%2A>não modificar <xref:System.Collections.Queue>.</xref:System.Collections.Queue> </xref:System.Collections.Queue.Peek%2A> </xref:System.Collections.Queue.Peek%2A>       `null`pode ser adicionada para o <xref:System.Collections.Queue>como um valor.</xref:System.Collections.Queue> Para distinguir entre um valor nulo e o fim do <xref:System.Collections.Queue>, verifique o <xref:System.Collections.Queue.Count%2A>propriedade ou catch o <xref:System.InvalidOperationException>, que é acionada quando o <xref:System.Collections.Queue>está vazia.</xref:System.Collections.Queue> </xref:System.InvalidOperationException> </xref:System.Collections.Queue.Count%2A> </xref:System.Collections.Queue>       Este método é uma operação de O(1)."
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Queue>, remove elements from the <xref:System.Collections.Queue>, or view the element at the beginning of the <xref:System.Collections.Queue>.  \n  \n [!code-vb[Classic Queue.Enqueue Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_0_1.vb)]\n [!code-cs[Classic Queue.Enqueue Example#1](~/add/codesnippet/csharp/m-system.collections.que_0_1.cs)]\n [!code-cpp[Classic Queue.Enqueue Example#1](~/add/codesnippet/cpp/m-system.collections.que_0_1.cpp)]"
  syntax:
    content: public virtual object Dequeue ();
    parameters: []
    return:
      type: System.Object
      description: "O objeto que é removido do início do <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.Dequeue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O <xref href=&quot;System.Collections.Queue&quot;> </xref> está vazio."
  platform:
  - net462
- uid: System.Collections.Queue.Enqueue(System.Object)
  id: Enqueue(System.Object)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Enqueue(Object)
  nameWithType: Queue.Enqueue(Object)
  fullName: System.Collections.Queue.Enqueue(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Adiciona um objeto ao fim do <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "A capacidade de um <xref:System.Collections.Queue>é o número de elementos a <xref:System.Collections.Queue>pode conter.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  Elementos são adicionadas a um <xref:System.Collections.Queue>, a capacidade é aumentada automaticamente conforme necessário, através da reatribuição.</xref:System.Collections.Queue>  A capacidade pode ser diminuída chamando <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>       O fator de crescimento é o número pelo qual a capacidade atual se multiplica quando não é necessária uma maior capacidade.  O fator de crescimento é determinado quando o <xref:System.Collections.Queue>é construído.</xref:System.Collections.Queue> A capacidade dos <xref:System.Collections.Queue>sempre irá aumentar por um valor mínimo, independentemente do fator de crescimento; um fator de crescimento de 1.0 não irá impedir que o <xref:System.Collections.Queue>de aumentar de tamanho.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       Se <xref:System.Collections.Queue.Count%2A>é inferior à capacidade de matriz interna, este método é uma operação O(1).</xref:System.Collections.Queue.Count%2A> Se tem de ser reatribuída para acomodar o novo elemento de matriz interna, este método torna-se um Nã (`n`) operação, onde `n` é <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Queue>, remove elements from the <xref:System.Collections.Queue>, or view the element at the beginning of the <xref:System.Collections.Queue>.  \n  \n [!code-vb[Classic Queue.Enqueue Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_5_1.vb)]\n [!code-cs[Classic Queue.Enqueue Example#1](~/add/codesnippet/csharp/m-system.collections.que_5_1.cs)]\n [!code-cpp[Classic Queue.Enqueue Example#1](~/add/codesnippet/cpp/m-system.collections.que_5_1.cpp)]"
  syntax:
    content: public virtual void Enqueue (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "O objeto a adicionar o <xref href=&quot;System.Collections.Queue&quot;> </xref>. O valor pode ser <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Queue.Enqueue*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.GetEnumerator
  id: GetEnumerator
  parent: System.Collections.Queue
  langs:
  - csharp
  name: GetEnumerator()
  nameWithType: Queue.GetEnumerator()
  fullName: System.Collections.Queue.GetEnumerator()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Devolve um enumerador que itera através de <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "O `foreach` declaração do Estado de linguagem c# (`for each` no Visual Basic) oculta a complexidade dos enumeradores.  Por conseguinte, utilizando `foreach` recomenda-se, em vez de manipular diretamente o enumerador.       Enumeradores podem ser utilizados para ler os dados da coleção, mas não pode ser utilizados para modificar a colecção subjacente.       Inicialmente, o enumerador está posicionado antes do primeiro elemento da coleção. <xref:System.Collections.IEnumerator.Reset%2A>também oferece o enumerador novamente para nesta posição.</xref:System.Collections.IEnumerator.Reset%2A>  Nesta posição <xref:System.Collections.IEnumerator.Current%2A>não está definido.</xref:System.Collections.IEnumerator.Current%2A> Por conseguinte, tem de chamar <xref:System.Collections.IEnumerator.MoveNext%2A>para avançar o enumerador para o primeiro elemento da coleção de antes de ler o valor de <xref:System.Collections.IEnumerator.Current%2A>.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A>       <xref:System.Collections.IEnumerator.Current%2A>Devolve o mesmo objeto até ser <xref:System.Collections.IEnumerator.MoveNext%2A>ou <xref:System.Collections.IEnumerator.Reset%2A>é chamado.</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A></xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>Define <xref:System.Collections.IEnumerator.Current%2A>para o próximo elemento.</xref:System.Collections.IEnumerator.Current%2A></xref:System.Collections.IEnumerator.MoveNext%2A>       Se <xref:System.Collections.IEnumerator.MoveNext%2A>transmite o fim da coleção, o enumerador está posicionado após o último elemento da coleção e <xref:System.Collections.IEnumerator.MoveNext%2A>devolve `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> Quando o enumerador está nesta posição, as chamadas subsequentes para <xref:System.Collections.IEnumerator.MoveNext%2A>também devolvem `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> Se a última chamada para <xref:System.Collections.IEnumerator.MoveNext%2A>devolvido `false`, <xref:System.Collections.IEnumerator.Current%2A>não está definido.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> Para definir <xref:System.Collections.IEnumerator.Current%2A>para o primeiro elemento da coleção, pode chamar <xref:System.Collections.IEnumerator.Reset%2A>seguido <xref:System.Collections.IEnumerator.MoveNext%2A>.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.Current%2A>       Um enumerador permanece válido desde que a coleção permanece inalterada. Caso sejam feitas alterações à coleção, como adicionar, modificar ou eliminar elementos, o enumerador está irrevogavelmente inválido e o respetivo comportamento não está definido.       O enumerador não tem acesso exclusivo à coleção; Por conseguinte, a enumerar através de uma coleção intrinsecamente não é um procedimento seguro para thread.  Para garantir a segurança de thread durante a enumeração, pode bloquear a coleção durante a enumeração de toda.  Para permitir a coleção ser acedido por vários threads para ler e escrever, tem de implementar a seus próprios sincronização.       Este método é uma operação de O(1)."
  syntax:
    content: public virtual System.Collections.IEnumerator GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IEnumerator
      description: "An <xref:System.Collections.IEnumerator> for the <xref href=&quot;System.Collections.Queue&quot;></xref>.</xref:System.Collections.IEnumerator>"
  overload: System.Collections.Queue.GetEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.IsSynchronized
  id: IsSynchronized
  parent: System.Collections.Queue
  langs:
  - csharp
  name: IsSynchronized
  nameWithType: Queue.IsSynchronized
  fullName: System.Collections.Queue.IsSynchronized
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Obtém um valor que indica se o acesso à <xref href=&quot;System.Collections.Queue&quot;> </xref> é sincronizado (seguros para threads)."
  remarks: "Para garantir a segurança de thread do <xref:System.Collections.Queue>, todas as operações tem de ser efetuadas através de wrapper devolvido pelo <xref:System.Collections.Queue.Synchronized%2A>método.</xref:System.Collections.Queue.Synchronized%2A> </xref:System.Collections.Queue>       Enumerar através de uma coleção intrinsecamente não é um procedimento seguro para thread. Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz com que o enumerador acionar uma excepção. Para garantir a segurança de thread durante a enumeração, pode bloquear a coleção durante a enumeração de toda ou detetar exceções resultantes das alterações efetuadas por outros threads."
  example:
  - "The following code example shows how to lock the collection using the <xref:System.Collections.Queue.SyncRoot%2A> during the entire enumeration. Retrieving the value of this property is an O(1) operation.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/cpp/p-system.collections.que_0_1.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/csharp/p-system.collections.que_0_1.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/visualbasic/p-system.collections.que_0_1.vb)]  \n  \n The following example shows how to synchronize a <xref:System.Collections.Queue>, determine if a <xref:System.Collections.Queue> is synchronized, and use a synchronized <xref:System.Collections.Queue>.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/cpp/p-system.collections.que_0_2.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/csharp/p-system.collections.que_0_2.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/visualbasic/p-system.collections.que_0_2.vb)]"
  syntax:
    content: public virtual bool IsSynchronized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o acesso à <xref href=&quot;System.Collections.Queue&quot;> </xref> é sincronizado (seguros para threads); caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. A predefinição é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Queue.IsSynchronized*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Peek
  id: Peek
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Peek()
  nameWithType: Queue.Peek()
  fullName: System.Collections.Queue.Peek()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Devolve o objeto no início do <xref href=&quot;System.Collections.Queue&quot;> </xref> sem a remover."
  remarks: "Este método é semelhante para o <xref:System.Collections.Queue.Dequeue%2A>método, mas observar não modificar <xref:System.Collections.Queue>.</xref:System.Collections.Queue> </xref:System.Collections.Queue.Dequeue%2A>       `null`pode ser adicionada para o <xref:System.Collections.Queue>como um valor.</xref:System.Collections.Queue> Para distinguir entre um valor nulo e o fim do <xref:System.Collections.Queue>, verifique o <xref:System.Collections.Queue.Count%2A>propriedade ou catch o <xref:System.InvalidOperationException>, que é acionada quando o <xref:System.Collections.Queue>está vazia.</xref:System.Collections.Queue> </xref:System.InvalidOperationException> </xref:System.Collections.Queue.Count%2A> </xref:System.Collections.Queue>       Este método é uma operação de O(1)."
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Queue>, remove elements from the <xref:System.Collections.Queue>, or view the element at the beginning of the <xref:System.Collections.Queue>.  \n  \n [!code-vb[Classic Queue.Enqueue Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_1_1.vb)]\n [!code-cs[Classic Queue.Enqueue Example#1](~/add/codesnippet/csharp/m-system.collections.que_1_1.cs)]\n [!code-cpp[Classic Queue.Enqueue Example#1](~/add/codesnippet/cpp/m-system.collections.que_1_1.cpp)]"
  syntax:
    content: public virtual object Peek ();
    parameters: []
    return:
      type: System.Object
      description: "O objeto no início do <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.Peek*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O <xref href=&quot;System.Collections.Queue&quot;> </xref> está vazio."
  platform:
  - net462
- uid: System.Collections.Queue.Synchronized(System.Collections.Queue)
  id: Synchronized(System.Collections.Queue)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Synchronized(Queue)
  nameWithType: Queue.Synchronized(Queue)
  fullName: System.Collections.Queue.Synchronized(Queue)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Devolve um novo <xref href=&quot;System.Collections.Queue&quot;> </xref> que encapsula num wrapper a fila original, não sendo seguros para threads."
  remarks: "O dispositivo de moldagem devolvido por este método bloqueia a fila antes que seja efetuada uma operação para que é executado de forma segura para os threads.       Para garantir a segurança de thread do <xref:System.Collections.Queue>, todas as operações tem de ser efetuadas através deste wrapper apenas.</xref:System.Collections.Queue>       Enumerar através de uma coleção intrinsecamente não é um procedimento seguro para thread. Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz com que o enumerador acionar uma excepção. Para garantir a segurança de thread durante a enumeração, pode bloquear a coleção durante a enumeração de toda ou detetar exceções resultantes das alterações efetuadas por outros threads."
  example:
  - "The following code example shows how to lock the collection using the <xref:System.Collections.Queue.SyncRoot%2A> during the entire enumeration. This method is an O(1) operation.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/cpp/m-system.collections.que_3_1.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/csharp/m-system.collections.que_3_1.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/visualbasic/m-system.collections.que_3_1.vb)]  \n  \n The following example shows how to synchronize a <xref:System.Collections.Queue>, determine if a <xref:System.Collections.Queue> is synchronized and use a synchronized <xref:System.Collections.Queue>.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/cpp/m-system.collections.que_3_2.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/csharp/m-system.collections.que_3_2.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_3_2.vb)]"
  syntax:
    content: public static System.Collections.Queue Synchronized (System.Collections.Queue queue);
    parameters:
    - id: queue
      type: System.Collections.Queue
      description: "O <xref href=&quot;System.Collections.Queue&quot;> </xref> a sincronizar."
    return:
      type: System.Collections.Queue
      description: "A <xref href=&quot;System.Collections.Queue&quot;> </xref> wrapper que seja sincronizado (seguros para threads)."
  overload: System.Collections.Queue.Synchronized*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>queue</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Queue.SyncRoot
  id: SyncRoot
  parent: System.Collections.Queue
  langs:
  - csharp
  name: SyncRoot
  nameWithType: Queue.SyncRoot
  fullName: System.Collections.Queue.SyncRoot
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Obtém um objeto que pode ser utilizado para sincronizar acesso para o <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Para criar uma versão sincronizada a <xref:System.Collections.Queue>, utilize o <xref:System.Collections.Queue.Synchronized%2A>método.</xref:System.Collections.Queue.Synchronized%2A> </xref:System.Collections.Queue> No entanto, as classes derivadas podem fornecer os seus próprios versão sincronizado do <xref:System.Collections.Queue>utilizando a propriedade SyncRoot.</xref:System.Collections.Queue> O código de sincronização tem de efetuar operações em SyncRoot do <xref:System.Collections.Queue>, não diretamente no <xref:System.Collections.Queue>.</xref:System.Collections.Queue> </xref:System.Collections.Queue> Isto assegura um funcionamento correto de coleções que são derivadas de outros objetos. Especificamente, mantém sincronização adequada com outros threads que podem ser simultaneamente modificar o <xref:System.Collections.Queue>objeto.</xref:System.Collections.Queue>       Enumerar através de uma coleção intrinsecamente não é um procedimento seguro para thread. Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz com que o enumerador acionar uma excepção. Para garantir a segurança de thread durante a enumeração, pode bloquear a coleção durante a enumeração de toda ou detetar exceções resultantes das alterações efetuadas por outros threads."
  example:
  - "The following code example shows how to lock the collection using the SyncRoot during the entire enumeration. Retrieving the value of this property is an O(1) operation.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/cpp/p-system.collections.que_1_1.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/csharp/p-system.collections.que_1_1.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/visualbasic/p-system.collections.que_1_1.vb)]"
  syntax:
    content: public virtual object SyncRoot { get; }
    return:
      type: System.Object
      description: "Um objeto que pode ser utilizado para sincronizar acesso para o <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.SyncRoot*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.ToArray
  id: ToArray
  parent: System.Collections.Queue
  langs:
  - csharp
  name: ToArray()
  nameWithType: Queue.ToArray()
  fullName: System.Collections.Queue.ToArray()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Copia o <xref href=&quot;System.Collections.Queue&quot;> </xref> elementos a uma matriz de novo."
  remarks: "O <xref:System.Collections.Queue>não está modificado.</xref:System.Collections.Queue> A ordem dos elementos na matriz da nova é o mesmo que a ordem dos elementos do início do <xref:System.Collections.Queue>ao respetivo fim.</xref:System.Collections.Queue>       Este método é um Nã (`n`) operação, onde `n` é <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Queue> into a one-dimensional array.  \n  \n [!code-cpp[Classic Queue.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.que_2_1.cpp)]\n [!code-cs[Classic Queue.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.que_2_1.cs)]\n [!code-vb[Classic Queue.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_2_1.vb)]"
  syntax:
    content: public virtual object[] ToArray ();
    parameters: []
    return:
      type: System.Object[]
      description: "Uma matriz nova que contém elementos copiados a partir de <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.ToArray*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.TrimToSize
  id: TrimToSize
  parent: System.Collections.Queue
  langs:
  - csharp
  name: TrimToSize()
  nameWithType: Queue.TrimToSize()
  fullName: System.Collections.Queue.TrimToSize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Define a capacidade para o número real de elementos a <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Este método pode ser utilizado para minimizar a memória de uma fila sobrecarga se nenhum novos elementos serão adicionados à fila.       Para repor um <xref:System.Collections.Queue>para o estado inicial, chame o <xref:System.Collections.Queue.Clear%2A>método antes de chamar TrimToSize.</xref:System.Collections.Queue.Clear%2A> </xref:System.Collections.Queue> Trimming vazio <xref:System.Collections.Queue>define a capacidade dos <xref:System.Collections.Queue>para a capacidade predefinida.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       Este método é um Nã (`n`) operação, onde `n` é <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  syntax:
    content: public virtual void TrimToSize ();
    parameters: []
  overload: System.Collections.Queue.TrimToSize*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O <xref href=&quot;System.Collections.Queue&quot;> </xref> é só de leitura."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArrayTypeMismatchException
  isExternal: true
  name: System.ArrayTypeMismatchException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.Collections.Queue.#ctor
  parent: System.Collections.Queue
  isExternal: false
  name: Queue()
  nameWithType: Queue.Queue()
  fullName: System.Collections.Queue.Queue()
- uid: System.Collections.Queue.#ctor(System.Collections.ICollection)
  parent: System.Collections.Queue
  isExternal: false
  name: Queue(ICollection)
  nameWithType: Queue.Queue(ICollection)
  fullName: System.Collections.Queue.Queue(ICollection)
- uid: System.Collections.ICollection
  parent: System.Collections
  isExternal: true
  name: ICollection
  nameWithType: ICollection
  fullName: System.Collections.ICollection
- uid: System.Collections.Queue.#ctor(System.Int32)
  parent: System.Collections.Queue
  isExternal: false
  name: Queue(Int32)
  nameWithType: Queue.Queue(Int32)
  fullName: System.Collections.Queue.Queue(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Collections.Queue.#ctor(System.Int32,System.Single)
  parent: System.Collections.Queue
  isExternal: false
  name: Queue(Int32,Single)
  nameWithType: Queue.Queue(Int32,Single)
  fullName: System.Collections.Queue.Queue(Int32,Single)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: System.Collections.Queue.Clear
  parent: System.Collections.Queue
  isExternal: false
  name: Clear()
  nameWithType: Queue.Clear()
  fullName: System.Collections.Queue.Clear()
- uid: System.Collections.Queue.Clone
  parent: System.Collections.Queue
  isExternal: false
  name: Clone()
  nameWithType: Queue.Clone()
  fullName: System.Collections.Queue.Clone()
- uid: System.Collections.Queue.Contains(System.Object)
  parent: System.Collections.Queue
  isExternal: false
  name: Contains(Object)
  nameWithType: Queue.Contains(Object)
  fullName: System.Collections.Queue.Contains(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Collections.Queue.CopyTo(System.Array,System.Int32)
  parent: System.Collections.Queue
  isExternal: false
  name: CopyTo(Array,Int32)
  nameWithType: Queue.CopyTo(Array,Int32)
  fullName: System.Collections.Queue.CopyTo(Array,Int32)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: System.Collections.Queue.Count
  parent: System.Collections.Queue
  isExternal: false
  name: Count
  nameWithType: Queue.Count
  fullName: System.Collections.Queue.Count
- uid: System.Collections.Queue.Dequeue
  parent: System.Collections.Queue
  isExternal: false
  name: Dequeue()
  nameWithType: Queue.Dequeue()
  fullName: System.Collections.Queue.Dequeue()
- uid: System.Collections.Queue.Enqueue(System.Object)
  parent: System.Collections.Queue
  isExternal: false
  name: Enqueue(Object)
  nameWithType: Queue.Enqueue(Object)
  fullName: System.Collections.Queue.Enqueue(Object)
- uid: System.Collections.Queue.GetEnumerator
  parent: System.Collections.Queue
  isExternal: false
  name: GetEnumerator()
  nameWithType: Queue.GetEnumerator()
  fullName: System.Collections.Queue.GetEnumerator()
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Collections.Queue.IsSynchronized
  parent: System.Collections.Queue
  isExternal: false
  name: IsSynchronized
  nameWithType: Queue.IsSynchronized
  fullName: System.Collections.Queue.IsSynchronized
- uid: System.Collections.Queue.Peek
  parent: System.Collections.Queue
  isExternal: false
  name: Peek()
  nameWithType: Queue.Peek()
  fullName: System.Collections.Queue.Peek()
- uid: System.Collections.Queue.Synchronized(System.Collections.Queue)
  parent: System.Collections.Queue
  isExternal: false
  name: Synchronized(Queue)
  nameWithType: Queue.Synchronized(Queue)
  fullName: System.Collections.Queue.Synchronized(Queue)
- uid: System.Collections.Queue
  parent: System.Collections
  isExternal: false
  name: Queue
  nameWithType: Queue
  fullName: System.Collections.Queue
- uid: System.Collections.Queue.SyncRoot
  parent: System.Collections.Queue
  isExternal: false
  name: SyncRoot
  nameWithType: Queue.SyncRoot
  fullName: System.Collections.Queue.SyncRoot
- uid: System.Collections.Queue.ToArray
  parent: System.Collections.Queue
  isExternal: false
  name: ToArray()
  nameWithType: Queue.ToArray()
  fullName: System.Collections.Queue.ToArray()
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Collections.Queue.TrimToSize
  parent: System.Collections.Queue
  isExternal: false
  name: TrimToSize()
  nameWithType: Queue.TrimToSize()
  fullName: System.Collections.Queue.TrimToSize()
- uid: System.Collections.Queue.#ctor*
  parent: System.Collections.Queue
  isExternal: false
  name: Queue
  nameWithType: Queue.Queue
- uid: System.Collections.Queue.Clear*
  parent: System.Collections.Queue
  isExternal: false
  name: Clear
  nameWithType: Queue.Clear
- uid: System.Collections.Queue.Clone*
  parent: System.Collections.Queue
  isExternal: false
  name: Clone
  nameWithType: Queue.Clone
- uid: System.Collections.Queue.Contains*
  parent: System.Collections.Queue
  isExternal: false
  name: Contains
  nameWithType: Queue.Contains
- uid: System.Collections.Queue.CopyTo*
  parent: System.Collections.Queue
  isExternal: false
  name: CopyTo
  nameWithType: Queue.CopyTo
- uid: System.Collections.Queue.Count*
  parent: System.Collections.Queue
  isExternal: false
  name: Count
  nameWithType: Queue.Count
- uid: System.Collections.Queue.Dequeue*
  parent: System.Collections.Queue
  isExternal: false
  name: Dequeue
  nameWithType: Queue.Dequeue
- uid: System.Collections.Queue.Enqueue*
  parent: System.Collections.Queue
  isExternal: false
  name: Enqueue
  nameWithType: Queue.Enqueue
- uid: System.Collections.Queue.GetEnumerator*
  parent: System.Collections.Queue
  isExternal: false
  name: GetEnumerator
  nameWithType: Queue.GetEnumerator
- uid: System.Collections.Queue.IsSynchronized*
  parent: System.Collections.Queue
  isExternal: false
  name: IsSynchronized
  nameWithType: Queue.IsSynchronized
- uid: System.Collections.Queue.Peek*
  parent: System.Collections.Queue
  isExternal: false
  name: Peek
  nameWithType: Queue.Peek
- uid: System.Collections.Queue.Synchronized*
  parent: System.Collections.Queue
  isExternal: false
  name: Synchronized
  nameWithType: Queue.Synchronized
- uid: System.Collections.Queue.SyncRoot*
  parent: System.Collections.Queue
  isExternal: false
  name: SyncRoot
  nameWithType: Queue.SyncRoot
- uid: System.Collections.Queue.ToArray*
  parent: System.Collections.Queue
  isExternal: false
  name: ToArray
  nameWithType: Queue.ToArray
- uid: System.Collections.Queue.TrimToSize*
  parent: System.Collections.Queue
  isExternal: false
  name: TrimToSize
  nameWithType: Queue.TrimToSize
