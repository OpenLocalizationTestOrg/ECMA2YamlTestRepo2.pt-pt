### YamlMime:ManagedReference
items:
- uid: System.IO.Log.LogStore
  id: LogStore
  children:
  - System.IO.Log.LogStore.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)
  - System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode)
  - System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  - System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  - System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)
  - System.IO.Log.LogStore.Archivable
  - System.IO.Log.LogStore.BaseSequenceNumber
  - System.IO.Log.LogStore.CreateLogArchiveSnapshot
  - System.IO.Log.LogStore.CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)
  - System.IO.Log.LogStore.Delete(System.String)
  - System.IO.Log.LogStore.Dispose
  - System.IO.Log.LogStore.Extents
  - System.IO.Log.LogStore.FreeBytes
  - System.IO.Log.LogStore.Handle
  - System.IO.Log.LogStore.LastSequenceNumber
  - System.IO.Log.LogStore.Length
  - System.IO.Log.LogStore.Policy
  - System.IO.Log.LogStore.SetArchiveTail(System.IO.Log.SequenceNumber)
  - System.IO.Log.LogStore.StreamCount
  langs:
  - csharp
  name: LogStore
  nameWithType: LogStore
  fullName: System.IO.Log.LogStore
  type: Class
  summary: "Representa um armazenamento estruturada em registos."
  remarks: "A <xref:System.IO.Log.LogRecordSequence>classe fornece uma implementação da interface de sequência de registos por cima de um registo de sistema de ficheiros de registo comuns (CLFS).</xref:System.IO.Log.LogRecordSequence> Funciona com a classe de LogStore, que fornece uma interface para diretamente manipulação e a gestão de um ficheiro de registo CLFS. Um arquivo de registo fornece armazenamento apenas de acrescentar um conjunto de extensões de disco. A classe de LogStore representa este tipo de armazenamento e fornece métodos para adicionar e remover contentores, definição de política e a criação de arquivos. Não fornece métodos para leitura a partir do e escrita para o armazenamento; Estes métodos são fornecidos pela <xref:System.IO.Log.LogRecordSequence>classe.</xref:System.IO.Log.LogRecordSequence>       A relação entre a classe de LogStore e <xref:System.IO.Log.LogRecordSequence>classe é semelhante para a relação entre um ficheiro de disco e um <xref:System.IO.FileStream>objeto.</xref:System.IO.FileStream> </xref:System.IO.Log.LogRecordSequence> O ficheiro de disco possibilita o armazenamento real e tem atributos, tais como o comprimento e a hora do último acesso, enquanto o <xref:System.IO.FileStream>objeto fornece uma vista do ficheiro que pode ser utilizado para ler a partir do mesmo e escrita ao mesmo.</xref:System.IO.FileStream> Da mesma forma, a classe de LogStore tem atributos como uma política e uma coleção de extensões de disco e o <xref:System.IO.Log.LogRecordSequence>classe fornece um mecanismo de orientado para o registo de mensagens em fila para ler e escrever dados.</xref:System.IO.Log.LogRecordSequence>       Ao contrário da sequência de registos do ficheiro representada pelo <xref:System.IO.Log.FileRecordSequence>classe, uma instância de LogStore armazena os respetivos dados de uma coleção de extensões de disco, representado pelo <xref:System.IO.Log.LogExtent>instâncias.</xref:System.IO.Log.LogExtent> </xref:System.IO.Log.FileRecordSequence> As extensões numa determinada instância LogStore são todas tamanho uniform e espaço é adicionado à e removido de uma instância de LogStore em incrementos de extensão. Para adicionar e remover as extensões de registo, utilize o <xref:System.IO.Log.LogExtentCollection.Add%2A>e <xref:System.IO.Log.LogExtentCollection.Remove%2A>métodos para a <xref:System.IO.Log.LogExtentCollection>objeto, que pode ser devolvido pelo <xref:System.IO.Log.LogStore.Extents%2A>propriedade.</xref:System.IO.Log.LogStore.Extents%2A> </xref:System.IO.Log.LogExtentCollection> </xref:System.IO.Log.LogExtentCollection.Remove%2A> </xref:System.IO.Log.LogExtentCollection.Add%2A>       Uma instância de LogStore pode ter políticas associadas à mesma. Estes são representados por <xref:System.IO.Log.LogPolicy>instâncias que podem ser devolvidas pelo <xref:System.IO.Log.LogStore.Policy%2A>propriedade.</xref:System.IO.Log.LogStore.Policy%2A> </xref:System.IO.Log.LogPolicy> Uma política dita regras que o registo tentará a seguir, tais como o número máximo de extensões e o tamanho mínimo e instruções crescer ou reduzir o LogStore em determinadas condições. Além disso, pode especificar se uma instância de LogStore pode ser arquivada. As políticas são definidas por registo e são volátil, o que significa que uma vez a cada identificador para o registo estiver fechado, a política já não existe."
  example:
  - "The following example shows how to archive a LogStore to an XML document.  \n  \n [!code-vb[logarchievesnapshot#0](~/add/codesnippet/visualbasic/t-system.io.log.logstore_1.vb)]\n [!code-cs[logarchievesnapshot#0](~/add/codesnippet/csharp/t-system.io.log.logstore_1.cs)]"
  syntax:
    content: 'public sealed class LogStore : IDisposable'
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.Log.LogStore.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)'
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: LogStore(SafeFileHandle)
  nameWithType: LogStore.LogStore(SafeFileHandle)
  fullName: System.IO.Log.LogStore.LogStore(SafeFileHandle)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> classe para o identificador especificado."
  syntax:
    content: public LogStore (Microsoft.Win32.SafeHandles.SafeFileHandle handle);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "Um identificador de ficheiro para o registo de ficheiros que atual <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> encapsula do objeto."
  overload: System.IO.Log.LogStore.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>handle</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Não foi possível vincular o identificador de registo para o conjunto de threads."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para o arquivo de registo especificado é negado pelo sistema operativo."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução de um programa."
  platform:
  - net462
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode)
  id: '#ctor(System.String,System.IO.FileMode)'
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: LogStore(String,FileMode)
  nameWithType: LogStore.LogStore(String,FileMode)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> classe com o caminho especificado e modo."
  remarks: "Utilize este construtor para abrir um arquivo de registos com o caminho especificado e modo. O arquivo está aberto com acesso de leitura/escrita e as partilhas de acesso de leitura.       O `path` parâmetro deve utilizar a seguinte sintaxe: `log:<physical log name>[::<log client name>]` onde `<physical log name>` é um caminho válido para um ficheiro de registo e `<log client name>` é um identificador exclusivo do cliente. Um arquivo de registo deve ser um arquivo de registo físico ou um arquivo de registo virtuais, mas não ambos. Assim que tiver sido criado um arquivo de registos, fisicamente ou virtualmente, continua a ser, pelo que, para o seu período de duração. Um arquivo de registo físico é criado por especificar apenas o nome do registo físico. Um arquivo de registo virtual é criado, especificando o nome do registo físicos e o nome de cliente do registo.       Clientes que partilham o mesmo nome de registo físico partilham a mesma coleção de extensões e a política."
  syntax:
    content: public LogStore (string path, System.IO.FileMode mode);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o ficheiro de base do arquivo do registo para abrir."
    - id: mode
      type: System.IO.FileMode
      description: "Um do <xref href=&quot;System.IO.FileMode&quot;> </xref> valores que determina como abrir ou criar o arquivo."
  overload: System.IO.Log.LogStore.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>é uma cadeia vazia (&quot;&quot;).       - ou - <code>path</code> contém apenas espaços em branco.       - ou - <code>path</code> contém um ou mais carateres inválidos."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>contém um valor inválido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Não é possível localizar o ficheiro."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorre um erro de e/s ao abrir o arquivo de registos."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para o arquivo de registo especificado é negado pelo sistema operativo."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogStore&quot;></xref>não pode ser utilizado porque o componente de sistema de ficheiros de registo comuns (CLFS) necessário não está instalado. Instale o componente CLFS se estiver disponível para a plataforma ou utilize o <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> em vez disso, a classe."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução de um programa."
  platform:
  - net462
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)'
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: LogStore(String,FileMode,FileAccess)
  nameWithType: LogStore.LogStore(String,FileMode,FileAccess)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode,FileAccess)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> classe com o caminho especificado, o modo e o acesso."
  remarks: "Utilize este construtor para abrir um novo arquivo de registo com o caminho especificado, o modo e o acesso. Abrir o arquivo de partilha de acesso de leitura.       O `path` parâmetro deve utilizar a seguinte sintaxe: `log:<physical log name>[::<log client name>]` onde `<physical log name>` é um caminho válido para um ficheiro de registo e `<log client name>` é um identificador exclusivo do cliente. Um arquivo de registo deve ser um arquivo de registo físico ou um arquivo de registo virtuais, mas não ambos. Assim que tiver sido criado um arquivo de registos, fisicamente ou virtualmente, continua a ser, pelo que, para o seu período de duração. Um arquivo de registo físico é criado por especificar apenas o nome do registo físico. Um arquivo de registo virtual é criado, especificando o nome do registo físicos e o nome de cliente do registo.       Clientes que partilham o mesmo nome de registo físico partilham a mesma coleção de extensões e a política."
  syntax:
    content: public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o ficheiro de base do arquivo do registo para abrir."
    - id: mode
      type: System.IO.FileMode
      description: "Um do <xref href=&quot;System.IO.FileMode&quot;> </xref> valores que determina como abrir ou criar o arquivo."
    - id: access
      type: System.IO.FileAccess
      description: "Um do <xref href=&quot;System.IO.FileAccess&quot;> </xref> valores que determina a forma como o ficheiro pode ser acedido pelo <xref href=&quot;System.IO.Log.LogStore&quot;> </xref>."
  overload: System.IO.Log.LogStore.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>é uma cadeia vazia (&quot;&quot;).       - ou - <code>path</code> contém apenas espaços em branco.       - ou - <code>path</code> contém um ou mais carateres inválidos."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>contém um valor inválido.       - ou <code>access</code> contém um valor inválido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Não é possível localizar o ficheiro."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorre um erro de e/s ao abrir o arquivo de registos."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para o arquivo de registo especificado é negado pelo sistema operativo."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogStore&quot;></xref>não pode ser utilizado porque o componente de sistema de ficheiros de registo comuns (CLFS) necessário não está instalado. Instale o componente CLFS se estiver disponível para a plataforma ou utilize o <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> em vez disso, a classe."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução de um programa."
  platform:
  - net462
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)'
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: LogStore(String,FileMode,FileAccess,FileShare)
  nameWithType: LogStore.LogStore(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode,FileAccess,FileShare)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> classe."
  remarks: "Este construtor inicializa uma nova <xref:System.IO.Log.LogStore>objeto abre-se com o caminho especificado, o modo e o acesso.</xref:System.IO.Log.LogStore> Abrir o arquivo de partilha de acesso especificado.       O `path` parâmetro deve utilizar a seguinte sintaxe: `log:<physical log name>[::<log client name>]` onde `<physical log name>` é um caminho válido para um ficheiro de registo e `<log client name>` é um identificador exclusivo do cliente. Um arquivo de registo deve ser um arquivo de registo físico ou um arquivo de registo virtuais, mas não ambos. Assim que tiver sido criado um arquivo de registos, fisicamente ou virtualmente, continua a ser, pelo que, para o seu período de duração. Um arquivo de registo físico é criado por especificar apenas o nome do registo físico. Um arquivo de registo virtual é criado, especificando o nome do registo físicos e o nome de cliente do registo.       Clientes que partilham o mesmo nome de registo físico partilham a mesma coleção de extensões e a política."
  syntax:
    content: public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o ficheiro de base do arquivo do registo para abrir."
    - id: mode
      type: System.IO.FileMode
      description: "Um do <xref href=&quot;System.IO.FileMode&quot;> </xref> valores que determina como abrir ou criar o arquivo."
    - id: access
      type: System.IO.FileAccess
      description: "Um do <xref href=&quot;System.IO.FileAccess&quot;> </xref> valores que determina a forma como o ficheiro pode ser acedido pelo <xref href=&quot;System.IO.Log.LogStore&quot;> </xref>."
    - id: share
      type: System.IO.FileShare
      description: "Um do <xref href=&quot;System.IO.FileShare&quot;> </xref> valores que determina a forma como o arquivo de registo será partilhado entre processos."
  overload: System.IO.Log.LogStore.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>é uma cadeia vazia (&quot;&quot;).       - ou - <code>path</code> contém apenas espaços em branco.       - ou - <code>path</code> contém um ou mais carateres inválidos."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>contém um valor inválido.       - ou <code>access</code> contém um valor inválido.       - ou - <code>share</code> contém um valor inválido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Não é possível localizar o ficheiro."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorre um erro de e/s ao abrir o arquivo de registos."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para o arquivo de registo especificado é negado pelo sistema operativo."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogStore&quot;></xref>não pode ser utilizado porque o componente de sistema de ficheiros de registo comuns (CLFS) necessário não está instalado. Instale o componente CLFS se estiver disponível para a plataforma ou utilize o <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> em vez disso, a classe."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução de um programa."
  platform:
  - net462
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)'
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: LogStore(String,FileMode,FileAccess,FileShare,FileSecurity)
  nameWithType: LogStore.LogStore(String,FileMode,FileAccess,FileShare,FileSecurity)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode,FileAccess,FileShare,FileSecurity)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicializa uma nova instância do <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> classe."
  remarks: "Este construtor inicializa uma nova <xref:System.IO.Log.LogStore>objeto abre-se com o caminho especificado, o modo e o acesso.</xref:System.IO.Log.LogStore> Abrir o arquivo de partilha de acesso especificado. O `path` parâmetro deve seguir a seguinte sintaxe: `log:<physical log name>[::<log client name>]` onde `<physical log name>` é um caminho válido para um ficheiro de registo e `<log client name>` é um identificador exclusivo do cliente. Um arquivo de registo deve ser um arquivo de registo físico ou um arquivo de registo virtuais, mas não ambos. Assim que tiver sido criado um arquivo de registos, fisicamente ou virtualmente, continua a ser, pelo que, para o seu período de duração. Um arquivo de registo físico é criado por especificar apenas o nome do registo físico. Um arquivo de registo virtual é criado, especificando o nome do registo físicos e o nome de cliente do registo.       Clientes que partilham o mesmo nome de registo físico partilham a mesma coleção de extensões e a política."
  syntax:
    content: public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o ficheiro de base do arquivo do registo para abrir."
    - id: mode
      type: System.IO.FileMode
      description: "Um do <xref href=&quot;System.IO.FileMode&quot;> </xref> valores que determina como abrir ou criar o arquivo."
    - id: access
      type: System.IO.FileAccess
      description: "Um do <xref href=&quot;System.IO.FileAccess&quot;> </xref> valores que determina a forma como o ficheiro pode ser acedido pelo <xref href=&quot;System.IO.Log.LogStore&quot;> </xref>."
    - id: share
      type: System.IO.FileShare
      description: "Um do <xref href=&quot;System.IO.FileShare&quot;> </xref> valores que determina a forma como o arquivo de registo será partilhado entre processos."
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "Um do <xref href=&quot;System.Security.AccessControl.FileSecurity&quot;> </xref> valor que especifica a segurança para definir no arquivo recentemente criado, se o arquivo tem de ser criado."
  overload: System.IO.Log.LogStore.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O nome de ficheiro de arquivo de registo especificado pelo <code> path </code> não é válido.       - ou - <code> Mode </code> é <xref uid=&quot;langword_csharp_CreateNew&quot; name=&quot;CreateNew&quot; href=&quot;&quot;> </xref>, que não pode ser utilizada sem acesso de escrita.       - ou - <code> Mode </code> é <xref uid=&quot;langword_csharp_OpenOrCreate&quot; name=&quot;OpenOrCreate&quot; href=&quot;&quot;> </xref>, que não pode ser utilizada sem acesso de escrita."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>contém um valor inválido.       - ou <code>access</code> contém um valor inválido.       - ou - <code>share</code> contém um valor inválido."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Não é possível localizar o ficheiro."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorre um erro de e/s ao abrir o arquivo de registos.       O ficheiro especificado pelo <code> path </code> não pode ser acedida porque está a ser utilizado por outro processo.       - ou - o ficheiro especificado pelo <code> path </code> não é possível criar porque o ficheiro ou diretório já existe.       - ou - não foi possível vincular o identificador de registo para o conjunto de threads.       - ou - a versão ou formato de ficheiro de registo especificado é inválida."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogStore&quot;></xref>não pode ser utilizado porque o componente de sistema de ficheiros de registo comuns (CLFS) necessário não está instalado. Instale o componente CLFS se estiver disponível para a plataforma ou utilize o <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> em vez disso, a classe."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução de um programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para o arquivo de registo especificado é negado pelo sistema operativo."
  platform:
  - net462
- uid: System.IO.Log.LogStore.Archivable
  id: Archivable
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Archivable
  nameWithType: LogStore.Archivable
  fullName: System.IO.Log.LogStore.Archivable
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Obtém um valor que indica se esta <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> instância pode ser arquivada."
  remarks: "Se um <xref:System.IO.Log.LogStore>não é arquivável, as chamadas para o <xref:System.IO.Log.LogStore.CreateLogArchiveSnapshot%2A>e <xref:System.IO.Log.LogStore.SetArchiveTail%2A>métodos resultem num <xref:System.NotSupportedException>que está a ser emitida.</xref:System.NotSupportedException> </xref:System.IO.Log.LogStore.SetArchiveTail%2A> </xref:System.IO.Log.LogStore.CreateLogArchiveSnapshot%2A> </xref:System.IO.Log.LogStore>"
  syntax:
    content: public bool Archivable { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se esta <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> instância pode ser arquivados; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.Log.LogStore.Archivable*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A propriedade foi acedida depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.LogStore.BaseSequenceNumber
  id: BaseSequenceNumber
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: BaseSequenceNumber
  nameWithType: LogStore.BaseSequenceNumber
  fullName: System.IO.Log.LogStore.BaseSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Obtém o menor número de sequência que corresponde a um registo de válido deste <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> instância."
  remarks: "Números de sequência válido são maior que ou igual a BaseSequenceNumber e inferior ao <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>.</xref:System.IO.Log.LogStore.LastSequenceNumber%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "O menor número de sequência que corresponde a um registo válido deste <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> instância."
  overload: System.IO.Log.LogStore.BaseSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A propriedade foi acedida depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.LogStore.CreateLogArchiveSnapshot
  id: CreateLogArchiveSnapshot
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: CreateLogArchiveSnapshot()
  nameWithType: LogStore.CreateLogArchiveSnapshot()
  fullName: System.IO.Log.LogStore.CreateLogArchiveSnapshot()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Tira um instantâneo do Estado de arquivo de registo para efetuar uma cópia de segurança."
  remarks: ''
  example:
  - "The following example shows how to archive a <xref:System.IO.Log.LogStore> to an XML document.  \n  \n [!code-vb[logarchievesnapshot#0](~/add/codesnippet/visualbasic/m-system.io.log.logstore_1_1.vb)]\n [!code-cs[logarchievesnapshot#0](~/add/codesnippet/csharp/m-system.io.log.logstore_1_1.cs)]"
  syntax:
    content: public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot ();
    parameters: []
    return:
      type: System.IO.Log.LogArchiveSnapshot
      description: "A <xref href=&quot;System.IO.Log.LogArchiveSnapshot&quot;> </xref> objeto que contém o estado necessário para disponibilizar um arquivo."
  overload: System.IO.Log.LogStore.CreateLogArchiveSnapshot*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O arquivo de registo não é arquivável."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorre um erro de e/s ao criar o instantâneo de arquivo."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Um argumento não é válido."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Uma operação inválida foi executada."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução de um programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para o arquivo de registo especificado é negado pelo sistema operativo."
  platform:
  - net462
- uid: System.IO.Log.LogStore.CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)
  id: CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: CreateLogArchiveSnapshot(SequenceNumber,SequenceNumber)
  nameWithType: LogStore.CreateLogArchiveSnapshot(SequenceNumber,SequenceNumber)
  fullName: System.IO.Log.LogStore.CreateLogArchiveSnapshot(SequenceNumber,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Tira um instantâneo do Estado de arquivo de registo entre os números de sequência especificado para efetuar uma cópia de segurança."
  remarks: "O instantâneo de arquivo devolvido por este método abrange as informações do número de sequência base ou o número de sequência de arquivo, optando-se inferiores, para o último número de sequência. Não é inclusive para o último número de sequência, o que significa que o arquivo inclui apenas os registos de até mas não incluindo último. Além disso, quando utilizar este método, o início SequenceNumber tem de ser igual do BaseSequenceNumber por ordem para o arquivo estar consistente."
  syntax:
    content: public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot (System.IO.Log.SequenceNumber first, System.IO.Log.SequenceNumber last);
    parameters:
    - id: first
      type: System.IO.Log.SequenceNumber
      description: "O iniciar sequência número no intervalo para arquivar."
    - id: last
      type: System.IO.Log.SequenceNumber
      description: "O fim sequência número no intervalo para arquivar."
    return:
      type: System.IO.Log.LogArchiveSnapshot
      description: "A <xref href=&quot;System.IO.Log.LogArchiveSnapshot&quot;> </xref> objeto que contém o estado necessário para disponibilizar um arquivo."
  overload: System.IO.Log.LogStore.CreateLogArchiveSnapshot*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>first</code>ou <code>last</code> não se situa entre os números de sequência base e final desta sequência."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>first</code>é maior do que <code>last</code>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Uma operação inválida foi executada."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorre um erro de e/s ao criar o instantâneo de arquivo."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O arquivo de registo não é arquivável."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução de um programa."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "A sequência de registos está cheia."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para o arquivo de registo especificado é negado pelo sistema operativo."
  platform:
  - net462
- uid: System.IO.Log.LogStore.Delete(System.String)
  id: Delete(System.String)
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Delete(String)
  nameWithType: LogStore.Delete(String)
  fullName: System.IO.Log.LogStore.Delete(String)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Remove o arquivo de registos."
  syntax:
    content: public static void Delete (string path);
    parameters:
    - id: path
      type: System.String
      description: "Um caminho relativo ou absoluto para o ficheiro de base do arquivo de registo para remover."
  overload: System.IO.Log.LogStore.Delete*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>é uma cadeia vazia (&quot;&quot;).       - ou - <code>path</code> contém apenas espaços em branco.       - ou - <code>path</code> contém um ou mais carateres inválidos."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Não é possível localizar o ficheiro."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorre um erro de e/s ao abrir o arquivo de registos."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para o arquivo de registo especificado é negado pelo sistema operativo."
  platform:
  - net462
- uid: System.IO.Log.LogStore.Dispose
  id: Dispose
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Dispose()
  nameWithType: LogStore.Dispose()
  fullName: System.IO.Log.LogStore.Dispose()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Versões de todos os recursos utilizados pelo <xref href=&quot;System.IO.Log.LogStore&quot;> </xref>."
  remarks: "É possível chamar Dispose quando tiver concluído a utilizar <xref:System.IO.Log.LogStore>.</xref:System.IO.Log.LogStore> O método de Dispose deixa o <xref:System.IO.Log.LogStore>num Estado não utilizável.</xref:System.IO.Log.LogStore> Depois de chamar Dispose, tem de libertar todas as referências para o <xref:System.IO.Log.LogStore>para que o recoletor de lixo pode reclame a memória que a <xref:System.IO.Log.LogStore>foi occupying.</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogStore>      > [!NOTE] > Sempre chamada eliminar antes de libertar a última referência <xref:System.IO.Log.LogStore>.</xref:System.IO.Log.LogStore> Caso contrário, os recursos que está a utilizar não irão ser libertados até que as chamadas de recoletor de lixo a <xref:System.IO.Log.LogStore>do objeto `Finalize` método.</xref:System.IO.Log.LogStore>"
  syntax:
    content: public void Dispose ();
    parameters: []
  overload: System.IO.Log.LogStore.Dispose*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.LogStore.Extents
  id: Extents
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Extents
  nameWithType: LogStore.Extents
  fullName: System.IO.Log.LogStore.Extents
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Obtém a coleção de extensões de registo que contêm os dados para este arquivo de registo."
  remarks: "A <xref:System.IO.Log.LogStore>instância armazena os respetivos dados de uma coleção de extensões de disco, representado pelo <xref:System.IO.Log.LogExtent>instâncias.</xref:System.IO.Log.LogExtent> </xref:System.IO.Log.LogStore> As extensões num determinado <xref:System.IO.Log.LogStore>instância são todas tamanho uniform e espaço é adicionado à e removido um <xref:System.IO.Log.LogStore>instância em incrementos de extensão.</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogStore> Para adicionar e remover as extensões de registo, utilize o <xref:System.IO.Log.LogExtentCollection.Add%2A>e<xref:System.IO.Log.LogExtentCollection.Remove%2A> métodos para a <xref:System.IO.Log.LogExtentCollection>objeto, que é devolvido por esta propriedade.</xref:System.IO.Log.LogExtentCollection> </xref:System.IO.Log.LogExtentCollection.Remove%2A> </xref:System.IO.Log.LogExtentCollection.Add%2A>"
  syntax:
    content: public System.IO.Log.LogExtentCollection Extents { get; }
    return:
      type: System.IO.Log.LogExtentCollection
      description: "A <xref href=&quot;System.IO.Log.LogExtentCollection&quot;> </xref> instância que contém a coleção de extensões de registo que contém dados para este arquivo de registo."
  overload: System.IO.Log.LogStore.Extents*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogStore.FreeBytes
  id: FreeBytes
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: FreeBytes
  nameWithType: LogStore.FreeBytes
  fullName: System.IO.Log.LogStore.FreeBytes
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Obtém o número de bytes disponíveis no arquivo de registo."
  syntax:
    content: public long FreeBytes { get; }
    return:
      type: System.Int64
      description: "O número de bytes disponíveis no arquivo de registo."
  overload: System.IO.Log.LogStore.FreeBytes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A propriedade foi acedida depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.LogStore.Handle
  id: Handle
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Handle
  nameWithType: LogStore.Handle
  fullName: System.IO.Log.LogStore.Handle
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Obtém o identificador de ficheiro de sistema operativo para o registo de ficheiros que atual <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> encapsula de instância."
  syntax:
    content: public Microsoft.Win32.SafeHandles.SafeFileHandle Handle { get; }
    return:
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "O identificador de ficheiro de sistema operativo para o registo de ficheiros que atual <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> encapsula de instância."
  overload: System.IO.Log.LogStore.Handle*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogStore.LastSequenceNumber
  id: LastSequenceNumber
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: LastSequenceNumber
  nameWithType: LogStore.LastSequenceNumber
  fullName: System.IO.Log.LogStore.LastSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Quando substituí-lo de uma classe derivada, obtém o número de sequência de registo seguinte para anexado ao arquivo de registo."
  remarks: "Números de sequência válido são maior que ou igual a <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A>e inferior ao LastSequenceNumber.</xref:System.IO.Log.LogStore.BaseSequenceNumber%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber LastSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência de registo seguinte para anexado ao arquivo de registo."
  overload: System.IO.Log.LogStore.LastSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A propriedade foi acedida depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.LogStore.Length
  id: Length
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Length
  nameWithType: LogStore.Length
  fullName: System.IO.Log.LogStore.Length
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Obtém o tamanho do arquivo de registo, em bytes."
  remarks: "O tamanho do arquivo do registo é a soma de tamanhos das extensões de registo."
  syntax:
    content: public long Length { get; }
    return:
      type: System.Int64
      description: "O tamanho do arquivo de registo, em bytes."
  overload: System.IO.Log.LogStore.Length*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "A propriedade foi acedida depois da sequência foi eliminada do."
  platform:
  - net462
- uid: System.IO.Log.LogStore.Policy
  id: Policy
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Policy
  nameWithType: LogStore.Policy
  fullName: System.IO.Log.LogStore.Policy
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Obtém a política associada este arquivo de registo."
  remarks: "Pode utilizar a <xref:System.IO.Log.LogPolicy>instância devolvida por esta propriedade para examinar e manipular a política de registo associados a este <xref:System.IO.Log.LogStore>.</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogPolicy>"
  syntax:
    content: public System.IO.Log.LogPolicy Policy { get; }
    return:
      type: System.IO.Log.LogPolicy
      description: "A <xref href=&quot;System.IO.Log.LogPolicy&quot;> </xref> instância que representa a política associada este arquivo de registo."
  overload: System.IO.Log.LogStore.Policy*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogStore.SetArchiveTail(System.IO.Log.SequenceNumber)
  id: SetArchiveTail(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: SetArchiveTail(SequenceNumber)
  nameWithType: LogStore.SetArchiveTail(SequenceNumber)
  fullName: System.IO.Log.LogStore.SetArchiveTail(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Define o número de sequência do seguimento de arquivo."
  remarks: "O menor do número de sequência base e o seguimento de arquivo-determina a cauda do registo."
  example:
  - "The following example shows how to archive a <xref:System.IO.Log.LogStore> to an XML document.  \n  \n [!code-vb[logarchievesnapshot#0](~/add/codesnippet/visualbasic/m-system.io.log.logstore_0_1.vb)]\n [!code-cs[logarchievesnapshot#0](~/add/codesnippet/csharp/m-system.io.log.logstore_0_1.cs)]"
  syntax:
    content: public void SetArchiveTail (System.IO.Log.SequenceNumber archiveTail);
    parameters:
    - id: archiveTail
      type: System.IO.Log.SequenceNumber
      description: "O número de sequência do seguimento de arquivo."
  overload: System.IO.Log.LogStore.SetArchiveTail*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>archiveTail</code>não se encontra entre os números de sequência base e final desta sequência."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>archiveTail</code>Não é válido para esta sequência."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Uma operação inválida foi executada."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ocorre um erro de e/s ao criar o instantâneo de arquivo."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "O arquivo de registo não é arquivável."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "O método foi chamado depois da sequência foi eliminada do."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Não há memória suficiente para continuar a execução de um programa."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Acesso para o arquivo de registo especificado é negado pelo sistema operativo."
  platform:
  - net462
- uid: System.IO.Log.LogStore.StreamCount
  id: StreamCount
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: StreamCount
  nameWithType: LogStore.StreamCount
  fullName: System.IO.Log.LogStore.StreamCount
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Obtém o número de fluxos de registo neste arquivo de registo."
  syntax:
    content: public int StreamCount { get; }
    return:
      type: System.Int32
      description: "O número de fluxos de registo neste arquivo de registo."
  overload: System.IO.Log.LogStore.StreamCount*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.IO.Log.SequenceFullException
  parent: System.IO.Log
  isExternal: false
  name: SequenceFullException
  nameWithType: SequenceFullException
  fullName: System.IO.Log.SequenceFullException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.IO.Log.LogStore.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LogStore(SafeFileHandle)
  nameWithType: LogStore.LogStore(SafeFileHandle)
  fullName: System.IO.Log.LogStore.LogStore(SafeFileHandle)
- uid: Microsoft.Win32.SafeHandles.SafeFileHandle
  parent: Microsoft.Win32.SafeHandles
  isExternal: false
  name: SafeFileHandle
  nameWithType: SafeFileHandle
  fullName: Microsoft.Win32.SafeHandles.SafeFileHandle
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LogStore(String,FileMode)
  nameWithType: LogStore.LogStore(String,FileMode)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.IO.FileMode
  parent: System.IO
  isExternal: false
  name: FileMode
  nameWithType: FileMode
  fullName: System.IO.FileMode
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LogStore(String,FileMode,FileAccess)
  nameWithType: LogStore.LogStore(String,FileMode,FileAccess)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LogStore(String,FileMode,FileAccess,FileShare)
  nameWithType: LogStore.LogStore(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode,FileAccess,FileShare)
- uid: System.IO.FileShare
  parent: System.IO
  isExternal: false
  name: FileShare
  nameWithType: FileShare
  fullName: System.IO.FileShare
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LogStore(String,FileMode,FileAccess,FileShare,FileSecurity)
  nameWithType: LogStore.LogStore(String,FileMode,FileAccess,FileShare,FileSecurity)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode,FileAccess,FileShare,FileSecurity)
- uid: System.Security.AccessControl.FileSecurity
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSecurity
  nameWithType: FileSecurity
  fullName: System.Security.AccessControl.FileSecurity
- uid: System.IO.Log.LogStore.Archivable
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Archivable
  nameWithType: LogStore.Archivable
  fullName: System.IO.Log.LogStore.Archivable
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.Log.LogStore.BaseSequenceNumber
  parent: System.IO.Log.LogStore
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: LogStore.BaseSequenceNumber
  fullName: System.IO.Log.LogStore.BaseSequenceNumber
- uid: System.IO.Log.SequenceNumber
  parent: System.IO.Log
  isExternal: false
  name: SequenceNumber
  nameWithType: SequenceNumber
  fullName: System.IO.Log.SequenceNumber
- uid: System.IO.Log.LogStore.CreateLogArchiveSnapshot
  parent: System.IO.Log.LogStore
  isExternal: false
  name: CreateLogArchiveSnapshot()
  nameWithType: LogStore.CreateLogArchiveSnapshot()
  fullName: System.IO.Log.LogStore.CreateLogArchiveSnapshot()
- uid: System.IO.Log.LogArchiveSnapshot
  parent: System.IO.Log
  isExternal: false
  name: LogArchiveSnapshot
  nameWithType: LogArchiveSnapshot
  fullName: System.IO.Log.LogArchiveSnapshot
- uid: System.IO.Log.LogStore.CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: CreateLogArchiveSnapshot(SequenceNumber,SequenceNumber)
  nameWithType: LogStore.CreateLogArchiveSnapshot(SequenceNumber,SequenceNumber)
  fullName: System.IO.Log.LogStore.CreateLogArchiveSnapshot(SequenceNumber,SequenceNumber)
- uid: System.IO.Log.LogStore.Delete(System.String)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Delete(String)
  nameWithType: LogStore.Delete(String)
  fullName: System.IO.Log.LogStore.Delete(String)
- uid: System.IO.Log.LogStore.Dispose
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Dispose()
  nameWithType: LogStore.Dispose()
  fullName: System.IO.Log.LogStore.Dispose()
- uid: System.IO.Log.LogStore.Extents
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Extents
  nameWithType: LogStore.Extents
  fullName: System.IO.Log.LogStore.Extents
- uid: System.IO.Log.LogExtentCollection
  parent: System.IO.Log
  isExternal: false
  name: LogExtentCollection
  nameWithType: LogExtentCollection
  fullName: System.IO.Log.LogExtentCollection
- uid: System.IO.Log.LogStore.FreeBytes
  parent: System.IO.Log.LogStore
  isExternal: false
  name: FreeBytes
  nameWithType: LogStore.FreeBytes
  fullName: System.IO.Log.LogStore.FreeBytes
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.Log.LogStore.Handle
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Handle
  nameWithType: LogStore.Handle
  fullName: System.IO.Log.LogStore.Handle
- uid: System.IO.Log.LogStore.LastSequenceNumber
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LastSequenceNumber
  nameWithType: LogStore.LastSequenceNumber
  fullName: System.IO.Log.LogStore.LastSequenceNumber
- uid: System.IO.Log.LogStore.Length
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Length
  nameWithType: LogStore.Length
  fullName: System.IO.Log.LogStore.Length
- uid: System.IO.Log.LogStore.Policy
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Policy
  nameWithType: LogStore.Policy
  fullName: System.IO.Log.LogStore.Policy
- uid: System.IO.Log.LogPolicy
  parent: System.IO.Log
  isExternal: false
  name: LogPolicy
  nameWithType: LogPolicy
  fullName: System.IO.Log.LogPolicy
- uid: System.IO.Log.LogStore.SetArchiveTail(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: SetArchiveTail(SequenceNumber)
  nameWithType: LogStore.SetArchiveTail(SequenceNumber)
  fullName: System.IO.Log.LogStore.SetArchiveTail(SequenceNumber)
- uid: System.IO.Log.LogStore.StreamCount
  parent: System.IO.Log.LogStore
  isExternal: false
  name: StreamCount
  nameWithType: LogStore.StreamCount
  fullName: System.IO.Log.LogStore.StreamCount
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.Log.LogStore.#ctor*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LogStore
  nameWithType: LogStore.LogStore
- uid: System.IO.Log.LogStore.Archivable*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Archivable
  nameWithType: LogStore.Archivable
- uid: System.IO.Log.LogStore.BaseSequenceNumber*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: LogStore.BaseSequenceNumber
- uid: System.IO.Log.LogStore.CreateLogArchiveSnapshot*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: CreateLogArchiveSnapshot
  nameWithType: LogStore.CreateLogArchiveSnapshot
- uid: System.IO.Log.LogStore.Delete*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Delete
  nameWithType: LogStore.Delete
- uid: System.IO.Log.LogStore.Dispose*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Dispose
  nameWithType: LogStore.Dispose
- uid: System.IO.Log.LogStore.Extents*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Extents
  nameWithType: LogStore.Extents
- uid: System.IO.Log.LogStore.FreeBytes*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: FreeBytes
  nameWithType: LogStore.FreeBytes
- uid: System.IO.Log.LogStore.Handle*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Handle
  nameWithType: LogStore.Handle
- uid: System.IO.Log.LogStore.LastSequenceNumber*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LastSequenceNumber
  nameWithType: LogStore.LastSequenceNumber
- uid: System.IO.Log.LogStore.Length*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Length
  nameWithType: LogStore.Length
- uid: System.IO.Log.LogStore.Policy*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Policy
  nameWithType: LogStore.Policy
- uid: System.IO.Log.LogStore.SetArchiveTail*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: SetArchiveTail
  nameWithType: LogStore.SetArchiveTail
- uid: System.IO.Log.LogStore.StreamCount*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: StreamCount
  nameWithType: LogStore.StreamCount
