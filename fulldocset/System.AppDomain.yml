### YamlMime:ManagedReference
items:
- uid: System.AppDomain
  id: AppDomain
  children:
  - System.AppDomain.ActivationContext
  - System.AppDomain.AppendPrivatePath(System.String)
  - System.AppDomain.ApplicationIdentity
  - System.AppDomain.ApplicationTrust
  - System.AppDomain.ApplyPolicy(System.String)
  - System.AppDomain.AssemblyLoad
  - System.AppDomain.AssemblyResolve
  - System.AppDomain.BaseDirectory
  - System.AppDomain.ClearPrivatePath
  - System.AppDomain.ClearShadowCopyPath
  - System.AppDomain.CreateComInstanceFrom(System.String,System.String)
  - System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  - System.AppDomain.CreateDomain(System.String)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  - System.AppDomain.CreateInstance(System.String,System.String)
  - System.AppDomain.CreateInstance(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CreateInstanceFrom(System.String,System.String)
  - System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CurrentDomain
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  - System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)
  - System.AppDomain.DomainManager
  - System.AppDomain.DomainUnload
  - System.AppDomain.DynamicDirectory
  - System.AppDomain.Evidence
  - System.AppDomain.ExecuteAssembly(System.String)
  - System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.ExecuteAssembly(System.String,System.String[])
  - System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  - System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  - System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  - System.AppDomain.ExecuteAssemblyByName(System.String)
  - System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  - System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])
  - System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  - System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  - System.AppDomain.FirstChanceException
  - System.AppDomain.FriendlyName
  - System.AppDomain.GetAssemblies
  - System.AppDomain.GetCurrentThreadId
  - System.AppDomain.GetData(System.String)
  - System.AppDomain.GetType
  - System.AppDomain.Id
  - System.AppDomain.InitializeLifetimeService
  - System.AppDomain.IsCompatibilitySwitchSet(System.String)
  - System.AppDomain.IsDefaultAppDomain
  - System.AppDomain.IsFinalizingForUnload
  - System.AppDomain.IsFullyTrusted
  - System.AppDomain.IsHomogenous
  - System.AppDomain.Load(System.Byte[])
  - System.AppDomain.Load(System.Reflection.AssemblyName)
  - System.AppDomain.Load(System.String)
  - System.AppDomain.Load(System.Byte[],System.Byte[])
  - System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  - System.AppDomain.Load(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  - System.AppDomain.MonitoringIsEnabled
  - System.AppDomain.MonitoringSurvivedMemorySize
  - System.AppDomain.MonitoringSurvivedProcessMemorySize
  - System.AppDomain.MonitoringTotalAllocatedMemorySize
  - System.AppDomain.MonitoringTotalProcessorTime
  - System.AppDomain.PermissionSet
  - System.AppDomain.ProcessExit
  - System.AppDomain.ReflectionOnlyAssemblyResolve
  - System.AppDomain.ReflectionOnlyGetAssemblies
  - System.AppDomain.RelativeSearchPath
  - System.AppDomain.ResourceResolve
  - System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  - System.AppDomain.SetCachePath(System.String)
  - System.AppDomain.SetData(System.String,System.Object)
  - System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)
  - System.AppDomain.SetDynamicBase(System.String)
  - System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  - System.AppDomain.SetShadowCopyFiles
  - System.AppDomain.SetShadowCopyPath(System.String)
  - System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)
  - System.AppDomain.SetupInformation
  - System.AppDomain.ShadowCopyFiles
  - System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  - System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  - System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  - System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  - System.AppDomain.ToString
  - System.AppDomain.TypeResolve
  - System.AppDomain.UnhandledException
  - System.AppDomain.Unload(System.AppDomain)
  langs:
  - csharp
  name: AppDomain
  nameWithType: AppDomain
  fullName: System.AppDomain
  type: Class
  summary: "Representa um domínio de aplicação, o que é um ambiente isolado onde executar aplicações. Esta classe não pode ser herdada."
  remarks: "Domínios de aplicação, são representados por objetos de AppDomain, ajudam a fornecer os limites de isolamento, descarregar e segurança para executar código gerido.      -Utilize domínios de aplicação para isolar as tarefas que podem colocar para baixo de um processo. Se o estado do AppDomain que está a executar uma tarefa torna-se instável, AppDomain pode ser descarregado sem afetar o processo. Isto é importante quando um processo tem de executar durante longos períodos sem reiniciar. Também pode utilizar domínios de aplicação para isolar as tarefas que não devem partilhar os dados.      -Se uma assemblagem for carregada para o domínio de aplicação predefinido, não é possível descarregar da memória durante o processo está em execução. No entanto, se abrir um segundo domínio de aplicação para carregar e executar a assemblagem, a assemblagem é descarregada quando esse domínio de aplicação é descarregado. Utilize esta técnica para minimizar o conjunto de trabalho dos processos de longa execução que utilizam ocasionalmente DLLs grandes.       Vários domínios de aplicação podem ser executado num único processo; No entanto, não é uma correlação um para um entre domínios de aplicação e threads. Vários threads podem pertencer a um domínio de aplicação único e durante um determinado thread não está limitado a um domínio de aplicação único, em qualquer momento, um thread executa a um domínio de aplicação único.       Domínios de aplicação são criados utilizando o <xref:System.AppDomain.CreateDomain%2A>método.</xref:System.AppDomain.CreateDomain%2A> Instâncias de AppDomain são utilizadas para carregar e executar as assemblagens (<xref:System.Reflection.Assembly>).</xref:System.Reflection.Assembly> Quando um AppDomain já não está a ser utilizado, pode ser descarregado.       A classe de AppDomain implementa um conjunto de eventos que permitem às aplicações responder quando uma assemblagem for carregada, quando um domínio de aplicação será descarregado, ou quando é emitida uma exceção não processada.       Para obter mais informações sobre como utilizar domínios de aplicação, consulte [domínios de aplicação](~/add/includes/ajax-current-ext-md.md).       Esta classe implementa o <xref:System.MarshalByRefObject>, <xref:System._AppDomain>, e <xref:System.Security.IEvidenceFactory>interfaces.</xref:System.Security.IEvidenceFactory> </xref:System._AppDomain> </xref:System.MarshalByRefObject>       Nunca deve criar um wrapper remota para um objeto de AppDomain. Se o fizer, conseguiu publicar uma referência remota que AppDomain, tais como a exposição de métodos <xref:System.AppDomain.CreateInstance%2A>para acesso remoto e de forma eficaz destroying segurança de acesso de código para esse AppDomain.</xref:System.AppDomain.CreateInstance%2A> Clientes maliciosos que se ligam do appdomain controlado remotamente foi possível obter acesso a qualquer recurso que AppDomain próprio tem acesso ao. Não crie wrappers remota para qualquer tipo que expande <xref:System.MarshalByRefObject>e que implementa métodos que podem ser utilizados por clientes maliciosos para ignorar o sistema de segurança.</xref:System.MarshalByRefObject>      > [!CAUTION] > O valor predefinido para o <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName>propriedade é `false`.</xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName> Esta definição não é segura para os serviços. Para impedir que os serviços de transferir o código parcialmente fidedigno, defina esta propriedade como `true`."
  example:
  - "This example shows how to create a new AppDomain, instantiate a type in that new AppDomain, and communicate with that type’s object. In addition, this example shows how to unload the AppDomain causing the object to be garbage collected.  \n  \n [!code-vb[AppDomainX#1](~/add/codesnippet/visualbasic/t-system.appdomain_1.vb)]\n [!code-cs[AppDomainX#1](~/add/codesnippet/csharp/t-system.appdomain_1.cs)]\n [!code-cpp[AppDomainX#1](~/add/codesnippet/cpp/t-system.appdomain_1.cpp)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]

      [System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  implements:
  - System._AppDomain
  - System.Security.IEvidenceFactory
  inheritedMembers:
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.AppDomain.ActivationContext
  id: ActivationContext
  parent: System.AppDomain
  langs:
  - csharp
  name: ActivationContext
  nameWithType: AppDomain.ActivationContext
  fullName: System.AppDomain.ActivationContext
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém o contexto de ativação para o domínio de aplicação atual."
  syntax:
    content: public ActivationContext ActivationContext { get; }
    return:
      type: System.ActivationContext
      description: "Um objecto que representa o contexto de ativação para o domínio de aplicação atual, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se o domínio não tiver nenhum contexto de ativação."
  overload: System.AppDomain.ActivationContext*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.AppendPrivatePath(System.String)
  id: AppendPrivatePath(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: AppendPrivatePath(String)
  nameWithType: AppDomain.AppendPrivatePath(String)
  fullName: System.AppDomain.AppendPrivatePath(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Acrescenta o nome do diretório especificado para a lista de caminho privado."
  remarks: "A utilização desta propriedade não é recomendada, porque, poderá alterar o caminho de pesquisa para assemblagens depois de já ter sido carregados. Utilize o <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>propriedade em vez disso.</xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>       O caminho privado ou o caminho de pesquisa relativo, é o caminho relativo do diretório de base onde a resolução de assemblagem sondas para assemblagens privadas."
  syntax:
    content: public void AppendPrivatePath (string path);
    parameters:
    - id: path
      type: System.String
      description: "O nome do diretório a acrescentar para o caminho privado."
  overload: System.AppDomain.AppendPrivatePath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.ApplicationIdentity
  id: ApplicationIdentity
  parent: System.AppDomain
  langs:
  - csharp
  name: ApplicationIdentity
  nameWithType: AppDomain.ApplicationIdentity
  fullName: System.AppDomain.ApplicationIdentity
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém a identidade da aplicação no domínio de aplicação."
  syntax:
    content: public ApplicationIdentity ApplicationIdentity { get; }
    return:
      type: System.ApplicationIdentity
      description: "Um objeto que identifica a aplicação no domínio de aplicação."
  overload: System.AppDomain.ApplicationIdentity*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ApplicationTrust
  id: ApplicationTrust
  parent: System.AppDomain
  langs:
  - csharp
  name: ApplicationTrust
  nameWithType: AppDomain.ApplicationTrust
  fullName: System.AppDomain.ApplicationTrust
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém as informações que descrevem as permissões concedidas a uma aplicação e se a aplicação tem um nível de fidedignidade que permite que seja executado."
  syntax:
    content: public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }
    return:
      type: System.Security.Policy.ApplicationTrust
      description: "Um objeto que contém informações de permissão e de confiança para a aplicação no domínio de aplicação."
  overload: System.AppDomain.ApplicationTrust*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ApplyPolicy(System.String)
  id: ApplyPolicy(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: ApplyPolicy(String)
  nameWithType: AppDomain.ApplyPolicy(String)
  fullName: System.AppDomain.ApplyPolicy(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Devolve o nome a apresentar da assemblagem depois de política foi aplicada."
  remarks: "ApplyPolicy método aceita uma assemblagem nome a apresentar e devolve o nome a apresentar da política de pós-implementação. Isto é útil se precisar de carregar uma assemblagem utilizando a política, porque o contexto de apenas de reflexão não se aplica a política."
  syntax:
    content: public string ApplyPolicy (string assemblyName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "A assemblagem de nome, a apresentar no formato fornecido pelo &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt; propriedade."
    return:
      type: System.String
      description: "Uma cadeia que contém a assemblagem de nome a apresentar depois de política foi aplicada."
  overload: System.AppDomain.ApplyPolicy*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.AssemblyLoad
  id: AssemblyLoad
  parent: System.AppDomain
  langs:
  - csharp
  name: AssemblyLoad
  nameWithType: AppDomain.AssemblyLoad
  fullName: System.AppDomain.AssemblyLoad
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ocorre quando uma assemblagem é carregada."
  remarks: "O <xref:System.AssemblyLoadEventHandler>Delegar para este evento indica que a assemblagem foi carregada.</xref:System.AssemblyLoadEventHandler>       Para registar um processador de eventos para este evento, tem de ter as permissões necessárias, ou um <xref:System.Security.SecurityException>é emitida.</xref:System.Security.SecurityException>       Para obter mais informações sobre como lidar com eventos, consulte [eventos](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following sample demonstrates the AssemblyLoad event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_AssemblyLoad#1](~/add/codesnippet/csharp/e-system.appdomain.assem_1_1.cs)]\n [!code-vb[AppDomain_AssemblyLoad#1](~/add/codesnippet/visualbasic/e-system.appdomain.assem_1_1.vb)]\n [!code-cpp[AppDomain_AssemblyLoad#1](~/add/codesnippet/cpp/e-system.appdomain.assem_1_1.cpp)]"
  syntax:
    content: public event AssemblyLoadEventHandler AssemblyLoad;
    return:
      type: System.AssemblyLoadEventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.AssemblyResolve
  id: AssemblyResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: AssemblyResolve
  nameWithType: AppDomain.AssemblyResolve
  fullName: System.AppDomain.AssemblyResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ocorre quando a resolução de uma assemblagem falha."
  remarks: "É da responsabilidade do <xref:System.ResolveEventHandler>para este evento devolver a assemblagem que é especificado pelo <xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>propriedade, ou para devolver null se a assemblagem não é reconhecida.</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName> </xref:System.ResolveEventHandler> A assemblagem tem de ser carregada para um contexto de execução; Se o que é carregado no contexto de apenas de reflexão, a carga que causou este evento de falha.       Para obter orientações sobre a utilização deste evento, consulte [resolver cargas de assemblagem](~/add/includes/ajax-current-ext-md.md).       Começando com o [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], a <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>propriedade devolve a assemblagem que pediu a carga de assemblagem não foi possível resolver.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> Por exemplo, o carregador poderão não é possível carregar uma dependência da assemblagem requerente porque a assemblagem de requerente e a respetiva dependência não estão no caminho de pesquisa. Saber a identidade da assemblagem requerente poderá ser útil em localizar a dependência ou identificar a versão correta, se estiver disponível mais do que uma versão da dependência. Para obter mais informações, consulte <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>      > [!IMPORTANT] > Começando com o [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], a <xref:System.ResolveEventHandler>evento é desencadeado para todas as assemblagens, incluindo as assemblagens de recursos.</xref:System.ResolveEventHandler> Nas versões anteriores, o evento não foi gerado para assemblagens de recursos. Se o sistema operativo está localizado, o processador poderá ser chamado várias vezes: uma vez para cada idioma na cadeia de contingência.       Para este evento, o <xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>propriedade devolve o nome de assemblagem antes da política é aplicada.</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>      > [!IMPORTANT] > Se mais do que um processador de eventos está registado para este evento, o evento handlersarecalled por ordem até que um processador de eventos devolve um valor que não se encontra `null`. Processadores de eventos subsequentes são ignorados.       Para obter mais informações sobre como lidar com eventos, consulte [eventos](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following sample demonstrates the AssemblyResolve event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cpp[AssemblyResolve#1](~/add/codesnippet/cpp/e-system.appdomain.assem_0_1.cpp)]\n [!code-cs[AssemblyResolve#1](~/add/codesnippet/csharp/e-system.appdomain.assem_0_1.cs)]\n [!code-vb[AssemblyResolve#1](~/add/codesnippet/visualbasic/e-system.appdomain.assem_0_1.vb)]"
  syntax:
    content: public event ResolveEventHandler AssemblyResolve;
    return:
      type: System.ResolveEventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.BaseDirectory
  id: BaseDirectory
  parent: System.AppDomain
  langs:
  - csharp
  name: BaseDirectory
  nameWithType: AppDomain.BaseDirectory
  fullName: System.AppDomain.BaseDirectory
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém o diretório de base que utiliza o Resolvedor de assemblagem para a sonda de assemblagens."
  remarks: "Esta propriedade corresponde do <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>propriedade.</xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName> Também pode ser obtida utilizando o <xref:System.AppDomain.GetData%2A>método com a cadeia &quot;APPBASE&quot;.</xref:System.AppDomain.GetData%2A>"
  example:
  - "The following code example creates a new application domain, specifying a base directory to use when searching for assemblies to load into the domain. The example then uses the BaseDirectory property to obtain the base directory path, for display to the console.  \n  \n [!code-cs[ADSetup#1](~/add/codesnippet/csharp/p-system.appdomain.based_1.cs)]\n [!code-cpp[ADSetup#1](~/add/codesnippet/cpp/p-system.appdomain.based_1.cpp)]\n [!code-vb[ADSetup#1](~/add/codesnippet/visualbasic/p-system.appdomain.based_1.vb)]"
  syntax:
    content: public string BaseDirectory { get; }
    return:
      type: System.String
      description: "O diretório de base que utiliza o Resolvedor de assemblagem para a sonda de assemblagens."
  overload: System.AppDomain.BaseDirectory*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.ClearPrivatePath
  id: ClearPrivatePath
  parent: System.AppDomain
  langs:
  - csharp
  name: ClearPrivatePath()
  nameWithType: AppDomain.ClearPrivatePath()
  fullName: System.AppDomain.ClearPrivatePath()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Repõe o caminho que especifica a localização das assemblagens privadas para a cadeia vazia (&quot;&quot;)."
  remarks: "O caminho privado é um caminho relativo do diretório de base que o language runtime procura para localizar as assemblagens privadas.       Para obter mais informações, consulte <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>.</xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>"
  example:
  - "The following code example demonstrates how to use the ClearPrivatePath method to remove all entries from the list of private paths to search when assemblies are loaded.  \n  \n This method is now obsolete, and should not be used for new development.  \n  \n [!code-cpp[ADClearPrivatePath#1](~/add/codesnippet/cpp/m-system.appdomain.clear_1.cpp)]\n [!code-cs[ADClearPrivatePath#1](~/add/codesnippet/csharp/m-system.appdomain.clear_1.cs)]\n [!code-vb[ADClearPrivatePath#1](~/add/codesnippet/visualbasic/m-system.appdomain.clear_1.vb)]"
  syntax:
    content: public void ClearPrivatePath ();
    parameters: []
  overload: System.AppDomain.ClearPrivatePath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.ClearShadowCopyPath
  id: ClearShadowCopyPath
  parent: System.AppDomain
  langs:
  - csharp
  name: ClearShadowCopyPath()
  nameWithType: AppDomain.ClearShadowCopyPath()
  fullName: System.AppDomain.ClearShadowCopyPath()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Repõe a lista de diretórios que contém as assemblagens de sombra copiada para a cadeia vazia (&quot;&quot;)."
  remarks: "O caminho de cópia sombra de volumes é uma lista de diretórios onde sombra copiados assemblagens são armazenadas.       Para obter mais informações, consulte <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName>e [assemblagens de cópia sombra de volumes](~/add/includes/ajax-current-ext-md.md).</xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName>"
  syntax:
    content: public void ClearShadowCopyPath ();
    parameters: []
  overload: System.AppDomain.ClearShadowCopyPath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String)
  id: CreateComInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateComInstanceFrom(String,String)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância de um tipo COM especificado. Os parâmetros de especificar o nome de um ficheiro que contém uma assemblagem que contém o tipo e o nome do tipo."
  remarks: "Utilize este método para criar objetos remotamente sem ter de carregar o tipo de localmente.       O valor de retorno tem de ser não encapsulada para aceder ao objeto real.       A<xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName> atributo com um valor de `true` tem de ser aplicada explicitamente ou por predefinição para o tipo de COM para este método para criar uma instância desse tipo; caso contrário, <xref:System.TypeLoadException>é emitida.</xref:System.TypeLoadException> </xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>"
  example:
  - "The following sample demonstrates  \n  \n [!code-cs[AppDomain_CreateComInstanceFrom#1](~/add/codesnippet/csharp/m-system.appdomain.creat_4_1.cs)]\n [!code-vb[AppDomain_CreateComInstanceFrom#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_4_1.vb)]\n [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/add/codesnippet/cpp/m-system.appdomain.creat_4_1.cpp)]"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "O nome de um ficheiro que contém uma assemblagem que define o tipo pedido."
    - id: typeName
      type: System.String
      description: "O nome do tipo pedido."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Um objeto que seja um wrapper para a nova ocorrência especificado pelo <code> typeName </code>. O valor de retorno tem de ser não encapsulada para aceder ao objeto real."
  overload: System.AppDomain.CreateComInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "Não é possível carregar o tipo."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Não foi encontrado nenhum construtor sem parâmetros público."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>Não foi encontrado."
  - type: System.MemberAccessException
    commentId: T:System.MemberAccessException
    description: "<code>typeName</code>é uma classe abstracta.       - ou - este membro foi invocado com um mecanismo de enlace dinâmico."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A função invocadora não consegue fornecer atributos de activação para um objeto que não herda de <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>assemblyName</code>é uma cadeia vazia (&quot;&quot;)."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>Não é uma assemblagem válida."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Uma assemblagem ou módulo foi carregado duas vezes com dois evidences diferentes."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "O objecto COM que está a ser referido é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  id: CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância de um tipo COM especificado. Os parâmetros de especificar o nome de um ficheiro que contém uma assemblagem que contém o tipo e o nome do tipo."
  remarks: "Utilize este método para criar objetos remotamente sem ter de carregar o tipo de localmente.       O valor de retorno tem de ser não encapsulada para aceder ao objeto real.       A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>atributo com um valor de `true` tem de ser aplicada explicitamente ou por predefinição para o tipo de COM para este método para criar uma instância desse tipo; caso contrário, <xref:System.TypeLoadException>é emitida.</xref:System.TypeLoadException> </xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "O nome de um ficheiro que contém uma assemblagem que define o tipo pedido."
    - id: typeName
      type: System.String
      description: "O nome do tipo pedido."
    - id: hashValue
      type: System.Byte[]
      description: "Representa o valor do código hash calculado."
    - id: hashAlgorithm
      type: System.Configuration.Assemblies.AssemblyHashAlgorithm
      description: "Representa o algoritmo hash utilizado pelo manifesto de assemblagem."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Um objeto que seja um wrapper para a nova ocorrência especificado pelo <code> typeName </code>. O valor de retorno tem de ser não encapsulada para aceder ao objeto real."
  overload: System.AppDomain.CreateComInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "Não é possível carregar o tipo."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Não foi encontrado nenhum construtor sem parâmetros público."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>Não foi encontrado."
  - type: System.MemberAccessException
    commentId: T:System.MemberAccessException
    description: "<code>typeName</code>é uma classe abstracta.       - ou - este membro foi invocado com um mecanismo de enlace dinâmico."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A função invocadora não consegue fornecer atributos de activação para um objeto que não herda de <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>assemblyFile</code>é a cadeia vazia (&quot;&quot;)."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>Não é uma assemblagem válida."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Uma assemblagem ou módulo foi carregado duas vezes com dois evidences diferentes."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "O objecto COM que está a ser referido é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String)
  id: CreateDomain(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String)
  nameWithType: AppDomain.CreateDomain(String)
  fullName: System.AppDomain.CreateDomain(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria um novo domínio de aplicação com o nome especificado."
  remarks: "O `friendlyName` parâmetro destina-se para identificar o domínio de uma forma que faça sentido humans. Esta cadeia deve ser adequada para apresentação em interfaces de utilizador.       Esta sobrecarga de método utiliza o <xref:System.AppDomainSetup>informações do domínio aplicacional predefinido.</xref:System.AppDomainSetup>"
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_1_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/m-system.appdomain.creat_1_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/m-system.appdomain.creat_1_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName);
    parameters:
    - id: friendlyName
      type: System.String
      description: "O nome amigável do domínio."
    return:
      type: System.AppDomain
      description: "O domínio de aplicação criado recentemente."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)
  id: CreateDomain(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence)
  nameWithType: AppDomain.CreateDomain(String,Evidence)
  fullName: System.AppDomain.CreateDomain(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria um novo domínio de aplicação com o nome especificado utilizando a provas fornecida."
  remarks: "This method overload uses the <xref:System.AppDomainSetup> information from the default application domain.  \n  \n If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the CreateDomain overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_0_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/m-system.appdomain.creat_0_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/m-system.appdomain.creat_0_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);
    parameters:
    - id: friendlyName
      type: System.String
      description: "O nome amigável do domínio. Este nome amigável pode ser apresentada em interfaces de utilizador para identificar o domínio. Para obter mais informações, consulte <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Provas estabelece a identidade do código que é executado no domínio de aplicação. Passar <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> para utilizar a provas de domínio de aplicação atual."
    return:
      type: System.AppDomain
      description: "O domínio de aplicação criado recentemente."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,AppDomainSetup)
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria um novo domínio de aplicação com o nome especificado, provas e as informações de configuração do domínio de aplicação."
  remarks: "If `info` is not supplied, this method overload uses the <xref:System.AppDomainSetup> information from the default application domain.  \n  \n If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/f22a5c12-7605-4011-8d1c-_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/f22a5c12-7605-4011-8d1c-_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/f22a5c12-7605-4011-8d1c-_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);
    parameters:
    - id: friendlyName
      type: System.String
      description: "O nome amigável do domínio. Este nome amigável pode ser apresentada em interfaces de utilizador para identificar o domínio. Para obter mais informações, consulte <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Provas estabelece a identidade do código que é executado no domínio de aplicação. Passar <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> para utilizar a provas de domínio de aplicação atual."
    - id: info
      type: System.AppDomainSetup
      description: "Um objeto que contém informações de inicialização de domínio de aplicação."
    return:
      type: System.AppDomain
      description: "O domínio de aplicação criado recentemente."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria um novo domínio de aplicação com o nome especificado, provas, as informações de configuração do domínio de aplicação, o conjunto de permissões predefinidas e matriz de assemblagens totalmente fidedignas."
  remarks: "Tem de definir o <xref:System.AppDomainSetup.ApplicationBase%2A>propriedade o <xref:System.AppDomainSetup>objeto que forneceu para `info`.</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.ApplicationBase%2A> Caso contrário, é emitida uma exceção.       Se `securityInfo` é fornecida não é utilizada a provas do domínio de aplicação atual.       As informações fornecidas para `grantSet` e `fullTrustAssemblies` é utilizado para criar um <xref:System.Security.Policy.ApplicationTrust>objeto para o novo domínio de aplicação.</xref:System.Security.Policy.ApplicationTrust>"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, System.Security.Policy.StrongName[] fullTrustAssemblies);
    parameters:
    - id: friendlyName
      type: System.String
      description: "O nome amigável do domínio. Este nome amigável pode ser apresentada em interfaces de utilizador para identificar o domínio. Para obter mais informações, consulte a descrição da <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Provas estabelece a identidade do código que é executado no domínio de aplicação. Passar <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> para utilizar a provas de domínio de aplicação atual."
    - id: info
      type: System.AppDomainSetup
      description: "Um objeto que contém informações de inicialização de domínio de aplicação."
    - id: grantSet
      type: System.Security.PermissionSet
      description: "Uma permissão de predefinido que é definida concedidos para todas as assemblagens carregados para o novo domínio de aplicação que não tenham concede específico."
    - id: fullTrustAssemblies
      type: System.Security.Policy.StrongName[]
      description: "Uma matriz de nomes seguros que representa as assemblagens ser considerada totalmente fidedignas no novo domínio de aplicação."
    return:
      type: System.AppDomain
      description: "O domínio de aplicação criado recentemente."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O domínio de aplicação é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>.       - ou - <xref:System.AppDomainSetup.ApplicationBase*>propriedade não está definida no <xref href=&quot;System.AppDomainSetup&quot;> </xref> objeto que é fornecido para <code> info </code>.</xref:System.AppDomainSetup.ApplicationBase*>"
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,String,String,Boolean)
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria um novo domínio de aplicação com o nome especificado, utilizando provas, caminho de base da aplicação, caminho de pesquisa relativo e um parâmetro que especifica se uma cópia sombra de uma assemblagem está a ser carregados para o domínio de aplicação."
  remarks: "If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A>and [Shadow Copying Assemblies](~/add/includes/ajax-current-ext-md.md).  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/9bed52ed-b275-4e3a-b9e6-_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/9bed52ed-b275-4e3a-b9e6-_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/9bed52ed-b275-4e3a-b9e6-_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);
    parameters:
    - id: friendlyName
      type: System.String
      description: "O nome amigável do domínio. Este nome amigável pode ser apresentada em interfaces de utilizador para identificar o domínio. Para obter mais informações, consulte <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Provas estabelece a identidade do código que é executado no domínio de aplicação. Passar <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> para utilizar a provas de domínio de aplicação atual."
    - id: appBasePath
      type: System.String
      description: "O diretório de base que utiliza o Resolvedor de assemblagem para a sonda de assemblagens. Para obter mais informações, consulte <xref:System.AppDomain.BaseDirectory*>.</xref:System.AppDomain.BaseDirectory*>"
    - id: appRelativeSearchPath
      type: System.String
      description: "O caminho relativo do diretório de base onde a resolução de assemblagem deve sonda para assemblagens privadas. Para obter mais informações, consulte <xref:System.AppDomain.RelativeSearchPath*>.</xref:System.AppDomain.RelativeSearchPath*>"
    - id: shadowCopyFiles
      type: System.Boolean
      description: "Se <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, uma cópia sombra de uma assemblagem é carregada para este domínio de aplicação."
    return:
      type: System.AppDomain
      description: "O domínio de aplicação criado recentemente."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria um novo domínio de aplicação com o nome especificado, utilizando provas, caminho de base da aplicação, caminho de pesquisa relativo e um parâmetro que especifica se uma cópia sombra de uma assemblagem está a ser carregados para o domínio de aplicação. Especifica um método de chamada de retorno que é invocado quando o domínio de aplicação foi inicializado e uma matriz de argumentos de cadeia para passar o método de chamada de retorno."
  remarks: "The method represented by `adInit` is executed in the context of the newly created application domain.  \n  \n If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A>and [Shadow Copying Assemblies](~/add/includes/ajax-current-ext-md.md).  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);
    parameters:
    - id: friendlyName
      type: System.String
      description: "O nome amigável do domínio. Este nome amigável pode ser apresentada em interfaces de utilizador para identificar o domínio. Para obter mais informações, consulte <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Provas estabelece a identidade do código que é executado no domínio de aplicação. Passar <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> para utilizar a provas de domínio de aplicação atual."
    - id: appBasePath
      type: System.String
      description: "O diretório de base que utiliza o Resolvedor de assemblagem para a sonda de assemblagens. Para obter mais informações, consulte <xref:System.AppDomain.BaseDirectory*>.</xref:System.AppDomain.BaseDirectory*>"
    - id: appRelativeSearchPath
      type: System.String
      description: "O caminho relativo do diretório de base onde a resolução de assemblagem deve sonda para assemblagens privadas. Para obter mais informações, consulte <xref:System.AppDomain.RelativeSearchPath*>.</xref:System.AppDomain.RelativeSearchPath*>"
    - id: shadowCopyFiles
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>para carregar uma cópia sombra de uma assemblagem para o domínio de aplicação."
    - id: adInit
      type: System.AppDomainInitializer
      description: "Um <xref href=&quot;System.AppDomainInitializer&quot;> </xref> delegado que representa um método de chamada de retorno para invocar quando a nova <xref href=&quot;System.AppDomain&quot;> </xref> objecto foi inicializado."
    - id: adInitArgs
      type: System.String[]
      description: "Uma matriz de argumentos de cadeia a ser transmitido para a chamada de retorno representada pelo `adInit`, quando a nova <xref href=&quot;System.AppDomain&quot;> </xref> objecto foi inicializado."
    return:
      type: System.AppDomain
      description: "O domínio de aplicação criado recentemente."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String)
  id: CreateInstance(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String)
  nameWithType: AppDomain.CreateInstance(String,String)
  fullName: System.AppDomain.CreateInstance(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância do tipo especificado definido na assemblagem especificada."
  remarks: "Este método chama o construtor predefinido para `typeName`.       Consulte <xref:System.Reflection.AssemblyName>para o formato do `assemblyName`.</xref:System.Reflection.AssemblyName>       Uma tentativa de chamar CreateInstance um domínio de aplicação de destino que não é o domínio de aplicação atual resultará numa carga bem sucedida da assemblagem no domínio de aplicação de destino. Uma vez que um <xref:System.Reflection.Assembly>não é <xref:System.MarshalByRefObject>, quando este método tenta devolver os <xref:System.Reflection.Assembly>para a assemblagem carregada para o domínio de aplicação atual, tempo de execução de idioma comum irá tentar carregar a assemblagem para o domínio de aplicação atual e a carga poderá falhar.</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> A assemblagem que é carregada para o domínio de aplicação atual pode ser diferente da assemblagem que foi carregada primeiro se as definições de caminho para os domínios de duas aplicação são diferentes."
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "O nome a apresentar da assemblagem. Consulte &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "O nome completamente qualificado do tipo pedido, incluindo o espaço de nomes, mas não a assemblagem, tal como devolvido pelo &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; propriedade."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Um objeto que seja um wrapper para a nova ocorrência especificado pelo <code> typeName </code>. O valor de retorno tem de ser não encapsulada para aceder ao objeto real."
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>Não é uma assemblagem válida.       - ou - versão 2.0 ou posterior do tempo de execução de idioma comum é actualmente carregado e <code>assemblyName</code> foi compilada com uma versão posterior."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Uma assemblagem ou módulo foi carregado duas vezes com dois evidences diferentes."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>Não foi encontrado."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "O chamador não tem permissão para chamar este construtor."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Não foi encontrado nenhum construtor público correspondente."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>Não foi encontrado no <code>assemblyName</code>."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Esta instância é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Object[])
  id: CreateInstance(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância do tipo especificado definido na assemblagem especificada. Um parâmetro especifica uma matriz de atributos de activação."
  remarks: "Este método chama o construtor predefinido para `typeName`.       Consulte <xref:System.Reflection.AssemblyName>para o formato do `assemblyName`.</xref:System.Reflection.AssemblyName>       Uma tentativa de chamar <xref:System.AppDomain.CreateInstance%2A>no destino de domínio de aplicação que não é o domínio de aplicação atual resultará numa carga bem sucedida da assemblagem no domínio de aplicação de destino.</xref:System.AppDomain.CreateInstance%2A> Uma vez que um <xref:System.Reflection.Assembly>não é <xref:System.MarshalByRefObject>, quando este método tenta devolver os <xref:System.Reflection.Assembly>para a assemblagem carregada para o domínio de aplicação atual, tempo de execução de idioma comum irá tentar carregar a assemblagem para o domínio de aplicação atual e a carga poderá falhar.</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> A assemblagem que é carregada para o domínio de aplicação atual pode ser diferente da assemblagem que foi carregada primeiro se as definições de caminho para os domínios de duas aplicação são diferentes."
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "O nome a apresentar da assemblagem. Consulte &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "O nome completamente qualificado do tipo pedido, incluindo o espaço de nomes, mas não a assemblagem, tal como devolvido pelo &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; propriedade."
    - id: activationAttributes
      type: System.Object[]
      description: "Uma matriz de um ou mais atributos que podem participar na ativação. Normalmente, uma matriz que contenha um único <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objeto que especifica o URL que é necessário para ativar um objecto remoto.       Este parâmetro é relacionadas com os objetos de cliente ativado. Ativação do cliente é uma tecnologia de legado que é mantida por questões de compatibilidade, mas não é recomendada para um novo desenvolvimento. As aplicações distribuídas em vez disso, devem utilizar o Windows Communication Foundation."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Um objeto que seja um wrapper para a nova ocorrência especificado pelo <code> typeName </code>. O valor de retorno tem de ser não encapsulada para aceder ao objeto real."
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>Não é uma assemblagem válida.       - ou - versão 2.0 ou posterior do tempo de execução de idioma comum é actualmente carregado e <code>assemblyName</code> foi compilada com uma versão posterior."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Uma assemblagem ou módulo foi carregado duas vezes com dois evidences diferentes."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>Não foi encontrado."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "O chamador não tem permissão para chamar este construtor."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Não foi encontrado nenhum construtor público correspondente."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A função invocadora não consegue fornecer atributos de activação para um objeto que não herda de <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>Não foi encontrado no <code>assemblyName</code>."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Esta instância é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância do tipo especificado definido na assemblagem especificada. Os parâmetros de especificar um Gestor de enlaces, sinalizadores de enlace, argumentos de construtor, informações de cultura específica utilizadas para interpretar argumentos e atributos de activação opcional."
  remarks: "Consulte <xref:System.Reflection.AssemblyName>para o formato do `assemblyName`.</xref:System.Reflection.AssemblyName>       Uma tentativa de chamar <xref:System.AppDomain.CreateInstance%2A>no destino de domínio de aplicação que não é o domínio de aplicação atual resultará numa carga bem sucedida da assemblagem no domínio de aplicação de destino.</xref:System.AppDomain.CreateInstance%2A> Uma vez que um <xref:System.Reflection.Assembly>não é <xref:System.MarshalByRefObject>, quando este método tenta devolver os <xref:System.Reflection.Assembly>para a assemblagem carregada para o domínio de aplicação atual, tempo de execução de idioma comum irá tentar carregar a assemblagem para o domínio de aplicação atual e a carga poderá falhar.</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> A assemblagem que é carregada para o domínio de aplicação atual pode ser diferente da assemblagem que foi carregada primeiro se as definições de caminho para os domínios de duas aplicação são diferentes."
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "O nome a apresentar da assemblagem. Consulte &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "O nome completamente qualificado do tipo pedido, incluindo o espaço de nomes, mas não a assemblagem, tal como devolvido pelo &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; propriedade."
    - id: ignoreCase
      type: System.Boolean
      description: "Um valor booleano que especifica se pretende efetuar uma pesquisa de maiúsculas e minúsculas ou não."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Uma combinação de zero ou mais sinalizadores de bits que afetam a pesquisa para o `typeName` construtor. Se `bindingAttr` é zero, uma pesquisa de maiúsculas e minúsculas para construtores públicos é efetuada."
    - id: binder
      type: System.Reflection.Binder
      description: "Tipos de um objeto que permite o enlace adesão do argumento, invocação de membros e a obtenção das <xref:System.Reflection.MemberInfo>objetos utilizando reflexão.</xref:System.Reflection.MemberInfo> Se `binder` é nulo, o Gestor de enlaces predefinido é utilizado."
    - id: args
      type: System.Object[]
      description: "Os argumentos transmitidos para o construtor. Esta matriz de argumentos tem correspondem em número de ordem e escreva os parâmetros do construtor para invocar. Se o construtor predefinido é preferencial, `args` tem de ser uma matriz vazia ou null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Informações específicas de cultura que regulam a adesão de `args` aos tipos formais declarados para a `typeName` construtor. Se `culture` é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, a <xref:System.Globalization.CultureInfo>para o thread actual é utilizado.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Uma matriz de um ou mais atributos que podem participar na ativação. Normalmente, uma matriz que contenha um único <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objeto que especifica o URL que é necessário para ativar um objecto remoto.       Este parâmetro é relacionadas com os objetos de cliente ativado. Ativação do cliente é uma tecnologia de legado que é mantida por questões de compatibilidade, mas não é recomendada para um novo desenvolvimento. As aplicações distribuídas em vez disso, devem utilizar o Windows Communication Foundation."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Um objeto que seja um wrapper para a nova ocorrência especificado pelo <code> typeName </code>. O valor de retorno tem de ser não encapsulada para aceder ao objeto real."
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>Não é uma assemblagem válida.       - ou - <code>assemblyName</code> foi compilada com uma versão posterior do tempo de execução de idioma comum à versão que atualmente está carregado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Uma assemblagem ou módulo foi carregado duas vezes com dois evidences diferentes."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>Não foi encontrado."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "O chamador não tem permissão para chamar este construtor."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Não foi encontrado nenhum construtor correspondente."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A função invocadora não consegue fornecer atributos de activação para um objeto que não herda de <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>Não foi encontrado no <code>assemblyName</code>."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Esta instância é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância do tipo especificado definido na assemblagem especificada. Os parâmetros especificar sinalizadores de enlace, um Gestor de enlaces, utilizadas para interpretar argumentos, atributos de activação e autorização para criar o tipo de informações de cultura específica e argumentos de construtor."
  remarks: "Consulte <xref:System.Reflection.AssemblyName>para o formato do `assemblyName`.</xref:System.Reflection.AssemblyName>       Uma tentativa de chamar <xref:System.AppDomain.CreateInstance%2A>no destino de domínio de aplicação que não é o domínio de aplicação atual resultará numa carga bem sucedida da assemblagem no domínio de aplicação de destino.</xref:System.AppDomain.CreateInstance%2A> Uma vez que um <xref:System.Reflection.Assembly>não é <xref:System.MarshalByRefObject>, quando este método tenta devolver os <xref:System.Reflection.Assembly>para a assemblagem carregada para o domínio de aplicação atual, tempo de execução de idioma comum irá tentar carregar a assemblagem para o domínio de aplicação atual e a carga poderá falhar.</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> A assemblagem que é carregada para o domínio de aplicação atual pode ser diferente da assemblagem que foi carregada primeiro se as definições de caminho para os domínios de duas aplicação são diferentes."
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "O nome a apresentar da assemblagem. Consulte &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "O nome completamente qualificado do tipo pedido, incluindo o espaço de nomes, mas não a assemblagem, tal como devolvido pelo &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; propriedade."
    - id: ignoreCase
      type: System.Boolean
      description: "Um valor booleano que especifica se pretende efetuar uma pesquisa de maiúsculas e minúsculas ou não."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Uma combinação de zero ou mais sinalizadores de bits que afetam a pesquisa para o `typeName` construtor. Se `bindingAttr` é zero, uma pesquisa de maiúsculas e minúsculas para construtores públicos é efetuada."
    - id: binder
      type: System.Reflection.Binder
      description: "Tipos de um objeto que permite o enlace adesão do argumento, invocação de membros e a obtenção das <xref:System.Reflection.MemberInfo>objetos utilizando reflexão.</xref:System.Reflection.MemberInfo> Se `binder` é nulo, o Gestor de enlaces predefinido é utilizado."
    - id: args
      type: System.Object[]
      description: "Os argumentos transmitidos para o construtor. Esta matriz de argumentos tem correspondem em número de ordem e escreva os parâmetros do construtor para invocar. Se o construtor predefinido é preferencial, `args` tem de ser uma matriz vazia ou null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Informações específicas de cultura que regulam a adesão de `args` aos tipos formais declarados para a `typeName` construtor. Se `culture` é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, a <xref:System.Globalization.CultureInfo>para o thread actual é utilizado.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Uma matriz de um ou mais atributos que podem participar na ativação. Normalmente, uma matriz que contenha um único <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objeto que especifica o URL que é necessário para ativar um objecto remoto.       Este parâmetro é relacionadas com os objetos de cliente ativado. Ativação do cliente é uma tecnologia de legado que é mantida por questões de compatibilidade, mas não é recomendada para um novo desenvolvimento. As aplicações distribuídas em vez disso, devem utilizar o Windows Communication Foundation."
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "Informações utilizadas para autorizar a criação de `typeName`."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Um objeto que seja um wrapper para a nova ocorrência especificado pelo <code> typeName </code>. O valor de retorno tem de ser não encapsulada para aceder ao objeto real."
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>Não é uma assemblagem válida.       - ou - versão 2.0 ou posterior do tempo de execução de idioma comum é actualmente carregado e <code>assemblyName</code> foi compilada com uma versão posterior."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Uma assemblagem ou módulo foi carregado duas vezes com dois evidences diferentes."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>Não foi encontrado."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "O chamador não tem permissão para chamar este construtor."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Não foi encontrado nenhum construtor correspondente."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A função invocadora não consegue fornecer atributos de activação para um objeto que não herda de <xref href=&quot;System.MarshalByRefObject&quot;> </xref>.       -or-       <code>securityAttributes</code> is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Quando a política CAS legada não estiver ativada, <code> securityAttributes </code> deve ser<xref uid=&quot;langword_csharp_null.&quot; name=&quot;null.&quot; href=&quot;&quot;></xref>"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>Não foi encontrado no <code>assemblyName</code>."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Esta instância é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)
  id: CreateInstanceAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância do tipo especificado. Os parâmetros de especificar a assemblagem onde o tipo está definido e o nome do tipo."
  remarks: "Este é um método de conveniência que combina <xref:System.AppDomain.CreateInstance%2A>e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstance%2A> Este método chama o construtor predefinido para `typeName`.       Consulte <xref:System.Reflection.AssemblyName>para o formato do `assemblyName`.</xref:System.Reflection.AssemblyName> Consulte o <xref:System.Type.FullName%2A?displayProperty=fullName>propriedade para o formato do `typeName`.</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > Se efetuar uma chamada de antecipado vinculados a um método `M` de um objeto do tipo `T1` que foi devolvido por CreateInstanceAndUnwrap e esse método efetua uma chamada de antecipado vinculados a um método de um objeto do tipo `T2` numa assemblagem `C` que não seja a assemblagem atual ou a assemblagem que contém `T1`, assemblagem `C` é carregado para o domínio de aplicação atual. Este carregamento ocorre mesmo que o antecipado vinculados a chamada para `T1.M()` foi efetuada no corpo de um <xref:System.Reflection.Emit.DynamicMethod>, ou outro código gerado dinamicamente.</xref:System.Reflection.Emit.DynamicMethod> Se o domínio atual é o domínio predefinido, assemblagem `C` não é possível descarregar até que o processo termina. Se o domínio atual tentar mais tarde carregar a assemblagem `C`, a carga poderá falhar."
  example:
  - "The following code example shows the simplest way to execute code in another application domain. The example defines a class named `Worker` that inherits from <xref:System.MarshalByRefObject>. The `Worker` class defines a method that displays the name of the application domain in which it is executing. The example creates instances of `Worker` in the default application domain and in a new application domain.  \n  \n> [!NOTE]\n>  The assembly that contains `Worker` must be loaded into both application domains, but it can load other assemblies that exist only in the new application domain.  \n  \n [!code-cpp[CreateInstanceAndUnwrap2#1](~/add/codesnippet/cpp/m-system.appdomain.creat_2_1.cpp)]\n [!code-cs[CreateInstanceAndUnwrap2#1](~/add/codesnippet/csharp/m-system.appdomain.creat_2_1.cs)]\n [!code-vb[CreateInstanceAndUnwrap2#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_2_1.vb)]"
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "O nome a apresentar da assemblagem. Consulte &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "O nome completamente qualificado do tipo pedido, incluindo o espaço de nomes, mas não a assemblagem, tal como devolvido pelo &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; propriedade."
    return:
      type: System.Object
      description: "Uma instância do objeto especificado por <code> typeName </code>."
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Não foi encontrado nenhum construtor público correspondente."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>Não foi encontrado no <code>assemblyName</code>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>Não foi encontrado."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "O chamador não tem permissão para chamar este construtor."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>Não é uma assemblagem válida.       - ou - versão 2.0 ou posterior do tempo de execução de idioma comum é actualmente carregado e <code>assemblyName</code> foi compilada com uma versão posterior."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Uma assemblagem ou módulo foi carregado duas vezes com dois evidences diferentes."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  id: CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância do tipo especificado. Os parâmetros de especificar a assemblagem onde o tipo está definido, o nome do tipo e uma matriz de atributos de activação."
  remarks: "Este é um método de conveniência que combina <xref:System.AppDomain.CreateInstance%2A>e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstance%2A> Este método chama o construtor predefinido para `typeName`.       Consulte <xref:System.Reflection.AssemblyName>para o formato do `assemblyName`.</xref:System.Reflection.AssemblyName> Consulte o <xref:System.Type.FullName%2A?displayProperty=fullName>propriedade para o formato do `typeName`.</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > Se efetuar uma chamada de antecipado vinculados a um método `M` de um objeto do tipo `T1` que foi devolvido por <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, e que o método faz uma chamada de antecipado vinculados a um método de um objeto do tipo `T2` numa assemblagem `C` que não seja a assemblagem atual ou a assemblagem que contém `T1`, assemblagem `C` é carregado para o domínio de aplicação atual.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> Este carregamento ocorre mesmo que o antecipado vinculados a chamada para `T1.M()` foi efetuada no corpo de um <xref:System.Reflection.Emit.DynamicMethod>, ou outro código gerado dinamicamente.</xref:System.Reflection.Emit.DynamicMethod> Se o domínio atual é o domínio predefinido, assemblagem `C` não é possível descarregar até que o processo termina. Se o domínio atual tentar mais tarde carregar a assemblagem `C`, a carga poderá falhar."
  example:
  - >-
    [!code-cpp[ADDyno#1](~/add/codesnippet/cpp/ec186439-6d54-4090-82e0-_1.cpp)]
     [!code-cs[ADDyno#1](~/add/codesnippet/csharp/ec186439-6d54-4090-82e0-_1.cs)]
     [!code-vb[ADDyno#1](~/add/codesnippet/visualbasic/ec186439-6d54-4090-82e0-_1.vb)]
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "O nome a apresentar da assemblagem. Consulte &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "O nome completamente qualificado do tipo pedido, incluindo o espaço de nomes, mas não a assemblagem, tal como devolvido pelo &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; propriedade."
    - id: activationAttributes
      type: System.Object[]
      description: "Uma matriz de um ou mais atributos que podem participar na ativação. Normalmente, uma matriz que contenha um único <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objeto que especifica o URL que é necessário para ativar um objecto remoto.       Este parâmetro é relacionadas com os objetos de cliente ativado. Ativação do cliente é uma tecnologia de legado que é mantida por questões de compatibilidade, mas não é recomendada para um novo desenvolvimento. As aplicações distribuídas em vez disso, devem utilizar o Windows Communication Foundation."
    return:
      type: System.Object
      description: "Uma instância do objeto especificado por <code> typeName </code>."
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Não foi encontrado nenhum construtor público correspondente."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>Não foi encontrado no <code>assemblyName</code>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>Não foi encontrado."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "O chamador não tem permissão para chamar este construtor."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A função invocadora não consegue fornecer atributos de activação para um objeto que não herda de <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>Não é uma assemblagem válida.       - ou - versão 2.0 ou posterior do tempo de execução de idioma comum é actualmente carregado e <code>assemblyName</code> foi compilada com uma versão posterior."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Uma assemblagem ou módulo foi carregado duas vezes com dois evidences diferentes."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância do tipo especificado definido na assemblagem especificada, especificar se as maiúsculas e minúsculas do nome do tipo é ignorada; os atributos de enlace e o Gestor de enlaces que são utilizados para selecionar o tipo a ser criado; os argumentos do construtor; a cultura; e os atributos de activação."
  remarks: "Este é um método de conveniência que combina <xref:System.AppDomain.CreateInstance%2A>e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstance%2A>       Consulte <xref:System.Reflection.AssemblyName>para o formato do `assemblyName`.</xref:System.Reflection.AssemblyName> Consulte o <xref:System.Type.FullName%2A?displayProperty=fullName>propriedade para o formato do `typeName`.</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > Se efetuar uma chamada de antecipado vinculados a um método `M` de um objeto do tipo `T1` que foi devolvido por <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, e que o método faz uma chamada de antecipado vinculados a um método de um objeto do tipo `T2` numa assemblagem `C` que não seja a assemblagem atual ou a assemblagem que contém `T1`, assemblagem `C` é carregado para o domínio de aplicação atual.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> Este carregamento ocorre mesmo que o antecipado vinculados a chamada para `T1.M()` foi efetuada no corpo de um <xref:System.Reflection.Emit.DynamicMethod>, ou outro código gerado dinamicamente.</xref:System.Reflection.Emit.DynamicMethod> Se o domínio atual é o domínio predefinido, assemblagem `C` não é possível descarregar até que o processo termina. Se o domínio atual tentar mais tarde carregar a assemblagem `C`, a carga poderá falhar."
  example:
  - "The following sample demonstrates the use of the `ignoreCase` parameter.  \n  \n [!code-cs[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/csharp/7b1dcc86-9680-463d-b78c-_1.cs)]\n [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/cpp/7b1dcc86-9680-463d-b78c-_1.cpp)]\n [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/visualbasic/7b1dcc86-9680-463d-b78c-_1.vb)]"
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "O nome a apresentar da assemblagem. Consulte &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "O nome completamente qualificado do tipo pedido, incluindo o espaço de nomes, mas não a assemblagem, tal como devolvido pelo &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; propriedade."
    - id: ignoreCase
      type: System.Boolean
      description: "Um valor booleano que especifica se pretende efetuar uma pesquisa de maiúsculas e minúsculas ou não."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Uma combinação de zero ou mais sinalizadores de bits que afetam a pesquisa para o `typeName` construtor. Se `bindingAttr` é zero, uma pesquisa de maiúsculas e minúsculas para construtores públicos é efetuada."
    - id: binder
      type: System.Reflection.Binder
      description: "Tipos de um objeto que permite o enlace adesão do argumento, invocação de membros e a obtenção das <xref:System.Reflection.MemberInfo>objetos utilizando reflexão.</xref:System.Reflection.MemberInfo> Se `binder` é nulo, o Gestor de enlaces predefinido é utilizado."
    - id: args
      type: System.Object[]
      description: "Os argumentos transmitidos para o construtor. Esta matriz de argumentos tem correspondem em número de ordem e escreva os parâmetros do construtor para invocar. Se o construtor predefinido é preferencial, `args` tem de ser uma matriz vazia ou null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Um objeto de cultura específica utilizado para governar a adesão de tipos. Se `culture` é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, a <xref uid=&quot;langword_csharp_CultureInfo&quot; name=&quot;CultureInfo&quot; href=&quot;&quot;> </xref> para o thread actual é utilizado."
    - id: activationAttributes
      type: System.Object[]
      description: "Uma matriz de um ou mais atributos que podem participar na ativação. Normalmente, uma matriz que contenha um único <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objeto. Especifica que o URL que é necessário para ativar um objecto remoto.       Este parâmetro é relacionadas com os objetos de cliente ativado. Ativação do cliente é uma tecnologia de legado que é mantida por questões de compatibilidade, mas não é recomendada para um novo desenvolvimento. As aplicações distribuídas em vez disso, devem utilizar o Windows Communication Foundation."
    return:
      type: System.Object
      description: "Uma instância do objeto especificado por <code> typeName </code>."
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Não foi encontrado nenhum construtor correspondente."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>Não foi encontrado no <code>assemblyName</code>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>Não foi encontrado."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "O chamador não tem permissão para chamar este construtor."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A função invocadora não consegue fornecer atributos de activação para um objeto que não herda de <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>Não é uma assemblagem válida.       - ou - <code>assemblyName</code> foi compilada com uma versão posterior do tempo de execução de idioma comum à versão que atualmente está carregado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Uma assemblagem ou módulo foi carregado duas vezes com dois evidences diferentes."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância do tipo especificado. Os parâmetros de especificar o nome do tipo e como é localizado e criado."
  remarks: "Este é um método de conveniência que combina <xref:System.AppDomain.CreateInstance%2A>e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstance%2A>       Consulte <xref:System.Reflection.AssemblyName>para o formato do `assemblyName`.</xref:System.Reflection.AssemblyName> Consulte o <xref:System.Type.FullName%2A?displayProperty=fullName>propriedade para o formato do `typeName`.</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > Se efetuar uma chamada de antecipado vinculados a um método `M` de um objeto do tipo `T1` que foi devolvido por <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, e que o método faz uma chamada de antecipado vinculados a um método de um objeto do tipo `T2` numa assemblagem `C` que não seja a assemblagem atual ou a assemblagem que contém `T1`, assemblagem `C` é carregado para o domínio de aplicação atual.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> Este carregamento ocorre mesmo que o antecipado vinculados a chamada para `T1.M()` foi efetuada no corpo de um <xref:System.Reflection.Emit.DynamicMethod>, ou outro código gerado dinamicamente.</xref:System.Reflection.Emit.DynamicMethod> Se o domínio atual é o domínio predefinido, assemblagem `C` não é possível descarregar até que o processo termina. Se o domínio atual tentar mais tarde carregar a assemblagem `C`, a carga poderá falhar."
  example:
  - "The following sample demonstrates the use of the `ignoreCase` parameter.  \n  \n [!code-cs[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/csharp/8e0d44ad-3def-4658-8d9d-_1.cs)]\n [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/cpp/8e0d44ad-3def-4658-8d9d-_1.cpp)]\n [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/visualbasic/8e0d44ad-3def-4658-8d9d-_1.vb)]"
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "O nome a apresentar da assemblagem. Consulte &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "O nome completamente qualificado do tipo pedido, incluindo o espaço de nomes, mas não a assemblagem, tal como devolvido pelo &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; propriedade."
    - id: ignoreCase
      type: System.Boolean
      description: "Um valor booleano que especifica se pretende efetuar uma pesquisa de maiúsculas e minúsculas ou não."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Uma combinação de zero ou mais sinalizadores de bits que afetam a pesquisa para o `typeName` construtor. Se `bindingAttr` é zero, uma pesquisa de maiúsculas e minúsculas para construtores públicos é efetuada."
    - id: binder
      type: System.Reflection.Binder
      description: "Tipos de um objeto que permite o enlace adesão do argumento, invocação de membros e a obtenção das <xref:System.Reflection.MemberInfo>objetos utilizando reflexão.</xref:System.Reflection.MemberInfo> Se `binder` é nulo, o Gestor de enlaces predefinido é utilizado."
    - id: args
      type: System.Object[]
      description: "Os argumentos transmitidos para o construtor. Esta matriz de argumentos tem correspondem em número de ordem e escreva os parâmetros do construtor para invocar. Se o construtor predefinido é preferencial, `args` tem de ser uma matriz vazia ou null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Um objeto de cultura específica utilizado para governar a adesão de tipos. Se `culture` é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, a <xref uid=&quot;langword_csharp_CultureInfo&quot; name=&quot;CultureInfo&quot; href=&quot;&quot;> </xref> para o thread actual é utilizado."
    - id: activationAttributes
      type: System.Object[]
      description: "Uma matriz de um ou mais atributos que podem participar na ativação. Normalmente, uma matriz que contenha um único <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objeto que especifica o URL que é necessário para ativar um objecto remoto.       Este parâmetro é relacionadas com os objetos de cliente ativado. Ativação do cliente é uma tecnologia de legado que é mantida por questões de compatibilidade, mas não é recomendada para um novo desenvolvimento. As aplicações distribuídas em vez disso, devem utilizar o Windows Communication Foundation."
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "Informações utilizadas para autorizar a criação de `typeName`."
    return:
      type: System.Object
      description: "Uma instância do objeto especificado por <code> typeName </code>."
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Não foi encontrado nenhum construtor correspondente."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>Não foi encontrado no <code>assemblyName</code>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>Não foi encontrado."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "O chamador não tem permissão para chamar este construtor."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A função invocadora não consegue fornecer atributos de activação para um objeto que não herda de <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>Não é uma assemblagem válida.       - ou - versão 2.0 ou posterior do tempo de execução de idioma comum é actualmente carregado e <code>assemblyName</code> foi compilada com uma versão posterior."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Uma assemblagem ou módulo foi carregado duas vezes com dois evidences diferentes."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String)
  id: CreateInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String)
  nameWithType: AppDomain.CreateInstanceFrom(String,String)
  fullName: System.AppDomain.CreateInstanceFrom(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância do tipo especificado definida no ficheiro de assemblagem especificado."
  remarks: "O construtor predefinido para `typeName` é invocado.       Para obter mais informações, consulte o <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>método.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       Quando o método CreateInstanceFrom é utilizado para criar uma instância num domínio de aplicação de destino, que não seja o domínio de aplicação a partir do qual é feita a chamada, a assemblagem é carregada no domínio de aplicação de destino. No entanto, se a instância e não encapsulada no domínio de aplicação chamada, utilizando a instância e não encapsulada de determinadas formas pode fazer com que a assemblagem ser carregados para o domínio de aplicação de chamada. Por exemplo, depois da instância e não encapsulada, poderão ser pedidas as respetivas informações de tipo, para chamar os métodos tardio. Quando a assemblagem for carregada para o domínio de aplicação de chamada, podem ocorrer exceções.      -Se outra versão da mesma assemblagem foi carregada anteriormente para o domínio de aplicação de chamada ou se o caminho de carregamento do domínio de aplicação chamada é diferente do que o domínio de aplicação de destino, exceções, tal como <xref:System.MissingMethodException>podem ocorrer.</xref:System.MissingMethodException>      -Se o domínio aplicacional chamar faz com que o antecipado vinculados chamadas para o tipo de instância, <xref:System.InvalidCastException>pode ser emitida quando é efetuada uma tentativa para converter a instância.</xref:System.InvalidCastException>"
  example:
  - "The following example shows how to use the CreateInstanceFrom method overload to create an instance of an object in a target application domain and call its methods.  \n  \n The example defines the `MarshallableExample` class, which can be marshaled across application domain boundaries. The example builds a path to the currently executing assembly, creates a target application domain, and uses the CreateInstanceFrom method overload to load the example assembly into the target application domain and create an instance of `MarshallableExample`.  \n  \n> [!NOTE]\n>  The path is absolute in this example, but a relative path would also work because the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=fullName> method is used to load the assembly.  \n  \n After unwrapping the object handle, the example demonstrates three ways to use an object in a target application domain:  \n  \n-   Invoking a method with late binding, using reflection. This requires type information, which causes the assembly to be loaded into the application domain of the caller. (In this example, it is already loaded.)  \n  \n-   Casting the object to an interface known to both the caller and the callee. If the interface is defined in the calling assembly or in a third assembly referenced by both the caller and the callee, the called assembly is not loaded into the application domain of the caller.  \n  \n-   Using the object directly when its type is known to the caller. The assembly must be loaded into the application domain of the caller.  \n  \n Another way to avoid loading the called assembly into the application domain of the caller is for the caller to derive from the <xref:System.MarshalByRefObject> class and to define a method that can be run in the target application domain. That method can use reflection to examine a target assembly, because the target assembly is already loaded into the target application domain. See the example for the <xref:System.AppDomain.DynamicDirectory%2A> property.  \n  \n [!code-cs[System.AppDomain.CreateInstanceFrom_StringString#1](~/add/codesnippet/csharp/m-system.appdomain.creat_3_1.cs)]\n [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/add/codesnippet/cpp/m-system.appdomain.creat_3_1.cpp)]\n [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_3_1.vb)]"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "O nome, incluindo o caminho, de um ficheiro que contém uma assemblagem que define o tipo pedido. A assemblagem for carregada utilizando o <xref:System.Reflection.Assembly.LoadFrom*>método.</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "O nome completamente qualificado do tipo pedido, incluindo o espaço de nomes, mas não a assemblagem, tal como devolvido pelo &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; propriedade."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Um objeto que seja um wrapper para a nova instância, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se <code> typeName </code> não foi encontrado. O valor de retorno tem de ser não encapsulada para aceder ao objeto real."
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>Não foi encontrado."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>Não foi encontrado no <code>assemblyFile</code>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Não foi encontrado nenhum construtor público sem parâmetros."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "O chamador não tem permissão suficiente para chamar este construtor."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>Não é uma assemblagem válida.       - ou - versão 2.0 ou posterior do tempo de execução de idioma comum é actualmente carregado e <code>assemblyFile</code> foi compilada com uma versão posterior."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Uma assemblagem ou módulo foi carregado duas vezes com dois evidences diferentes."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Esta instância é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])
  id: CreateInstanceFrom(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância do tipo especificado definida no ficheiro de assemblagem especificado."
  remarks: "O construtor predefinido para `typeName` é invocado.       Para obter mais informações sobre este método, consulte o <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>método.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       Quando o <xref:System.AppDomain.CreateInstanceFrom%2A>método é utilizado para criar uma instância num domínio de aplicação de destino, que não seja o domínio de aplicação a partir do qual é feita a chamada, a assemblagem é carregada no domínio de aplicação de destino.</xref:System.AppDomain.CreateInstanceFrom%2A> No entanto, se a instância e não encapsulada no domínio de aplicação chamada, utilizando a instância e não encapsulada de determinadas formas pode fazer com que a assemblagem ser carregados para o domínio de aplicação de chamada. Por exemplo, depois da instância e não encapsulada, poderão ser pedidas as respetivas informações de tipo, para chamar os métodos tardio. Quando a assemblagem for carregada para o domínio de aplicação de chamada, podem ocorrer exceções.      -Se outra versão da mesma assemblagem foi carregada anteriormente para o domínio de aplicação de chamada ou se o caminho de carregamento do domínio de aplicação chamada é diferente do que o domínio de aplicação de destino, exceções, tal como <xref:System.MissingMethodException>podem ocorrer.</xref:System.MissingMethodException>      -Se o domínio aplicacional chamar faz com que o antecipado vinculados chamadas para o tipo de instância, <xref:System.InvalidCastException>pode ser emitida quando é efetuada uma tentativa para converter a instância.</xref:System.InvalidCastException>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "O nome, incluindo o caminho, de um ficheiro que contém uma assemblagem que define o tipo pedido. A assemblagem for carregada utilizando o <xref:System.Reflection.Assembly.LoadFrom*>método.</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "O nome completamente qualificado do tipo pedido, incluindo o espaço de nomes, mas não a assemblagem, tal como devolvido pelo &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; propriedade."
    - id: activationAttributes
      type: System.Object[]
      description: "Uma matriz de um ou mais atributos que podem participar na ativação. Normalmente, uma matriz que contenha um único <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objeto que especifica o URL que é necessário para ativar um objecto remoto.       Este parâmetro é relacionadas com os objetos de cliente ativado. Ativação do cliente é uma tecnologia de legado que é mantida por questões de compatibilidade, mas não é recomendada para um novo desenvolvimento. As aplicações distribuídas em vez disso, devem utilizar o Windows Communication Foundation."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Um objeto que seja um wrapper para a nova instância, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se <code> typeName </code> não foi encontrado. O valor de retorno tem de ser não encapsulada para aceder ao objeto real."
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>Não foi encontrado."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>Não foi encontrado no <code>assemblyFile</code>."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "O chamador não tem permissão suficiente para chamar este construtor."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Não foi encontrado nenhum construtor público correspondente."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A função invocadora não consegue fornecer atributos de activação para um objeto que não herda de <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>Não é uma assemblagem válida.       - ou - versão 2.0 ou posterior do tempo de execução de idioma comum é actualmente carregado e <code>assemblyFile</code> foi compilada com uma versão posterior."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Uma assemblagem ou módulo foi carregado duas vezes com dois evidences diferentes."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Esta instância é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância do tipo especificado definida no ficheiro de assemblagem especificado."
  remarks: "Para obter mais informações, consulte o <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>método.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       Quando o <xref:System.AppDomain.CreateInstanceFrom%2A>método é utilizado para criar uma instância num domínio de aplicação de destino, que não seja o domínio de aplicação a partir do qual é feita a chamada, a assemblagem é carregada no domínio de aplicação de destino.</xref:System.AppDomain.CreateInstanceFrom%2A> No entanto, se a instância e não encapsulada no domínio de aplicação chamada, utilizando a instância e não encapsulada de determinadas formas pode fazer com que a assemblagem ser carregados para o domínio de aplicação de chamada. Por exemplo, depois da instância e não encapsulada, poderão ser pedidas as respetivas informações de tipo, para chamar os métodos tardio. Quando a assemblagem for carregada para o domínio de aplicação de chamada, podem ocorrer exceções.      -Se outra versão da mesma assemblagem foi carregada anteriormente para o domínio de aplicação de chamada ou se o caminho de carregamento do domínio de aplicação chamada é diferente do que o domínio de aplicação de destino, exceções, tal como <xref:System.MissingMethodException>podem ocorrer.</xref:System.MissingMethodException>      -Se o domínio aplicacional chamar faz com que o antecipado vinculados chamadas para o tipo de instância, <xref:System.InvalidCastException>pode ser emitida quando é efetuada uma tentativa para converter a instância.</xref:System.InvalidCastException>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "O nome, incluindo o caminho, de um ficheiro que contém uma assemblagem que define o tipo pedido. A assemblagem for carregada utilizando o <xref:System.Reflection.Assembly.LoadFrom*>método.</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "O nome completamente qualificado do tipo pedido, incluindo o espaço de nomes, mas não a assemblagem, tal como devolvido pelo &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; propriedade."
    - id: ignoreCase
      type: System.Boolean
      description: "Um valor booleano que especifica se pretende efetuar uma pesquisa de maiúsculas e minúsculas ou não."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Uma combinação de zero ou mais sinalizadores de bits que afetam a pesquisa para o `typeName` construtor. Se `bindingAttr` é zero, uma pesquisa de maiúsculas e minúsculas para construtores públicos é efetuada."
    - id: binder
      type: System.Reflection.Binder
      description: "Tipos de um objeto que permite o enlace adesão do argumento, invocação de membros e a obtenção das <xref:System.Reflection.MemberInfo>objetos através de reflexão.</xref:System.Reflection.MemberInfo> Se `binder` é nulo, o Gestor de enlaces predefinido é utilizado."
    - id: args
      type: System.Object[]
      description: "Os argumentos transmitidos para o construtor. Esta matriz de argumentos tem correspondem em número de ordem e escreva os parâmetros do construtor para invocar. Se o construtor predefinido é preferencial, `args` tem de ser uma matriz vazia ou null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Informações específicas de cultura que regulam a adesão de `args` aos tipos formais declarados para a `typeName` construtor. Se `culture` é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, a <xref:System.Globalization.CultureInfo>para o thread actual é utilizado.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Uma matriz de um ou mais atributos que podem participar na ativação. Normalmente, uma matriz que contenha um único <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objeto que especifica o URL que é necessário para ativar um objecto remoto.       Este parâmetro é relacionadas com os objetos de cliente ativado. Ativação do cliente é uma tecnologia de legado que é mantida por questões de compatibilidade, mas não é recomendada para um novo desenvolvimento. As aplicações distribuídas em vez disso, devem utilizar o Windows Communication Foundation."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Um objeto que seja um wrapper para a nova instância, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se <code> typeName </code> não foi encontrado. O valor de retorno tem de ser não encapsulada para aceder ao objeto real."
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A função invocadora não consegue fornecer atributos de activação para um objeto que não herda de <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>Não foi encontrado."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>Não foi encontrado no <code>assemblyFile</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Não foi encontrado nenhum construtor público correspondente."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "O chamador não tem permissão suficiente para chamar este construtor."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>Não é uma assemblagem válida.       - ou - <code>assemblyFile</code> foi compilada com uma versão posterior do tempo de execução de idioma comum à versão que atualmente está carregado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Uma assemblagem ou módulo foi carregado duas vezes com dois evidences diferentes."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Esta instância é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância do tipo especificado definida no ficheiro de assemblagem especificado."
  remarks: "Para obter mais informações sobre este método, consulte o <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>método.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       Quando o <xref:System.AppDomain.CreateInstanceFrom%2A>método é utilizado para criar uma instância num domínio de aplicação de destino, que não seja o domínio de aplicação a partir do qual é feita a chamada, a assemblagem é carregada no domínio de aplicação de destino.</xref:System.AppDomain.CreateInstanceFrom%2A> No entanto, se a instância e não encapsulada no domínio de aplicação chamada, utilizando a instância e não encapsulada de determinadas formas pode fazer com que a assemblagem ser carregados para o domínio de aplicação de chamada. Por exemplo, depois da instância e não encapsulada, poderão ser pedidas as respetivas informações de tipo, para chamar os métodos tardio. Quando a assemblagem for carregada para o domínio de aplicação de chamada, podem ocorrer exceções.      -Se outra versão da mesma assemblagem foi carregada anteriormente para o domínio de aplicação de chamada ou se o caminho de carregamento do domínio de aplicação chamada é diferente do que o domínio de aplicação de destino, exceções, tal como <xref:System.MissingMethodException>podem ocorrer.</xref:System.MissingMethodException>      -Se o domínio aplicacional chamar faz com que o antecipado vinculados chamadas para o tipo de instância, <xref:System.InvalidCastException>pode ser emitida quando é efetuada uma tentativa para converter a instância.</xref:System.InvalidCastException>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "O nome, incluindo o caminho, de um ficheiro que contém uma assemblagem que define o tipo pedido. A assemblagem for carregada utilizando o <xref:System.Reflection.Assembly.LoadFrom*>método.</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "O nome completamente qualificado do tipo pedido, incluindo o espaço de nomes, mas não a assemblagem, tal como devolvido pelo &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; propriedade."
    - id: ignoreCase
      type: System.Boolean
      description: "Um valor booleano que especifica se pretende efetuar uma pesquisa de maiúsculas e minúsculas ou não."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Uma combinação de zero ou mais sinalizadores de bits que afetam a pesquisa para o `typeName` construtor. Se `bindingAttr` é zero, uma pesquisa de maiúsculas e minúsculas para construtores públicos é efetuada."
    - id: binder
      type: System.Reflection.Binder
      description: "Tipos de um objeto que permite o enlace adesão do argumento, invocação de membros e a obtenção das <xref:System.Reflection.MemberInfo>objetos através de reflexão.</xref:System.Reflection.MemberInfo> Se `binder` é nulo, o Gestor de enlaces predefinido é utilizado."
    - id: args
      type: System.Object[]
      description: "Os argumentos transmitidos para o construtor. Esta matriz de argumentos tem correspondem em número de ordem e escreva os parâmetros do construtor para invocar. Se o construtor predefinido é preferencial, `args` tem de ser uma matriz vazia ou null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Informações específicas de cultura que regulam a adesão de `args` aos tipos formais declarados para a `typeName` construtor. Se `culture` é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, a <xref:System.Globalization.CultureInfo>para o thread actual é utilizado.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Uma matriz de um ou mais atributos que podem participar na ativação. Normalmente, uma matriz que contenha um único <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objeto que especifica o URL que é necessário para ativar um objecto remoto.       Este parâmetro é relacionadas com os objetos de cliente ativado. Ativação do cliente é uma tecnologia de legado que é mantida por questões de compatibilidade, mas não é recomendada para um novo desenvolvimento. As aplicações distribuídas em vez disso, devem utilizar o Windows Communication Foundation."
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "Informações utilizadas para autorizar a criação de `typeName`."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Um objeto que seja um wrapper para a nova instância, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se <code> typeName </code> não foi encontrado. O valor de retorno tem de ser não encapsulada para aceder ao objeto real."
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A função invocadora não consegue fornecer atributos de activação para um objeto que não herda de <xref href=&quot;System.MarshalByRefObject&quot;> </xref>.       -or-       <code>securityAttributes</code> is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Quando a política CAS legada não estiver ativada, <code> securityAttributes </code> deve ser <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>Não foi encontrado."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>Não foi encontrado no <code>assemblyFile</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Não foi encontrado nenhum construtor público correspondente."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "O chamador não tem permissão suficiente para chamar este construtor."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>Não é uma assemblagem válida.       - ou - versão 2.0 ou posterior do tempo de execução de idioma comum é actualmente carregado e <code>assemblyFile</code> foi compilada com uma versão posterior."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Uma assemblagem ou módulo foi carregado duas vezes com dois evidences diferentes."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Esta instância é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)
  id: CreateInstanceFromAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância do tipo especificado definida no ficheiro de assemblagem especificado."
  remarks: "Este é um método de conveniência que combina <xref:System.AppDomain.CreateInstanceFrom%2A>e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstanceFrom%2A> Este método chama o construtor predefinido para `typeName`.       Para obter mais informações, consulte o <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>método.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "O nome de ficheiro e caminho da assemblagem que define o tipo pedido."
    - id: typeName
      type: System.String
      description: "O nome completamente qualificado do tipo pedido, incluindo o espaço de nomes, mas não a assemblagem, tal como devolvido pelo &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; propriedade."
    return:
      type: System.Object
      description: "O objeto pedido, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se <code> typeName </code> não foi encontrado."
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>Não foi encontrado."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>Não foi encontrado no <code>assemblyName</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Não foi encontrado nenhum construtor público sem parâmetros."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "O chamador não tem permissão suficiente para chamar este construtor."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>Não é uma assemblagem válida.       - ou - versão 2.0 ou posterior do tempo de execução de idioma comum é actualmente carregado e <code>assemblyName</code> foi compilada com uma versão posterior."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Uma assemblagem ou módulo foi carregado duas vezes com dois evidences diferentes."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  id: CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância do tipo especificado definida no ficheiro de assemblagem especificado."
  remarks: "Este é um método de conveniência que combina <xref:System.AppDomain.CreateInstanceFrom%2A>e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstanceFrom%2A> Este método chama o construtor predefinido para `typeName`.       Para obter mais informações sobre este método, consulte o <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>método.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "O nome de ficheiro e caminho da assemblagem que define o tipo pedido."
    - id: typeName
      type: System.String
      description: "O nome completamente qualificado do tipo pedido, incluindo o espaço de nomes, mas não a assemblagem (consulte o &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; propriedade)."
    - id: activationAttributes
      type: System.Object[]
      description: "Uma matriz de um ou mais atributos que podem participar na ativação. Normalmente, uma matriz que contenha um único <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objeto que especifica o URL que é necessário para ativar um objecto remoto.       Este parâmetro é relacionadas com os objetos de cliente ativado. Ativação do cliente é uma tecnologia de legado que é mantida por questões de compatibilidade, mas não é recomendada para um novo desenvolvimento. As aplicações distribuídas em vez disso, devem utilizar o Windows Communication Foundation."
    return:
      type: System.Object
      description: "O objeto pedido, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se <code> typeName </code> não foi encontrado."
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A função invocadora não consegue fornecer atributos de activação para um objeto que não herda de <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>Não foi encontrado."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>Não foi encontrado no <code>assemblyName</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Não foi encontrado nenhum construtor público sem parâmetros."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "O chamador não tem permissão suficiente para chamar este construtor."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>Não é uma assemblagem válida.       - ou - versão 2.0 ou posterior do tempo de execução de idioma comum é actualmente carregado e <code>assemblyName</code> foi compilada com uma versão posterior."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Uma assemblagem ou módulo foi carregado duas vezes com dois evidences diferentes."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância do tipo especificado definida no ficheiro de assemblagem especificado, especificar se as maiúsculas e minúsculas do nome do tipo é ignorada; os atributos de enlace e o Gestor de enlaces que são utilizados para selecionar o tipo a ser criado; os argumentos do construtor; a cultura; e os atributos de activação."
  remarks: "Este é um método de conveniência que combina <xref:System.AppDomain.CreateInstanceFrom%2A>e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstanceFrom%2A>       Para obter mais informações sobre este método, consulte o <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>método.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "O nome de ficheiro e caminho da assemblagem que define o tipo pedido."
    - id: typeName
      type: System.String
      description: "O nome completamente qualificado do tipo pedido, incluindo o espaço de nomes, mas não a assemblagem, tal como devolvido pelo &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; propriedade."
    - id: ignoreCase
      type: System.Boolean
      description: "Um valor booleano que especifica se pretende efetuar uma pesquisa de maiúsculas e minúsculas ou não."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Uma combinação de zero ou mais sinalizadores de bits que afetam a pesquisa para o `typeName` construtor. Se `bindingAttr` é zero, uma pesquisa de maiúsculas e minúsculas para construtores públicos é efetuada."
    - id: binder
      type: System.Reflection.Binder
      description: "Tipos de um objeto que permite o enlace adesão do argumento, invocação de membros e a obtenção das <xref:System.Reflection.MemberInfo>objetos através de reflexão.</xref:System.Reflection.MemberInfo> Se `binder` é nulo, o Gestor de enlaces predefinido é utilizado."
    - id: args
      type: System.Object[]
      description: "Os argumentos transmitidos para o construtor. Esta matriz de argumentos tem correspondem em número de ordem e escreva os parâmetros do construtor para invocar. Se o construtor predefinido é preferencial, `args` tem de ser uma matriz vazia ou null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Informações específicas de cultura que regulam a adesão de `args` aos tipos formais declarados para a `typeName` construtor. Se `culture` é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, a <xref:System.Globalization.CultureInfo>para o thread actual é utilizado.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Uma matriz de um ou mais atributos que podem participar na ativação. Normalmente, uma matriz que contenha um único <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objeto que especifica o URL que é necessário para ativar um objecto remoto.       Este parâmetro é relacionadas com os objetos de cliente ativado. Ativação do cliente é uma tecnologia de legado que é mantida por questões de compatibilidade, mas não é recomendada para um novo desenvolvimento. As aplicações distribuídas em vez disso, devem utilizar o Windows Communication Foundation."
    return:
      type: System.Object
      description: "O objeto pedido, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se <code> typeName </code> não foi encontrado."
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A função invocadora não consegue fornecer atributos de activação para um objeto que não herda de <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>Não foi encontrado."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>Não foi encontrado no <code>assemblyName</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Não foi encontrado nenhum construtor público correspondente."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "O chamador não tem permissão suficiente para chamar este construtor."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>Não é uma assemblagem válida.       - ou - <code>assemblyName</code> foi compilada com uma versão posterior do tempo de execução de idioma comum que a versão que está atualmente a ser carregado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Uma assemblagem ou módulo foi carregado duas vezes com dois evidences diferentes."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Cria uma nova instância do tipo especificado definida no ficheiro de assemblagem especificado."
  remarks: "Este é um método de conveniência que combina <xref:System.AppDomain.CreateInstanceFrom%2A>e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstanceFrom%2A>       Para obter mais informações sobre este método, consulte o <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>método.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "O nome de ficheiro e caminho da assemblagem que define o tipo pedido."
    - id: typeName
      type: System.String
      description: "O nome completamente qualificado do tipo pedido, incluindo o espaço de nomes, mas não a assemblagem, tal como devolvido pelo &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; propriedade."
    - id: ignoreCase
      type: System.Boolean
      description: "Um valor booleano que especifica se pretende efetuar uma pesquisa de maiúsculas e minúsculas ou não."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Uma combinação de zero ou mais sinalizadores de bits que afetam a pesquisa para o `typeName` construtor. Se `bindingAttr` é zero, uma pesquisa de maiúsculas e minúsculas para construtores públicos é efetuada."
    - id: binder
      type: System.Reflection.Binder
      description: "Tipos de um objeto que permite o enlace adesão do argumento, invocação de membros e a obtenção das <xref:System.Reflection.MemberInfo>objetos através de reflexão.</xref:System.Reflection.MemberInfo> Se `binder` é nulo, o Gestor de enlaces predefinido é utilizado."
    - id: args
      type: System.Object[]
      description: "Os argumentos transmitidos para o construtor. Esta matriz de argumentos tem correspondem em número de ordem e escreva os parâmetros do construtor para invocar. Se o construtor predefinido é preferencial, `args` tem de ser uma matriz vazia ou null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Informações específicas de cultura que regulam a adesão de `args` aos tipos formais declarados para a `typeName` construtor. Se `culture` é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, a <xref:System.Globalization.CultureInfo>para o thread actual é utilizado.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Uma matriz de um ou mais atributos que podem participar na ativação. Normalmente, uma matriz que contenha um único <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objeto que especifica o URL que é necessário para ativar um objecto remoto.       Este parâmetro é relacionadas com os objetos de cliente ativado. Ativação do cliente é uma tecnologia de legado que é mantida por questões de compatibilidade, mas não é recomendada para um novo desenvolvimento. As aplicações distribuídas em vez disso, devem utilizar o Windows Communication Foundation."
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "Informações utilizadas para autorizar a criação de `typeName`."
    return:
      type: System.Object
      description: "O objeto pedido, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se <code> typeName </code> não foi encontrado."
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "A função invocadora não consegue fornecer atributos de activação para um objeto que não herda de <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>Não foi encontrado."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>Não foi encontrado no <code>assemblyName</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Não foi encontrado nenhum construtor público correspondente."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "O chamador não tem permissão suficiente para chamar este construtor."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>Não é uma assemblagem válida.       - ou - versão 2.0 ou posterior do tempo de execução de idioma comum é actualmente carregado e <code>assemblyName</code> foi compilada com uma versão posterior."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Uma assemblagem ou módulo foi carregado duas vezes com dois evidences diferentes."
  platform:
  - net462
- uid: System.AppDomain.CurrentDomain
  id: CurrentDomain
  parent: System.AppDomain
  langs:
  - csharp
  name: CurrentDomain
  nameWithType: AppDomain.CurrentDomain
  fullName: System.AppDomain.CurrentDomain
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém o domínio de aplicação atual para o atual <xref href=&quot;System.Threading.Thread&quot;> </xref>."
  remarks: ''
  example:
  - "The following code example creates a new application domain. The CurrentDomain property is used to obtain an <xref:System.AppDomain> object that represents the current application domain. The <xref:System.AppDomain.FriendlyName%2A> property provides the name of the current application domain, which is then displayed at the command line.  \n  \n [!code-vb[ADApplicationBase#1](~/add/codesnippet/visualbasic/p-system.appdomain.curre_1.vb)]\n [!code-cpp[ADApplicationBase#1](~/add/codesnippet/cpp/p-system.appdomain.curre_1.cpp)]\n [!code-cs[ADApplicationBase#1](~/add/codesnippet/csharp/p-system.appdomain.curre_1.cs)]"
  syntax:
    content: public static AppDomain CurrentDomain { get; }
    return:
      type: System.AppDomain
      description: "O domínio de aplicação atual."
  overload: System.AppDomain.CurrentDomain*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Define uma assemblagem dinâmica com o modo de acesso e o nome especificado."
  remarks: "Este método só deve ser utilizado para definir uma assemblagem dinâmica no domínio de aplicação atual. Para obter mais informações, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>sobrecarga de método.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > Durante o desenvolvimento de código que emite assemblagens dinâmicas, é recomendado que utilize uma sobrecarga do <xref:System.AppDomain.DefineDynamicAssembly%2A>método que especifica provas e permissões, forneça a prova que pretende que a assemblagem dinâmica ter e inclua <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>no `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Incluindo <xref:System.Security.Permissions.SecurityPermissionFlag>no `refusedPermissions` parâmetro assegura que o MSIL é verificado.</xref:System.Security.Permissions.SecurityPermissionFlag> Uma limitação desta técnica é o que também faz com que <xref:System.Security.SecurityException>para ser emitida quando utilizado com o código que imperativas fidedignidade total.</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the DefineDynamicAssembly method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/ec69fa93-4aea-4fc8-90e1-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/ec69fa93-4aea-4fc8-90e1-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/ec69fa93-4aea-4fc8-90e1-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A identidade exclusiva da assemblagem dinâmica."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "O modo de acesso para a assemblagem dinâmica."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Uma assemblagem dinâmica com o modo de acesso e o nome especificado."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - ou - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> propriedade <code> name </code> começa com um espaço em branco ou contém uma barra de pesquisa direta ou com versões anteriores."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Define uma assemblagem dinâmica com o nome especificado, o modo de acesso e a atributos personalizados."
  remarks: "Utilize esta sobrecarga de método para especificar os atributos que não funcione corretamente, a menos que estas são aplicadas quando é criada uma assemblagem dinâmica. Por exemplo, segurança, tais como atributos <xref:System.Security.SecurityTransparentAttribute>e <xref:System.Security.SecurityCriticalAttribute>não funcionam corretamente se estes são adicionados depois de criada uma assemblagem dinâmica.</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       Este método deve ser utilizado apenas para definir uma assemblagem dinâmica no domínio de aplicação atual. Para mais informações sobre esta restrição, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>sobrecarga de método.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>       Esta sobrecarga de método é introduzida no [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)]."
  example:
  - "The following code sample shows how to create a dynamic assembly that has the <xref:System.Security.SecurityTransparentAttribute>. The attribute must be specified as an element of an array of <xref:System.Reflection.Emit.CustomAttributeBuilder> objects.  \n  \n The first step in creating the <xref:System.Reflection.Emit.CustomAttributeBuilder> is to obtain a constructor for the attribute. The constructor has no parameters, so the <xref:System.Type.GetConstructor%2A> method is called with an empty array of <xref:System.Type> objects to represent the types of the parameters. The second step is to pass the resulting <xref:System.Reflection.ConstructorInfo> object to the constructor for the <xref:System.Reflection.Emit.CustomAttributeBuilder> class, together with an empty array of type <xref:System.Object> to represent the arguments.  \n  \n The resulting <xref:System.Reflection.Emit.CustomAttributeBuilder> is then passed to the DefineDynamicAssembly method as the only element of an array.  \n  \n The example code defines a module and a type in the new dynamic assembly, and then displays the assembly's attributes.  \n  \n [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/add/codesnippet/cpp/02b9ff71-a699-4692-a2ae-_1.cpp)]\n [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/add/codesnippet/visualbasic/02b9ff71-a699-4692-a2ae-_1.vb)]\n [!code-cs[DefineDynamicAssemblyWithAttributes#1](~/add/codesnippet/csharp/02b9ff71-a699-4692-a2ae-_1.cs)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A identidade exclusiva da assemblagem dinâmica."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "O modo de acesso para a assemblagem dinâmica."
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "Uma lista enumeráveis de atributos a aplicar a assemblagem, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se existirem sem atributos."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Uma assemblagem dinâmica com o nome especificado e funcionalidades."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - ou - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> propriedade <code> name </code> começa com um espaço em branco ou contém uma barra de pesquisa direta ou com versões anteriores."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Define uma assemblagem dinâmica com o nome especificado, o modo de acesso e a provas."
  remarks: "Apenas totalmente fidedigna os chamadores podem fornecer as respetivas `evidence` quando se definem um dinâmico <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> O tempo de execução mapeará a <xref:System.Security.Policy.Evidence>através da política de segurança para determinar as permissões concedidas.</xref:System.Security.Policy.Evidence> Parcialmente fidedigna os chamadores tem de fornecer um valor nulo `evidence`. Se `evidence` é `null`, o tempo de execução copia os conjuntos de permissão, ou seja, o atual conceder e negar conjuntos, a partir da função invocadora <xref:System.Reflection.Assembly>a dinâmico <xref:System.Reflection.Assembly>que está a ser definido e marca política como resolvido.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Se a dinâmica <xref:System.Reflection.Assembly>é guardado no disco, carrega subsequentes irão obter concede com base nas políticas associadas com a localização onde o <xref:System.Reflection.Assembly>foi guardado.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Este método só deve ser utilizado para definir uma assemblagem dinâmica no domínio de aplicação atual. Para obter mais informações, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>sobrecarga de método.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > Durante o desenvolvimento de código que emite assemblagens dinâmicas, é recomendado que utilize uma sobrecarga do <xref:System.AppDomain.DefineDynamicAssembly%2A>método que especifica provas e permissões, forneça a prova que pretende que a assemblagem dinâmica ter e inclua <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>no `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Incluindo <xref:System.Security.Permissions.SecurityPermissionFlag>no `refusedPermissions` parâmetro assegura que o MSIL é verificado.</xref:System.Security.Permissions.SecurityPermissionFlag> Uma limitação desta técnica é o que também faz com que <xref:System.Security.SecurityException>para ser emitida quando utilizado com o código que imperativas fidedignidade total.</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and the <xref:System.AppDomain.AssemblyResolve> event.  \n  \n First, the code example tries to create an instance of `MyDynamicType` by calling the <xref:System.AppDomain.CreateInstance%2A> method with an invalid assembly name, and catches the resulting exception.  \n  \n The code example then adds an event handler for the <xref:System.AppDomain.AssemblyResolve> event, and again tries to create an instance of`MyDynamicType`. During the call to <xref:System.AppDomain.CreateInstance%2A>, the <xref:System.AppDomain.AssemblyResolve> event is raised for the invalid assembly. The event handler creates a dynamic assembly that contains a type named `MyDynamicType`, gives the type a parameterless constructor, and returns the new dynamic assembly. The call to <xref:System.AppDomain.CreateInstance%2A> then finishes successfully, and the constructor for `MyDynamicType` displays a message at the console.  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/1d1d705b-aac9-4233-8756-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/1d1d705b-aac9-4233-8756-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/1d1d705b-aac9-4233-8756-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A identidade exclusiva da assemblagem dinâmica."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "O modo em que a assemblagem dinâmica será acedida."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "A prova fornecida para a assemblagem dinâmica. A prova é utilizada será alterado como o conjunto final de prova utilizado para a resolução de política."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Uma assemblagem dinâmica com o nome especificado e funcionalidades."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - ou - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> propriedade <code> name </code> começa com um espaço em branco ou contém uma barra de pesquisa direta ou com versões anteriores."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Define uma assemblagem dinâmica com o nome especificado, o modo de acesso e o diretório de armazenamento."
  remarks: "Este método só deve ser utilizado para definir uma assemblagem dinâmica no domínio de aplicação atual. Para obter mais informações, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>sobrecarga de método.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > Durante o desenvolvimento de código que emite assemblagens dinâmicas, é recomendado que utilize uma sobrecarga do <xref:System.AppDomain.DefineDynamicAssembly%2A>método que especifica provas e permissões, forneça a prova que pretende que a assemblagem dinâmica ter e inclua <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>no `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Incluindo <xref:System.Security.Permissions.SecurityPermissionFlag>no `refusedPermissions` parâmetro assegura que o MSIL é verificado.</xref:System.Security.Permissions.SecurityPermissionFlag> Uma limitação desta técnica é o que também faz com que <xref:System.Security.SecurityException>para ser emitida quando utilizado com o código que imperativas fidedignidade total.</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/f3a30d18-28ff-4503-b1c6-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/f3a30d18-28ff-4503-b1c6-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/f3a30d18-28ff-4503-b1c6-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A identidade exclusiva da assemblagem dinâmica."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "O modo em que a assemblagem dinâmica será acedida."
    - id: dir
      type: System.String
      description: "O nome do diretório onde será guardada a assemblagem. Se `dir` é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, o diretório está predefinida para o diretório atual."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Uma assemblagem dinâmica com o nome especificado e funcionalidades."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - ou - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> propriedade <code> name </code> começa com um espaço em branco ou contém uma barra de pesquisa direta ou com versões anteriores."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Define uma assemblagem dinâmica com o nome especificado, o modo de acesso e a atributos personalizados e utilizar a origem especificada para o contexto de segurança."
  remarks: "Utilize esta sobrecarga de método para especificar os atributos que não funcione corretamente, a menos que estas são aplicadas quando é criada uma assemblagem dinâmica. Por exemplo, segurança, tais como atributos <xref:System.Security.SecurityTransparentAttribute>e <xref:System.Security.SecurityCriticalAttribute>não funcionam corretamente se estes são adicionados depois de criada uma assemblagem dinâmica.</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       Este método deve ser utilizado apenas para definir uma assemblagem dinâmica no domínio de aplicação atual. Para mais informações sobre esta restrição, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>sobrecarga de método.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes, System.Security.SecurityContextSource securityContextSource);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A identidade exclusiva da assemblagem dinâmica."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "O modo de acesso para a assemblagem dinâmica."
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "Uma lista enumeráveis de atributos a aplicar a assemblagem, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se existirem sem atributos."
    - id: securityContextSource
      type: System.Security.SecurityContextSource
      description: "A origem do contexto de segurança."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Uma assemblagem dinâmica com o nome especificado e funcionalidades."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - ou - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> propriedade <code> name </code> começa com um espaço em branco ou contém uma barra de pesquisa direta ou com versões anteriores."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "O valor de <code> securityContextSource </code> não era um dos valores de enumeração."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Define uma assemblagem dinâmica com o nome especificado, o modo de acesso, o diretório de armazenamento e a provas."
  remarks: "Apenas totalmente fidedigna os chamadores podem fornecer as respetivas `evidence` quando se definem um dinâmico <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> O tempo de execução mapeará a <xref:System.Security.Policy.Evidence>através da política de segurança para determinar as permissões concedidas.</xref:System.Security.Policy.Evidence> Parcialmente fidedigna os chamadores tem de fornecer um valor nulo `evidence`. Se `evidence` é `null`, o tempo de execução copia os conjuntos de permissão, ou seja, o atual conceder e negar conjuntos, a partir da função invocadora <xref:System.Reflection.Assembly>a dinâmico <xref:System.Reflection.Assembly>que está a ser definido e marca política como resolvido.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Se a dinâmica <xref:System.Reflection.Assembly>é guardado no disco, carrega subsequentes irão obter concede com base nas políticas associadas com a localização onde o <xref:System.Reflection.Assembly>foi guardado.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Este método só deve ser utilizado para definir uma assemblagem dinâmica no domínio de aplicação atual. Para obter mais informações, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>sobrecarga de método.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > Durante o desenvolvimento de código que emite assemblagens dinâmicas, é recomendado que utilize uma sobrecarga do <xref:System.AppDomain.DefineDynamicAssembly%2A>método que especifica provas e permissões, forneça a prova que pretende que a assemblagem dinâmica ter e inclua <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>no `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Incluindo <xref:System.Security.Permissions.SecurityPermissionFlag>no `refusedPermissions` parâmetro assegura que o MSIL é verificado.</xref:System.Security.Permissions.SecurityPermissionFlag> Uma limitação desta técnica é o que também faz com que <xref:System.Security.SecurityException>para ser emitida quando utilizado com o código que imperativas fidedignidade total.</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/2cf98986-7843-48cf-a73f-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/2cf98986-7843-48cf-a73f-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/2cf98986-7843-48cf-a73f-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A identidade exclusiva da assemblagem dinâmica."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "O modo em que a assemblagem dinâmica será acedida."
    - id: dir
      type: System.String
      description: "O nome do diretório onde será guardada a assemblagem. Se `dir` é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, o diretório está predefinida para o diretório atual."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "A prova fornecida para a assemblagem dinâmica. A prova é utilizada será alterado como o conjunto final de prova utilizado para a resolução de política."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Uma assemblagem dinâmica com o nome especificado e funcionalidades."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - ou - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> propriedade <code> name </code> começa com um espaço em branco ou contém uma barra de pesquisa direta ou com versões anteriores."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Define uma assemblagem dinâmica com o nome especificado, o modo de acesso e a pedidos de permissão."
  remarks: "Os pedidos de permissão especificados para `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` não são utilizadas, a menos que a assemblagem dinâmica foi guardada e recarregar na memória. Para especificar os pedidos de permissão para uma assemblagem transitória que nunca é guardada em disco, utilize uma sobrecarga do <xref:System.AppDomain.DefineDynamicAssembly%2A>método que especifica provas como solicitado, bem como permissões e forneça um <xref:System.Security.Policy.Evidence>objeto.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.DefineDynamicAssembly%2A>      > [!NOTE] > Durante o desenvolvimento de código que emite assemblagens dinâmicas, é recomendado que utilize uma sobrecarga do <xref:System.AppDomain.DefineDynamicAssembly%2A>método que especifica provas e permissões, forneça a prova que pretende que a assemblagem dinâmica ter e inclua <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>no `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Incluindo <xref:System.Security.Permissions.SecurityPermissionFlag>no `refusedPermissions` parâmetro assegura que o MSIL é verificado.</xref:System.Security.Permissions.SecurityPermissionFlag> Uma limitação desta técnica é o que também faz com que <xref:System.Security.SecurityException>para ser emitida quando utilizado com o código que imperativas fidedignidade total.</xref:System.Security.SecurityException>       Este método só deve ser utilizado para definir uma assemblagem dinâmica no domínio de aplicação atual. Para obter mais informações, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>sobrecarga de método.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/be48f0dd-e58f-4a8c-bdad-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/be48f0dd-e58f-4a8c-bdad-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/be48f0dd-e58f-4a8c-bdad-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A identidade exclusiva da assemblagem dinâmica."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "O modo em que a assemblagem dinâmica será acedida."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "Pedem as permissões necessárias."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "As permissões opcionais do pedido."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "As permissões negadas o pedido."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Uma assemblagem dinâmica com o nome especificado e funcionalidades."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - ou - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> propriedade <code> name </code> começa com um espaço em branco ou contém uma barra de pesquisa direta ou com versões anteriores."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Define uma assemblagem dinâmica com o nome especificado, o modo de acesso, o diretório de armazenamento e a opção de sincronização."
  remarks: "Utilize esta sobrecarga de método para especificar os atributos que não funcione corretamente, a menos que estas são aplicadas quando é criada uma assemblagem dinâmica. Por exemplo, segurança, tais como atributos <xref:System.Security.SecurityTransparentAttribute>e <xref:System.Security.SecurityCriticalAttribute>não funcionam corretamente se estes são adicionados depois de criada uma assemblagem dinâmica.</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       Se `isSynchronized` é `true`, os seguintes métodos de resultante <xref:System.Reflection.Emit.AssemblyBuilder>serão sincronizados: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>e <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> </xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> </xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder> Se dois destes métodos são denominados em diferentes threads, uma irá bloquear até que o outro está concluído."
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A identidade exclusiva da assemblagem dinâmica."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "O modo em que a assemblagem dinâmica será acedida."
    - id: dir
      type: System.String
      description: "O nome do diretório onde será guardada a assemblagem dinâmica. Se `dir` é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, é utilizado o diretório atual."
    - id: isSynchronized
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>para sincronizar a criação de módulos, tipos e membros na assemblagem dinâmica; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "Uma lista enumeráveis de atributos a aplicar a assemblagem, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se existirem sem atributos."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Uma assemblagem dinâmica com o nome especificado e funcionalidades."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - ou - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> propriedade <code> name </code> começa com um espaço em branco ou contém uma barra de pesquisa direta ou com versões anteriores."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Define uma assemblagem dinâmica com o nome especificado, modo de acesso, provas e pedidos de permissão."
  remarks: "Os pedidos de permissão especificados para `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` são utilizadas apenas se `evidence` também for fornecido, ou se a assemblagem dinâmica é guardada e recarregar na memória.      > [!NOTE] > Durante o desenvolvimento de código que emite assemblagens dinâmicas, é recomendado que inclui <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>no `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> Incluindo <xref:System.Security.Permissions.SecurityPermissionFlag>no `refusedPermissions` parâmetro assegura que o MSIL é verificado.</xref:System.Security.Permissions.SecurityPermissionFlag> Uma limitação desta técnica é o que também faz com que <xref:System.Security.SecurityException>para ser emitida quando utilizado com o código que imperativas fidedignidade total.</xref:System.Security.SecurityException>       Apenas totalmente fidedigna os chamadores podem fornecer as respetivas `evidence` quando se definem um dinâmico <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> O tempo de execução mapeará a <xref:System.Security.Policy.Evidence>através da política de segurança para determinar as permissões concedidas.</xref:System.Security.Policy.Evidence> Parcialmente fidedigna os chamadores tem de fornecer um valor nulo `evidence`. Se `evidence` é `null`, o tempo de execução copia os conjuntos de permissão, ou seja, o atual conceder e negar conjuntos, a partir da função invocadora <xref:System.Reflection.Assembly>a dinâmico <xref:System.Reflection.Assembly>que está a ser definido e marca política como resolvido.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Se a dinâmica <xref:System.Reflection.Assembly>é guardado no disco, carrega subsequentes irão obter concede com base nas políticas associadas com a localização onde o <xref:System.Reflection.Assembly>foi guardado.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Este método só deve ser utilizado para definir uma assemblagem dinâmica no domínio de aplicação atual. Para obter mais informações, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>sobrecarga de método.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/7d7c7162-9e00-4b91-93d0-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/7d7c7162-9e00-4b91-93d0-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/7d7c7162-9e00-4b91-93d0-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A identidade exclusiva da assemblagem dinâmica."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "O modo em que a assemblagem dinâmica será acedida."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "A prova fornecida para a assemblagem dinâmica. A prova é utilizada será alterado como o conjunto final de prova utilizado para a resolução de política."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "Pedem as permissões necessárias."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "As permissões opcionais do pedido."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "As permissões negadas o pedido."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Uma assemblagem dinâmica com o nome especificado e funcionalidades."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - ou - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> propriedade <code> name </code> começa com um espaço em branco ou contém uma barra de pesquisa direta ou com versões anteriores."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Define uma assemblagem dinâmica com o nome especificado, o modo de acesso, o diretório de armazenamento e a pedidos de permissão."
  remarks: "Os pedidos de permissão especificados para `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` não são utilizadas, a menos que a assemblagem dinâmica foi guardada e recarregar na memória. Para especificar os pedidos de permissão para uma assemblagem transitória que nunca é guardada em disco, utilize uma sobrecarga do <xref:System.AppDomain.DefineDynamicAssembly%2A>método que especifica provas como solicitado, bem como permissões e forneça um <xref:System.Security.Policy.Evidence>objeto.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.DefineDynamicAssembly%2A>      > [!NOTE] > Durante o desenvolvimento de código que emite assemblagens dinâmicas, é recomendado que utilize uma sobrecarga do <xref:System.AppDomain.DefineDynamicAssembly%2A>método que especifica provas e permissões, forneça a prova que pretende que a assemblagem dinâmica ter e inclua <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>no `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Incluindo <xref:System.Security.Permissions.SecurityPermissionFlag>no `refusedPermissions` parâmetro assegura que o MSIL é verificado.</xref:System.Security.Permissions.SecurityPermissionFlag> Uma limitação desta técnica é o que também faz com que <xref:System.Security.SecurityException>para ser emitida quando utilizado com o código que imperativas fidedignidade total.</xref:System.Security.SecurityException>       Este método só deve ser utilizado para definir uma assemblagem dinâmica no domínio de aplicação atual. Para obter mais informações, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>sobrecarga de método.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/0fc3676e-96ff-42c6-ad25-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/0fc3676e-96ff-42c6-ad25-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/0fc3676e-96ff-42c6-ad25-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A identidade exclusiva da assemblagem dinâmica."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "O modo em que a assemblagem dinâmica será acedida."
    - id: dir
      type: System.String
      description: "O nome do diretório onde será guardada a assemblagem. Se `dir` é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, o diretório está predefinida para o diretório atual."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "Pedem as permissões necessárias."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "As permissões opcionais do pedido."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "As permissões negadas o pedido."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Uma assemblagem dinâmica com o nome especificado e funcionalidades."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - ou - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> propriedade <code> name </code> começa com um espaço em branco ou contém uma barra de pesquisa direta ou com versões anteriores."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Define uma assemblagem dinâmica com o nome especificado, modo de acesso, o diretório de armazenamento, provas e pedidos de permissão."
  remarks: "Os pedidos de permissão especificados para `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` são utilizadas apenas se `evidence` também for fornecido, ou se a assemblagem dinâmica é guardada e recarregar na memória.      > [!NOTE] > Durante o desenvolvimento de código que emite assemblagens dinâmicas, é recomendado que inclui <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>no `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> Incluindo <xref:System.Security.Permissions.SecurityPermissionFlag>no `refusedPermissions` parâmetro assegura que o MSIL é verificado.</xref:System.Security.Permissions.SecurityPermissionFlag> Uma limitação desta técnica é o que também faz com que <xref:System.Security.SecurityException>para ser emitida quando utilizado com o código que imperativas fidedignidade total.</xref:System.Security.SecurityException>       Apenas totalmente fidedigna os chamadores podem fornecer as respetivas `evidence` quando se definem um dinâmico <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> O tempo de execução mapeará a <xref:System.Security.Policy.Evidence>através da política de segurança para determinar as permissões concedidas.</xref:System.Security.Policy.Evidence> Parcialmente fidedigna os chamadores tem de fornecer um valor nulo `evidence`. Se `evidence` é `null`, o tempo de execução copia os conjuntos de permissão, ou seja, o atual conceder e negar conjuntos, a partir da função invocadora <xref:System.Reflection.Assembly>a dinâmico <xref:System.Reflection.Assembly>que está a ser definido e marca política como resolvido.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Se a dinâmica <xref:System.Reflection.Assembly>é guardado no disco, carrega subsequentes irão obter concede com base nas políticas associadas com a localização onde o <xref:System.Reflection.Assembly>foi guardado.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Este método só deve ser utilizado para definir uma assemblagem dinâmica no domínio de aplicação atual. Para obter mais informações, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>sobrecarga de método.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/0baa3466-02cf-4d9c-bb66-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/0baa3466-02cf-4d9c-bb66-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/0baa3466-02cf-4d9c-bb66-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A identidade exclusiva da assemblagem dinâmica."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "O modo em que a assemblagem dinâmica será acedida."
    - id: dir
      type: System.String
      description: "O nome do diretório onde será guardada a assemblagem. Se `dir` é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, o diretório está predefinida para o diretório atual."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "A prova fornecida para a assemblagem dinâmica. A prova é utilizada será alterado como o conjunto final de prova utilizado para a resolução de política."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "Pedem as permissões necessárias."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "As permissões opcionais do pedido."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "As permissões negadas o pedido."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Uma assemblagem dinâmica com o nome especificado e funcionalidades."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - ou - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> propriedade <code> name </code> começa com um espaço em branco ou contém uma barra de pesquisa direta ou com versões anteriores."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Define uma assemblagem dinâmica com o nome especificado, modo de acesso, o diretório de armazenamento, provas, pedidos de permissão e opção de sincronização."
  remarks: "Os pedidos de permissão especificados para `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` são utilizadas apenas se `evidence` também for fornecido, ou se a assemblagem dinâmica é guardada e recarregar na memória.      > [!NOTE] > Durante o desenvolvimento de código que emite assemblagens dinâmicas, é recomendado que inclui <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>no `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> Incluindo <xref:System.Security.Permissions.SecurityPermissionFlag>no `refusedPermissions` parâmetro assegura que o MSIL é verificado.</xref:System.Security.Permissions.SecurityPermissionFlag> Uma limitação desta técnica é o que também faz com que <xref:System.Security.SecurityException>para ser emitida quando utilizado com o código que imperativas fidedignidade total.</xref:System.Security.SecurityException>       Só os chamadores totalmente fidedignos podem fornecer as respetivas provas quando se definem um dinâmico <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> O tempo de execução mapeará a <xref:System.Security.Policy.Evidence>através da política de segurança para determinar as permissões concedidas.</xref:System.Security.Policy.Evidence> Parcialmente fidedigna tem de fornecer os chamadores `null` para o `evidence` parâmetro. Se `evidence` é `null`, o tempo de execução copia os conjuntos de permissão, ou seja, o atual conceder e negar conjuntos, a partir da função invocadora <xref:System.Reflection.Assembly>a dinâmico <xref:System.Reflection.Assembly>que está a ser definido e marca política como resolvido.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Se a dinâmica <xref:System.Reflection.Assembly>é guardado no disco, carrega subsequentes irão obter concede com base nas políticas associadas com a localização onde o <xref:System.Reflection.Assembly>foi guardado.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Se `isSynchronized` é `true`, os seguintes métodos de resultante <xref:System.Reflection.Emit.AssemblyBuilder>serão sincronizados: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>e <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> </xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> </xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder> Se dois destes métodos são denominados em diferentes threads, um bloqueia enquanto o outro for concluída."
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/84dd3b17-5601-467b-b1e3-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/84dd3b17-5601-467b-b1e3-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/84dd3b17-5601-467b-b1e3-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A identidade exclusiva da assemblagem dinâmica."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "O modo em que a assemblagem dinâmica será acedida."
    - id: dir
      type: System.String
      description: "O nome do diretório onde será guardada a assemblagem dinâmica. Se `dir` é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, o diretório está predefinida para o diretório atual."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "A prova fornecida para a assemblagem dinâmica. A prova é utilizada será alterado como o conjunto final de prova utilizado para a resolução de política."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "Pedem as permissões necessárias."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "As permissões opcionais do pedido."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "As permissões negadas o pedido."
    - id: isSynchronized
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>para sincronizar a criação de módulos, tipos e membros na assemblagem dinâmica; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Uma assemblagem dinâmica com o nome especificado e funcionalidades."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - ou - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> propriedade <code> name </code> começa com um espaço em branco ou contém uma barra de pesquisa direta ou com versões anteriores."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Define uma assemblagem dinâmica com o nome especificado, modo de acesso, o diretório de armazenamento, provas, pedidos de permissão, opção de sincronização e atributos personalizados."
  remarks: "Utilize esta sobrecarga de método para especificar os atributos que não funcione corretamente, a menos que estas são aplicadas quando é criada uma assemblagem dinâmica. Por exemplo, segurança, tais como atributos <xref:System.Security.SecurityTransparentAttribute>e <xref:System.Security.SecurityCriticalAttribute>não funcionam corretamente se estes são adicionados depois de criada uma assemblagem dinâmica.</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       Os pedidos de permissão especificados para o `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` parâmetros são utilizados apenas se o `evidence` parâmetro também for fornecido, ou se a assemblagem dinâmica é guardada e recarregar na memória.      > [!NOTE] > Quando desenvolver código que emite assemblagens dinâmicas, recomendamos que inclui o <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>mostram o `refusedPermissions` parâmetro.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> A inclusão deste sinalizador assegura que a Microsoft idioma intermédio (MSIL) será verificado. Esta técnica irá detetar a geração de código não verificável, caso contrário, que é muito difícil detetar não intencional. Uma limitação desta técnica é o que também faz com que <xref:System.Security.SecurityException>para ser emitida quando é utilizado com o código que imperativas fidedignidade total.</xref:System.Security.SecurityException>       Só os chamadores totalmente fidedignos podem fornecer provas quando se definem um dinâmico <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> O tempo de execução mapeia o <xref:System.Security.Policy.Evidence>através da política de segurança para determinar as permissões concedidas.</xref:System.Security.Policy.Evidence> Parcialmente fidedigna tem de fornecer os chamadores `null` para o `evidence` parâmetro. Se `evidence` é `null`, o tempo de execução copia os conjuntos de permissão (que é a concessão atual e negar conjuntos) da assemblagem do chamador para a assemblagem dinâmica que está a ser definida e marca a política como resolvido.       Se a assemblagem dinâmica é guardada no disco, subsequente cargas obterá concede com base nas políticas que estão associadas a localização onde foi guardada a assemblagem dinâmica.       Se `isSynchronized` é `true`, os seguintes métodos de resultante <xref:System.Reflection.Emit.AssemblyBuilder>serão sincronizados: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>e <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> </xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> </xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder> Se dois destes métodos são denominados em diferentes threads, uma irá bloquear até que o outro está concluído.       Esta sobrecarga de método é introduzida no [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)]."
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "A identidade exclusiva da assemblagem dinâmica."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "O modo em que a assemblagem dinâmica será acedida."
    - id: dir
      type: System.String
      description: "O nome do diretório onde será guardada a assemblagem dinâmica. Se `dir` é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, é utilizado o diretório atual."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "A prova que é fornecida para a assemblagem dinâmica. A prova é utilizada será alterado como o conjunto final de prova utilizado para a resolução de política."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "Pedem as permissões necessárias."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "As permissões opcionais do pedido."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "As permissões negadas o pedido."
    - id: isSynchronized
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>para sincronizar a criação de módulos, tipos e membros na assemblagem dinâmica; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "Uma lista enumeráveis de atributos a aplicar a assemblagem, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se existirem sem atributos."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Uma assemblagem dinâmica com o nome especificado e funcionalidades."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - ou - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> propriedade <code> name </code> começa com um espaço em branco ou contém uma barra de pesquisa direta ou com versões anteriores."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)
  id: DoCallBack(System.CrossAppDomainDelegate)
  parent: System.AppDomain
  langs:
  - csharp
  name: DoCallBack(CrossAppDomainDelegate)
  nameWithType: AppDomain.DoCallBack(CrossAppDomainDelegate)
  fullName: System.AppDomain.DoCallBack(CrossAppDomainDelegate)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Executa o código no outro domínio de aplicação que é identificado pelo delegado do especificado."
  remarks: '`callBackDelegate`Pode especificar um empacotamento de referências por valor, <xref:System.MarshalByRefObject>, ou <xref:System.ContextBoundObject>.</xref:System.ContextBoundObject> </xref:System.MarshalByRefObject>'
  example:
  - "The following sample demonstrates using a static DoCallBack method.  \n  \n [!code-vb[AppDomain_DoCallBack#1](~/add/codesnippet/visualbasic/m-system.appdomain.docal_1.vb)]\n [!code-cpp[AppDomain_DoCallBack#1](~/add/codesnippet/cpp/m-system.appdomain.docal_1.cpp)]\n [!code-cs[AppDomain_DoCallBack#1](~/add/codesnippet/csharp/m-system.appdomain.docal_1.cs)]  \n  \n The following sample demonstrates using the DoCallBack method by value.  \n  \n [!code-vb[AppDomain_DoCallBack#2](~/add/codesnippet/visualbasic/m-system.appdomain.docal_2.vb)]\n [!code-cs[AppDomain_DoCallBack#2](~/add/codesnippet/csharp/m-system.appdomain.docal_2.cs)]\n [!code-cpp[AppDomain_DoCallBack#2](~/add/codesnippet/cpp/m-system.appdomain.docal_2.cpp)]  \n  \n The following sample demonstrates using the DoCallBack method by reference.  \n  \n [!code-cpp[AppDomain_DoCallBack#3](~/add/codesnippet/cpp/m-system.appdomain.docal_3.cpp)]\n [!code-cs[AppDomain_DoCallBack#3](~/add/codesnippet/csharp/m-system.appdomain.docal_3.cs)]\n [!code-vb[AppDomain_DoCallBack#3](~/add/codesnippet/visualbasic/m-system.appdomain.docal_3.vb)]"
  syntax:
    content: public void DoCallBack (CrossAppDomainDelegate callBackDelegate);
    parameters:
    - id: callBackDelegate
      type: System.CrossAppDomainDelegate
      description: "Um delegado que especifica um método de chamada."
  overload: System.AppDomain.DoCallBack*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBackDelegate</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.DomainManager
  id: DomainManager
  parent: System.AppDomain
  langs:
  - csharp
  name: DomainManager
  nameWithType: AppDomain.DomainManager
  fullName: System.AppDomain.DomainManager
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém o Gestor de domínio fornecido pelo anfitrião quando o domínio de aplicação foi inicializado."
  remarks: "Um anfitrião gerido do language runtime (CLR) pode fornecer um Gestor de domínio. O Gestor de domínio pode participar de inicialização do novo domínio de aplicação e fornecer outros gestores, tal como um <xref:System.Security.HostSecurityManager>, que participar em operações de domínio de aplicação.</xref:System.Security.HostSecurityManager>"
  syntax:
    content: public AppDomainManager DomainManager { get; }
    return:
      type: System.AppDomainManager
      description: "Um objecto que representa o Gestor de domínio fornecido pelo anfitrião, quando o domínio de aplicação foi inicializado, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> não se foi fornecido nenhum gestor de domínios."
  overload: System.AppDomain.DomainManager*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.DomainUnload
  id: DomainUnload
  parent: System.AppDomain
  langs:
  - csharp
  name: DomainUnload
  nameWithType: AppDomain.DomainUnload
  fullName: System.AppDomain.DomainUnload
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ocorre quando um <xref href=&quot;System.AppDomain&quot;> </xref> está prestes a ser descarregado."
  remarks: "O <xref:System.EventHandler>Delegar para este evento pode efetuar quaisquer atividades de terminação antes do domínio de aplicação é descarregado.</xref:System.EventHandler>       Cada domínio de aplicação que necessita para efetuar o processamento quando é descarregado deve registar um processador de eventos para este evento. Um processador de eventos partilhado não deve ser utilizado, porque o <xref:System.EventHandler>delegado não identifica o domínio que está a ser descarregado.</xref:System.EventHandler>      > [!NOTE] > Este evento é desencadeado nunca no domínio de aplicação predefinido.       Não efetue pressupostos sobre o evento é gerado no thread. O evento pode ser gerado num thread diferente daquela que chamar a <xref:System.AppDomain.Unload%2A>método.</xref:System.AppDomain.Unload%2A>       Para obter mais informações sobre como lidar com eventos, consulte [eventos](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public event EventHandler DomainUnload;
    return:
      type: System.EventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.DynamicDirectory
  id: DynamicDirectory
  parent: System.AppDomain
  langs:
  - csharp
  name: DynamicDirectory
  nameWithType: AppDomain.DynamicDirectory
  fullName: System.AppDomain.DynamicDirectory
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém o diretório que utiliza o Resolvedor de assemblagem para a sonda para assemblagens dinamicamente criadas."
  remarks: "Para definir o diretório dinâmico, atribua um caminho de diretório base para o <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName>propriedade o <xref:System.AppDomainSetup>objeto que será utilizado para criar o novo domínio de aplicação.</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName> O caminho de diretório base a atribuir à propriedade é modificado pela adição de um subdiretório cujo nome simple é o código hash da cadeia de atribuir ao <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>propriedade, pelo que é o formato do diretório base *caminho original*\\\\*hash código*.</xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName> O diretório dinâmico é um subdiretório do diretório de base. O nome simple é o valor da <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>propriedade, pelo que é o seu formato *caminho original*\\\\*hash código*\\\\*nome da aplicação*.</xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>"
  example:
  - "The following example creates an application domain with a directory for dynamic assemblies, emits a dynamic assembly and stores it in the dynamic directory, and then loads the assembly into the new application domain and uses it.  \n  \n The example creates an <xref:System.AppDomainSetup> object and sets its <xref:System.AppDomainSetup.ApplicationName%2A> property to \"Example\" and its <xref:System.AppDomainSetup.DynamicBase%2A> property to \"C:\\DynamicAssemblyDir\". The example then displays the <xref:System.AppDomainSetup.DynamicBase%2A> property, to show that the hash code of the application name has been appended as a subdirectory of the path that was originally assigned.  \n  \n> [!NOTE]\n>  The base directory in this example is intended to be outside the probing path for the example application. Be sure to compile the example in a different location. Delete the base directory and all its subdirectories each time you run the example.  \n  \n The example creates a new application domain, using the <xref:System.AppDomainSetup> object. The example uses the DynamicDirectory property to retrieve the name of the directory, so it can create the directory. (The example could just as easily create the directory beforehand by concatenating the original path, the hash code of the application name, and the application name.)  \n  \n The example has a `GenerateDynamicAssembly` method that emits an assembly named `DynamicHelloWorld.dll` and stores it in the new application domain's dynamic directory. The dynamic assembly contains one type, `HelloWorld`, that has a static method (`Shared` method in Visual Basic) named `HelloFromAD`. Calling this method displays the name of the application domain.  \n  \n The `Example` class derives from <xref:System.MarshalByRefObject>, so the example can create an instance of the class in the new application domain and call its `Test` method. The `Test` method loads the dynamic assembly by its display name and calls the static `HelloFromAD` method.  \n  \n You can show that the dynamic directory is searched after the normal probing paths by writing code for an assembly named `DynamicHelloWorld.dll` and compiling it in the same directory as this example. The assembly must have a class named `HelloWorld` with a static method named `HelloFromAD`. This method does not have to have the same functionality as the one in the example; it can simply display a string to the console. The assembly must also have an <xref:System.Reflection.AssemblyVersionAttribute> attribute that sets its version to 1.0.0.0. When you run the example, the assembly you compiled in the current directory is found before the dynamic directory is searched.  \n  \n [!code-cpp[ADDynamicBase#1](~/add/codesnippet/cpp/p-system.appdomain.dynam_1.cpp)]\n [!code-cs[ADDynamicBase#1](~/add/codesnippet/csharp/p-system.appdomain.dynam_1.cs)]\n [!code-vb[ADDynamicBase#1](~/add/codesnippet/visualbasic/p-system.appdomain.dynam_1.vb)]"
  syntax:
    content: public string DynamicDirectory { get; }
    return:
      type: System.String
      description: "O diretório que utiliza o Resolvedor de assemblagem para a sonda dinamicamente para criar assemblagens."
  overload: System.AppDomain.DynamicDirectory*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.Evidence
  id: Evidence
  parent: System.AppDomain
  langs:
  - csharp
  name: Evidence
  nameWithType: AppDomain.Evidence
  fullName: System.AppDomain.Evidence
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém o <xref href=&quot;System.Security.Policy.Evidence&quot;> </xref> associados a este domínio de aplicação."
  syntax:
    content: public System.Security.Policy.Evidence Evidence { get; }
    return:
      type: System.Security.Policy.Evidence
      description: "A prova associada a este domínio de aplicação."
  overload: System.AppDomain.Evidence*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String)
  id: ExecuteAssembly(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String)
  nameWithType: AppDomain.ExecuteAssembly(String)
  fullName: System.AppDomain.ExecuteAssembly(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Executa a assemblagem contida no ficheiro especificado."
  remarks: "A assemblagem começa em execução no ponto de entrada especificado no cabeçalho do .NET Framework.       Este método não criar um novo processo ou domínio de aplicação e não é executado o método de ponto de entrada num thread novo.       Este método carrega assemblagens utilizando o <xref:System.Reflection.Assembly.LoadFile%2A>método.</xref:System.Reflection.Assembly.LoadFile%2A> Também pode executar assemblagens utilizando o <xref:System.AppDomain.ExecuteAssemblyByName%2A>método, o que é carregado assemblagens utilizando o <xref:System.Reflection.Assembly.Load%2A>método.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       Para criar o <xref:System.AppDomain>para carregar e executar, utilize o <xref:System.AppDomain.CreateDomain%2A>método.</xref:System.AppDomain.CreateDomain%2A> </xref:System.AppDomain>"
  example:
  - "The following sample demonstrates using one of the overloads of ExecuteAssembly on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/m-system.appdomain.execu_0_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/m-system.appdomain.execu_0_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/m-system.appdomain.execu_0_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "O nome do ficheiro que contém a assemblagem para executar."
    return:
      type: System.Int32
      description: "O valor devolvido pelo ponto de entrada da assemblagem."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>Não foi encontrado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>Não é uma assemblagem válida.       - ou - versão 2.0 ou posterior do tempo de execução de idioma comum é actualmente carregado e <code>assemblyFile</code> foi compilada com uma versão posterior."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Uma assemblagem ou módulo foi carregado duas vezes com dois evidences diferentes."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "A assemblagem especificada não tem nenhum ponto de entrada."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  id: ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,Evidence)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Executa a assemblagem contida no ficheiro especificado, utilizando a prova especificada."
  remarks: "A assemblagem começa em execução no ponto de entrada especificado no cabeçalho do .NET Framework.       O <xref:System.AppDomain.ExecuteAssembly%2A>método não criar um novo processo ou domínio de aplicação e não é executado o método de ponto de entrada num novo thread.</xref:System.AppDomain.ExecuteAssembly%2A>       Este método carrega assemblagens utilizando o <xref:System.Reflection.Assembly.LoadFile%2A>método.</xref:System.Reflection.Assembly.LoadFile%2A> Também pode executar assemblagens utilizando o <xref:System.AppDomain.ExecuteAssemblyByName%2A>método, o que é carregado assemblagens utilizando o <xref:System.Reflection.Assembly.Load%2A>método.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/8a3b95e3-eb51-4f5b-bb93-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/8a3b95e3-eb51-4f5b-bb93-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/8a3b95e3-eb51-4f5b-bb93-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "O nome do ficheiro que contém a assemblagem para executar."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Provas para carregar a assemblagem."
    return:
      type: System.Int32
      description: "O valor devolvido pelo ponto de entrada da assemblagem."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>Não foi encontrado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>Não é uma assemblagem válida.       - ou - versão 2.0 ou posterior do tempo de execução de idioma comum é actualmente carregado e <code>assemblyFile</code> foi compilada com uma versão posterior."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Uma assemblagem ou módulo foi carregado duas vezes com dois evidences diferentes."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "A assemblagem especificada não tem nenhum ponto de entrada."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[])
  id: ExecuteAssembly(System.String,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Executa a assemblagem contida no ficheiro especificado, utilizando os argumentos especificados."
  remarks: "A assemblagem começa em execução no ponto de entrada especificado no cabeçalho do .NET Framework.       Este método não criar um novo processo ou domínio de aplicação e não é executado o método de ponto de entrada num thread novo.       Este método carrega assemblagens utilizando o <xref:System.Reflection.Assembly.LoadFile%2A>método.</xref:System.Reflection.Assembly.LoadFile%2A> Também pode executar assemblagens utilizando o <xref:System.AppDomain.ExecuteAssemblyByName%2A>método, o que é carregado assemblagens utilizando o <xref:System.Reflection.Assembly.Load%2A>método.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/m-system.appdomain.execu_1_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/m-system.appdomain.execu_1_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/m-system.appdomain.execu_1_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, string[] args);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "O nome do ficheiro que contém a assemblagem para executar."
    - id: args
      type: System.String[]
      description: "Os argumentos para o ponto de entrada da assemblagem."
    return:
      type: System.Int32
      description: "O valor devolvido pelo ponto de entrada da assemblagem."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>Não foi encontrado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>Não é uma assemblagem válida.       - ou - <code>assemblyFile</code> foi compilada com uma versão posterior do tempo de execução de idioma comum à versão que atualmente está carregado."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Uma assemblagem ou módulo foi carregado duas vezes com dois evidences diferentes."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "A assemblagem especificada não tem nenhum ponto de entrada."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  id: ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Executa a assemblagem contida no ficheiro especificado, utilizando os argumentos e provas especificada."
  remarks: "A assemblagem começa em execução no ponto de entrada especificado no cabeçalho do .NET Framework.       Este método não criar um novo processo ou domínio de aplicação e não é executado o método de ponto de entrada num thread novo.       Este método carrega assemblagens utilizando o <xref:System.Reflection.Assembly.LoadFile%2A>método.</xref:System.Reflection.Assembly.LoadFile%2A> Também pode executar assemblagens utilizando o <xref:System.AppDomain.ExecuteAssemblyByName%2A>método, o que é carregado assemblagens utilizando o <xref:System.Reflection.Assembly.Load%2A>método.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/cb15b913-548c-4cb1-bbc5-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/cb15b913-548c-4cb1-bbc5-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/cb15b913-548c-4cb1-bbc5-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "O nome do ficheiro que contém a assemblagem para executar."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Provas fornecida para a assemblagem."
    - id: args
      type: System.String[]
      description: "Os argumentos para o ponto de entrada da assemblagem."
    return:
      type: System.Int32
      description: "O valor devolvido pelo ponto de entrada da assemblagem."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>Não foi encontrado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>Não é uma assemblagem válida.       - ou - versão 2.0 ou posterior do tempo de execução de idioma comum é actualmente carregado e <code>assemblyFile</code> foi compilada com uma versão posterior."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Uma assemblagem ou módulo foi carregado duas vezes com dois evidences diferentes."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Quando a política CAS legada não estiver ativada, <code>assemblySecurity</code> deve ser <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "A assemblagem especificada não tem nenhum ponto de entrada."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  id: ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Executa a assemblagem contida no ficheiro especificado, utilizando os argumentos especificados, o valor de hash e o algoritmo hash."
  remarks: "A assemblagem começa em execução no ponto de entrada especificado no cabeçalho do .NET Framework.       Este método não criar um novo processo ou domínio de aplicação e não é executado o método de ponto de entrada num thread novo.       Este método carrega assemblagens utilizando o <xref:System.Reflection.Assembly.LoadFile%2A>método.</xref:System.Reflection.Assembly.LoadFile%2A> Também pode executar assemblagens utilizando o <xref:System.AppDomain.ExecuteAssemblyByName%2A>método, o que é carregado assemblagens utilizando o <xref:System.Reflection.Assembly.Load%2A>método.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/ccb3b356-1169-4d65-9fdd-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/ccb3b356-1169-4d65-9fdd-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/ccb3b356-1169-4d65-9fdd-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "O nome do ficheiro que contém a assemblagem para executar."
    - id: args
      type: System.String[]
      description: "Os argumentos para o ponto de entrada da assemblagem."
    - id: hashValue
      type: System.Byte[]
      description: "Representa o valor do código hash calculado."
    - id: hashAlgorithm
      type: System.Configuration.Assemblies.AssemblyHashAlgorithm
      description: "Representa o algoritmo hash utilizado pelo manifesto de assemblagem."
    return:
      type: System.Int32
      description: "O valor devolvido pelo ponto de entrada da assemblagem."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>Não foi encontrado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>Não é uma assemblagem válida.       - ou - <code>assemblyFile</code> foi compilada com uma versão posterior do tempo de execução de idioma comum à versão que atualmente está carregado."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Uma assemblagem ou módulo foi carregado duas vezes com dois evidences diferentes."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "A assemblagem especificada não tem nenhum ponto de entrada."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  id: ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Executa a assemblagem contida no ficheiro especificado, utilizando o provas especificada, argumentos, o valor de hash e algoritmo hash."
  remarks: "A assemblagem começa em execução no ponto de entrada especificado no cabeçalho do .NET Framework.       Este método não criar um novo processo ou domínio de aplicação e não é executado o método de ponto de entrada num thread novo.       Este método carrega assemblagens utilizando o <xref:System.Reflection.Assembly.LoadFile%2A>método.</xref:System.Reflection.Assembly.LoadFile%2A> Também pode executar assemblagens utilizando o <xref:System.AppDomain.ExecuteAssemblyByName%2A>método, o que é carregado assemblagens utilizando o <xref:System.Reflection.Assembly.Load%2A>método.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "Thefollowing sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/c176353b-cef5-4b78-b4a8-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/c176353b-cef5-4b78-b4a8-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/c176353b-cef5-4b78-b4a8-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "O nome do ficheiro que contém a assemblagem para executar."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Provas fornecida para a assemblagem."
    - id: args
      type: System.String[]
      description: "Os argumentos para o ponto de entrada da assemblagem."
    - id: hashValue
      type: System.Byte[]
      description: "Representa o valor do código hash calculado."
    - id: hashAlgorithm
      type: System.Configuration.Assemblies.AssemblyHashAlgorithm
      description: "Representa o algoritmo hash utilizado pelo manifesto de assemblagem."
    return:
      type: System.Int32
      description: "O valor devolvido pelo ponto de entrada da assemblagem."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>Não foi encontrado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>Não é uma assemblagem válida.       - ou - versão 2.0 ou posterior do tempo de execução de idioma comum é actualmente carregado e <code>assemblyFile</code> foi compilada com uma versão posterior."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Uma assemblagem ou módulo foi carregado duas vezes com dois evidences diferentes."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Quando a política CAS legada não estiver ativada, <code>assemblySecurity</code> deve ser <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "A assemblagem especificada não tem nenhum ponto de entrada."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String)
  id: ExecuteAssemblyByName(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String)
  nameWithType: AppDomain.ExecuteAssemblyByName(String)
  fullName: System.AppDomain.ExecuteAssemblyByName(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Executa uma assemblagem indicada o nome a apresentar."
  remarks: "O <xref:System.AppDomain.ExecuteAssemblyByName%2A>método fornece uma funcionalidade semelhante para o <xref:System.AppDomain.ExecuteAssembly%2A>método, especifica, mas a assemblagem através do nome a apresentar ou <xref:System.Reflection.AssemblyName>em vez de localização do ficheiro.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Por conseguinte, <xref:System.AppDomain.ExecuteAssemblyByName%2A>carrega assemblagens com o <xref:System.Reflection.Assembly.Load%2A>método em vez da com a <xref:System.Reflection.Assembly.LoadFile%2A>método.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       A assemblagem começa em execução no ponto de entrada especificado no cabeçalho do .NET Framework.       Este método não criar um novo processo ou domínio de aplicação e não é executado o método de ponto de entrada num thread novo.       Para criar o <xref:System.AppDomain>para carregar e executar, utilize o <xref:System.AppDomain.CreateDomain%2A>método.</xref:System.AppDomain.CreateDomain%2A> </xref:System.AppDomain>"
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "O nome a apresentar da assemblagem. Consulte &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    return:
      type: System.Int32
      description: "O valor devolvido pelo ponto de entrada da assemblagem."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "A assemblagem especificada pelo <code> assemblyName </code> não foi encontrado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "A assemblagem especificada pelo <code> assemblyName </code> não é uma assemblagem válida.       - ou - versão 2.0 ou posterior do tempo de execução de idioma comum é actualmente carregado e <code> assemblyName </code> foi compilada com uma versão posterior."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "A assemblagem especificada pelo <code> assemblyName </code> foi encontrado, mas não foi possível carregar."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "A assemblagem especificada não tem nenhum ponto de entrada."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  id: ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(AssemblyName,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Executa a assemblagem fornecida um <xref:System.Reflection.AssemblyName>, utilizando os argumentos especificados.</xref:System.Reflection.AssemblyName>"
  remarks: "O <xref:System.AppDomain.ExecuteAssemblyByName%2A>método fornece uma funcionalidade semelhante para o <xref:System.AppDomain.ExecuteAssembly%2A>método, especifica, mas a assemblagem através do nome a apresentar ou <xref:System.Reflection.AssemblyName>em vez de localização do ficheiro.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Por conseguinte, <xref:System.AppDomain.ExecuteAssemblyByName%2A>carrega assemblagens com o <xref:System.Reflection.Assembly.Load%2A>método em vez da com a <xref:System.Reflection.Assembly.LoadFile%2A>método.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       A assemblagem começa em execução no ponto de entrada especificado no cabeçalho do .NET Framework.       Este método não criar um novo processo ou domínio de aplicação e não é executado o método de ponto de entrada num thread novo."
  syntax:
    content: public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, string[] args);
    parameters:
    - id: assemblyName
      type: System.Reflection.AssemblyName
      description: "Um <xref:System.Reflection.AssemblyName>objeto que representa o nome da assemblagem.</xref:System.Reflection.AssemblyName>"
    - id: args
      type: System.String[]
      description: "Argumentos da linha de comandos transmitidos ao iniciar o processo."
    return:
      type: System.Int32
      description: "O valor devolvido pelo ponto de entrada da assemblagem."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "A assemblagem especificada pelo <code> assemblyName </code> não foi encontrado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "A assemblagem especificada pelo <code> assemblyName </code> foi encontrado, mas não foi possível carregar."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "A assemblagem especificada pelo <code> assemblyName </code> não é uma assemblagem válida.       - ou - <code> assemblyName </code> foi compilada com uma versão posterior do tempo de execução de idioma comum à versão que atualmente está carregado."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "A assemblagem especificada não tem nenhum ponto de entrada."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  id: ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String,Evidence)
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence)
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Executa uma assemblagem indicada o nome a apresentar, utilizando a prova especificada."
  remarks: "O <xref:System.AppDomain.ExecuteAssemblyByName%2A>método fornece uma funcionalidade semelhante para o <xref:System.AppDomain.ExecuteAssembly%2A>método, especifica, mas a assemblagem através do nome a apresentar ou <xref:System.Reflection.AssemblyName>em vez de localização do ficheiro.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Por conseguinte, <xref:System.AppDomain.ExecuteAssemblyByName%2A>carrega assemblagens com o <xref:System.Reflection.Assembly.Load%2A>método em vez da com a <xref:System.Reflection.Assembly.LoadFile%2A>método.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       A assemblagem começa em execução no ponto de entrada especificado no cabeçalho do .NET Framework.       O <xref:System.AppDomain.ExecuteAssemblyByName%2A>método não criar um novo processo ou domínio de aplicação e não é executado o método de ponto de entrada num novo thread.</xref:System.AppDomain.ExecuteAssemblyByName%2A>      > [!NOTE] > Quando utiliza o <xref:System.AppDomain.ExecuteAssemblyByName%2A>método com um <xref:System.Security.Policy.Evidence>são intercaladas parâmetro, peças de prova.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Partes de prova fornecido como um argumento para o <xref:System.AppDomain.ExecuteAssemblyByName%2A>método substituem peças de prova fornecido pelo carregador.</xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyName
      type: System.String
      description: "O nome a apresentar da assemblagem. Consulte &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Provas para carregar a assemblagem."
    return:
      type: System.Int32
      description: "O valor devolvido pelo ponto de entrada da assemblagem."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "A assemblagem especificada pelo <code> assemblyName </code> não foi encontrado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "A assemblagem especificada pelo <code> assemblyName </code> foi encontrado, mas não foi possível carregar."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "A assemblagem especificada pelo <code> assemblyName </code> não é uma assemblagem válida.       - ou - versão 2.0 ou posterior do tempo de execução de idioma comum é actualmente carregado e <code> assemblyName </code> foi compilada com uma versão posterior."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "A assemblagem especificada não tem nenhum ponto de entrada."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])
  id: ExecuteAssemblyByName(System.String,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Executa a assemblagem indicada o nome a apresentar, utilizando os argumentos especificados."
  remarks: "O <xref:System.AppDomain.ExecuteAssemblyByName%2A>método fornece uma funcionalidade semelhante para o <xref:System.AppDomain.ExecuteAssembly%2A>método, especifica, mas a assemblagem através do nome a apresentar ou <xref:System.Reflection.AssemblyName>em vez de localização do ficheiro.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Por conseguinte, <xref:System.AppDomain.ExecuteAssemblyByName%2A>carrega assemblagens com o <xref:System.Reflection.Assembly.Load%2A>método em vez da com a <xref:System.Reflection.Assembly.LoadFile%2A>método.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       A assemblagem começa em execução no ponto de entrada especificado no cabeçalho do .NET Framework.       Este método não criar um novo processo ou domínio de aplicação e não é executado o método de ponto de entrada num thread novo."
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName, string[] args);
    parameters:
    - id: assemblyName
      type: System.String
      description: "O nome a apresentar da assemblagem. Consulte &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: args
      type: System.String[]
      description: "Argumentos da linha de comandos transmitidos ao iniciar o processo."
    return:
      type: System.Int32
      description: "O valor devolvido pelo ponto de entrada da assemblagem."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "A assemblagem especificada pelo <code> assemblyName </code> não foi encontrado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "A assemblagem especificada pelo <code> assemblyName </code> foi encontrado, mas não foi possível carregar."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "A assemblagem especificada pelo <code> assemblyName </code> não é uma assemblagem válida.       - ou - <code> assemblyName </code> foi compilada com uma versão posterior do tempo de execução de idioma comum à versão que atualmente está carregado."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "A assemblagem especificada não tem nenhum ponto de entrada."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  id: ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Executa a assemblagem fornecida um <xref:System.Reflection.AssemblyName>, utilizando os argumentos e provas especificada.</xref:System.Reflection.AssemblyName>"
  remarks: "O <xref:System.AppDomain.ExecuteAssemblyByName%2A>método fornece uma funcionalidade semelhante para o <xref:System.AppDomain.ExecuteAssembly%2A>método, especifica, mas a assemblagem através do nome a apresentar ou <xref:System.Reflection.AssemblyName>em vez de localização do ficheiro.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Por conseguinte, <xref:System.AppDomain.ExecuteAssemblyByName%2A>carrega assemblagens com o <xref:System.Reflection.Assembly.Load%2A>método em vez da com a <xref:System.Reflection.Assembly.LoadFile%2A>método.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       A assemblagem começa em execução no ponto de entrada especificado no cabeçalho do .NET Framework.       Este método não criar um novo processo ou domínio de aplicação e não é executado o método de ponto de entrada num thread novo.      > [!NOTE] > Quando utiliza o <xref:System.AppDomain.ExecuteAssemblyByName%2A>método com um <xref:System.Security.Policy.Evidence>são intercaladas parâmetro, peças de prova.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Partes de prova fornecido como um argumento para o <xref:System.AppDomain.ExecuteAssemblyByName%2A>método substituem peças de prova fornecido pelo carregador.</xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  syntax:
    content: public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, string[] args);
    parameters:
    - id: assemblyName
      type: System.Reflection.AssemblyName
      description: "Um <xref:System.Reflection.AssemblyName>objeto que representa o nome da assemblagem.</xref:System.Reflection.AssemblyName>"
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Provas para carregar a assemblagem."
    - id: args
      type: System.String[]
      description: "Argumentos da linha de comandos transmitidos ao iniciar o processo."
    return:
      type: System.Int32
      description: "O valor devolvido pelo ponto de entrada da assemblagem."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "A assemblagem especificada pelo <code> assemblyName </code> não foi encontrado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "A assemblagem especificada pelo <code> assemblyName </code> foi encontrado, mas não foi possível carregar."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "A assemblagem especificada pelo <code> assemblyName </code> não é uma assemblagem válida.       - ou - versão 2.0 ou posterior do tempo de execução de idioma comum é actualmente carregado e <code> assemblyName </code> foi compilada com uma versão posterior."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Quando a política CAS legada não estiver ativada, <code>assemblySecurity</code> deve ser <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "A assemblagem especificada não tem nenhum ponto de entrada."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  id: ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Executa a assemblagem indicada o nome a apresentar, utilizando os argumentos e provas especificada."
  remarks: "O <xref:System.AppDomain.ExecuteAssemblyByName%2A>método fornece uma funcionalidade semelhante para o <xref:System.AppDomain.ExecuteAssembly%2A>método, especifica, mas a assemblagem através do nome a apresentar ou <xref:System.Reflection.AssemblyName>em vez de localização do ficheiro.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Por conseguinte, <xref:System.AppDomain.ExecuteAssemblyByName%2A>carrega assemblagens com o <xref:System.Reflection.Assembly.Load%2A>método em vez da com a <xref:System.Reflection.Assembly.LoadFile%2A>método.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       A assemblagem começa em execução no ponto de entrada especificado no cabeçalho do .NET Framework.       Este método não criar um novo processo ou domínio de aplicação e não é executado o método de ponto de entrada num thread novo.      > [!NOTE] > Quando utiliza o <xref:System.AppDomain.ExecuteAssemblyByName%2A>método com um <xref:System.Security.Policy.Evidence>são intercaladas parâmetro, peças de prova.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Partes de prova fornecido como um argumento para o <xref:System.AppDomain.ExecuteAssemblyByName%2A>método substituem peças de prova fornecido pelo carregador.</xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, string[] args);
    parameters:
    - id: assemblyName
      type: System.String
      description: "O nome a apresentar da assemblagem. Consulte &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Provas para carregar a assemblagem."
    - id: args
      type: System.String[]
      description: "Argumentos da linha de comandos transmitidos ao iniciar o processo."
    return:
      type: System.Int32
      description: "O valor devolvido pelo ponto de entrada da assemblagem."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "A assemblagem especificada pelo <code> assemblyName </code> não foi encontrado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "A assemblagem especificada pelo <code> assemblyName </code> foi encontrado, mas não foi possível carregar."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "A assemblagem especificada pelo <code> assemblyName </code> não é uma assemblagem válida.       - ou - versão 2.0 ou posterior do tempo de execução de idioma comum é actualmente carregado e <code> assemblyName </code> foi compilada com uma versão posterior."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Quando a política CAS legada não estiver ativada, <code>assemblySecurity</code> deve ser <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "A assemblagem especificada não tem nenhum ponto de entrada."
  platform:
  - net462
- uid: System.AppDomain.FirstChanceException
  id: FirstChanceException
  parent: System.AppDomain
  langs:
  - csharp
  name: FirstChanceException
  nameWithType: AppDomain.FirstChanceException
  fullName: System.AppDomain.FirstChanceException
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ocorre quando é emitida uma exceção no código gerido, antes do tempo de execução procura a pilha de chamadas para um processador de excepções no domínio de aplicação."
  remarks: "Este evento é apenas uma notificação. Processar este evento não processar a excepção ou afetam subsequente excepção a processar de qualquer forma. Depois do evento foi gerado e processadores de eventos tem sido invocados, começa o language runtime (CLR) para procurar um processador para a exceção. FirstChanceException fornece o domínio de aplicação com uma primeira oportunidade para examinar qualquer excepção gerida.       O evento pode ser processado por domínio de aplicação. Se um thread passa através de vários domínios de aplicação ao executar uma chamada, o evento é desencadeado em cada domínio de aplicação que registou um processador de eventos, antes do CLR começa a procurar um processador de excepções correspondente nesse domínio de aplicação. Depois do evento foi processado, é efetuada uma pesquisa para um processador de excepções correspondente nesse domínio de aplicação. Se não for encontrado nenhum, o evento é gerado no domínio de aplicação seguinte.       Deve processar todas as exceções que ocorrem de eventos de processador para o evento FirstChanceException. Caso contrário, FirstChanceException é gerado em modo recursivo. Isto pode resultar numa capacidade excedida da pilha e terminação da aplicação. Recomendamos que implementar processadores de eventos para este evento como regiões de execução restrita (CERs), para manter as exceções relacionadas com a infraestrutura, tais como a memória esgotada ou de pilha excedida de afetarem a máquina virtual enquanto a notificação de exceção que está a ser processada.       Este evento é desencadeado não exceções indicar danos de estado do processo, tal como violações de acesso, a menos que o processador de eventos é fundamental para a segurança e tem o <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>atributo.</xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>       O language runtime suspende cancelamentos de thread enquanto estiver a ser processado este evento de notificação."
  example:
  - "The following example creates a series of application domains named `AD0` through `AD3`, with a `Worker` object in each application domain. Each `Worker` object has a reference to the `Worker` object in the next application domain, except for the `Worker` in the last application domain. The FirstChanceException event is handled in all application domains except `AD1`.  \n  \n> [!NOTE]\n>  In addition to this example, which demonstrates first-chance exception notifications in multiple application domains, you can find simple use cases in [How to: Receive First-Chance Exception Notifications](~/add/includes/ajax-current-ext-md.md).  \n  \n When the application domains have been created, the default application domain calls the `TestException` method for the first application domain. Each `Worker` object calls the `TestException` method for the next application domain, until the last `Worker` throws an exception that is either handled or unhandled. Thus, the current thread passes through all the application domains, and `TestException` is added to the stack in each application domain.  \n  \n When the last `Worker` object handles the exception, the FirstChanceException event is raised only in the last application domain. The other application domains never get a chance to handle the exception, so the event is not raised.  \n  \n When the last `Worker` object does not handle the exception, the FirstChanceException event is raised in each application domain that has an event handler. After each event handler has finished, the stack continues to unwind until the exception is caught by the default application domain.  \n  \n> [!NOTE]\n>  To see how the stack display grows as the event is raised closer and closer to the default application domain, change `e.Exception.Message` to `e.Exception` in the `FirstChanceHandler` event handlers. Notice that when `TestException` is called across application domain boundaries, it appears twice: once for the proxy and once for the stub.  \n  \n [!code-vb[System.AppDomain.FirstChanceException#1](~/add/codesnippet/visualbasic/e-system.appdomain.first_1.vb)]\n [!code-cs[System.AppDomain.FirstChanceException#1](~/add/codesnippet/csharp/e-system.appdomain.first_1.cs)]"
  syntax:
    content: public event EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs> FirstChanceException;
    return:
      type: System.EventHandler{System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs}
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.FriendlyName
  id: FriendlyName
  parent: System.AppDomain
  langs:
  - csharp
  name: FriendlyName
  nameWithType: AppDomain.FriendlyName
  fullName: System.AppDomain.FriendlyName
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém o nome amigável para este domínio de aplicação."
  remarks: "O nome amigável do domínio de aplicação predefinido é o nome de ficheiro do processo executável. Por exemplo, se o executável utilizado para iniciar o processo é `&quot;c:\\MyAppDirectory\\MyAssembly.exe&quot;`, o nome amigável do domínio de aplicação predefinido é `&quot;MyAssembly.exe&quot;`."
  example:
  - "The following code example uses the FriendlyName property to get the friendly name of the current application domain. For the default application domain, the friendly name is the name of the application's executable file. The code example also displays additional information about the application domain.  \n  \n [!code-vb[ADApplicationBase#1](~/add/codesnippet/visualbasic/p-system.appdomain.frien_1.vb)]\n [!code-cpp[ADApplicationBase#1](~/add/codesnippet/cpp/p-system.appdomain.frien_1.cpp)]\n [!code-cs[ADApplicationBase#1](~/add/codesnippet/csharp/p-system.appdomain.frien_1.cs)]"
  syntax:
    content: public string FriendlyName { get; }
    return:
      type: System.String
      description: "O nome amigável deste domínio de aplicação."
  overload: System.AppDomain.FriendlyName*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.GetAssemblies
  id: GetAssemblies
  parent: System.AppDomain
  langs:
  - csharp
  name: GetAssemblies()
  nameWithType: AppDomain.GetAssemblies()
  fullName: System.AppDomain.GetAssemblies()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém as assemblagens que foram carregadas no contexto de execução deste domínio de aplicação."
  remarks: ''
  example:
  - "The following code example uses the GetAssemblies method to get a list of all assemblies that have been loaded into the application domain. The assemblies are then displayed to the console.  \n  \n To run this code example, you need to create an assembly named `CustomLibrary.dll`, or change the assembly name that is passed to the GetAssemblies method.  \n  \n [!code-cpp[ADGetAssemblies#1](~/add/codesnippet/cpp/m-system.appdomain.getas_1.cpp)]\n [!code-cs[ADGetAssemblies#1](~/add/codesnippet/csharp/m-system.appdomain.getas_1.cs)]\n [!code-vb[ADGetAssemblies#1](~/add/codesnippet/visualbasic/m-system.appdomain.getas_1.vb)]"
  syntax:
    content: public System.Reflection.Assembly[] GetAssemblies ();
    parameters: []
    return:
      type: System.Reflection.Assembly[]
      description: "Uma matriz de assemblagens neste domínio de aplicação."
  overload: System.AppDomain.GetAssemblies*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.GetCurrentThreadId
  id: GetCurrentThreadId
  parent: System.AppDomain
  langs:
  - csharp
  name: GetCurrentThreadId()
  nameWithType: AppDomain.GetCurrentThreadId()
  fullName: System.AppDomain.GetCurrentThreadId()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém o identificador de thread atual."
  remarks: "Utilize o <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=fullName>propriedade, o que está estável, mesmo quando o .NET Framework está hospedado num ambiente que suporte fibers (ou seja, os threads simples).</xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=fullName>"
  syntax:
    content: public static int GetCurrentThreadId ();
    parameters: []
    return:
      type: System.Int32
      description: "Inteiro sinal de 32 bits que é o identificador de thread atual."
  overload: System.AppDomain.GetCurrentThreadId*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.GetData(System.String)
  id: GetData(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: GetData(String)
  nameWithType: AppDomain.GetData(String)
  fullName: System.AppDomain.GetData(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém o valor armazenado no domínio de aplicação atual para o nome especificado."
  remarks: "Utilize este método para obter o valor de uma entrada numa cache interna de pares de nome de dados que descrevem as propriedades desta instância de <xref:System.AppDomain>.</xref:System.AppDomain> Tenha em atenção que a comparação `name` com o nome de pares chave-valor diferencia maiúsculas de minúsculas.       A cache contém automaticamente as entradas do sistema predefinidas que são inseridas quando o domínio de aplicação é criado. Pode inspecionar os respetivos valores com o método GetData, ou equivalente <xref:System.AppDomainSetup>Propriedades.</xref:System.AppDomainSetup>       Pode inserir ou modificar os suas próprias pares de nome de dados definido pelo utilizador com o <xref:System.AppDomain.SetData%2A>método e Inspecione os respetivos valores com o método GetData.</xref:System.AppDomain.SetData%2A>       A tabela seguinte descreve o `name` de cada predefinidas de entrada de sistema e a correspondente <xref:System.AppDomainSetup>propriedade.</xref:System.AppDomainSetup>      | Valor de &quot;name&quot; | Propriedade |   |---------------------|--------------|   |&quot; APPBASE &quot;| <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>|   |&quot; APP_CONFIG_FILE &quot;| <xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=fullName>|   |&quot; APP_LAUNCH_URL &quot;| (nenhuma propriedade)</xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=fullName> </xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName><br /><br /> &quot;APP_LAUNCH_URL&quot; representa o URL pedido inicialmente pelo utilizador, antes de redirecionamento. Está disponível apenas quando a aplicação foi iniciada com um browser, tais como o Internet Explorer. Nem todos os browsers fornecem este valor. |   |&quot; APP_NAME&GT;.AZUREWEBSITES.NET &quot;| <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>|   |&quot; BINPATH_PROBE_ONLY &quot;| <xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=fullName>|   |&quot; CACHE_BASE &quot;| <xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName>|   |&quot; CODE_DOWNLOAD_DISABLED &quot;| <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName>|   |&quot; DEV_PATH &quot;| (nenhuma propriedade) |   |&quot; DISALLOW_APP &quot;| <xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=fullName>|   |&quot; DISALLOW_APP_BASE_PROBING &quot;| <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=fullName>|   |&quot; DISALLOW_APP_REDIRECTS &quot;| <xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=fullName>|   |&quot; DYNAMIC_BASE &quot;| <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName>|   |&quot; FORCE_CACHE_INSTALL &quot;| <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName>|   |&quot; LICENSE_FILE&quot;, ou uma cadeia de específicas da aplicação | <xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=fullName>|   |&quot; LOADER_OPTIMIZATION &quot;| <xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=fullName>|   |&quot; LOCATION_URI &quot;| (nenhuma propriedade) |   |&quot; PRIVATE_BINPATH &quot;| <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>|   |&quot; REGEX_DEFAULT_MATCH_TIMEOUT &quot;| <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=fullName></xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=fullName></xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName></xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=fullName></xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=fullName></xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName></xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName></xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName></xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=fullName></xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName><br /><br /> &quot;REGEX_DEFAULT_MATCH_TIMEOUT&quot; não é uma entrada de sistema e o valor pode ser definido ao chamar o método <xref:System.AppDomain.SetData%2A>. |   |&quot; SHADOW_COPY_DIRS &quot;| <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName>|</xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName></xref:System.AppDomain.SetData%2A>"
  example:
  - "The following example creates a new application domain, sets a system-provided value for the domain, and adds a new value pair for the domain. The example then demonstrates how to use the GetData method to retrieve the data from these value pairs and display them to the console.  \n  \n [!code-cpp[ADGetData#1](~/add/codesnippet/cpp/m-system.appdomain.getda_1.cpp)]\n [!code-vb[ADGetData#1](~/add/codesnippet/visualbasic/m-system.appdomain.getda_1.vb)]\n [!code-cs[ADGetData#1](~/add/codesnippet/csharp/m-system.appdomain.getda_1.cs)]"
  syntax:
    content: public object GetData (string name);
    parameters:
    - id: name
      type: System.String
      description: "O nome de uma propriedade de domínio de aplicação predefinida, ou o nome de uma propriedade de domínio de aplicação que definiu."
    return:
      type: System.Object
      description: "O valor da <code> name </code> propriedade, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se a propriedade não existe."
  overload: System.AppDomain.GetData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.GetType
  id: GetType
  parent: System.AppDomain
  langs:
  - csharp
  name: GetType()
  nameWithType: AppDomain.GetType()
  fullName: System.AppDomain.GetType()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém o tipo de instância atual."
  syntax:
    content: public Type GetType ();
    parameters: []
    return:
      type: System.Type
      description: "O tipo de instância atual."
  overload: System.AppDomain.GetType*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.Id
  id: Id
  parent: System.AppDomain
  langs:
  - csharp
  name: Id
  nameWithType: AppDomain.Id
  fullName: System.AppDomain.Id
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém um número inteiro que identifica exclusivamente o domínio de aplicação no processo."
  remarks: ''
  example:
  - "The following code example creates a second application domain and displays information about the default domain and the new domain.  \n  \n [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/visualbasic/p-system.appdomain.id_1.vb)]\n [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/cpp/p-system.appdomain.id_1.cpp)]\n [!code-cs[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/csharp/p-system.appdomain.id_1.cs)]"
  syntax:
    content: public int Id { get; }
    return:
      type: System.Int32
      description: "Um número inteiro que identifica o domínio de aplicação."
  overload: System.AppDomain.Id*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.InitializeLifetimeService
  id: InitializeLifetimeService
  parent: System.AppDomain
  langs:
  - csharp
  name: InitializeLifetimeService()
  nameWithType: AppDomain.InitializeLifetimeService()
  fullName: System.AppDomain.InitializeLifetimeService()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Fornece o <xref href=&quot;System.AppDomain&quot;> </xref> uma duração infinita por a impedir que uma concessão a ser criada."
  syntax:
    content: public override object InitializeLifetimeService ();
    parameters: []
    return:
      type: System.Object
      description: "Always <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  overload: System.AppDomain.InitializeLifetimeService*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.IsCompatibilitySwitchSet(System.String)
  id: IsCompatibilitySwitchSet(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: IsCompatibilitySwitchSet(String)
  nameWithType: AppDomain.IsCompatibilitySwitchSet(String)
  fullName: System.AppDomain.IsCompatibilitySwitchSet(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém um valor booleano que pode ser nulo, que indica se estiverem definidas quaisquer comutadores de compatibilidade e, se assim for, se o comutador de compatibilidade especificado está definido."
  remarks: "This method tests whether the specified compatibility switch has been set for the current application domain. Compatibility switches typically restore a behavior (such as the way strings are sorted) that was changed between versions of the .NET Framework.  They are set by calling the <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=fullName> method before creating an application domain.  \n  \n The following table provides examples of compatibility switches that can be set to restore the behavior of earlier versions of the .NET Framework.  \n  \n|Switch|Meaning|  \n|------------|-------------|  \n|\"NetFx40_LegacySecurityPolicy\"|Code access security (CAS) for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] is enabled in this application domain. See [\\&lt;NetFx40_LegacySecurityPolicy\\&gt; Element](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md).|  \n|\"NetFx40_Legacy20SortingBehavior\"|String sorting defaults for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] are enabled in this application domain. Its success requires sort00001000.dll to be installed. See [\\&lt;CompatSortNLSVersion\\&gt; Element](../Topic/%3CCompatSortNLSVersion%3E%20Element.md).|  \n|\"NetFx40_Legacy40SortingBehavior\"|String sorting defaults for the [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]and Unicode 5.0 are enabled in this application domain. Its success requires sort00060101.dll to be installed.|  \n|\"NetFx40_TimeSpanLegacyFormatMode\"|<xref:System.TimeSpan> formatting behavior for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] is enabled in this application domain.  See [\\&lt;TimeSpan_LegacyFormatMode\\&gt; Element](../Topic/%3CTimeSpan_LegacyFormatMode%3E%20Element.md) and the \"Restoring Legacy TimeSpan Formatting\" section of the <xref:System.TimeSpan> topic.|  \n|\"UseRandomizedStringHashAlgorithm\"|The runtime calculates hash codes for strings on a per application domain basis instead of using a single hashing algorithm that produces a consistent hash code across application domains. See [\\&lt;UseRandomizedStringHashAlgorithm\\&gt; Element](../Topic/%3CUseRandomizedStringHashAlgorithm%3E%20Element.md).|"
  syntax:
    content: public Nullable<bool> IsCompatibilitySwitchSet (string value);
    parameters:
    - id: value
      type: System.String
      description: "O comutador de compatibilidade para testar."
    return:
      type: System.Nullable{System.Boolean}
      description: "Uma referência nula (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref> no Visual Basic) se não existem comutadores de compatibilidade são definidos; caso contrário, um valor booleano que indica se a compatibilidade de comutador que é especificado por <code> value </code> está definido."
  overload: System.AppDomain.IsCompatibilitySwitchSet*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsDefaultAppDomain
  id: IsDefaultAppDomain
  parent: System.AppDomain
  langs:
  - csharp
  name: IsDefaultAppDomain()
  nameWithType: AppDomain.IsDefaultAppDomain()
  fullName: System.AppDomain.IsDefaultAppDomain()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Devolve um valor que indica se o domínio de aplicação é o domínio de aplicação predefinido para o processo."
  remarks: "Cada processo gerido tem um domínio de aplicação predefinido. Execução começa no domínio predefinido."
  example:
  - "The following code example creates a second application domain and displays information about the default domain and the new domain.  \n  \n [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/visualbasic/m-system.appdomain.isdef_1.vb)]\n [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/cpp/m-system.appdomain.isdef_1.cpp)]\n [!code-cs[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/csharp/m-system.appdomain.isdef_1.cs)]"
  syntax:
    content: public bool IsDefaultAppDomain ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se atual <xref href=&quot;System.AppDomain&quot;> </xref> objeto representa o domínio de aplicação predefinido para o processo; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.IsDefaultAppDomain*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsFinalizingForUnload
  id: IsFinalizingForUnload
  parent: System.AppDomain
  langs:
  - csharp
  name: IsFinalizingForUnload()
  nameWithType: AppDomain.IsFinalizingForUnload()
  fullName: System.AppDomain.IsFinalizingForUnload()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Indica se estiver a é descarregado este domínio de aplicação e os objetos que nela contidos estão a ser finalizados pelo tempo de execução de idioma comum."
  remarks: "O método de finalização para um objeto fornece uma oportunidade para executar quaisquer operações necessárias de limpeza antes do objeto é memória libertada. Após a finalização, o objeto é acessível, mas num estado inválido e, por conseguinte, não utilizável. Eventualmente, recolha de lixo realiza e reclama o objeto.       Método de finalização de um objeto denomina-se de uma das seguintes situações: durante a recolha de lixo, quando está a encerrar o language runtime, ou quando o domínio de aplicação que contém o objeto é descarregado. O método IsFinalizingForUnload devolve `true` apenas no caso de último; não devolver `true` se resulta de finalização da recolha de lixo de rotina ou encerramento de CLR.      > [!NOTE] > Para determinar se Finalização devido ao encerramento do CLR, utilize o <xref:System.Environment.HasShutdownStarted%2A?displayProperty=fullName>propriedade.</xref:System.Environment.HasShutdownStarted%2A?displayProperty=fullName> Devolve `true` esteja Finalização devido a um domínio de aplicação a ser descarregado ou para o CLR encerrar.       Ao executar no seu método de finalização durante o descarregamento de domínio, poderá aceder a outro objeto que é referenciado por um campo estático e tem um método de finalização. No entanto, fazê-lo não é possível fiável porque o objeto acedido poderá já ter foi finalizado.      > [!NOTE] > Uma exceção a esta regra é o <xref:System.Console>classe que contém campos estáticos que referenciam os objetos de fluxo, mas é implementado, especialmente para sempre pode escrever na consola do sistema, mesmo durante o encerramento de sistema ou o descarregamento de domínio.</xref:System.Console>       Utilize este método no método de finalização de um objecto para determinar se o domínio de aplicação que contém o objeto estiver a é descarregado. Se for esse o caso, fiável não pode aceder a qualquer objeto que tem um método de Finalização e é referenciado por um campo estático."
  syntax:
    content: public bool IsFinalizingForUnload ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se este domínio de aplicação é descarregar e o tempo de execução de idioma comum começou a invocar os finalizadores; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.IsFinalizingForUnload*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsFullyTrusted
  id: IsFullyTrusted
  parent: System.AppDomain
  langs:
  - csharp
  name: IsFullyTrusted
  nameWithType: AppDomain.IsFullyTrusted
  fullName: System.AppDomain.IsFullyTrusted
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém um valor que indica se as assemblagens que são carregadas para o domínio de aplicação atual executar com fidedignidade total."
  remarks: "Este método devolve sempre `true` para o domínio de aplicação predefinido de uma aplicação que é executado no ambiente de trabalho. Devolve `false` para um domínio de uma aplicação que foi criado utilizando o [AppDomain.CreateDomain (cadeia provas, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) método de sobrecarga, a menos que as permissões que são concedidas para o domínio de aplicação são equivalentes aos fidedignidade total."
  example:
  - "The following example demonstrates the IsFullyTrusted property and the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> property with fully trusted and partially trusted application domains. The fully trusted application domain is the default application domain for the application. The partially trusted application domain is created by using the [AppDomain.CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) method overload.  \n  \n The example uses a `Worker` class that derives from <xref:System.MarshalByRefObject>, so it can be marshaled across application domain boundaries. The example creates a `Worker` object in the default application domain. It then calls the `TestIsFullyTrusted` method to display the property value for the application domain and for two assemblies that are loaded into the application domain: mscorlib, which is part of the .NET Framework, and the example assembly. The application domain is fully trusted, so both assemblies are fully trusted.  \n  \n The example creates another `Worker` object in a sandboxed application domain and again calls the `TestIsFullyTrusted` method. Mscorlib is always trusted, even in a partially trusted application domain, but the example assembly is partially trusted.  \n  \n [!code-vb[System.AppDomain.IsFullyTrusted#1](~/add/codesnippet/visualbasic/p-system.appdomain.isful_1.vb)]\n [!code-cs[System.AppDomain.IsFullyTrusted#1](~/add/codesnippet/csharp/p-system.appdomain.isful_1.cs)]"
  syntax:
    content: public bool IsFullyTrusted { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se executar as assemblagens que são carregadas para o domínio de aplicação atual com fidedignidade total; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.IsFullyTrusted*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsHomogenous
  id: IsHomogenous
  parent: System.AppDomain
  langs:
  - csharp
  name: IsHomogenous
  nameWithType: AppDomain.IsHomogenous
  fullName: System.AppDomain.IsHomogenous
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém um valor que indica se o domínio de aplicação atual tem um conjunto de permissões que é concedido a todas as assemblagens que são carregadas para o domínio de aplicação."
  remarks: "This property returns `true` for sandboxed application domains that were created by using the [AppDomain.CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) method overload. Sandboxed application domains have a homogenous set of permissions; that is, the same set of permissions is granted to all partially trusted assemblies that are loaded into the application domain. A sandboxed application domain optionally has a list of strong-named assemblies that are exempt from this permission set, and instead run with full trust.  \n  \n Fully trusted code can use the <xref:System.AppDomain.PermissionSet%2A> property to determine the homogenous grant set of a sandboxed application domain.  \n  \n This property also returns `true` for the default application domain of a desktop application, because that application domain grants full trust to all assemblies."
  syntax:
    content: public bool IsHomogenous { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o domínio de aplicação atual tiver um ambiente homogéneo conjunto de permissões; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.IsHomogenous*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.Load(System.Byte[])
  id: Load(System.Byte[])
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(Byte[])
  nameWithType: AppDomain.Load(Byte[])
  fullName: System.AppDomain.Load(Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Carrega <xref:System.Reflection.Assembly>com comuns objeto formato (COFF) baseada em imagem de um ficheiro que contém um <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> emitted</xref:System.Reflection.Assembly>"
  remarks: "Começando com o [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], o nível de confiança de uma assemblagem que foi carregada através deste método é o mesmo que o nível de fidedignidade do domínio de aplicação.       Este método deve ser utilizado apenas para carregar uma assemblagem para o domínio de aplicação atual. Este método é fornecido para efeitos práticos para os chamadores de interoperabilidade que não é possível chamar a estática <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>método.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Para carregar assemblagens para outros domínios de aplicação, utilize um método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Para informações que são comuns a todas as sobrecargas deste método, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>sobrecarga de método.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the use of loading a raw assembly.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AppDomain_LoadRaw#1](~/add/codesnippet/visualbasic/m-system.appdomain.load-_1_1.vb)]\n [!code-cs[AppDomain_LoadRaw#1](~/add/codesnippet/csharp/m-system.appdomain.load-_1_1.cs)]\n [!code-cpp[AppDomain_LoadRaw#1](~/add/codesnippet/cpp/m-system.appdomain.load-_1_1.cpp)]"
  syntax:
    content: public System.Reflection.Assembly Load (byte[] rawAssembly);
    parameters:
    - id: rawAssembly
      type: System.Byte[]
      description: "Uma matriz do tipo <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> que é uma imagem com base em COFF que contém uma assemblagem emitted."
    return:
      type: System.Reflection.Assembly
      description: "A assemblagem carregada."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rawAssembly</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>rawAssembly</code>Não é uma assemblagem válida.       - ou - versão 2.0 ou posterior do tempo de execução de idioma comum é actualmente carregado e <code>rawAssembly</code> foi compilada com uma versão posterior."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Uma assemblagem ou módulo foi carregado duas vezes com dois evidences diferentes."
  platform:
  - net462
- uid: System.AppDomain.Load(System.Reflection.AssemblyName)
  id: Load(System.Reflection.AssemblyName)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(AssemblyName)
  nameWithType: AppDomain.Load(AssemblyName)
  fullName: System.AppDomain.Load(AssemblyName)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Carrega um <xref:System.Reflection.Assembly>dado o <xref:System.Reflection.AssemblyName>.</xref:System.Reflection.AssemblyName> </xref:System.Reflection.Assembly>"
  remarks: "Este método deve ser utilizado apenas para carregar uma assemblagem para o domínio de aplicação atual. Este método é fornecido para efeitos práticos para os chamadores de interoperabilidade que não é possível chamar a estática <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>método.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Para carregar assemblagens para outros domínios de aplicação, utilize um método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Se uma versão da assemblagem pedida já está carregada, este método devolve a assemblagem carregada, mesmo se for pedida uma versão diferente.       Fornecer um nome de assemblagem parcial para `assemblyRef` não é recomendada. (O nome parcial omite um ou mais dos cultura, versão ou token de chave pública. Para sobrecargas que utilizam uma cadeia em vez de um <xref:System.Reflection.AssemblyName>objeto, &quot;por exemplo, versão =&1;.0.0.0&quot; é um exemplo de um nome parcial e &quot;por exemplo, versão =&1;.0.0.0, Culture = independente, PublicKeyToken =&18;ab3442da84b47&quot; é um exemplo de um nome completo.)</xref:System.Reflection.AssemblyName> Utilizar nomes parciais tem um efeito negativo no desempenho. Além disso, um nome de assemblagem parcial pode carregar uma assemblagem da cache de assemblagem global apenas se existir uma cópia exata da assemblagem no diretório base da aplicação (<xref:System.AppDomain.BaseDirectory%2A> ou <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>).</xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName> </xref:System.AppDomain.BaseDirectory%2A>       Se atual <xref:System.AppDomain>objeto representa o domínio aplicacional `A`e o <xref:System.AppDomain.Load%2A>método denomina-se do domínio aplicacional `B`, a assemblagem é carregada para ambos os domínios de aplicação.</xref:System.AppDomain.Load%2A> </xref:System.AppDomain> Por exemplo, o seguinte código carrega `MyAssembly` para o novo domínio de aplicação `ChildDomain` e também para o domínio de aplicação em que executa o código: [!code-vb [System.AppDomain.Load#1](~/add/codesnippet/visualbasic/m-system.appdomain.load-_2_1.vb)][!code-cpp[System.AppDomain.Load#1](~/add/codesnippet/cpp/m-system.appdomain.load-_2_1.cpp)][!code-cs[System.AppDomain.Load#1](~/add/codesnippet/csharp/m-system.appdomain.load-_2_1.cs) ] a assemblagem for carregada para ambos os domínios porque <xref:System.Reflection.Assembly>não deriva da <xref:System.MarshalByRefObject>e, por conseguinte, o valor de retorno do <xref:System.AppDomain.Load%2A>método não é possível empacotar as referências.</xref:System.AppDomain.Load%2A> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly>     Em vez disso, o tempo de execução de idioma comum tenta carregar a assemblagem para o domínio de aplicação de chamada. As assemblagens que são carregadas para os domínios de dois aplicação poderão ser diferentes se as definições de caminho para os domínios de duas aplicação são diferentes.      > [!NOTE] > Se ambas as <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=fullName>propriedade e o <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=fullName>propriedade estiver definida, a primeira tentativa para carregar a assemblagem utiliza o nome a apresentar (incluindo versão, cultura e assim sucessivamente, tal como devolvido pelo <xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName>propriedade).</xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName> </xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=fullName> </xref:System.Reflection.AssemblyName.Name%2A?displayProperty=fullName> Se o ficheiro não for encontrado, o <xref:System.Reflection.AssemblyName.CodeBase%2A>propriedade é utilizada para procurar a assemblagem.</xref:System.Reflection.AssemblyName.CodeBase%2A> Se a assemblagem encontra-se utilizando <xref:System.Reflection.AssemblyName.CodeBase%2A>, o nome a apresentar é comparado com a assemblagem.</xref:System.Reflection.AssemblyName.CodeBase%2A> Se a correspondência falhar, um <xref:System.IO.FileLoadException>é emitida.</xref:System.IO.FileLoadException>"
  syntax:
    content: public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);
    parameters:
    - id: assemblyRef
      type: System.Reflection.AssemblyName
      description: "Um objeto que descreve a assemblagem para carregar."
    return:
      type: System.Reflection.Assembly
      description: "A assemblagem carregada."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyRef</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyRef</code>Não foi encontrado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyRef</code>Não é uma assemblagem válida.       - ou - versão 2.0 ou posterior do tempo de execução de idioma comum é actualmente carregado e <code>assemblyRef</code> foi compilada com uma versão posterior."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Uma assemblagem ou módulo foi carregado duas vezes com dois evidences diferentes."
  platform:
  - net462
- uid: System.AppDomain.Load(System.String)
  id: Load(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(String)
  nameWithType: AppDomain.Load(String)
  fullName: System.AppDomain.Load(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Carrega um <xref:System.Reflection.Assembly>indicado o nome a apresentar.</xref:System.Reflection.Assembly>"
  remarks: "Este método deve ser utilizado apenas para carregar uma assemblagem para o domínio de aplicação atual. Este método é fornecido para efeitos práticos para os chamadores de interoperabilidade que não é possível chamar a estática <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>método.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Para carregar assemblagens para outros domínios de aplicação, utilize um método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Para informações que são comuns a todas as sobrecargas deste método, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>sobrecarga de método.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Assembly Load (string assemblyString);
    parameters:
    - id: assemblyString
      type: System.String
      description: "O nome a apresentar da assemblagem. Consulte &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    return:
      type: System.Reflection.Assembly
      description: "A assemblagem carregada."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyString</code>é<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyString</code>Não foi encontrado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyString</code>Não é uma assemblagem válida.       - ou - versão 2.0 ou posterior do tempo de execução de idioma comum é actualmente carregado e <code>assemblyString</code> foi compilada com uma versão posterior."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Uma assemblagem ou módulo foi carregado duas vezes com dois evidences diferentes."
  platform:
  - net462
- uid: System.AppDomain.Load(System.Byte[],System.Byte[])
  id: Load(System.Byte[],System.Byte[])
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(Byte[],Byte[])
  nameWithType: AppDomain.Load(Byte[],Byte[])
  fullName: System.AppDomain.Load(Byte[],Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Carrega <xref:System.Reflection.Assembly>com comuns objeto formato (COFF) baseada em imagem de um ficheiro que contém um <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> emitted</xref:System.Reflection.Assembly> Os bytes não processados que representa os símbolos para o <xref:System.Reflection.Assembly>também são carregadas.</xref:System.Reflection.Assembly>"
  remarks: "Começando com o [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], o nível de confiança de uma assemblagem que foi carregada através deste método é o mesmo que o nível de fidedignidade do domínio de aplicação.       Este método deve ser utilizado apenas para carregar uma assemblagem para o domínio de aplicação atual. Este método é fornecido para efeitos práticos para os chamadores de interoperabilidade que não é possível chamar a estática <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>método.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Para carregar assemblagens para outros domínios de aplicação, utilize um método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Para informações que são comuns a todas as sobrecargas deste método, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>sobrecarga de método.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the use of loading a raw assembly.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AppDomain_LoadRaw#1](~/add/codesnippet/visualbasic/m-system.appdomain.load-_0_1.vb)]\n [!code-cs[AppDomain_LoadRaw#1](~/add/codesnippet/csharp/m-system.appdomain.load-_0_1.cs)]\n [!code-cpp[AppDomain_LoadRaw#1](~/add/codesnippet/cpp/m-system.appdomain.load-_0_1.cpp)]"
  syntax:
    content: public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);
    parameters:
    - id: rawAssembly
      type: System.Byte[]
      description: "Uma matriz do tipo <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> que é uma imagem com base em COFF que contém uma assemblagem emitted."
    - id: rawSymbolStore
      type: System.Byte[]
      description: "Uma matriz do tipo <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> que contém os bytes não processados que representa os símbolos para a assemblagem."
    return:
      type: System.Reflection.Assembly
      description: "A assemblagem carregada."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rawAssembly</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>rawAssembly</code>Não é uma assemblagem válida.       - ou - versão 2.0 ou posterior do tempo de execução de idioma comum é actualmente carregado e <code>rawAssembly</code> foi compilada com uma versão posterior."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Uma assemblagem ou módulo foi carregado duas vezes com dois evidences diferentes."
  platform:
  - net462
- uid: System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  id: Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(AssemblyName,Evidence)
  nameWithType: AppDomain.Load(AssemblyName,Evidence)
  fullName: System.AppDomain.Load(AssemblyName,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Carrega um <xref:System.Reflection.Assembly>dado o <xref:System.Reflection.AssemblyName>.</xref:System.Reflection.AssemblyName> </xref:System.Reflection.Assembly>"
  remarks: "Este método deve ser utilizado apenas para carregar uma assemblagem para o domínio de aplicação atual. Este método é fornecido para efeitos práticos para os chamadores de interoperabilidade que não é possível chamar a estática <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>método.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Para carregar assemblagens para outros domínios de aplicação, utilize um método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Para informações que são comuns a todas as sobrecargas deste método, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>sobrecarga de método.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyRef
      type: System.Reflection.AssemblyName
      description: "Um objeto que descreve a assemblagem para carregar."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Provas para carregar a assemblagem."
    return:
      type: System.Reflection.Assembly
      description: "A assemblagem carregada."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyRef</code>é<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyRef</code>Não foi encontrado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyRef</code>Não é uma assemblagem válida.       - ou - versão 2.0 ou posterior do tempo de execução de idioma comum é actualmente carregado e <code>assemblyRef</code> foi compilada com uma versão posterior."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Uma assemblagem ou módulo foi carregado duas vezes com dois evidences diferentes."
  platform:
  - net462
- uid: System.AppDomain.Load(System.String,System.Security.Policy.Evidence)
  id: Load(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(String,Evidence)
  nameWithType: AppDomain.Load(String,Evidence)
  fullName: System.AppDomain.Load(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Carrega um <xref:System.Reflection.Assembly>indicado o nome a apresentar.</xref:System.Reflection.Assembly>"
  remarks: "Este método deve ser utilizado apenas para carregar uma assemblagem para o domínio de aplicação atual. Este método é fornecido para efeitos práticos para os chamadores de interoperabilidade que não é possível chamar a estática <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>método.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Para carregar assemblagens para outros domínios de aplicação, utilize um método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Para informações que são comuns a todas as sobrecargas deste método, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>sobrecarga de método.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyString
      type: System.String
      description: "O nome a apresentar da assemblagem. Consulte &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Provas para carregar a assemblagem."
    return:
      type: System.Reflection.Assembly
      description: "A assemblagem carregada."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyString</code>é<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyString</code>Não foi encontrado."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyString</code>Não é uma assemblagem válida.       - ou - versão 2.0 ou posterior do tempo de execução de idioma comum é actualmente carregado e <code>assemblyString</code> foi compilada com uma versão posterior."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Uma assemblagem ou módulo foi carregado duas vezes com dois evidences diferentes."
  platform:
  - net462
- uid: System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  id: Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(Byte[],Byte[],Evidence)
  nameWithType: AppDomain.Load(Byte[],Byte[],Evidence)
  fullName: System.AppDomain.Load(Byte[],Byte[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Carrega <xref:System.Reflection.Assembly>com comuns objeto formato (COFF) baseada em imagem de um ficheiro que contém um <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> emitted</xref:System.Reflection.Assembly> Os bytes não processados que representa os símbolos para o <xref:System.Reflection.Assembly>também são carregadas.</xref:System.Reflection.Assembly>"
  remarks: "Começando com o [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], o nível de confiança de uma assemblagem que foi carregada através deste método é o mesmo que o nível de fidedignidade do domínio de aplicação.       Este método deve ser utilizado apenas para carregar uma assemblagem para o domínio de aplicação atual. Este método é fornecido para efeitos práticos para os chamadores de interoperabilidade que não é possível chamar a estática <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>método.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Para carregar assemblagens para outros domínios de aplicação, utilize um método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Para informações que são comuns a todas as sobrecargas deste método, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>sobrecarga de método.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the use of loading a raw assembly.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AppDomain_LoadRaw#1](~/add/codesnippet/visualbasic/1e204365-b0ec-4650-8d52-_1.vb)]\n [!code-cs[AppDomain_LoadRaw#1](~/add/codesnippet/csharp/1e204365-b0ec-4650-8d52-_1.cs)]\n [!code-cpp[AppDomain_LoadRaw#1](~/add/codesnippet/cpp/1e204365-b0ec-4650-8d52-_1.cpp)]"
  syntax:
    content: public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);
    parameters:
    - id: rawAssembly
      type: System.Byte[]
      description: "Uma matriz do tipo <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> que é uma imagem com base em COFF que contém uma assemblagem emitted."
    - id: rawSymbolStore
      type: System.Byte[]
      description: "Uma matriz do tipo <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> que contém os bytes não processados que representa os símbolos para a assemblagem."
    - id: securityEvidence
      type: System.Security.Policy.Evidence
      description: "Provas para carregar a assemblagem."
    return:
      type: System.Reflection.Assembly
      description: "A assemblagem carregada."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rawAssembly</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>rawAssembly</code>Não é uma assemblagem válida.       - ou - versão 2.0 ou posterior do tempo de execução de idioma comum é actualmente carregado e <code>rawAssembly</code> foi compilada com uma versão posterior."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Uma assemblagem ou módulo foi carregado duas vezes com dois evidences diferentes."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>securityEvidence</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Quando a política CAS legada não estiver ativada, <code>securityEvidence</code> deve ser <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.MonitoringIsEnabled
  id: MonitoringIsEnabled
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringIsEnabled
  nameWithType: AppDomain.MonitoringIsEnabled
  fullName: System.AppDomain.MonitoringIsEnabled
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém ou define um valor que indica se a CPU e memória monitorização dos domínios de aplicação está ativada para o processo atual. Quando a monitorização estiver ativada para um processo, não pode ser desativado."
  remarks: "Isto `static` propriedade (`Shared` propriedade no Visual Basic) controla da CPU e memória de monitorização de todos os domínios de aplicação no processo.       Se tentar definir esta propriedade para `false`, um <xref:System.ArgumentException>exceção é emitida, mesmo que o valor atual da propriedade é `false`.</xref:System.ArgumentException>       Quando a monitorização estiver ativada, pode utilizar o <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>, <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>, <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>, e <xref:System.AppDomain.MonitoringTotalProcessorTime%2A>instância propriedades para monitorizar a utilização da CPU e memória de domínios de aplicação individuais.</xref:System.AppDomain.MonitoringTotalProcessorTime%2A> </xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A> </xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A> </xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>"
  syntax:
    content: public static bool MonitoringIsEnabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a monitorização está ativada; caso contrário <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.MonitoringIsEnabled*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "O processo atual tentou atribuir o valor <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> para esta propriedade."
  platform:
  - net462
- uid: System.AppDomain.MonitoringSurvivedMemorySize
  id: MonitoringSurvivedMemorySize
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringSurvivedMemorySize
  nameWithType: AppDomain.MonitoringSurvivedMemorySize
  fullName: System.AppDomain.MonitoringSurvivedMemorySize
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém o número de bytes que survived a última recolha e que são conhecidos por ser referenciado por domínio de aplicação atual."
  remarks: "As estatísticas são atualizadas com cada coleção de libertação da memória. No entanto, são garantidos para ser exato apenas após uma completa, bloqueio coleção; ou seja, uma coleção que inclui todas as gerações e que interrompe a aplicação durante a coleção ocorre. Por exemplo, o <xref:System.GC.Collect?displayProperty=fullName>sobrecarga de método executa uma completa, bloqueio coleção.</xref:System.GC.Collect?displayProperty=fullName> (Coleção em simultâneo ocorre em segundo plano e não bloqueia a aplicação.)"
  syntax:
    content: public long MonitoringSurvivedMemorySize { get; }
    return:
      type: System.Int64
      description: "O número de bytes operacional."
  overload: System.AppDomain.MonitoringSurvivedMemorySize*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O <xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref> no Visual Basic) <xref:System.AppDomain.MonitoringIsEnabled*>propriedade está definida como <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.MonitoringSurvivedProcessMemorySize
  id: MonitoringSurvivedProcessMemorySize
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringSurvivedProcessMemorySize
  nameWithType: AppDomain.MonitoringSurvivedProcessMemorySize
  fullName: System.AppDomain.MonitoringSurvivedProcessMemorySize
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém o total de bytes que survived da última coleção para todos os domínios de aplicação no processo."
  remarks: "Depois de uma coleção completa, bloqueio, este número representa o número de bytes actualmente contido em direto no geridos pilhas. Deve estar perto o número que relatados pelo <xref:System.GC.GetTotalMemory%2A>método.</xref:System.GC.GetTotalMemory%2A> Depois de uma coleção efémeras, este número representa o número de bytes actualmente contido em direto no gerações efémeras."
  syntax:
    content: public static long MonitoringSurvivedProcessMemorySize { get; }
    return:
      type: System.Int64
      description: "O número total de bytes operacional para o processo."
  overload: System.AppDomain.MonitoringSurvivedProcessMemorySize*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O <xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref> no Visual Basic) <xref:System.AppDomain.MonitoringIsEnabled*>propriedade está definida como <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.MonitoringTotalAllocatedMemorySize
  id: MonitoringTotalAllocatedMemorySize
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringTotalAllocatedMemorySize
  nameWithType: AppDomain.MonitoringTotalAllocatedMemorySize
  fullName: System.AppDomain.MonitoringTotalAllocatedMemorySize
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém o tamanho total, em bytes, de todas as alocações de memória que tiverem sido efetuadas pelo domínio aplicacional desde que foi criado, sem subtraindo a memória que tenha sido recolhida."
  syntax:
    content: public long MonitoringTotalAllocatedMemorySize { get; }
    return:
      type: System.Int64
      description: "O tamanho total de todas as alocações de memória."
  overload: System.AppDomain.MonitoringTotalAllocatedMemorySize*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O <xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref> no Visual Basic) <xref:System.AppDomain.MonitoringIsEnabled*>propriedade está definida como <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.MonitoringTotalProcessorTime
  id: MonitoringTotalProcessorTime
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringTotalProcessorTime
  nameWithType: AppDomain.MonitoringTotalProcessorTime
  fullName: System.AppDomain.MonitoringTotalProcessorTime
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém o tempo total do processador que foi utilizado por todos os threads durante a execução no domínio de aplicação atual, uma vez que iniciar o processo."
  remarks: "O tempo total que é comunicado para um domínio de aplicação inclui o tempo despendido a cada thread no processo em execução nesse domínio de aplicação.       Um thread que chama em código não gerido é associado a um domínio de aplicação e o tempo de processador despende a executar que o código não gerido é reportado para o domínio de aplicação onde foi efetuada a chamada.       Quando um thread é bloqueado ou suspensão, não consome tempo do processador."
  syntax:
    content: public TimeSpan MonitoringTotalProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "Tempo total do processador para o domínio de aplicação atual."
  overload: System.AppDomain.MonitoringTotalProcessorTime*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "O <xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref> no Visual Basic) <xref:System.AppDomain.MonitoringIsEnabled*>propriedade está definida como <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.PermissionSet
  id: PermissionSet
  parent: System.AppDomain
  langs:
  - csharp
  name: PermissionSet
  nameWithType: AppDomain.PermissionSet
  fullName: System.AppDomain.PermissionSet
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém o conjunto de permissões de um domínio de uma aplicação."
  remarks: "Domínios de uma aplicação que foram criados utilizando o [AppDomain.CreateDomain (cadeia provas, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) sobrecarga de método tem um conjunto de permissões homogéneo; ou seja, o mesmo conjunto de permissões é concedido a todas as assemblagens parcialmente fidedignas, que são carregadas para o domínio de aplicação. Um domínio de uma aplicação, opcionalmente, tem uma lista de assemblagens com nome seguro que estão excluídos esta permissão definido e, em vez disso, execute com fidedignidade total."
  syntax:
    content: public System.Security.PermissionSet PermissionSet { get; }
    return:
      type: System.Security.PermissionSet
      description: "O conjunto de permissões do domínio de uma aplicação."
  overload: System.AppDomain.PermissionSet*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ProcessExit
  id: ProcessExit
  parent: System.AppDomain
  langs:
  - csharp
  name: ProcessExit
  nameWithType: AppDomain.ProcessExit
  fullName: System.AppDomain.ProcessExit
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ocorre quando sai do processo de principal do domínio de aplicação de predefinido."
  remarks: "O <xref:System.EventHandler>para este evento pode efetuar atividades de terminação, por exemplo, fechar ficheiros, ao libertar armazenamento e assim sucessivamente, antes de terminar o processo.</xref:System.EventHandler>       A partir do .NET Framework versão 2.0, este evento é desencadeado em cada domínio de aplicação que regista um processador de eventos.      > [!NOTE] > O total de tempo de execução de todos os processadores de eventos de ProcessExit é limitada, tal como o tempo de execução total de todos os finalizadores está limitado ao encerramento do processo. A predefinição é dois segundos. Um anfitrião não gerido pode alterar este tempo de execução ao chamar o [ICLRPolicyManager::SetTimeout](~/add/includes/ajax-current-ext-md.md) método com o [OPR_ProcessExit](~/add/includes/ajax-current-ext-md.md) valor de enumeração.       Nas versões do .NET Framework 1.0 e 1.1, este evento é gerado apenas no domínio de aplicação predefinido e apenas se um processador de eventos está registado no domínio de aplicação predefinido.       Para registar um processador de eventos para este evento, tem de ter as permissões necessárias, ou um <xref:System.Security.SecurityException>é emitida.</xref:System.Security.SecurityException>       Para obter mais informações sobre como lidar com eventos, consulte [eventos](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public event EventHandler ProcessExit;
    return:
      type: System.EventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ReflectionOnlyAssemblyResolve
  id: ReflectionOnlyAssemblyResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: ReflectionOnlyAssemblyResolve
  nameWithType: AppDomain.ReflectionOnlyAssemblyResolve
  fullName: System.AppDomain.ReflectionOnlyAssemblyResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ocorre quando a resolução de uma assemblagem no contexto apenas de reflexão."
  remarks: "No contexto apenas de reflexão, dependências não estão resolvidas automaticamente. Tem de ser pré-carregado ou devolvidos pelo processador para este evento. Este evento é desencadeado quando uma assemblagem tem uma dependência que já não está carregada no contexto de apenas de reflexão. A dependência em falta é especificada pelo <xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>propriedade.</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName> O <xref:System.ResolveEventHandler>para este evento tem de devolver uma assemblagem que satisfaça a dependência.</xref:System.ResolveEventHandler> A assemblagem que é devolvida tem de ser carregada no contexto de apenas de reflexão.      > [!IMPORTANT] > Este evento é desencadeado apenas para as dependências em falta da assemblagem que está a carregar no contexto de apenas de reflexão (por exemplo, utilizando o <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=fullName>método).</xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=fullName> -Não é gerado se não é possível encontrar a assemblagem que está a carregar.       Começando com o [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], a <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>propriedade devolve a assemblagem que pediu a carga de assemblagem não foi possível resolver.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> Poderá ser útil para identificar a versão correta da dependência, se estiver disponível mais do que uma versão saber a identidade da assemblagem requerente. Para obter mais informações, consulte <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>       Para este evento, o <xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>propriedade devolve o nome de assemblagem antes da política é aplicada.</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>       Para obter mais informações sobre como lidar com eventos, consulte [eventos](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public event ResolveEventHandler ReflectionOnlyAssemblyResolve;
    return:
      type: System.ResolveEventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ReflectionOnlyGetAssemblies
  id: ReflectionOnlyGetAssemblies
  parent: System.AppDomain
  langs:
  - csharp
  name: ReflectionOnlyGetAssemblies()
  nameWithType: AppDomain.ReflectionOnlyGetAssemblies()
  fullName: System.AppDomain.ReflectionOnlyGetAssemblies()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Devolve as assemblagens que foram carregadas no contexto de apenas de reflexão do domínio de aplicação."
  remarks: "Este método devolve as assemblagens que foram carregadas no contexto de apenas de reflexão. Para obter as assemblagens que foram carregadas para execução, utilize o <xref:System.AppDomain.GetAssemblies%2A>método.</xref:System.AppDomain.GetAssemblies%2A>"
  example:
  - "The following code example loads the System.dll assembly into the execution context and then into the reflection-only context. The <xref:System.AppDomain.GetAssemblies%2A> and ReflectionOnlyGetAssemblies methods are used to display the assemblies loaded into each context.  \n  \n [!code-cs[AppDomain.ReflectionOnlyGetAssemblies#1](~/add/codesnippet/csharp/m-system.appdomain.refle_1.cs)]\n [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/add/codesnippet/cpp/m-system.appdomain.refle_1.cpp)]\n [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/add/codesnippet/visualbasic/m-system.appdomain.refle_1.vb)]"
  syntax:
    content: public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();
    parameters: []
    return:
      type: System.Reflection.Assembly[]
      description: "Uma matriz de <xref:System.Reflection.Assembly>objetos que representam as assemblagens carregadas no contexto de apenas de reflexão do domínio de aplicação.</xref:System.Reflection.Assembly>"
  overload: System.AppDomain.ReflectionOnlyGetAssemblies*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "É tentada uma operação num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.RelativeSearchPath
  id: RelativeSearchPath
  parent: System.AppDomain
  langs:
  - csharp
  name: RelativeSearchPath
  nameWithType: AppDomain.RelativeSearchPath
  fullName: System.AppDomain.RelativeSearchPath
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém o caminho no diretório de base onde a resolução de assemblagem deve sonda para assemblagens privadas."
  remarks: "As assemblagens privadas são implementadas na mesma estrutura de diretório como a aplicação. Se o caminho especificado pela propriedade RelativeSearchPath não está em <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>, será ignorada.</xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>       Esta propriedade devolve o valor definido utilizando <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>.</xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>"
  syntax:
    content: public string RelativeSearchPath { get; }
    return:
      type: System.String
      description: "O caminho no diretório de base onde a resolução de assemblagem deve sonda para assemblagens privadas."
  overload: System.AppDomain.RelativeSearchPath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.ResourceResolve
  id: ResourceResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: ResourceResolve
  nameWithType: AppDomain.ResourceResolve
  fullName: System.AppDomain.ResourceResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ocorre quando a resolução de um recurso falha porque o recurso não é um recurso incorporado ou ligado válido na assemblagem."
  remarks: "<xref:System.ResolveEventHandler>Para este evento pode tentar localizar a assemblagem que contém o recurso e devolver o mesmo.</xref:System.ResolveEventHandler>      > [!IMPORTANT] > Este evento é desencadeado não se resolução falhar porque pode ser encontrado nenhum ficheiro para um recurso ligado válido. Este é gerado se não é possível localizar um fluxo de recurso de manifesto, mas não é gerado se a chave de um recurso individual não é possível encontrar.       Começando com o [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], a <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>propriedade contém a assemblagem que o recurso requerido.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> Para obter mais informações, consulte <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>       Para registar um processador de eventos para este evento, tem de ter as permissões necessárias, ou um <xref:System.Security.SecurityException>é emitida.</xref:System.Security.SecurityException>       Para obter mais informações sobre como lidar com eventos, consulte [eventos](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public event ResolveEventHandler ResourceResolve;
    return:
      type: System.ResolveEventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  id: SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetAppDomainPolicy(PolicyLevel)
  nameWithType: AppDomain.SetAppDomainPolicy(PolicyLevel)
  fullName: System.AppDomain.SetAppDomainPolicy(PolicyLevel)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Estabelece o nível de política de segurança para este domínio de aplicação."
  remarks: "Chamar este método antes de uma assemblagem é carregada para o <xref:System.AppDomain>por ordem para a política de segurança para ter efeito.</xref:System.AppDomain>"
  example:
  - "The following example demonstrates how to use the SetAppDomainPolicymethod to set the security policy level of an application domain.  \n  \n [!code-cs[ADSetAppDomainPolicy#1](~/add/codesnippet/csharp/m-system.appdomain.setap_1.cs)]\n [!code-cpp[ADSetAppDomainPolicy#1](~/add/codesnippet/cpp/m-system.appdomain.setap_1.cpp)]\n [!code-vb[ADSetAppDomainPolicy#1](~/add/codesnippet/visualbasic/m-system.appdomain.setap_1.vb)]"
  syntax:
    content: public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);
    parameters:
    - id: domainPolicy
      type: System.Security.Policy.PolicyLevel
      description: "O nível de política de segurança."
  overload: System.AppDomain.SetAppDomainPolicy*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>domainPolicy</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.Policy.PolicyException
    commentId: T:System.Security.Policy.PolicyException
    description: "O nível de política de segurança já foi definido."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.SetCachePath(System.String)
  id: SetCachePath(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetCachePath(String)
  nameWithType: AppDomain.SetCachePath(String)
  fullName: System.AppDomain.SetCachePath(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Estabelece o caminho do diretório especificado como a localização onde as assemblagens forem copiada de sombra de volumes."
  remarks: "O caminho da cache é ignorado se o <xref:System.AppDomainSetup.ApplicationName%2A>propriedade não está definida.</xref:System.AppDomainSetup.ApplicationName%2A> Consulte o <xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName>propriedade.</xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName>       Para obter mais informações sobre a cópia de sombra Consulte [assemblagens de cópia sombra de volumes](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void SetCachePath (string path);
    parameters:
    - id: path
      type: System.String
      description: "O caminho completamente qualificado para a localização de cópia sombra de volumes."
  overload: System.AppDomain.SetCachePath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.SetData(System.String,System.Object)
  id: SetData(System.String,System.Object)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetData(String,Object)
  nameWithType: AppDomain.SetData(String,Object)
  fullName: System.AppDomain.SetData(String,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Atribui o valor especificado para a propriedade de domínio de aplicação especificada."
  remarks: "Utilize este método para inserir uma entrada ou modifique o valor de uma entrada numa cache interna de pares de nome de dados que descrevem as propriedades desta instância de <xref:System.AppDomain>.</xref:System.AppDomain>       A cache contém automaticamente as entradas do sistema predefinidas que são inseridas quando o domínio de aplicação é criado. Não é possível inserir ou modificar as entradas do sistema com este método. Uma chamada de método que tentou modificar uma entrada de sistema não tem qualquer efeito; o método não acionar uma excepção. Pode inspecionar os valores das entradas de sistema com o <xref:System.AppDomain.GetData%2A>método, ou equivalente <xref:System.AppDomainSetup>Propriedades descritas na <xref:System.AppDomain.GetData%2A>.</xref:System.AppDomain.GetData%2A> </xref:System.AppDomainSetup> </xref:System.AppDomain.GetData%2A>       Pode chamar este método para definir o valor do intervalo de tempo limite predefinido para avaliar os padrões de expressão regular por alimentação &quot;REGEX_DEFAULT_MATCH_TIMEOUT&quot; como o valor a `name` argumento e uma <xref:System.TimeSpan>valor que representa o intervalo de tempo limite, como o valor do `data` argumento.</xref:System.TimeSpan> Também pode inserir ou modificar os suas próprias pares de nome de dados definido pelo utilizador com este método e Inspecione os respetivos valores com o <xref:System.AppDomain.GetData%2A>método.</xref:System.AppDomain.GetData%2A>"
  example:
  - "The following example demonstrates how to use the SetData method to create a new value pair. The example then uses the <xref:System.AppDomain.GetData%2A> method to retrieve the value, and displays it to the console.  \n  \n [!code-cpp[ADGetData#1](~/add/codesnippet/cpp/m-system.appdomain.setda_1.cpp)]\n [!code-vb[ADGetData#1](~/add/codesnippet/visualbasic/m-system.appdomain.setda_1.vb)]\n [!code-cs[ADGetData#1](~/add/codesnippet/csharp/m-system.appdomain.setda_1.cs)]"
  syntax:
    content: public void SetData (string name, object data);
    parameters:
    - id: name
      type: System.String
      description: "O nome de uma propriedade de domínio de aplicação definido pelo utilizador para criar ou alterar."
    - id: data
      type: System.Object
      description: "O valor da propriedade."
  overload: System.AppDomain.SetData*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)
  id: SetData(System.String,System.Object,System.Security.IPermission)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetData(String,Object,IPermission)
  nameWithType: AppDomain.SetData(String,Object,IPermission)
  fullName: System.AppDomain.SetData(String,Object,IPermission)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Atribui o valor especificado para a propriedade de domínio de aplicação especificada, com uma permissão especificada para a pedido do chamador quando a propriedade é obtida."
  remarks: "Utilize este método para inserir ou modificar as suas próprias entradas definido pelo utilizador numa cache interna de pares nome/dados que descrevem as propriedades do domínio de aplicação. Ao inserir uma entrada, pode especificar um pedido de permissão para impor quando a entrada é obtida. Além disso, pode chamar este método para definir o valor do intervalo de tempo limite predefinido para avaliar os padrões de expressão regular por alimentação &quot;REGEX_DEFAULT_MATCH_TIMEOUT&quot; como o valor a `name` argumento e uma <xref:System.TimeSpan>valor que representa o intervalo de tempo limite, como o valor o `data` argumento.</xref:System.TimeSpan>       Não é possível utilizar este método para atribuir um pedido de segurança para uma cadeia de propriedade definido pelo sistema.       A cache contém automaticamente as entradas do sistema predefinidas que são inseridas quando o domínio de aplicação é criado. Não é possível inserir ou modificar as entradas do sistema com este método. Uma chamada de método que tentou modificar uma entrada de sistema não tem qualquer efeito; o método não acionar uma excepção. Pode inspecionar os valores das entradas de sistema com o <xref:System.AppDomain.GetData%2A>método ou equivalente <xref:System.AppDomainSetup>Propriedades descritas na secção observações para o <xref:System.AppDomain.GetData%2A>método.</xref:System.AppDomain.GetData%2A> </xref:System.AppDomainSetup> </xref:System.AppDomain.GetData%2A>"
  syntax:
    content: public void SetData (string name, object data, System.Security.IPermission permission);
    parameters:
    - id: name
      type: System.String
      description: "O nome de uma propriedade de domínio de aplicação definido pelo utilizador para criar ou alterar."
    - id: data
      type: System.Object
      description: "O valor da propriedade."
    - id: permission
      type: System.Security.IPermission
      description: "A permissão para a pedido do chamador quando a propriedade é obtida."
  overload: System.AppDomain.SetData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>name</code>Especifica uma cadeia de propriedade definido pelo sistema e <code>permission</code> não é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.SetDynamicBase(System.String)
  id: SetDynamicBase(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetDynamicBase(String)
  nameWithType: AppDomain.SetDynamicBase(String)
  fullName: System.AppDomain.SetDynamicBase(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Estabelece o caminho do diretório especificado como o diretório de base para subdiretórios onde os ficheiros gerados dinamicamente são armazenados e acedidos."
  remarks: "Este método define o <xref:System.AppDomainSetup.DynamicBase%2A>propriedade interna <xref:System.AppDomainSetup>associados a esta instância.</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.DynamicBase%2A>"
  example:
  - "This method is now obsolete, and should not be used for new development. The following example shows how to use the non-obsolete alternative, the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName> property. For an explanation of this example, see the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName> property or the <xref:System.AppDomain.DynamicDirectory%2A> property.  \n  \n [!code-cpp[ADDynamicBase#1](~/add/codesnippet/cpp/m-system.appdomain.setdy_1.cpp)]\n [!code-cs[ADDynamicBase#1](~/add/codesnippet/csharp/m-system.appdomain.setdy_1.cs)]\n [!code-vb[ADDynamicBase#1](~/add/codesnippet/visualbasic/m-system.appdomain.setdy_1.vb)]"
  syntax:
    content: public void SetDynamicBase (string path);
    parameters:
    - id: path
      type: System.String
      description: "O caminho completamente qualificado que é o diretório de base para subdiretórios onde estão armazenadas as assemblagens dinâmicas."
  overload: System.AppDomain.SetDynamicBase*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  id: SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetPrincipalPolicy(PrincipalPolicy)
  nameWithType: AppDomain.SetPrincipalPolicy(PrincipalPolicy)
  fullName: System.AppDomain.SetPrincipalPolicy(PrincipalPolicy)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Especifica como objetos principais e de identidade devem ser ligados a um thread se o thread tenta vincular a um principal ao executar neste domínio de aplicação."
  remarks: "Definir este valor só serão aplicado se defini-lo antes de utilizar o <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>propriedade.</xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> Por exemplo, se definir <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>para um determinado principal (por exemplo, um principal de genérico) e, em seguida, utilize o método de SetPrincipalPolicy para definir o <xref:System.Security.Principal.PrincipalPolicy>para <xref:System.Security.Principal.PrincipalPolicy>, o principal atual permanecerá o principal genérico.</xref:System.Security.Principal.PrincipalPolicy> </xref:System.Security.Principal.PrincipalPolicy> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>"
  example:
  - "The following example shows the effect on threads of using the SetPrincipalPolicy method to change the principal policy of the application domain. It also shows the effect of using the <xref:System.AppDomain.SetThreadPrincipal%2A> method to change the principal that is available for attaching to threads in the application domain.  \n  \n [!code-cpp[ADPrincipal#1](~/add/codesnippet/cpp/m-system.appdomain.setpr_1.cpp)]\n [!code-vb[ADPrincipal#1](~/add/codesnippet/visualbasic/m-system.appdomain.setpr_1.vb)]\n [!code-cs[ADPrincipal#1](~/add/codesnippet/csharp/m-system.appdomain.setpr_1.cs)]"
  syntax:
    content: public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);
    parameters:
    - id: policy
      type: System.Security.Principal.PrincipalPolicy
      description: "Um do <xref href=&quot;System.Security.Principal.PrincipalPolicy&quot;> </xref> valores que especifica o tipo do objeto principal para anexar ao threads."
  overload: System.AppDomain.SetPrincipalPolicy*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.SetShadowCopyFiles
  id: SetShadowCopyFiles
  parent: System.AppDomain
  langs:
  - csharp
  name: SetShadowCopyFiles()
  nameWithType: AppDomain.SetShadowCopyFiles()
  fullName: System.AppDomain.SetShadowCopyFiles()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ativa a cópia sombra de volumes."
  remarks: "Para obter mais informações sobre a cópia sombra de volumes, consulte [assemblagens de cópia sombra de volumes](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This method is now obsolete, and should not be used for new development.  \n  \n [!code-cpp[adproperties#1](~/add/codesnippet/cpp/m-system.appdomain.setsh_0_1.cpp)]\n [!code-vb[adproperties#1](~/add/codesnippet/visualbasic/m-system.appdomain.setsh_0_1.vb)]\n [!code-cs[adproperties#1](~/add/codesnippet/csharp/m-system.appdomain.setsh_0_1.cs)]"
  syntax:
    content: public void SetShadowCopyFiles ();
    parameters: []
  overload: System.AppDomain.SetShadowCopyFiles*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.SetShadowCopyPath(System.String)
  id: SetShadowCopyPath(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetShadowCopyPath(String)
  nameWithType: AppDomain.SetShadowCopyPath(String)
  fullName: System.AppDomain.SetShadowCopyPath(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Estabelece o caminho do diretório especificado como a localização das assemblagens para ser copiada de sombra de volumes."
  remarks: "Por predefinição, uma cópia sombra inclui todas as assemblagens encontradas através da pesquisa. O método SetShadowCopyPath restringe a cópia sombra para as assemblagens nos diretórios especificados pelo `path`.       O método SetShadowCopyPath não especifica diretórios adicionais para ser pesquisadas para assemblagens. As assemblagens para ser copiado de sombra já tem de estar localizadas no caminho de pesquisa, por exemplo em <xref:System.AppDomain.BaseDirectory%2A>.</xref:System.AppDomain.BaseDirectory%2A> O método SetShadowCopyPath Especifica os caminhos de pesquisa são elegíveis para ser sombra-copiado.       Este método define o <xref:System.AppDomainSetup.ShadowCopyDirectories%2A>propriedade interna <xref:System.AppDomainSetup>associados a esta instância.</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.ShadowCopyDirectories%2A>       Para obter mais informações sobre a cópia sombra de volumes, consulte [assemblagens de cópia sombra de volumes](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This method is now obsolete, and should not be used for new development.  \n  \n [!code-cpp[ADShadowCopy#1](~/add/codesnippet/cpp/m-system.appdomain.setsh_1_1.cpp)]\n [!code-vb[ADShadowCopy#1](~/add/codesnippet/visualbasic/m-system.appdomain.setsh_1_1.vb)]\n [!code-cs[ADShadowCopy#1](~/add/codesnippet/csharp/m-system.appdomain.setsh_1_1.cs)]"
  syntax:
    content: public void SetShadowCopyPath (string path);
    parameters:
    - id: path
      type: System.String
      description: "Uma lista de nomes de diretório, onde cada nome é separado por ponto e vírgula."
  overload: System.AppDomain.SetShadowCopyPath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)
  id: SetThreadPrincipal(System.Security.Principal.IPrincipal)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetThreadPrincipal(IPrincipal)
  nameWithType: AppDomain.SetThreadPrincipal(IPrincipal)
  fullName: System.AppDomain.SetThreadPrincipal(IPrincipal)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Define o objecto predefinido principal ligado ao threads caso tentem vincular a um principal ao executar neste domínio de aplicação."
  remarks: ''
  example:
  - "The following example shows the effect of using the SetThreadPrincipal method to change the principal that is available for attaching to threads that are executing in the application domain. It also shows the effect on threads of using the <xref:System.AppDomain.SetPrincipalPolicy%2A> method to change the principal policy of the application domain.  \n  \n [!code-cpp[ADPrincipal#1](~/add/codesnippet/cpp/m-system.appdomain.setth_1.cpp)]\n [!code-vb[ADPrincipal#1](~/add/codesnippet/visualbasic/m-system.appdomain.setth_1.vb)]\n [!code-cs[ADPrincipal#1](~/add/codesnippet/csharp/m-system.appdomain.setth_1.cs)]"
  syntax:
    content: public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);
    parameters:
    - id: principal
      type: System.Security.Principal.IPrincipal
      description: "O objeto principal para anexar ao threads."
  overload: System.AppDomain.SetThreadPrincipal*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>principal</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.Policy.PolicyException
    commentId: T:System.Security.Policy.PolicyException
    description: "O principal de thread já foi definido."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.SetupInformation
  id: SetupInformation
  parent: System.AppDomain
  langs:
  - csharp
  name: SetupInformation
  nameWithType: AppDomain.SetupInformation
  fullName: System.AppDomain.SetupInformation
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém as informações de configuração do domínio de aplicação para esta instância."
  syntax:
    content: public AppDomainSetup SetupInformation { get; }
    return:
      type: System.AppDomainSetup
      description: "As informações de inicialização de domínio de aplicação."
  overload: System.AppDomain.SetupInformation*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.ShadowCopyFiles
  id: ShadowCopyFiles
  parent: System.AppDomain
  langs:
  - csharp
  name: ShadowCopyFiles
  nameWithType: AppDomain.ShadowCopyFiles
  fullName: System.AppDomain.ShadowCopyFiles
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém uma indicação se o domínio aplicacional está configurado para ficheiros de cópia sombra de volumes."
  remarks: "Para obter mais informações, consulte <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName>e [assemblagens de cópia sombra de volumes](~/add/includes/ajax-current-ext-md.md).</xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName>"
  syntax:
    content: public bool ShadowCopyFiles { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o domínio aplicacional está configurado para ficheiros de cópia sombra de volumes caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.ShadowCopyFiles*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "A operação for tentada num domínio de aplicação descarregado."
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  id: System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Mapeia um conjunto de nomes para um conjunto de identificadores de emissão correspondente."
  remarks: "Este método é para acesso por classes geridas a partir do código não gerido e não deve ser chamado a partir do código gerido. Para obter mais informações sobre `IDispatch::GetIDsOfNames`, consulte a biblioteca da MSDN."
  syntax:
    content: void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
    parameters:
    - id: riid
      type: System.Guid
      description: "Reservado para utilização futura. Tem de ser IID_NULL."
    - id: rgszNames
      type: System.IntPtr
      description: "No passado a matriz de nomes deve ser mapeado."
    - id: cNames
      type: System.UInt32
      description: "Contagem dos nomes a ser mapeado."
    - id: lcid
      type: System.UInt32
      description: "O contexto de região na qual a interpretar os nomes."
    - id: rgDispId
      type: System.IntPtr
      description: "Matriz alocado de autor da chamada que recebe os IDs correspondentes aos nomes."
  overload: System.AppDomain.System#_AppDomain#GetIDsOfNames*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Acesso de vinculação tardia utilizando o COM `IDispatch` interface não é suportada."
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  id: System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém as informações de tipo para um objeto, que, em seguida, pode ser utilizado para obter as informações de tipo para uma interface."
  remarks: "Este método é para acesso por classes geridas a partir do código não gerido e não deve ser chamado a partir do código gerido. Para obter mais informações sobre `IDispatch::GetTypeInfo`, consulte a biblioteca da MSDN."
  syntax:
    content: void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);
    parameters:
    - id: iTInfo
      type: System.UInt32
      description: "As informações de tipo de retorno."
    - id: lcid
      type: System.UInt32
      description: "O identificador de região para obter as informações de tipo."
    - id: ppTInfo
      type: System.IntPtr
      description: "Recebe um ponteiro para o objeto de informações do tipo pedido."
  overload: System.AppDomain.System#_AppDomain#GetTypeInfo*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Acesso de vinculação tardia utilizando o COM `IDispatch` interface não é suportada."
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  id: System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.GetTypeInfoCount(UInt32)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém o número de interfaces de informações de tipo que um objeto fornece (0 ou 1)."
  remarks: "Este método é para acesso por classes geridas a partir do código não gerido e não deve ser chamado a partir do código gerido. Para obter mais informações sobre `IDispatch::GetTypeInfoCount`, consulte a biblioteca da MSDN."
  syntax:
    content: void _AppDomain.GetTypeInfoCount (out uint pcTInfo);
    parameters:
    - id: pcTInfo
      type: System.UInt32
      description: "Aponta para uma localização que recebe o número de interfaces de informações de tipo fornecido pelo objeto."
  overload: System.AppDomain.System#_AppDomain#GetTypeInfoCount*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Acesso de vinculação tardia utilizando o COM `IDispatch` interface não é suportada."
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  id: System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Fornece acesso às propriedades e métodos expostos por um objeto."
  remarks: "Este método é para acesso por classes geridas a partir do código não gerido e não deve ser chamado a partir do código gerido. Para obter mais informações sobre `IDispatch::Invoke`, consulte a biblioteca da MSDN."
  syntax:
    content: void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    parameters:
    - id: dispIdMember
      type: System.UInt32
      description: "Identifica o membro."
    - id: riid
      type: System.Guid
      description: "Reservado para utilização futura. Tem de ser IID_NULL."
    - id: lcid
      type: System.UInt32
      description: "O contexto de região na qual interpretar argumentos."
    - id: wFlags
      type: System.Int16
      description: "Sinalizadores que descrevem o contexto da chamada."
    - id: pDispParams
      type: System.IntPtr
      description: "Apontador para uma estrutura que contém uma matriz de argumentos, uma matriz de argumento DISPID para os argumentos com nome e contagens para o número de elementos nas matrizes."
    - id: pVarResult
      type: System.IntPtr
      description: "Apontador para a localização onde o resultado é que sejam armazenadas."
    - id: pExcepInfo
      type: System.IntPtr
      description: "Apontador para uma estrutura que contém informações de exceção."
    - id: puArgErr
      type: System.IntPtr
      description: "O índice do primeiro argumento tem um erro."
  overload: System.AppDomain.System#_AppDomain#Invoke*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Acesso de vinculação tardia utilizando o COM `IDispatch` interface não é suportada."
  platform:
  - net462
- uid: System.AppDomain.ToString
  id: ToString
  parent: System.AppDomain
  langs:
  - csharp
  name: ToString()
  nameWithType: AppDomain.ToString()
  fullName: System.AppDomain.ToString()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Obtém uma representação de cadeia que inclui o nome amigável do domínio de aplicação e quaisquer políticas de contexto."
  remarks: ''
  example:
  - "The following code example displays the return value of the ToString method.  \n  \n [!code-cpp[ADToString#1](~/add/codesnippet/cpp/m-system.appdomain.tostr_1.cpp)]\n [!code-cs[ADToString#1](~/add/codesnippet/csharp/m-system.appdomain.tostr_1.cs)]\n [!code-vb[ADToString#1](~/add/codesnippet/visualbasic/m-system.appdomain.tostr_1.vb)]"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "Uma cadeia de formato por concatenar a cadeia literal &quot;nome:&quot;, o nome amigável do domínio de aplicação e o representações de cadeia das políticas de contexto ou a cadeia &quot;existem não existem políticas de contexto.&quot;"
  overload: System.AppDomain.ToString*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "O domínio aplicacional representado pelo atual <xref href=&quot;System.AppDomain&quot;> </xref> foi descarregado."
  platform:
  - net462
- uid: System.AppDomain.TypeResolve
  id: TypeResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: TypeResolve
  nameWithType: AppDomain.TypeResolve
  fullName: System.AppDomain.TypeResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ocorre quando a resolução de um tipo de falha."
  remarks: "O evento TypeResolve ocorre quando o language runtime não é possível determinar a assemblagem que pode criar o tipo pedido. Isto pode ocorrer se o tipo está definido numa assemblagem dinâmica, ou o tipo não está definido numa assemblagem dinâmica, mas o tempo de execução não souber qual o tipo está definido de assemblagem. Última situação pode ocorrer quando <xref:System.Type.GetType%2A?displayProperty=fullName>é chamado com um nome de tipo que não está qualificado com o nome de assemblagem.</xref:System.Type.GetType%2A?displayProperty=fullName>       O <xref:System.ResolveEventHandler>para este evento pode tentar localizar e criar o tipo.</xref:System.ResolveEventHandler>       No entanto, o evento TypeResolve não ocorre se o tempo de execução sabe não é possível localizar um tipo em determinados assemblagens. Por exemplo, este evento ocorre se o tipo não está numa assemblagem estática porque o tempo de execução sabe tipos não não possível adicionar dinamicamente a assemblagens estáticas.       Começando com o [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], a <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>propriedade contém a assemblagem que o tipo pedido.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> Para obter mais informações, consulte <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>       Para registar um processador de eventos para este evento, tem de ter as permissões necessárias, ou um <xref:System.Security.SecurityException>é emitida.</xref:System.Security.SecurityException>       Para obter mais informações sobre como lidar com eventos, consulte [eventos](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following sample demonstrates the TypeResolve event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_TypeResolve#1](~/add/codesnippet/csharp/e-system.appdomain.typer_1.cs)]\n [!code-vb[AppDomain_TypeResolve#1](~/add/codesnippet/visualbasic/e-system.appdomain.typer_1.vb)]\n [!code-cpp[AppDomain_TypeResolve#1](~/add/codesnippet/cpp/e-system.appdomain.typer_1.cpp)]"
  syntax:
    content: public event ResolveEventHandler TypeResolve;
    return:
      type: System.ResolveEventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.UnhandledException
  id: UnhandledException
  parent: System.AppDomain
  langs:
  - csharp
  name: UnhandledException
  nameWithType: AppDomain.UnhandledException
  fullName: System.AppDomain.UnhandledException
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ocorre quando não é detetada uma exceção."
  remarks: "Este evento fornece a notificação de exceções não identificadas. Permite que a aplicação registar informações sobre a exceção antes do processador de predefinido do sistema comunica a exceção de utilizador e termina a aplicação. Se estiver disponíveis informações suficientes sobre o estado da aplicação, poderão ser undertaken outras ações — por exemplo, guardar os dados de programa para a recuperação posterior. Atenção recomenda-se, porque os dados do programa podem ficar danificados quando exceções não processadas.      > [!NOTE] > Nas versões do .NET Framework 1.0 e 1.1, terminação de aplicação e as opções de depuração são reportados ao utilizador antes deste evento é desencadeado, em vez depois.       Este evento pode ser processado em qualquer domínio de aplicação. No entanto, o evento não é gerado necessariamente no domínio de aplicação onde ocorreu a exceção. Uma exceção não processada só é se a pilha de completa para o thread foi descarregar sem localizar um processador de excepções aplicável, pelo que é o primeiro local que o evento pode ser gerado no domínio de aplicação onde o thread foi originado.      > [!NOTE] > No versões do .NET Framework 1.0 e 1.1, este evento ocorre apenas para o domínio de aplicação predefinido que é criado pelo sistema, quando uma aplicação é iniciada. Se uma aplicação cria domínios de aplicação adicionais, especificar um delegado para este evento nesses domínios de aplicações não tem qualquer efeito.       Se o evento UnhandledException é processado no domínio de aplicação predefinido, é gerado não existe para qualquer excepção não processada em qualquer thread, independentemente do que o thread foi iniciado no domínio da aplicação. Se o thread foi iniciada num domínio de aplicação que tem um processador de eventos para UnhandledException, o evento é desencadeado nesse domínio de aplicação. Se esse domínio de aplicação não é o domínio de aplicação predefinido, e também existir um processador de eventos no domínio de aplicação predefinido, o evento é desencadeado em ambos os domínios de aplicação.       Por exemplo, suponha um thread é iniciado no domínio de aplicação &quot;AD1&quot;, chama um método no domínio de aplicação &quot;AD2&quot; e a partir daí chama um método no domínio de aplicação &quot;AD3&quot;, onde emite uma exceção. O primeiro domínio de aplicação na qual o evento de UnhandledException pode ser gerado é &quot;AD1&quot;. Se esse domínio de aplicação não é o domínio de aplicação predefinido, o evento também pode ser gerado no domínio de aplicação predefinido.      > [!NOTE] > O language runtime suspende cancelamentos de thread enquanto processadores de eventos para o evento UnhandledException se encontram em execução.       Se o processador de eventos tem um <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>atributo com os sinalizadores apropriados, o processador de eventos é tratado como uma região de execução restrita.</xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>       Iniciando com o [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], este evento é desencadeado não exceções que o estado do processo, tais como a capacidade excedida da pilha ou o acesso violações, a menos que o processador de eventos é fundamental para a segurança e tem o <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>atributo.</xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>       Nas versões do .NET Framework 1.0 e 1.1, uma exceção não processada que ocorre num thread diferente do thread de aplicação principal é detetada pelo runtime e, por conseguinte, não fazer com que a aplicação terminar. Assim, é possível para o evento de UnhandledException gerado sem terminar a aplicação. A partir do .NET Framework versão 2.0, este backstop para exceções não processadas threads subordinado foi removido, porque o efeito de tais falhas automáticas cumulativo degradação do desempenho, dados danificados e lockups, sendo todas foram difíceis de depuração. Para obter mais informações, incluindo uma lista de cenários em que o tempo de execução não terminar, consulte [exceções geridos Threads](~/add/includes/ajax-current-ext-md.md).       Para registar um processador de eventos para este evento, tem de ter as permissões necessárias, ou um <xref:System.Security.SecurityException>é emitida.</xref:System.Security.SecurityException>       Para obter mais informações sobre como lidar com eventos, consulte [eventos](~/add/includes/ajax-current-ext-md.md).      ## Outros eventos de exceções não processadas para determinadas aplicações modelos, UnhandledException evento pode ser impedido por outros eventos se ocorrer uma excepção não processada no thread de aplicação principal.       Em aplicações que utilizam Windows Forms, não processada exceções a causa do thread de aplicação principal o <xref:System.Windows.Forms.Application.ThreadException?displayProperty=fullName>evento seja gerado.</xref:System.Windows.Forms.Application.ThreadException?displayProperty=fullName> Se este evento é processado, o comportamento predefinido é que a exceção não processada não fecha a aplicação, apesar da aplicação for deixada em estado desconhecido. Nesse caso, o evento de UnhandledException não é gerado. Este comportamento pode ser alterado utilizando o ficheiro de configuração de aplicação, ou utilizando o <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=fullName>método para alterar o modo <xref:System.Windows.Forms.UnhandledExceptionMode?displayProperty=fullName>antes do <xref:System.Windows.Forms.Application.ThreadException>processador de eventos é estabelecer ligação com ele correr</xref:System.Windows.Forms.Application.ThreadException> </xref:System.Windows.Forms.UnhandledExceptionMode?displayProperty=fullName> </xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=fullName> Isto aplica-se apenas para o thread principal da aplicação. O evento de UnhandledException é gerado para exceções não processadas emitidas no outros threads.       A partir do Microsoft Visual Studio 2005, a estrutura da aplicação Visual Basic fornece outro evento para o thread de aplicação principal exceções não processadas. Consulte o <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=fullName>eventos.</xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=fullName> Este evento tem um objeto de argumentos de evento com o mesmo nome que o objeto de argumentos de evento utilizado pelo UnhandledException, mas com propriedades diferentes. Em particular, este objecto de argumentos de evento tem um <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A>propriedade que permite que a aplicação continuar em execução, a ignorar a exceção não processada (e mantendo a aplicação num Estado desconhecido).</xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> Nesse caso, o evento de UnhandledException não é gerado."
  example:
  - "The followingexample demonstrates the UnhandledException event. It defines an event handler, `MyHandler`, that is invoked whenever an unhandled exception is thrown in the default application domain. It then throws two exceptions. The first is handled by a **try/catch** block. The second is unhandled and invokes the `MyHandle` routine before the application terminates.  \n  \n [!code-cs[AppDomain_UnhandledException#1](~/add/codesnippet/csharp/e-system.appdomain.unhan_1.cs)]\n [!code-vb[AppDomain_UnhandledException#1](~/add/codesnippet/visualbasic/e-system.appdomain.unhan_1.vb)]\n [!code-cpp[AppDomain_UnhandledException#1](~/add/codesnippet/cpp/e-system.appdomain.unhan_1.cpp)]"
  syntax:
    content: public event UnhandledExceptionEventHandler UnhandledException;
    return:
      type: System.UnhandledExceptionEventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.Unload(System.AppDomain)
  id: Unload(System.AppDomain)
  parent: System.AppDomain
  langs:
  - csharp
  name: Unload(AppDomain)
  nameWithType: AppDomain.Unload(AppDomain)
  fullName: System.AppDomain.Unload(AppDomain)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Efetua a descarga de domínio de aplicação especificada."
  remarks: "Na versão 2.0 do .NET Framework não há um thread dedicado para descarregar domínios de aplicação. Isto melhora a fiabilidade, especialmente quando o .NET Framework está alojado. Quando um thread chamadas descarregado, o domínio de destino está marcado para descarregar. O thread dedicado tenta ao descarregar o domínio, e todos os threads no domínio foram abortados. Se um thread não abort, por exemplo porque está a executar código não gerido ou porque esta está a executar um `finally` bloco, em seguida, após um período de tempo de um <xref:System.CannotUnloadAppDomainException>é emitida no thread que originalmente denominado descarregamento.</xref:System.CannotUnloadAppDomainException> Se o thread que não foi abortado eventualmente termina, o domínio de destino não é descarregado. Assim, na versão 2.0 do .NET Framework `domain` não é garantida ao descarregar, porque pode não ser possível terminar de threads em execução.      > [!NOTE] > Em alguns casos, chamar descarregamento faz com que um imediata <xref:System.CannotUnloadAppDomainException>, por exemplo se denomina-se num finalizador.</xref:System.CannotUnloadAppDomainException>       Threads no `domain` estão terminadas utilizando o <xref:System.Threading.Thread.Abort%2A>método, o que emite um <xref:System.Threading.ThreadAbortException>no thread.</xref:System.Threading.ThreadAbortException> </xref:System.Threading.Thread.Abort%2A> Embora o thread deve terminar retomadas rapidamente, pode continuar a executar durante um período de tempo em imprevisível um `finally` cláusula.      ## Versão de compatibilidade no .NET Framework versão 1.0 e 1.1 se estiver a executar o thread que chama descarregamento `domain`, outro thread é iniciado para efetuar a operação de descarregamento. Se `domain` não podem ser descarregados, um <xref:System.CannotUnloadAppDomainException>é emitida nesse thread, não no thread original que descarregamento de chamada.</xref:System.CannotUnloadAppDomainException> No entanto, se o thread que chama descarregamento está em execução fora `domain`, que o thread recebe a exceção."
  example:
  - "The following code example shows how to unload an application domain.  \n  \n [!code-cpp[ADUnload#1](~/add/codesnippet/cpp/m-system.appdomain.unloa_1.cpp)]\n [!code-vb[ADUnload#1](~/add/codesnippet/visualbasic/m-system.appdomain.unloa_1.vb)]\n [!code-cs[ADUnload#1](~/add/codesnippet/csharp/m-system.appdomain.unloa_1.cs)]"
  syntax:
    content: public static void Unload (AppDomain domain);
    parameters:
    - id: domain
      type: System.AppDomain
      description: "Um domínio de aplicação ao descarregar."
  overload: System.AppDomain.Unload*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>domain</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.CannotUnloadAppDomainException
    commentId: T:System.CannotUnloadAppDomainException
    description: "<code>domain</code>Não foi possível ser descarregado."
  - type: System.Exception
    commentId: T:System.Exception
    description: "Ocorreu um erro durante o processo de descarregamento."
  platform:
  - net462
references:
- uid: System.MarshalByRefObject
  isExternal: false
  name: System.MarshalByRefObject
- uid: System.AppDomainUnloadedException
  parent: System
  isExternal: false
  name: AppDomainUnloadedException
  nameWithType: AppDomainUnloadedException
  fullName: System.AppDomainUnloadedException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.TypeLoadException
  isExternal: true
  name: System.TypeLoadException
- uid: System.MissingMethodException
  isExternal: true
  name: System.MissingMethodException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.MemberAccessException
  isExternal: true
  name: System.MemberAccessException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.BadImageFormatException
  isExternal: true
  name: System.BadImageFormatException
- uid: System.IO.FileLoadException
  isExternal: true
  name: System.IO.FileLoadException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.MethodAccessException
  isExternal: true
  name: System.MethodAccessException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Security.Policy.PolicyException
  parent: System.Security.Policy
  isExternal: false
  name: PolicyException
  nameWithType: PolicyException
  fullName: System.Security.Policy.PolicyException
- uid: System.NotImplementedException
  isExternal: true
  name: System.NotImplementedException
- uid: System.CannotUnloadAppDomainException
  parent: System
  isExternal: false
  name: CannotUnloadAppDomainException
  nameWithType: CannotUnloadAppDomainException
  fullName: System.CannotUnloadAppDomainException
- uid: System.Exception
  isExternal: true
  name: System.Exception
- uid: System.AppDomain.ActivationContext
  parent: System.AppDomain
  isExternal: false
  name: ActivationContext
  nameWithType: AppDomain.ActivationContext
  fullName: System.AppDomain.ActivationContext
- uid: System.ActivationContext
  parent: System
  isExternal: false
  name: ActivationContext
  nameWithType: ActivationContext
  fullName: System.ActivationContext
- uid: System.AppDomain.AppendPrivatePath(System.String)
  parent: System.AppDomain
  isExternal: false
  name: AppendPrivatePath(String)
  nameWithType: AppDomain.AppendPrivatePath(String)
  fullName: System.AppDomain.AppendPrivatePath(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.AppDomain.ApplicationIdentity
  parent: System.AppDomain
  isExternal: false
  name: ApplicationIdentity
  nameWithType: AppDomain.ApplicationIdentity
  fullName: System.AppDomain.ApplicationIdentity
- uid: System.ApplicationIdentity
  parent: System
  isExternal: false
  name: ApplicationIdentity
  nameWithType: ApplicationIdentity
  fullName: System.ApplicationIdentity
- uid: System.AppDomain.ApplicationTrust
  parent: System.AppDomain
  isExternal: false
  name: ApplicationTrust
  nameWithType: AppDomain.ApplicationTrust
  fullName: System.AppDomain.ApplicationTrust
- uid: System.Security.Policy.ApplicationTrust
  parent: System.Security.Policy
  isExternal: false
  name: ApplicationTrust
  nameWithType: ApplicationTrust
  fullName: System.Security.Policy.ApplicationTrust
- uid: System.AppDomain.ApplyPolicy(System.String)
  parent: System.AppDomain
  isExternal: false
  name: ApplyPolicy(String)
  nameWithType: AppDomain.ApplyPolicy(String)
  fullName: System.AppDomain.ApplyPolicy(String)
- uid: System.AppDomain.AssemblyLoad
  parent: System.AppDomain
  isExternal: false
  name: AssemblyLoad
  nameWithType: AppDomain.AssemblyLoad
  fullName: System.AppDomain.AssemblyLoad
- uid: System.AssemblyLoadEventHandler
  parent: System
  isExternal: false
  name: AssemblyLoadEventHandler
  nameWithType: AssemblyLoadEventHandler
  fullName: System.AssemblyLoadEventHandler
- uid: System.AppDomain.AssemblyResolve
  parent: System.AppDomain
  isExternal: false
  name: AssemblyResolve
  nameWithType: AppDomain.AssemblyResolve
  fullName: System.AppDomain.AssemblyResolve
- uid: System.ResolveEventHandler
  parent: System
  isExternal: false
  name: ResolveEventHandler
  nameWithType: ResolveEventHandler
  fullName: System.ResolveEventHandler
- uid: System.AppDomain.BaseDirectory
  parent: System.AppDomain
  isExternal: false
  name: BaseDirectory
  nameWithType: AppDomain.BaseDirectory
  fullName: System.AppDomain.BaseDirectory
- uid: System.AppDomain.ClearPrivatePath
  parent: System.AppDomain
  isExternal: false
  name: ClearPrivatePath()
  nameWithType: AppDomain.ClearPrivatePath()
  fullName: System.AppDomain.ClearPrivatePath()
- uid: System.AppDomain.ClearShadowCopyPath
  parent: System.AppDomain
  isExternal: false
  name: ClearShadowCopyPath()
  nameWithType: AppDomain.ClearShadowCopyPath()
  fullName: System.AppDomain.ClearShadowCopyPath()
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateComInstanceFrom(String,String)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String)
- uid: System.Runtime.Remoting.ObjectHandle
  parent: System.Runtime.Remoting
  isExternal: false
  name: ObjectHandle
  nameWithType: ObjectHandle
  fullName: System.Runtime.Remoting.ObjectHandle
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  isExternal: false
  name: CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Configuration.Assemblies.AssemblyHashAlgorithm
  parent: System.Configuration.Assemblies
  isExternal: false
  name: AssemblyHashAlgorithm
  nameWithType: AssemblyHashAlgorithm
  fullName: System.Configuration.Assemblies.AssemblyHashAlgorithm
- uid: System.AppDomain.CreateDomain(System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String)
  nameWithType: AppDomain.CreateDomain(String)
  fullName: System.AppDomain.CreateDomain(String)
- uid: System.AppDomain
  parent: System
  isExternal: false
  name: AppDomain
  nameWithType: AppDomain
  fullName: System.AppDomain
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence)
  nameWithType: AppDomain.CreateDomain(String,Evidence)
  fullName: System.AppDomain.CreateDomain(String,Evidence)
- uid: System.Security.Policy.Evidence
  parent: System.Security.Policy
  isExternal: false
  name: Evidence
  nameWithType: Evidence
  fullName: System.Security.Policy.Evidence
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,AppDomainSetup)
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
- uid: System.AppDomainSetup
  parent: System
  isExternal: false
  name: AppDomainSetup
  nameWithType: AppDomainSetup
  fullName: System.AppDomainSetup
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
- uid: System.Security.PermissionSet
  parent: System.Security
  isExternal: false
  name: PermissionSet
  nameWithType: PermissionSet
  fullName: System.Security.PermissionSet
- uid: System.Security.Policy.StrongName[]
  parent: System.Security.Policy
  isExternal: false
  name: StrongName
  nameWithType: StrongName
  fullName: System.Security.Policy.StrongName[]
  spec.csharp:
  - uid: System.Security.Policy.StrongName
    name: StrongName
    nameWithType: StrongName
    fullName: StrongName[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,String,String,Boolean)
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
- uid: System.AppDomainInitializer
  parent: System
  isExternal: false
  name: AppDomainInitializer
  nameWithType: AppDomainInitializer
  fullName: System.AppDomainInitializer
- uid: System.String[]
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.CreateInstance(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String)
  nameWithType: AppDomain.CreateInstance(String,String)
  fullName: System.AppDomain.CreateInstance(String,String)
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Object[])
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.Reflection.BindingFlags
  parent: System.Reflection
  isExternal: false
  name: BindingFlags
  nameWithType: BindingFlags
  fullName: System.Reflection.BindingFlags
- uid: System.Reflection.Binder
  parent: System.Reflection
  isExternal: false
  name: Binder
  nameWithType: Binder
  fullName: System.Reflection.Binder
- uid: System.Globalization.CultureInfo
  parent: System.Globalization
  isExternal: true
  name: CultureInfo
  nameWithType: CultureInfo
  fullName: System.Globalization.CultureInfo
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String)
  nameWithType: AppDomain.CreateInstanceFrom(String,String)
  fullName: System.AppDomain.CreateInstanceFrom(String,String)
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Object[])
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String)
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CurrentDomain
  parent: System.AppDomain
  isExternal: false
  name: CurrentDomain
  nameWithType: AppDomain.CurrentDomain
  fullName: System.AppDomain.CurrentDomain
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
- uid: System.Reflection.Emit.AssemblyBuilder
  parent: System.Reflection.Emit
  isExternal: true
  name: AssemblyBuilder
  nameWithType: AssemblyBuilder
  fullName: System.Reflection.Emit.AssemblyBuilder
- uid: System.Reflection.AssemblyName
  parent: System.Reflection
  isExternal: true
  name: AssemblyName
  nameWithType: AssemblyName
  fullName: System.Reflection.AssemblyName
- uid: System.Reflection.Emit.AssemblyBuilderAccess
  parent: System.Reflection.Emit
  isExternal: true
  name: AssemblyBuilderAccess
  nameWithType: AssemblyBuilderAccess
  fullName: System.Reflection.Emit.AssemblyBuilderAccess
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
- uid: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<CustomAttributeBuilder>
  nameWithType: IEnumerable<CustomAttributeBuilder>
  fullName: System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.Reflection.Emit.CustomAttributeBuilder>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Reflection.Emit.CustomAttributeBuilder
    name: CustomAttributeBuilder
    nameWithType: CustomAttributeBuilder
    fullName: CustomAttributeBuilder
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
- uid: System.Security.SecurityContextSource
  parent: System.Security
  isExternal: false
  name: SecurityContextSource
  nameWithType: SecurityContextSource
  fullName: System.Security.SecurityContextSource
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
- uid: System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)
  parent: System.AppDomain
  isExternal: false
  name: DoCallBack(CrossAppDomainDelegate)
  nameWithType: AppDomain.DoCallBack(CrossAppDomainDelegate)
  fullName: System.AppDomain.DoCallBack(CrossAppDomainDelegate)
- uid: System.CrossAppDomainDelegate
  parent: System
  isExternal: false
  name: CrossAppDomainDelegate
  nameWithType: CrossAppDomainDelegate
  fullName: System.CrossAppDomainDelegate
- uid: System.AppDomain.DomainManager
  parent: System.AppDomain
  isExternal: false
  name: DomainManager
  nameWithType: AppDomain.DomainManager
  fullName: System.AppDomain.DomainManager
- uid: System.AppDomainManager
  parent: System
  isExternal: false
  name: AppDomainManager
  nameWithType: AppDomainManager
  fullName: System.AppDomainManager
- uid: System.AppDomain.DomainUnload
  parent: System.AppDomain
  isExternal: false
  name: DomainUnload
  nameWithType: AppDomain.DomainUnload
  fullName: System.AppDomain.DomainUnload
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.AppDomain.DynamicDirectory
  parent: System.AppDomain
  isExternal: false
  name: DynamicDirectory
  nameWithType: AppDomain.DynamicDirectory
  fullName: System.AppDomain.DynamicDirectory
- uid: System.AppDomain.Evidence
  parent: System.AppDomain
  isExternal: false
  name: Evidence
  nameWithType: AppDomain.Evidence
  fullName: System.AppDomain.Evidence
- uid: System.AppDomain.ExecuteAssembly(System.String)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String)
  nameWithType: AppDomain.ExecuteAssembly(String)
  fullName: System.AppDomain.ExecuteAssembly(String)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,Evidence)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence)
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,String[])
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[])
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
- uid: System.AppDomain.ExecuteAssemblyByName(System.String)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String)
  nameWithType: AppDomain.ExecuteAssemblyByName(String)
  fullName: System.AppDomain.ExecuteAssemblyByName(String)
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(AssemblyName,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String,Evidence)
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence)
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence)
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,String[])
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
- uid: System.AppDomain.FirstChanceException
  parent: System.AppDomain
  isExternal: false
  name: FirstChanceException
  nameWithType: AppDomain.FirstChanceException
  fullName: System.AppDomain.FirstChanceException
- uid: System.EventHandler{System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<FirstChanceExceptionEventArgs>
  nameWithType: EventHandler<FirstChanceExceptionEventArgs>
  fullName: System.EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs
    name: FirstChanceExceptionEventArgs
    nameWithType: FirstChanceExceptionEventArgs
    fullName: FirstChanceExceptionEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.AppDomain.FriendlyName
  parent: System.AppDomain
  isExternal: false
  name: FriendlyName
  nameWithType: AppDomain.FriendlyName
  fullName: System.AppDomain.FriendlyName
- uid: System.AppDomain.GetAssemblies
  parent: System.AppDomain
  isExternal: false
  name: GetAssemblies()
  nameWithType: AppDomain.GetAssemblies()
  fullName: System.AppDomain.GetAssemblies()
- uid: System.Reflection.Assembly[]
  parent: System.Reflection
  isExternal: true
  name: Assembly
  nameWithType: Assembly
  fullName: System.Reflection.Assembly[]
  spec.csharp:
  - uid: System.Reflection.Assembly
    name: Assembly
    nameWithType: Assembly
    fullName: Assembly[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.GetCurrentThreadId
  parent: System.AppDomain
  isExternal: false
  name: GetCurrentThreadId()
  nameWithType: AppDomain.GetCurrentThreadId()
  fullName: System.AppDomain.GetCurrentThreadId()
- uid: System.AppDomain.GetData(System.String)
  parent: System.AppDomain
  isExternal: false
  name: GetData(String)
  nameWithType: AppDomain.GetData(String)
  fullName: System.AppDomain.GetData(String)
- uid: System.AppDomain.GetType
  parent: System.AppDomain
  isExternal: false
  name: GetType()
  nameWithType: AppDomain.GetType()
  fullName: System.AppDomain.GetType()
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.AppDomain.Id
  parent: System.AppDomain
  isExternal: false
  name: Id
  nameWithType: AppDomain.Id
  fullName: System.AppDomain.Id
- uid: System.AppDomain.InitializeLifetimeService
  parent: System.AppDomain
  isExternal: false
  name: InitializeLifetimeService()
  nameWithType: AppDomain.InitializeLifetimeService()
  fullName: System.AppDomain.InitializeLifetimeService()
- uid: System.AppDomain.IsCompatibilitySwitchSet(System.String)
  parent: System.AppDomain
  isExternal: false
  name: IsCompatibilitySwitchSet(String)
  nameWithType: AppDomain.IsCompatibilitySwitchSet(String)
  fullName: System.AppDomain.IsCompatibilitySwitchSet(String)
- uid: System.Nullable{System.Boolean}
  parent: System
  isExternal: true
  name: Nullable<Boolean>
  nameWithType: Nullable<Boolean>
  fullName: System.Nullable<System.Boolean>
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    nameWithType: Nullable
    fullName: Nullable<System.Boolean>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Boolean
    name: Boolean
    nameWithType: Boolean
    fullName: Boolean
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.AppDomain.IsDefaultAppDomain
  parent: System.AppDomain
  isExternal: false
  name: IsDefaultAppDomain()
  nameWithType: AppDomain.IsDefaultAppDomain()
  fullName: System.AppDomain.IsDefaultAppDomain()
- uid: System.AppDomain.IsFinalizingForUnload
  parent: System.AppDomain
  isExternal: false
  name: IsFinalizingForUnload()
  nameWithType: AppDomain.IsFinalizingForUnload()
  fullName: System.AppDomain.IsFinalizingForUnload()
- uid: System.AppDomain.IsFullyTrusted
  parent: System.AppDomain
  isExternal: false
  name: IsFullyTrusted
  nameWithType: AppDomain.IsFullyTrusted
  fullName: System.AppDomain.IsFullyTrusted
- uid: System.AppDomain.IsHomogenous
  parent: System.AppDomain
  isExternal: false
  name: IsHomogenous
  nameWithType: AppDomain.IsHomogenous
  fullName: System.AppDomain.IsHomogenous
- uid: System.AppDomain.Load(System.Byte[])
  parent: System.AppDomain
  isExternal: false
  name: Load(Byte[])
  nameWithType: AppDomain.Load(Byte[])
  fullName: System.AppDomain.Load(Byte[])
- uid: System.Reflection.Assembly
  parent: System.Reflection
  isExternal: true
  name: Assembly
  nameWithType: Assembly
  fullName: System.Reflection.Assembly
- uid: System.AppDomain.Load(System.Reflection.AssemblyName)
  parent: System.AppDomain
  isExternal: false
  name: Load(AssemblyName)
  nameWithType: AppDomain.Load(AssemblyName)
  fullName: System.AppDomain.Load(AssemblyName)
- uid: System.AppDomain.Load(System.String)
  parent: System.AppDomain
  isExternal: false
  name: Load(String)
  nameWithType: AppDomain.Load(String)
  fullName: System.AppDomain.Load(String)
- uid: System.AppDomain.Load(System.Byte[],System.Byte[])
  parent: System.AppDomain
  isExternal: false
  name: Load(Byte[],Byte[])
  nameWithType: AppDomain.Load(Byte[],Byte[])
  fullName: System.AppDomain.Load(Byte[],Byte[])
- uid: System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: Load(AssemblyName,Evidence)
  nameWithType: AppDomain.Load(AssemblyName,Evidence)
  fullName: System.AppDomain.Load(AssemblyName,Evidence)
- uid: System.AppDomain.Load(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: Load(String,Evidence)
  nameWithType: AppDomain.Load(String,Evidence)
  fullName: System.AppDomain.Load(String,Evidence)
- uid: System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: Load(Byte[],Byte[],Evidence)
  nameWithType: AppDomain.Load(Byte[],Byte[],Evidence)
  fullName: System.AppDomain.Load(Byte[],Byte[],Evidence)
- uid: System.AppDomain.MonitoringIsEnabled
  parent: System.AppDomain
  isExternal: false
  name: MonitoringIsEnabled
  nameWithType: AppDomain.MonitoringIsEnabled
  fullName: System.AppDomain.MonitoringIsEnabled
- uid: System.AppDomain.MonitoringSurvivedMemorySize
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedMemorySize
  nameWithType: AppDomain.MonitoringSurvivedMemorySize
  fullName: System.AppDomain.MonitoringSurvivedMemorySize
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.AppDomain.MonitoringSurvivedProcessMemorySize
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedProcessMemorySize
  nameWithType: AppDomain.MonitoringSurvivedProcessMemorySize
  fullName: System.AppDomain.MonitoringSurvivedProcessMemorySize
- uid: System.AppDomain.MonitoringTotalAllocatedMemorySize
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalAllocatedMemorySize
  nameWithType: AppDomain.MonitoringTotalAllocatedMemorySize
  fullName: System.AppDomain.MonitoringTotalAllocatedMemorySize
- uid: System.AppDomain.MonitoringTotalProcessorTime
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalProcessorTime
  nameWithType: AppDomain.MonitoringTotalProcessorTime
  fullName: System.AppDomain.MonitoringTotalProcessorTime
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.AppDomain.PermissionSet
  parent: System.AppDomain
  isExternal: false
  name: PermissionSet
  nameWithType: AppDomain.PermissionSet
  fullName: System.AppDomain.PermissionSet
- uid: System.AppDomain.ProcessExit
  parent: System.AppDomain
  isExternal: false
  name: ProcessExit
  nameWithType: AppDomain.ProcessExit
  fullName: System.AppDomain.ProcessExit
- uid: System.AppDomain.ReflectionOnlyAssemblyResolve
  parent: System.AppDomain
  isExternal: false
  name: ReflectionOnlyAssemblyResolve
  nameWithType: AppDomain.ReflectionOnlyAssemblyResolve
  fullName: System.AppDomain.ReflectionOnlyAssemblyResolve
- uid: System.AppDomain.ReflectionOnlyGetAssemblies
  parent: System.AppDomain
  isExternal: false
  name: ReflectionOnlyGetAssemblies()
  nameWithType: AppDomain.ReflectionOnlyGetAssemblies()
  fullName: System.AppDomain.ReflectionOnlyGetAssemblies()
- uid: System.AppDomain.RelativeSearchPath
  parent: System.AppDomain
  isExternal: false
  name: RelativeSearchPath
  nameWithType: AppDomain.RelativeSearchPath
  fullName: System.AppDomain.RelativeSearchPath
- uid: System.AppDomain.ResourceResolve
  parent: System.AppDomain
  isExternal: false
  name: ResourceResolve
  nameWithType: AppDomain.ResourceResolve
  fullName: System.AppDomain.ResourceResolve
- uid: System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  parent: System.AppDomain
  isExternal: false
  name: SetAppDomainPolicy(PolicyLevel)
  nameWithType: AppDomain.SetAppDomainPolicy(PolicyLevel)
  fullName: System.AppDomain.SetAppDomainPolicy(PolicyLevel)
- uid: System.Security.Policy.PolicyLevel
  parent: System.Security.Policy
  isExternal: false
  name: PolicyLevel
  nameWithType: PolicyLevel
  fullName: System.Security.Policy.PolicyLevel
- uid: System.AppDomain.SetCachePath(System.String)
  parent: System.AppDomain
  isExternal: false
  name: SetCachePath(String)
  nameWithType: AppDomain.SetCachePath(String)
  fullName: System.AppDomain.SetCachePath(String)
- uid: System.AppDomain.SetData(System.String,System.Object)
  parent: System.AppDomain
  isExternal: false
  name: SetData(String,Object)
  nameWithType: AppDomain.SetData(String,Object)
  fullName: System.AppDomain.SetData(String,Object)
- uid: System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)
  parent: System.AppDomain
  isExternal: false
  name: SetData(String,Object,IPermission)
  nameWithType: AppDomain.SetData(String,Object,IPermission)
  fullName: System.AppDomain.SetData(String,Object,IPermission)
- uid: System.Security.IPermission
  parent: System.Security
  isExternal: false
  name: IPermission
  nameWithType: IPermission
  fullName: System.Security.IPermission
- uid: System.AppDomain.SetDynamicBase(System.String)
  parent: System.AppDomain
  isExternal: false
  name: SetDynamicBase(String)
  nameWithType: AppDomain.SetDynamicBase(String)
  fullName: System.AppDomain.SetDynamicBase(String)
- uid: System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  parent: System.AppDomain
  isExternal: false
  name: SetPrincipalPolicy(PrincipalPolicy)
  nameWithType: AppDomain.SetPrincipalPolicy(PrincipalPolicy)
  fullName: System.AppDomain.SetPrincipalPolicy(PrincipalPolicy)
- uid: System.Security.Principal.PrincipalPolicy
  parent: System.Security.Principal
  isExternal: false
  name: PrincipalPolicy
  nameWithType: PrincipalPolicy
  fullName: System.Security.Principal.PrincipalPolicy
- uid: System.AppDomain.SetShadowCopyFiles
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyFiles()
  nameWithType: AppDomain.SetShadowCopyFiles()
  fullName: System.AppDomain.SetShadowCopyFiles()
- uid: System.AppDomain.SetShadowCopyPath(System.String)
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyPath(String)
  nameWithType: AppDomain.SetShadowCopyPath(String)
  fullName: System.AppDomain.SetShadowCopyPath(String)
- uid: System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)
  parent: System.AppDomain
  isExternal: false
  name: SetThreadPrincipal(IPrincipal)
  nameWithType: AppDomain.SetThreadPrincipal(IPrincipal)
  fullName: System.AppDomain.SetThreadPrincipal(IPrincipal)
- uid: System.Security.Principal.IPrincipal
  parent: System.Security.Principal
  isExternal: true
  name: IPrincipal
  nameWithType: IPrincipal
  fullName: System.Security.Principal.IPrincipal
- uid: System.AppDomain.SetupInformation
  parent: System.AppDomain
  isExternal: false
  name: SetupInformation
  nameWithType: AppDomain.SetupInformation
  fullName: System.AppDomain.SetupInformation
- uid: System.AppDomain.ShadowCopyFiles
  parent: System.AppDomain
  isExternal: false
  name: ShadowCopyFiles
  nameWithType: AppDomain.ShadowCopyFiles
  fullName: System.AppDomain.ShadowCopyFiles
- uid: System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
- uid: System.Guid
  parent: System
  isExternal: true
  name: Guid
  nameWithType: Guid
  fullName: System.Guid
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.UInt32
  parent: System
  isExternal: true
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
- uid: System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfoCount(UInt32)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
- uid: System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: System.AppDomain.ToString
  parent: System.AppDomain
  isExternal: false
  name: ToString()
  nameWithType: AppDomain.ToString()
  fullName: System.AppDomain.ToString()
- uid: System.AppDomain.TypeResolve
  parent: System.AppDomain
  isExternal: false
  name: TypeResolve
  nameWithType: AppDomain.TypeResolve
  fullName: System.AppDomain.TypeResolve
- uid: System.AppDomain.UnhandledException
  parent: System.AppDomain
  isExternal: false
  name: UnhandledException
  nameWithType: AppDomain.UnhandledException
  fullName: System.AppDomain.UnhandledException
- uid: System.UnhandledExceptionEventHandler
  parent: System
  isExternal: false
  name: UnhandledExceptionEventHandler
  nameWithType: UnhandledExceptionEventHandler
  fullName: System.UnhandledExceptionEventHandler
- uid: System.AppDomain.Unload(System.AppDomain)
  parent: System.AppDomain
  isExternal: false
  name: Unload(AppDomain)
  nameWithType: AppDomain.Unload(AppDomain)
  fullName: System.AppDomain.Unload(AppDomain)
- uid: System.AppDomain.ActivationContext*
  parent: System.AppDomain
  isExternal: false
  name: ActivationContext
  nameWithType: AppDomain.ActivationContext
- uid: System.AppDomain.AppendPrivatePath*
  parent: System.AppDomain
  isExternal: false
  name: AppendPrivatePath
  nameWithType: AppDomain.AppendPrivatePath
- uid: System.AppDomain.ApplicationIdentity*
  parent: System.AppDomain
  isExternal: false
  name: ApplicationIdentity
  nameWithType: AppDomain.ApplicationIdentity
- uid: System.AppDomain.ApplicationTrust*
  parent: System.AppDomain
  isExternal: false
  name: ApplicationTrust
  nameWithType: AppDomain.ApplicationTrust
- uid: System.AppDomain.ApplyPolicy*
  parent: System.AppDomain
  isExternal: false
  name: ApplyPolicy
  nameWithType: AppDomain.ApplyPolicy
- uid: System.AppDomain.BaseDirectory*
  parent: System.AppDomain
  isExternal: false
  name: BaseDirectory
  nameWithType: AppDomain.BaseDirectory
- uid: System.AppDomain.ClearPrivatePath*
  parent: System.AppDomain
  isExternal: false
  name: ClearPrivatePath
  nameWithType: AppDomain.ClearPrivatePath
- uid: System.AppDomain.ClearShadowCopyPath*
  parent: System.AppDomain
  isExternal: false
  name: ClearShadowCopyPath
  nameWithType: AppDomain.ClearShadowCopyPath
- uid: System.AppDomain.CreateComInstanceFrom*
  parent: System.AppDomain
  isExternal: false
  name: CreateComInstanceFrom
  nameWithType: AppDomain.CreateComInstanceFrom
- uid: System.AppDomain.CreateDomain*
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain
  nameWithType: AppDomain.CreateDomain
- uid: System.AppDomain.CreateInstance*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance
  nameWithType: AppDomain.CreateInstance
- uid: System.AppDomain.CreateInstanceAndUnwrap*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap
  nameWithType: AppDomain.CreateInstanceAndUnwrap
- uid: System.AppDomain.CreateInstanceFrom*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom
  nameWithType: AppDomain.CreateInstanceFrom
- uid: System.AppDomain.CreateInstanceFromAndUnwrap*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap
- uid: System.AppDomain.CurrentDomain*
  parent: System.AppDomain
  isExternal: false
  name: CurrentDomain
  nameWithType: AppDomain.CurrentDomain
- uid: System.AppDomain.DefineDynamicAssembly*
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly
  nameWithType: AppDomain.DefineDynamicAssembly
- uid: System.AppDomain.DoCallBack*
  parent: System.AppDomain
  isExternal: false
  name: DoCallBack
  nameWithType: AppDomain.DoCallBack
- uid: System.AppDomain.DomainManager*
  parent: System.AppDomain
  isExternal: false
  name: DomainManager
  nameWithType: AppDomain.DomainManager
- uid: System.AppDomain.DynamicDirectory*
  parent: System.AppDomain
  isExternal: false
  name: DynamicDirectory
  nameWithType: AppDomain.DynamicDirectory
- uid: System.AppDomain.Evidence*
  parent: System.AppDomain
  isExternal: false
  name: Evidence
  nameWithType: AppDomain.Evidence
- uid: System.AppDomain.ExecuteAssembly*
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly
  nameWithType: AppDomain.ExecuteAssembly
- uid: System.AppDomain.ExecuteAssemblyByName*
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName
  nameWithType: AppDomain.ExecuteAssemblyByName
- uid: System.AppDomain.FriendlyName*
  parent: System.AppDomain
  isExternal: false
  name: FriendlyName
  nameWithType: AppDomain.FriendlyName
- uid: System.AppDomain.GetAssemblies*
  parent: System.AppDomain
  isExternal: false
  name: GetAssemblies
  nameWithType: AppDomain.GetAssemblies
- uid: System.AppDomain.GetCurrentThreadId*
  parent: System.AppDomain
  isExternal: false
  name: GetCurrentThreadId
  nameWithType: AppDomain.GetCurrentThreadId
- uid: System.AppDomain.GetData*
  parent: System.AppDomain
  isExternal: false
  name: GetData
  nameWithType: AppDomain.GetData
- uid: System.AppDomain.GetType*
  parent: System.AppDomain
  isExternal: false
  name: GetType
  nameWithType: AppDomain.GetType
- uid: System.AppDomain.Id*
  parent: System.AppDomain
  isExternal: false
  name: Id
  nameWithType: AppDomain.Id
- uid: System.AppDomain.InitializeLifetimeService*
  parent: System.AppDomain
  isExternal: false
  name: InitializeLifetimeService
  nameWithType: AppDomain.InitializeLifetimeService
- uid: System.AppDomain.IsCompatibilitySwitchSet*
  parent: System.AppDomain
  isExternal: false
  name: IsCompatibilitySwitchSet
  nameWithType: AppDomain.IsCompatibilitySwitchSet
- uid: System.AppDomain.IsDefaultAppDomain*
  parent: System.AppDomain
  isExternal: false
  name: IsDefaultAppDomain
  nameWithType: AppDomain.IsDefaultAppDomain
- uid: System.AppDomain.IsFinalizingForUnload*
  parent: System.AppDomain
  isExternal: false
  name: IsFinalizingForUnload
  nameWithType: AppDomain.IsFinalizingForUnload
- uid: System.AppDomain.IsFullyTrusted*
  parent: System.AppDomain
  isExternal: false
  name: IsFullyTrusted
  nameWithType: AppDomain.IsFullyTrusted
- uid: System.AppDomain.IsHomogenous*
  parent: System.AppDomain
  isExternal: false
  name: IsHomogenous
  nameWithType: AppDomain.IsHomogenous
- uid: System.AppDomain.Load*
  parent: System.AppDomain
  isExternal: false
  name: Load
  nameWithType: AppDomain.Load
- uid: System.AppDomain.MonitoringIsEnabled*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringIsEnabled
  nameWithType: AppDomain.MonitoringIsEnabled
- uid: System.AppDomain.MonitoringSurvivedMemorySize*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedMemorySize
  nameWithType: AppDomain.MonitoringSurvivedMemorySize
- uid: System.AppDomain.MonitoringSurvivedProcessMemorySize*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedProcessMemorySize
  nameWithType: AppDomain.MonitoringSurvivedProcessMemorySize
- uid: System.AppDomain.MonitoringTotalAllocatedMemorySize*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalAllocatedMemorySize
  nameWithType: AppDomain.MonitoringTotalAllocatedMemorySize
- uid: System.AppDomain.MonitoringTotalProcessorTime*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalProcessorTime
  nameWithType: AppDomain.MonitoringTotalProcessorTime
- uid: System.AppDomain.PermissionSet*
  parent: System.AppDomain
  isExternal: false
  name: PermissionSet
  nameWithType: AppDomain.PermissionSet
- uid: System.AppDomain.ReflectionOnlyGetAssemblies*
  parent: System.AppDomain
  isExternal: false
  name: ReflectionOnlyGetAssemblies
  nameWithType: AppDomain.ReflectionOnlyGetAssemblies
- uid: System.AppDomain.RelativeSearchPath*
  parent: System.AppDomain
  isExternal: false
  name: RelativeSearchPath
  nameWithType: AppDomain.RelativeSearchPath
- uid: System.AppDomain.SetAppDomainPolicy*
  parent: System.AppDomain
  isExternal: false
  name: SetAppDomainPolicy
  nameWithType: AppDomain.SetAppDomainPolicy
- uid: System.AppDomain.SetCachePath*
  parent: System.AppDomain
  isExternal: false
  name: SetCachePath
  nameWithType: AppDomain.SetCachePath
- uid: System.AppDomain.SetData*
  parent: System.AppDomain
  isExternal: false
  name: SetData
  nameWithType: AppDomain.SetData
- uid: System.AppDomain.SetDynamicBase*
  parent: System.AppDomain
  isExternal: false
  name: SetDynamicBase
  nameWithType: AppDomain.SetDynamicBase
- uid: System.AppDomain.SetPrincipalPolicy*
  parent: System.AppDomain
  isExternal: false
  name: SetPrincipalPolicy
  nameWithType: AppDomain.SetPrincipalPolicy
- uid: System.AppDomain.SetShadowCopyFiles*
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyFiles
  nameWithType: AppDomain.SetShadowCopyFiles
- uid: System.AppDomain.SetShadowCopyPath*
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyPath
  nameWithType: AppDomain.SetShadowCopyPath
- uid: System.AppDomain.SetThreadPrincipal*
  parent: System.AppDomain
  isExternal: false
  name: SetThreadPrincipal
  nameWithType: AppDomain.SetThreadPrincipal
- uid: System.AppDomain.SetupInformation*
  parent: System.AppDomain
  isExternal: false
  name: SetupInformation
  nameWithType: AppDomain.SetupInformation
- uid: System.AppDomain.ShadowCopyFiles*
  parent: System.AppDomain
  isExternal: false
  name: ShadowCopyFiles
  nameWithType: AppDomain.ShadowCopyFiles
- uid: System.AppDomain.System#_AppDomain#GetIDsOfNames*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetIDsOfNames
  nameWithType: AppDomain.System._AppDomain.GetIDsOfNames
- uid: System.AppDomain.System#_AppDomain#GetTypeInfo*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfo
  nameWithType: AppDomain.System._AppDomain.GetTypeInfo
- uid: System.AppDomain.System#_AppDomain#GetTypeInfoCount*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfoCount
  nameWithType: AppDomain.System._AppDomain.GetTypeInfoCount
- uid: System.AppDomain.System#_AppDomain#Invoke*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.Invoke
  nameWithType: AppDomain.System._AppDomain.Invoke
- uid: System.AppDomain.ToString*
  parent: System.AppDomain
  isExternal: false
  name: ToString
  nameWithType: AppDomain.ToString
- uid: System.AppDomain.Unload*
  parent: System.AppDomain
  isExternal: false
  name: Unload
  nameWithType: AppDomain.Unload
