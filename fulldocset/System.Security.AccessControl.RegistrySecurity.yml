### YamlMime:ManagedReference
items:
- uid: System.Security.AccessControl.RegistrySecurity
  id: RegistrySecurity
  children:
  - System.Security.AccessControl.RegistrySecurity.#ctor
  - System.Security.AccessControl.RegistrySecurity.AccessRightType
  - System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  - System.Security.AccessControl.RegistrySecurity.AccessRuleType
  - System.Security.AccessControl.RegistrySecurity.AddAccessRule(System.Security.AccessControl.RegistryAccessRule)
  - System.Security.AccessControl.RegistrySecurity.AddAuditRule(System.Security.AccessControl.RegistryAuditRule)
  - System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  - System.Security.AccessControl.RegistrySecurity.AuditRuleType
  - System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(System.Security.AccessControl.RegistryAccessRule)
  - System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(System.Security.AccessControl.RegistryAccessRule)
  - System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.RegistryAccessRule)
  - System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(System.Security.AccessControl.RegistryAuditRule)
  - System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(System.Security.AccessControl.RegistryAuditRule)
  - System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.RegistryAuditRule)
  - System.Security.AccessControl.RegistrySecurity.ResetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  - System.Security.AccessControl.RegistrySecurity.SetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  - System.Security.AccessControl.RegistrySecurity.SetAuditRule(System.Security.AccessControl.RegistryAuditRule)
  langs:
  - csharp
  name: RegistrySecurity
  nameWithType: RegistrySecurity
  fullName: System.Security.AccessControl.RegistrySecurity
  type: Class
  summary: "Representa a segurança de controlo de acesso do Windows para uma chave de registo. Esta classe não pode ser herdada."
  remarks: "Um objeto de RegistrySecurity especifica direitos de acesso para uma chave de registo e também especifica como são auditadas tentativas de acesso. Direitos de acesso à chave de registo são expressos em regras, com cada regra de acesso representado por um <xref:System.Security.AccessControl.RegistryAccessRule>objeto.</xref:System.Security.AccessControl.RegistryAccessRule> Cada regra de auditoria é representada por um <xref:System.Security.AccessControl.RegistryAuditRule>objeto.</xref:System.Security.AccessControl.RegistryAuditRule>       Isto reflete o sistema de segurança de Windows subjacente, no qual cada objeto com capacidade de segurança tem no máximo um controlo lista de acesso discricionário (DACL) que controla o acesso ao objeto segurado e no máximo um sistema acesso lista de controlo (SACL) que especifica as tentativas de acesso são auditadas. O DACL e SACL ordenadas apresenta uma lista de entradas de controlo de acesso (ACE) que especificam o acesso e auditoria para utilizadores e grupos. A <xref:System.Security.AccessControl.RegistryAccessRule>ou <xref:System.Security.AccessControl.RegistryAuditRule>objeto poderão representar mais de uma ACE.</xref:System.Security.AccessControl.RegistryAuditRule> </xref:System.Security.AccessControl.RegistryAccessRule>      > [!NOTE] > Só pode ser aplicada a segurança de controlo de acesso do Windows para as chaves de registo. Não é possível aplicar a pares chave/valor individual armazenados uma chave.       O RegistrySecurity <xref:System.Security.AccessControl.RegistryAccessRule>, e <xref:System.Security.AccessControl.RegistryAuditRule>classes ocultar os detalhes de implementação de ACLs e ACEs.</xref:System.Security.AccessControl.RegistryAuditRule> </xref:System.Security.AccessControl.RegistryAccessRule> Estas permitem-lhe ignorar os diferentes tipos ACE seventeen e a complexidade de manter corretamente herança e propagação de direitos de acesso. Estes objetos são também foi concebidos para impedir que os seguintes erros de controlo de acesso comuns:-criar um descritor de segurança com um DACL nulo. Uma referência nula para um DACL permite que qualquer utilizador adicionar regras de acesso a um objeto, potencialmente, criar um ataque denial-of-service. Um novo objeto de RegistrySecurity sempre começa com um DACL vazio, que nega todos os acessos para todos os utilizadores.      -Violar a ordenação de ACEs canónico. Se a lista de ACE o DACL não é mantida pela ordem canónica, os utilizadores podem inadvertidamente ser dado acesso ao objeto segurado. Por exemplo, direitos de acesso negado sempre têm de aparecer antes de direitos de acesso permitido. Objetos de RegistrySecurity mantêm internamente ordem correta.      -Manipulação de sinalizadores de descritor de segurança, devem ser sob o controlo do Gestor de recursos apenas.      -Criar inválidas combinações de ACE sinalizadores.      -Manipular ACEs herdados. Herança e propagação são processadas pelo Gestor de recursos em resposta a alterações efetuadas às regras de acesso e auditoria.      -Inserir ACEs sem significado ACLs.       As capacidades apenas não suportadas pelos objetos de segurança do .NET estão perigosos atividades que devem ser evitadas pela maioria dos programadores de aplicações, tais como o seguinte:-tarefas de baixo nível que normalmente são executadas pelo Gestor de recursos.      -Adicionar ou remover entradas de controlo de acesso de formas que não mantêm a ordenação canónico.       Para modificar a segurança de controlo de acesso do Windows para uma chave de registo, utilize o <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName>método para obter o objeto de RegistrySecurity.</xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> Modificar o objecto de segurança ao adicionar e remover regras e, em seguida, utilize o <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>método para reattach mesmo.</xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>      > [!IMPORTANT] > Alterações efetuadas a um objeto de RegistrySecurity não afetam os níveis de acesso da chave do registo até a chamar o <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>método para atribuir o objeto de segurança alterada para a chave de registo.</xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>       Para copiar a segurança de controlo de acesso da chave de registo de um para outro, utilize o <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName>método para obter um objeto de RegistrySecurity que representa as regras de acesso e auditoria para a primeira chave de registo e, em seguida, utilize o <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>método para atribuir essas regras para a segunda chave de registo.</xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName> </xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> Também pode atribuir as regras para uma segunda chave de registo com um <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A?displayProperty=fullName>ou <xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A?displayProperty=fullName>método que assume um parâmetro de objeto RegistrySecurity.</xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A?displayProperty=fullName> </xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A?displayProperty=fullName>       Os utilizadores com um investimento na linguagem de definição de descritor de segurança (SDDL) podem utilizar o <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A>método para definir regras de acesso para uma chave de registo e o <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A>método para obter uma cadeia que representa as regras de acesso no formato SDDL.</xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> </xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> Não é recomendado para um novo desenvolvimento."
  example:
  - "This section contains two code examples. The first example shows how compatible rules merge when added and removed, and the second shows how inheritance and propagation flags affect the addition and deletion of rules.  \n  \n Example 1  \n  \n The following code example shows how the <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> method removes rights from a compatible rule, and how the <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> method merges rights with compatible rules.  \n  \n The example creates a RegistrySecurity object and adds a rule that allows the current user <xref:System.Security.AccessControl.RegistryRights?displayProperty=fullName> rights. The example then creates a rule that grants the user <xref:System.Security.AccessControl.RegistryRights?displayProperty=fullName>, with the same inheritance and propagation rights as the first rule, and uses the <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> method to remove this new rule from the RegistrySecurity object. <xref:System.Security.AccessControl.RegistryRights> is a constituent of <xref:System.Security.AccessControl.RegistryRights>, so it is removed from the compatible rule. The rules in the RegistrySecurity object are displayed, showing the remaining constituents of <xref:System.Security.AccessControl.RegistryRights>.  \n  \n The example code then calls the <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> method to merge the <xref:System.Security.AccessControl.RegistryRights> right back into the rule in the RegistrySecurity object.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. The second example in this section attaches a security object, and so do the examples in <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> and <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/add/codesnippet/visualbasic/t-system.security.access_15_1.vb)]\n [!code-cs[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/add/codesnippet/csharp/t-system.security.access_15_1.cs)]  \n  \n Example 2  \n  \n The following code example demonstrates access rules with inheritance and propagation. The example creates a RegistrySecurity object, then creates and adds two rules that have the <xref:System.Security.AccessControl.InheritanceFlags> flag. The first rule has no propagation flags, while the second has <xref:System.Security.AccessControl.PropagationFlags> and <xref:System.Security.AccessControl.PropagationFlags>.  \n  \n The program displays the rules in the RegistrySecurity object, and then uses the RegistrySecurity object to create a subkey. The program creates a child subkey and a grandchild subkey, then displays the security for each subkey. Finally, the program deletes the test keys.  \n  \n [!code-vb[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/add/codesnippet/visualbasic/t-system.security.access_15_2.vb)]\n [!code-cs[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/add/codesnippet/csharp/t-system.security.access_15_2.cs)]"
  syntax:
    content: 'public sealed class RegistrySecurity : System.Security.AccessControl.NativeObjectSecurity'
  inheritance:
  - System.Object
  - System.Security.AccessControl.ObjectSecurity
  - System.Security.AccessControl.CommonObjectSecurity
  - System.Security.AccessControl.NativeObjectSecurity
  implements: []
  inheritedMembers:
  - System.Security.AccessControl.CommonObjectSecurity.AddAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.AddAuditRule(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.GetAccessRules(System.Boolean,System.Boolean,System.Type)
  - System.Security.AccessControl.CommonObjectSecurity.GetAuditRules(System.Boolean,System.Boolean,System.Type)
  - System.Security.AccessControl.CommonObjectSecurity.ModifyAccess(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AccessRule,System.Boolean@)
  - System.Security.AccessControl.CommonObjectSecurity.ModifyAudit(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AuditRule,System.Boolean@)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAccessRuleAll(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAuditRule(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAuditRuleAll(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.ResetAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.SetAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.SetAuditRule(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.Runtime.InteropServices.SafeHandle,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.Runtime.InteropServices.SafeHandle,System.Security.AccessControl.AccessControlSections,System.Object)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.String,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.String,System.Security.AccessControl.AccessControlSections,System.Object)
  - System.Security.AccessControl.ObjectSecurity.AccessRulesModified
  - System.Security.AccessControl.ObjectSecurity.AreAccessRulesCanonical
  - System.Security.AccessControl.ObjectSecurity.AreAccessRulesProtected
  - System.Security.AccessControl.ObjectSecurity.AreAuditRulesCanonical
  - System.Security.AccessControl.ObjectSecurity.AreAuditRulesProtected
  - System.Security.AccessControl.ObjectSecurity.AuditRulesModified
  - System.Security.AccessControl.ObjectSecurity.GetGroup(System.Type)
  - System.Security.AccessControl.ObjectSecurity.GetOwner(System.Type)
  - System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm
  - System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm(System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.GroupModified
  - System.Security.AccessControl.ObjectSecurity.IsContainer
  - System.Security.AccessControl.ObjectSecurity.IsDS
  - System.Security.AccessControl.ObjectSecurity.IsSddlConversionSupported
  - System.Security.AccessControl.ObjectSecurity.ModifyAccessRule(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AccessRule,System.Boolean@)
  - System.Security.AccessControl.ObjectSecurity.ModifyAuditRule(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AuditRule,System.Boolean@)
  - System.Security.AccessControl.ObjectSecurity.OwnerModified
  - System.Security.AccessControl.ObjectSecurity.Persist(System.Boolean,System.String,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.PurgeAccessRules(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.PurgeAuditRules(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.ReadLock
  - System.Security.AccessControl.ObjectSecurity.ReadUnlock
  - System.Security.AccessControl.ObjectSecurity.SetAccessRuleProtection(System.Boolean,System.Boolean)
  - System.Security.AccessControl.ObjectSecurity.SetAuditRuleProtection(System.Boolean,System.Boolean)
  - System.Security.AccessControl.ObjectSecurity.SetGroup(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.SetOwner(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm(System.Byte[])
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm(System.Byte[],System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm(System.String)
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm(System.String,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.WriteLock
  - System.Security.AccessControl.ObjectSecurity.WriteUnlock
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.#ctor
  id: '#ctor'
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RegistrySecurity()
  nameWithType: RegistrySecurity.RegistrySecurity()
  fullName: System.Security.AccessControl.RegistrySecurity.RegistrySecurity()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Security.AccessControl.RegistrySecurity&quot;> </xref> classe com valores predefinidos."
  remarks: "Um novo <xref:System.Security.AccessControl.RegistrySecurity>objeto sempre começa com uma lista vazia de acesso discricionário (DACL), que nega todos os acessos para todos os utilizadores.</xref:System.Security.AccessControl.RegistrySecurity>"
  syntax:
    content: public RegistrySecurity ();
    parameters: []
  overload: System.Security.AccessControl.RegistrySecurity.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AccessRightType
  id: AccessRightType
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AccessRightType
  nameWithType: RegistrySecurity.AccessRightType
  fullName: System.Security.AccessControl.RegistrySecurity.AccessRightType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Obtém o tipo de enumeração que o <xref href=&quot;System.Security.AccessControl.RegistrySecurity&quot;> </xref> utiliza para representar os direitos de acesso de classe."
  remarks: "Classes que derivam de <xref:System.Security.AccessControl.ObjectSecurity>substituição de classe a <xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A>propriedade e devolver o tipo que utilizam para representar os direitos de acesso.</xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> </xref:System.Security.AccessControl.ObjectSecurity> Quando trabalha com matrizes ou coleções que contenham vários tipos de objetos de segurança, utilize esta propriedade para determinar o tipo de enumeração correto a utilizar com cada objeto de segurança."
  syntax:
    content: public override Type AccessRightType { get; }
    return:
      type: System.Type
      description: "A <xref:System.Type>objeto que representa o <xref href=&quot;System.Security.AccessControl.RegistryRights&quot;> </xref> enumeração.</xref:System.Type>"
  overload: System.Security.AccessControl.RegistrySecurity.AccessRightType*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  id: AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  nameWithType: RegistrySecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  fullName: System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Cria uma nova regra de controlo de acesso para o utilizador especificado, com os direitos de acesso especificado, o controlo de acesso e sinalizadores."
  remarks: "O modo recomendado para criar regras de controlo de acesso está a utilizar os construtores da <xref:System.Security.AccessControl.RegistryAccessRule>classe.</xref:System.Security.AccessControl.RegistryAccessRule>      > [!NOTE] > Embora possa especificar o <xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName>sinalizador, não existe nenhum ponto no processo.</xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName> Para efeitos de controlo de acesso, os pares nome/valor numa subchave não são objetos separados. Os direitos de acesso para pares nome/valor são controlados pelos direitos da subchave. Além disso, uma vez que todas as subchaves são contentores (ou seja, podem conter outras subchaves), não são afetadas pelo <xref:System.Security.AccessControl.InheritanceFlags>sinalizador.</xref:System.Security.AccessControl.InheritanceFlags> Por fim, especificando o <xref:System.Security.AccessControl.InheritanceFlags>Sinalizador complicates perdas de tempo de manutenção de regras, porque este interfere com a combinação normal de regras compatíveis.</xref:System.Security.AccessControl.InheritanceFlags>"
  syntax:
    content: public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);
    parameters:
    - id: identityReference
      type: System.Security.Principal.IdentityReference
      description: "Um <xref href=&quot;System.Security.Principal.IdentityReference&quot;> </xref> que identifica o utilizador ou grupo a regra se aplica."
    - id: accessMask
      type: System.Int32
      description: "Uma combinação bit a bit de <xref href=&quot;System.Security.AccessControl.RegistryRights&quot;> </xref> valores especificar os direitos de acesso para permitir ou negar, converter para um número inteiro."
    - id: isInherited
      type: System.Boolean
      description: "Um valor booleano que especifica se a regra é herdada."
    - id: inheritanceFlags
      type: System.Security.AccessControl.InheritanceFlags
      description: "Uma combinação bit a bit de <xref href=&quot;System.Security.AccessControl.InheritanceFlags&quot;> </xref> valores que especificar como a regra é herdada pelos subchaves."
    - id: propagationFlags
      type: System.Security.AccessControl.PropagationFlags
      description: "Uma combinação bit a bit de <xref href=&quot;System.Security.AccessControl.PropagationFlags&quot;> </xref> valores que modificam a forma como a regra é herdada pelos subchaves. Sem significado se o valor de `inheritanceFlags` é <xref href=&quot;System.Security.AccessControl.InheritanceFlags&quot;> </xref>."
    - id: type
      type: System.Security.AccessControl.AccessControlType
      description: "Um do <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> valores especificar se os direitos são permitidos ou negados."
    return:
      type: System.Security.AccessControl.AccessRule
      description: "A <xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;> </xref> objeto que representa os direitos especificados para o utilizador especificado."
  overload: System.Security.AccessControl.RegistrySecurity.AccessRuleFactory*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>accessMask</code>, <code>inheritanceFlags</code>, <code>propagationFlags</code>, ou <code>type</code> Especifica um valor inválido."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>identityReference</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - ou - <code>accessMask</code> é zero."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>identityReference</code>é nenhum tipo <xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>, nem um tipo como <xref href=&quot;System.Security.Principal.NTAccount&quot;> </xref> que pode ser convertido no tipo <xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AccessRuleType
  id: AccessRuleType
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AccessRuleType
  nameWithType: RegistrySecurity.AccessRuleType
  fullName: System.Security.AccessControl.RegistrySecurity.AccessRuleType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Obtém o tipo que o <xref href=&quot;System.Security.AccessControl.RegistrySecurity&quot;> </xref> utiliza para representar as regras de acesso de classe."
  remarks: "Classes que derivam de <xref:System.Security.AccessControl.ObjectSecurity>substituição de classe a <xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A>propriedade e devolver o tipo que utilizam para representar as regras de acesso.</xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> </xref:System.Security.AccessControl.ObjectSecurity> Quando trabalha com matrizes ou coleções que contenham vários tipos de objetos de segurança, utilize esta propriedade para determinar o tipo de regra de acesso corretas para utilizar com cada objeto de segurança."
  syntax:
    content: public override Type AccessRuleType { get; }
    return:
      type: System.Type
      description: "A <xref:System.Type>objeto que representa o <xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;> </xref> classe</xref:System.Type>"
  overload: System.Security.AccessControl.RegistrySecurity.AccessRuleType*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AddAccessRule(System.Security.AccessControl.RegistryAccessRule)
  id: AddAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AddAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.AddAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.AddAccessRule(RegistryAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Procura um controlo de acesso correspondente com o qual a nova regra possam ser intercalada. Se não for encontrada nenhuma, adiciona a nova regra."
  remarks: "O método AddAccessRule procura regras com o mesmo utilizador ou grupo e o mesmo <xref:System.Security.AccessControl.AccessControlType>como `rule`.</xref:System.Security.AccessControl.AccessControlType> Se não for encontrada nenhuma, `rule` é adicionado. Se for encontrada uma regra correspondente, os direitos no `rule` são intercaladas com a regra existente.       Não não possível intercalar regras, se tiverem sinalizadores de herança diferentes. Por exemplo, se um utilizador tem permissão de acesso de leitura com nenhuma sinalizadores de herança e AddAccessRule é utilizada para adicionar uma regra dá ao utilizador acesso com herança para subchaves de escrita (<xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName>), não não possível intercalar duas regras.</xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName>       As regras diferentes com <xref:System.Security.AccessControl.AccessControlType>valores nunca são intercalados.</xref:System.Security.AccessControl.AccessControlType>       Regras express direitos da forma mais económica. Por exemplo, se um utilizador tiver <xref:System.Security.AccessControl.RegistryRights>, <xref:System.Security.AccessControl.RegistryRights>e <xref:System.Security.AccessControl.RegistryRights>direitos e adicionar uma regra que permite <xref:System.Security.AccessControl.RegistryRights>direitos, o utilizador tem todas as partes de constituintes <xref:System.Security.AccessControl.RegistryRights>direitos.</xref:System.Security.AccessControl.RegistryRights> </xref:System.Security.AccessControl.RegistryRights> </xref:System.Security.AccessControl.RegistryRights> </xref:System.Security.AccessControl.RegistryRights> </xref:System.Security.AccessControl.RegistryRights> Se a consulta os direitos de utilizador, verá uma regra que contém <xref:System.Security.AccessControl.RegistryRights>direitos.</xref:System.Security.AccessControl.RegistryRights> Da mesma forma, se remover <xref:System.Security.AccessControl.RegistryRights>direitos as outros constituents de <xref:System.Security.AccessControl.RegistryRights>voltará a ser direitos.</xref:System.Security.AccessControl.RegistryRights> </xref:System.Security.AccessControl.RegistryRights>"
  example:
  - "The following code example creates registry access rules and adds them to a <xref:System.Security.AccessControl.RegistrySecurity> object, showing how rules that allow and deny rights remain separate, while compatible rules of the same kind are merged.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. Examples that attach security objects can be found in <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> and <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>.  \n  \n A code example that demonstrates inheritance and propagation flags can be found in the <xref:System.Security.AccessControl.RegistryAccessRule> class.  \n  \n [!code-cs[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/add/codesnippet/csharp/0595520c-e456-4072-a959-_1.cs)]\n [!code-vb[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/add/codesnippet/visualbasic/0595520c-e456-4072-a959-_1.vb)]"
  syntax:
    content: public void AddAccessRule (System.Security.AccessControl.RegistryAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAccessRule
      description: "A regra de controlo de acesso para adicionar."
  overload: System.Security.AccessControl.RegistrySecurity.AddAccessRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AddAuditRule(System.Security.AccessControl.RegistryAuditRule)
  id: AddAuditRule(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AddAuditRule(RegistryAuditRule)
  nameWithType: RegistrySecurity.AddAuditRule(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.AddAuditRule(RegistryAuditRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Procura uma regra de auditoria com a qual a nova regra pode ser intercalada. Se não for encontrada nenhuma, adiciona a nova regra."
  remarks: "O método AddAuditRule procura regras com o mesmo utilizador ou grupo como `rule`. Se não for encontrada nenhuma, `rule` é adicionado. Se for encontrada uma regra correspondente, os sinalizadores no `rule` são intercaladas para a regra existente.       Não não possível intercalar regras, se tiverem sinalizadores de herança diferentes. Por exemplo, se são auditadas tentativas falhadas para escrever uma chave para um utilizador específico, com nenhuma sinalizadores de herança e AddAuditRule é utilizada para adicionar uma regra, especificar que falharam a tentar alterar as permissões são a serem auditados para o mesmo utilizador, mas com herança para subchaves (<xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName>), não não possível intercalar duas regras.</xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName>"
  syntax:
    content: public void AddAuditRule (System.Security.AccessControl.RegistryAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAuditRule
      description: "A regra de auditoria para adicionar. O utilizador especificado por esta regra determina a pesquisa."
  overload: System.Security.AccessControl.RegistrySecurity.AddAuditRule*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  id: AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  nameWithType: RegistrySecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  fullName: System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Cria uma nova regra de auditoria, especificando o utilizador que a regra se aplica, os direitos de acesso a auditoria, a herança e propagação da regra e o resultado que aciona a regra."
  remarks: "O modo recomendado para criar regras de auditoria é utilizar os construtores da <xref:System.Security.AccessControl.RegistryAuditRule>classe.</xref:System.Security.AccessControl.RegistryAuditRule>      > [!NOTE] > Embora possa especificar o <xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName>sinalizador, não existe nenhum ponto no processo.</xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName> Para efeitos de controlo de auditoria, de pares nome/valor numa subchave não são objetos separados. Os direitos de auditoria para pares nome/valor são controlados pelos direitos da subchave. Além disso, uma vez que todas as subchaves são contentores (ou seja, podem conter outras subchaves), não são afetadas pelo <xref:System.Security.AccessControl.InheritanceFlags>sinalizador.</xref:System.Security.AccessControl.InheritanceFlags> Por fim, especificando o <xref:System.Security.AccessControl.InheritanceFlags>Sinalizador complicates perdas de tempo de manutenção de regras, porque este interfere com a combinação normal de regras compatíveis.</xref:System.Security.AccessControl.InheritanceFlags>"
  syntax:
    content: public override System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);
    parameters:
    - id: identityReference
      type: System.Security.Principal.IdentityReference
      description: "Um <xref href=&quot;System.Security.Principal.IdentityReference&quot;> </xref> que identifica o utilizador ou grupo a regra se aplica."
    - id: accessMask
      type: System.Int32
      description: "Uma combinação bit a bit de <xref href=&quot;System.Security.AccessControl.RegistryRights&quot;> </xref> valores especificar os direitos de acesso a auditoria, converter para um número inteiro."
    - id: isInherited
      type: System.Boolean
      description: "Um valor booleano que especifica se a regra é herdada."
    - id: inheritanceFlags
      type: System.Security.AccessControl.InheritanceFlags
      description: "Uma combinação bit a bit de <xref href=&quot;System.Security.AccessControl.InheritanceFlags&quot;> </xref> valores que especificar como a regra é herdada pelos subchaves."
    - id: propagationFlags
      type: System.Security.AccessControl.PropagationFlags
      description: "Uma combinação bit a bit de <xref href=&quot;System.Security.AccessControl.PropagationFlags&quot;> </xref> valores que modificam a forma como a regra é herdada pelos subchaves. Sem significado se o valor de `inheritanceFlags` é <xref href=&quot;System.Security.AccessControl.InheritanceFlags&quot;> </xref>."
    - id: flags
      type: System.Security.AccessControl.AuditFlags
      description: "Uma combinação bit a bit de <xref href=&quot;System.Security.AccessControl.AuditFlags&quot;> </xref> valores especificar se a auditoria de acesso com êxito, falha de acesso ou ambos."
    return:
      type: System.Security.AccessControl.AuditRule
      description: "A <xref href=&quot;System.Security.AccessControl.RegistryAuditRule&quot;> </xref> objeto que representa a regra de auditoria especificado para o utilizador especificado, com os sinalizadores especificados. O tipo de retorno do método é a classe base, <xref href=&quot;System.Security.AccessControl.AuditRule&quot;> </xref>, mas o valor de retorno pode ser convertido em segurança para a classe derivada."
  overload: System.Security.AccessControl.RegistrySecurity.AuditRuleFactory*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>accessMask</code>, <code>inheritanceFlags</code>, <code>propagationFlags</code>, ou <code>flags</code> Especifica um valor inválido."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>identityReference</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - ou - <code>accessMask</code> é zero."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>identityReference</code>é nenhum tipo <xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>, nem um tipo como <xref href=&quot;System.Security.Principal.NTAccount&quot;> </xref> que pode ser convertido no tipo <xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AuditRuleType
  id: AuditRuleType
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AuditRuleType
  nameWithType: RegistrySecurity.AuditRuleType
  fullName: System.Security.AccessControl.RegistrySecurity.AuditRuleType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Obtém o tipo que o <xref href=&quot;System.Security.AccessControl.RegistrySecurity&quot;> </xref> utiliza para representar regras de auditoria de classe."
  remarks: "Classes que derivam de <xref:System.Security.AccessControl.ObjectSecurity>substituição de classe a <xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A>propriedade e devolver o tipo que utilizam para representar os direitos de auditoria.</xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> </xref:System.Security.AccessControl.ObjectSecurity> Quando trabalha com matrizes ou coleções que contenham vários tipos de objetos de segurança, utilize esta propriedade para determinar o tipo de regra de auditoria correta a utilizar com cada objeto de segurança."
  syntax:
    content: public override Type AuditRuleType { get; }
    return:
      type: System.Type
      description: "A <xref:System.Type>objeto que representa o <xref href=&quot;System.Security.AccessControl.RegistryAuditRule&quot;> </xref> classe</xref:System.Type>"
  overload: System.Security.AccessControl.RegistrySecurity.AuditRuleType*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(System.Security.AccessControl.RegistryAccessRule)
  id: RemoveAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RemoveAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.RemoveAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(RegistryAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Procura uma regra de controlo de acesso com o mesmo utilizador e <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> (permitir ou negar) como a regra de acesso especificado e com compatível herança e sinalizadores de propagação; se for encontrada essa uma regra, os direitos contidos na regra de acesso especificado são removidos do mesmo."
  remarks: "Atual <xref:System.Security.AccessControl.RegistrySecurity>é procurada uma regra que tem o mesmo utilizador e o mesmo <xref:System.Security.AccessControl.AccessControlType>valor como `rule`.</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.RegistrySecurity> Se nenhuma regra tal for encontrada, foi efetuada nenhuma ação e o método devolve `false`. Se forem encontradas regras de correspondência, os sinalizadores de herança e de compatibilidade são verificados para compatibilidade com os sinalizadores especificados na `rule`. Não se for encontrada nenhuma regra compatível, foi efetuada nenhuma ação e o método devolve `false`. Se for encontrada qualquer regra com sinalizadores compatíveis, os direitos especificados `rule` são removidas da regra compatível, e o método devolve `true`. Se `rule` especifica direitos não contidos na regra compatível, foi efetuada nenhuma ação no que respeita a esses direitos. Se todos os direitos são removidos da regra compatível, a regra completa é removida do atual <xref:System.Security.AccessControl.RegistrySecurity>objeto.</xref:System.Security.AccessControl.RegistrySecurity>"
  example:
  - "The following code example shows how the RemoveAccessRule method removes rights from a compatible rule, and how the <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> method merges rights with compatible rules.  \n  \n The example creates a <xref:System.Security.AccessControl.RegistrySecurity> object and adds a rule that allows the current user <xref:System.Security.AccessControl.RegistryRights?displayProperty=fullName> rights. The example then creates a rule that grants the user <xref:System.Security.AccessControl.RegistryRights?displayProperty=fullName>, with the same inheritance and propagation rights as the first rule, and uses the RemoveAccessRule method to remove this new rule from the <xref:System.Security.AccessControl.RegistrySecurity> object. <xref:System.Security.AccessControl.RegistryRights> is a constituent of <xref:System.Security.AccessControl.RegistryRights>, so it is removed from the compatible rule. The rules in the <xref:System.Security.AccessControl.RegistrySecurity> object are displayed, showing the remaining constituents of <xref:System.Security.AccessControl.RegistryRights>.  \n  \n The example code then calls the RemoveAccessRule method to merge the <xref:System.Security.AccessControl.RegistryRights> right back into the rule in the <xref:System.Security.AccessControl.RegistrySecurity> object.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. The second example in this section attaches a security object, and so do the examples in <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName><xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/add/codesnippet/visualbasic/797f5ef0-d4da-43dd-bbe9-_1.vb)]\n [!code-cs[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/add/codesnippet/csharp/797f5ef0-d4da-43dd-bbe9-_1.cs)]"
  syntax:
    content: public bool RemoveAccessRule (System.Security.AccessControl.RegistryAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAccessRule
      description: "A <xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;> </xref> Especifica que o utilizador e <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> para procurar e um conjunto de sinalizadores de herança e propagação de uma correspondência de regras, se encontrar, tem de ser compatível com. Especifica os direitos para remover a regra compatível, se encontrar."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se for encontrada uma regra compatível; caso contrário <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Security.AccessControl.RegistrySecurity.RemoveAccessRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(System.Security.AccessControl.RegistryAccessRule)
  id: RemoveAccessRuleAll(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RemoveAccessRuleAll(RegistryAccessRule)
  nameWithType: RegistrySecurity.RemoveAccessRuleAll(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(RegistryAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Regras de controlo com o mesmo utilizador de acesso de procura para todos os e <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> (permitir ou negar) especificado como regra e, se encontrar remove-los."
  remarks: "Atual <xref:System.Security.AccessControl.RegistrySecurity>serão pesquisadas as regras que têm o mesmo utilizador e o mesmo <xref:System.Security.AccessControl.AccessControlType>valor como `rule`.</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.RegistrySecurity> Quaisquer direitos, os sinalizadores de herança ou sinalizadores de propagação especificados pelo `rule` são ignoradas quando efetuar esta pesquisa. Se não for encontradas nenhuma regras de correspondência, não é necessária nenhuma ação.       Por exemplo, se um utilizador tiver várias regras que permitem que vários direitos com diferentes herança e sinalizadores de propagação, pode remover todos os essas regras criando um <xref:System.Security.AccessControl.RegistryAccessRule>objeto que especifica o utilizador e <xref:System.Security.AccessControl.AccessControlType?displayProperty=fullName>, com quaisquer direitos arbitrários e sinalizadores e transmitir que a regra para o método RemoveAccessRuleAll.</xref:System.Security.AccessControl.AccessControlType?displayProperty=fullName> </xref:System.Security.AccessControl.RegistryAccessRule>"
  example:
  - "The following code example shows that the RemoveAccessRuleAll method removes all rules that match user and <xref:System.Security.AccessControl.AccessControlType>, ignoring rights and flags.  \n  \n The example creates a <xref:System.Security.AccessControl.RegistrySecurity> object and adds rules that allow and deny various rights for the current user, with different inheritance and propagation flags. The example then creates a new rule that allows the current user to take ownership, and passes that rule to the RemoveAccessRuleAll method to remove the two rules that allow access.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. See the <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> method and the <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName> method.  \n  \n [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll#1](~/add/codesnippet/visualbasic/2ba6e9de-1f41-4d05-af76-_1.vb)]\n [!code-cs[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll#1](~/add/codesnippet/csharp/2ba6e9de-1f41-4d05-af76-_1.cs)]"
  syntax:
    content: public void RemoveAccessRuleAll (System.Security.AccessControl.RegistryAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAccessRule
      description: "A <xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;> </xref> Especifica que o utilizador e <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> para procurar. Quaisquer direitos, os sinalizadores de herança ou sinalizadores de propagação especificados por esta regra são ignorados."
  overload: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.RegistryAccessRule)
  id: RemoveAccessRuleSpecific(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RemoveAccessRuleSpecific(RegistryAccessRule)
  nameWithType: RegistrySecurity.RemoveAccessRuleSpecific(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(RegistryAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Procura de uma regra de controlo de acesso que corresponde exatamente a especificado regra e, se encontrar remove-lo."
  remarks: "A regra é removida apenas se corresponde exatamente `rule` em todos os detalhes, incluindo sinalizadores. Outras regras com o mesmo utilizador e <xref:System.Security.AccessControl.AccessControlType>não são afetadas.</xref:System.Security.AccessControl.AccessControlType>      > [!IMPORTANT] > Uma regra representa uma ou mais subjacente controlo entradas de acesso (ACE), e estas entradas são dividir ou combinadas, conforme necessário, ao modificar as regras de segurança de acesso para um utilizador. Assim, uma regra já não pode existir no formato específico tinha quando foi adicionado e, caso em que o método RemoveAccessRuleSpecific o não é possível removê-lo."
  example:
  - "The following code example shows that the RemoveAccessRuleSpecific method removes a rule only if it matches exactly.  \n  \n The example creates two rules that allow different rights. The rules have compatible inheritance and propagation flags, so when the second rule is added it merges with the first. The example calls the RemoveAccessRuleSpecific method, specifying the first rule, but because the rules are merged there is no rule that matches. The example then calls the <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> method to the remove the second rule from the merged rule, and finally calls the RemoveAccessRuleSpecific method to remove the first rule.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. See the <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> method and the <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName> method.  \n  \n [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific#1](~/add/codesnippet/visualbasic/9819c0cd-2b26-4472-a333-_1.vb)]\n [!code-cs[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific#1](~/add/codesnippet/csharp/9819c0cd-2b26-4472-a333-_1.cs)]"
  syntax:
    content: public void RemoveAccessRuleSpecific (System.Security.AccessControl.RegistryAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAccessRule
      description: "O <xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;> </xref> para remover."
  overload: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(System.Security.AccessControl.RegistryAuditRule)
  id: RemoveAuditRule(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RemoveAuditRule(RegistryAuditRule)
  nameWithType: RegistrySecurity.RemoveAuditRule(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(RegistryAuditRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Procura uma regra de controlo de auditoria com o mesmo utilizador a regra especificado e com compatível herança e sinalizadores de propagação; Se for encontrada uma regra compatível, os direitos contidos na regra especificada são removidos do mesmo."
  remarks: "Atual <xref:System.Security.AccessControl.RegistrySecurity>é procurada uma regra de auditoria que tem o mesmo utilizador `rule`.</xref:System.Security.AccessControl.RegistrySecurity> Se nenhuma regra tal for encontrada, foi efetuada nenhuma ação e o método devolve `false`. Se forem encontradas regras de correspondência, os sinalizadores de herança e de compatibilidade são verificados para compatibilidade com os sinalizadores especificados na `rule`. Não se for encontrada nenhuma regra compatível, foi efetuada nenhuma ação e o método devolve `false`. Se for encontrada qualquer regra com sinalizadores compatíveis, os direitos especificados `rule` são removidas da regra compatível, e o método devolve `true`. Se `rule` especifica direitos não contidos na regra compatível, foi efetuada nenhuma ação no que respeita a esses direitos. Se todos os direitos são removidos da regra compatível, a regra completa é removida do atual <xref:System.Security.AccessControl.RegistrySecurity>objeto.</xref:System.Security.AccessControl.RegistrySecurity>"
  syntax:
    content: public bool RemoveAuditRule (System.Security.AccessControl.RegistryAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAuditRule
      description: "A <xref href=&quot;System.Security.AccessControl.RegistryAuditRule&quot;> </xref> Especifica que o utilizador para procurar e um conjunto de sinalizadores de herança e propagação de que a regra uma correspondência, se encontrar, tem de ser compatível com. Especifica os direitos para remover a regra compatível, se encontrar."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se for encontrada uma regra compatível; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Security.AccessControl.RegistrySecurity.RemoveAuditRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(System.Security.AccessControl.RegistryAuditRule)
  id: RemoveAuditRuleAll(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RemoveAuditRuleAll(RegistryAuditRule)
  nameWithType: RegistrySecurity.RemoveAuditRuleAll(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(RegistryAuditRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Pesquisa para todas as regras com o mesmo utilizador a regra especificada de auditoria e, se encontrar, remove-os."
  remarks: "Atual <xref:System.Security.AccessControl.RegistrySecurity>serão pesquisadas as regras de auditoria que têm o mesmo utilizador `rule`.</xref:System.Security.AccessControl.RegistrySecurity> Quaisquer direitos, os sinalizadores de herança ou sinalizadores de propagação especificados pelo `rule` são ignoradas quando efetuar esta pesquisa. Se não for encontradas nenhuma regras de correspondência, não é necessária nenhuma ação."
  syntax:
    content: public void RemoveAuditRuleAll (System.Security.AccessControl.RegistryAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAuditRule
      description: "A <xref href=&quot;System.Security.AccessControl.RegistryAuditRule&quot;> </xref> Especifica que o utilizador para procurar. Quaisquer direitos, os sinalizadores de herança ou sinalizadores de propagação especificados por esta regra são ignorados."
  overload: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.RegistryAuditRule)
  id: RemoveAuditRuleSpecific(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RemoveAuditRuleSpecific(RegistryAuditRule)
  nameWithType: RegistrySecurity.RemoveAuditRuleSpecific(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(RegistryAuditRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Procura de uma regra de auditoria que corresponde exatamente ao especificado regra e, se encontrar remove-lo."
  remarks: "A regra é removida apenas se corresponde exatamente `rule` em todos os detalhes, incluindo sinalizadores. Não são afetadas outras regras de auditoria para o mesmo utilizador.      > [!IMPORTANT] > Uma regra representa uma ou mais subjacente controlo entradas de acesso (ACE), e estas entradas são dividir ou combinadas, conforme necessário, ao modificar as regras de segurança de auditoria para um utilizador. Assim, uma regra já não pode existir no formato específico tinha quando foi adicionado e, caso em que o método RemoveAuditRuleSpecific o não é possível removê-lo."
  syntax:
    content: public void RemoveAuditRuleSpecific (System.Security.AccessControl.RegistryAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAuditRule
      description: "O <xref href=&quot;System.Security.AccessControl.RegistryAuditRule&quot;> </xref> a serem removidos."
  overload: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.ResetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  id: ResetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: ResetAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.ResetAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.ResetAccessRule(RegistryAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Remove todas as regras de controlo de acesso com o mesmo utilizador regra especificada, independentemente da <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref>e, em seguida, adiciona a regra especificada."
  remarks: "Se existem quaisquer regras de acesso cujo utilizador corresponde à regra de especificado, `rule` é adicionado."
  example:
  - "The following code example shows how the ResetAccessRule method replaces all rules for the matching user with the rule specified for the match.  \n  \n The example creates a <xref:System.Security.AccessControl.RegistrySecurity> object and adds rules that allow and deny various rights for the current user, with different inheritance and propagation flags. The example then creates a new rule that allows the current user only to read the key, and uses the ResetAccessRule method to remove the all rules for the user and replace them with the new rule.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. See the <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> method and the <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName> method.  \n  \n [!code-cs[System.Security.AccessControl.RegistrySecurity.ResetAccessRule#1](~/add/codesnippet/csharp/80c97a6c-33e0-43c8-8894-_1.cs)]\n [!code-vb[System.Security.AccessControl.RegistrySecurity.ResetAccessRule#1](~/add/codesnippet/visualbasic/80c97a6c-33e0-43c8-8894-_1.vb)]"
  syntax:
    content: public void ResetAccessRule (System.Security.AccessControl.RegistryAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAccessRule
      description: "The <xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;></xref> to add. O utilizador especificado por esta regra determina as regras para remover antes de é adicionada esta regra."
  overload: System.Security.AccessControl.RegistrySecurity.ResetAccessRule*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.SetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  id: SetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: SetAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.SetAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.SetAccessRule(RegistryAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Remove todas as regras de controlo de acesso com o mesmo utilizador e <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> (permitir ou negar) como a regra especificada e, em seguida, adiciona a regra especificada."
  remarks: "Se a regra especificada tem <xref:System.Security.AccessControl.AccessControlType>, o efeito deste método é remover todas as <xref:System.Security.AccessControl.AccessControlType>regras para o utilizador especificado, substituindo-las com a regra especificada.</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.AccessControlType> Se a regra especificada tem <xref:System.Security.AccessControl.AccessControlType>, todos os <xref:System.Security.AccessControl.AccessControlType>regras para o utilizador especificado são substituídas com a regra especificada.</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.AccessControlType>       Se existem quaisquer regras cujo utilizador e <xref:System.Security.AccessControl.AccessControlType>corresponde à regra especificada, `rule` é adicionado.</xref:System.Security.AccessControl.AccessControlType>"
  example:
  - "The following code example shows that the SetAccessRule method removes all rules that match both the user and the <xref:System.Security.AccessControl.AccessControlType> of `rule`, ignoring rights and flags, and replaces them with `rule`.  \n  \n The example creates a <xref:System.Security.AccessControl.RegistrySecurity> object and adds rules that allow and deny various rights for the current user, with different inheritance and propagation flags. The example then creates a new rule that allows the current user only to read the key, and uses the SetAccessRule method to remove the two rules that allow access and to replace them with the new rule. The rule that denies access is not affected.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. See the <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> method and the <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName> method.  \n  \n [!code-vb[System.Security.AccessControl.RegistrySecurity.SetAccessRule#1](~/add/codesnippet/visualbasic/908f14bb-fbc5-4e71-ac82-_1.vb)]\n [!code-cs[System.Security.AccessControl.RegistrySecurity.SetAccessRule#1](~/add/codesnippet/csharp/908f14bb-fbc5-4e71-ac82-_1.cs)]"
  syntax:
    content: public void SetAccessRule (System.Security.AccessControl.RegistryAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAccessRule
      description: "The <xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;></xref> to add. O utilizador e <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> desta regra determinar as regras para remover antes de é adicionada esta regra."
  overload: System.Security.AccessControl.RegistrySecurity.SetAccessRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.SetAuditRule(System.Security.AccessControl.RegistryAuditRule)
  id: SetAuditRule(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: SetAuditRule(RegistryAuditRule)
  nameWithType: RegistrySecurity.SetAuditRule(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.SetAuditRule(RegistryAuditRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "Remove todas as regras com o mesmo utilizador regra especificada, de auditoria, independentemente do <xref href=&quot;System.Security.AccessControl.AuditFlags&quot;> </xref> valor e, em seguida, adiciona a regra especificada."
  remarks: "Se existem quaisquer regras de auditoria cujo utilizador corresponde à regra de especificado, `rule` é adicionado."
  syntax:
    content: public void SetAuditRule (System.Security.AccessControl.RegistryAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAuditRule
      description: "The <xref href=&quot;System.Security.AccessControl.RegistryAuditRule&quot;></xref> to add. O utilizador especificado por esta regra determina as regras para remover antes de é adicionada esta regra."
  overload: System.Security.AccessControl.RegistrySecurity.SetAuditRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
references:
- uid: System.Security.AccessControl.NativeObjectSecurity
  isExternal: false
  name: System.Security.AccessControl.NativeObjectSecurity
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Security.AccessControl.RegistrySecurity.#ctor
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RegistrySecurity()
  nameWithType: RegistrySecurity.RegistrySecurity()
  fullName: System.Security.AccessControl.RegistrySecurity.RegistrySecurity()
- uid: System.Security.AccessControl.RegistrySecurity.AccessRightType
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AccessRightType
  nameWithType: RegistrySecurity.AccessRightType
  fullName: System.Security.AccessControl.RegistrySecurity.AccessRightType
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  nameWithType: RegistrySecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  fullName: System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
- uid: System.Security.AccessControl.AccessRule
  parent: System.Security.AccessControl
  isExternal: false
  name: AccessRule
  nameWithType: AccessRule
  fullName: System.Security.AccessControl.AccessRule
- uid: System.Security.Principal.IdentityReference
  parent: System.Security.Principal
  isExternal: false
  name: IdentityReference
  nameWithType: IdentityReference
  fullName: System.Security.Principal.IdentityReference
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Security.AccessControl.InheritanceFlags
  parent: System.Security.AccessControl
  isExternal: false
  name: InheritanceFlags
  nameWithType: InheritanceFlags
  fullName: System.Security.AccessControl.InheritanceFlags
- uid: System.Security.AccessControl.PropagationFlags
  parent: System.Security.AccessControl
  isExternal: false
  name: PropagationFlags
  nameWithType: PropagationFlags
  fullName: System.Security.AccessControl.PropagationFlags
- uid: System.Security.AccessControl.AccessControlType
  parent: System.Security.AccessControl
  isExternal: false
  name: AccessControlType
  nameWithType: AccessControlType
  fullName: System.Security.AccessControl.AccessControlType
- uid: System.Security.AccessControl.RegistrySecurity.AccessRuleType
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AccessRuleType
  nameWithType: RegistrySecurity.AccessRuleType
  fullName: System.Security.AccessControl.RegistrySecurity.AccessRuleType
- uid: System.Security.AccessControl.RegistrySecurity.AddAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AddAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.AddAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.AddAccessRule(RegistryAccessRule)
- uid: System.Security.AccessControl.RegistryAccessRule
  parent: System.Security.AccessControl
  isExternal: false
  name: RegistryAccessRule
  nameWithType: RegistryAccessRule
  fullName: System.Security.AccessControl.RegistryAccessRule
- uid: System.Security.AccessControl.RegistrySecurity.AddAuditRule(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AddAuditRule(RegistryAuditRule)
  nameWithType: RegistrySecurity.AddAuditRule(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.AddAuditRule(RegistryAuditRule)
- uid: System.Security.AccessControl.RegistryAuditRule
  parent: System.Security.AccessControl
  isExternal: false
  name: RegistryAuditRule
  nameWithType: RegistryAuditRule
  fullName: System.Security.AccessControl.RegistryAuditRule
- uid: System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  nameWithType: RegistrySecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  fullName: System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
- uid: System.Security.AccessControl.AuditRule
  parent: System.Security.AccessControl
  isExternal: false
  name: AuditRule
  nameWithType: AuditRule
  fullName: System.Security.AccessControl.AuditRule
- uid: System.Security.AccessControl.AuditFlags
  parent: System.Security.AccessControl
  isExternal: false
  name: AuditFlags
  nameWithType: AuditFlags
  fullName: System.Security.AccessControl.AuditFlags
- uid: System.Security.AccessControl.RegistrySecurity.AuditRuleType
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AuditRuleType
  nameWithType: RegistrySecurity.AuditRuleType
  fullName: System.Security.AccessControl.RegistrySecurity.AuditRuleType
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.RemoveAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(RegistryAccessRule)
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAccessRuleAll(RegistryAccessRule)
  nameWithType: RegistrySecurity.RemoveAccessRuleAll(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(RegistryAccessRule)
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAccessRuleSpecific(RegistryAccessRule)
  nameWithType: RegistrySecurity.RemoveAccessRuleSpecific(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(RegistryAccessRule)
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAuditRule(RegistryAuditRule)
  nameWithType: RegistrySecurity.RemoveAuditRule(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(RegistryAuditRule)
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAuditRuleAll(RegistryAuditRule)
  nameWithType: RegistrySecurity.RemoveAuditRuleAll(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(RegistryAuditRule)
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAuditRuleSpecific(RegistryAuditRule)
  nameWithType: RegistrySecurity.RemoveAuditRuleSpecific(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(RegistryAuditRule)
- uid: System.Security.AccessControl.RegistrySecurity.ResetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: ResetAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.ResetAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.ResetAccessRule(RegistryAccessRule)
- uid: System.Security.AccessControl.RegistrySecurity.SetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: SetAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.SetAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.SetAccessRule(RegistryAccessRule)
- uid: System.Security.AccessControl.RegistrySecurity.SetAuditRule(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: SetAuditRule(RegistryAuditRule)
  nameWithType: RegistrySecurity.SetAuditRule(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.SetAuditRule(RegistryAuditRule)
- uid: System.Security.AccessControl.RegistrySecurity.#ctor*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RegistrySecurity
  nameWithType: RegistrySecurity.RegistrySecurity
- uid: System.Security.AccessControl.RegistrySecurity.AccessRightType*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AccessRightType
  nameWithType: RegistrySecurity.AccessRightType
- uid: System.Security.AccessControl.RegistrySecurity.AccessRuleFactory*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AccessRuleFactory
  nameWithType: RegistrySecurity.AccessRuleFactory
- uid: System.Security.AccessControl.RegistrySecurity.AccessRuleType*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AccessRuleType
  nameWithType: RegistrySecurity.AccessRuleType
- uid: System.Security.AccessControl.RegistrySecurity.AddAccessRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AddAccessRule
  nameWithType: RegistrySecurity.AddAccessRule
- uid: System.Security.AccessControl.RegistrySecurity.AddAuditRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AddAuditRule
  nameWithType: RegistrySecurity.AddAuditRule
- uid: System.Security.AccessControl.RegistrySecurity.AuditRuleFactory*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AuditRuleFactory
  nameWithType: RegistrySecurity.AuditRuleFactory
- uid: System.Security.AccessControl.RegistrySecurity.AuditRuleType*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AuditRuleType
  nameWithType: RegistrySecurity.AuditRuleType
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAccessRule
  nameWithType: RegistrySecurity.RemoveAccessRule
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAccessRuleAll
  nameWithType: RegistrySecurity.RemoveAccessRuleAll
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAccessRuleSpecific
  nameWithType: RegistrySecurity.RemoveAccessRuleSpecific
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAuditRule
  nameWithType: RegistrySecurity.RemoveAuditRule
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAuditRuleAll
  nameWithType: RegistrySecurity.RemoveAuditRuleAll
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAuditRuleSpecific
  nameWithType: RegistrySecurity.RemoveAuditRuleSpecific
- uid: System.Security.AccessControl.RegistrySecurity.ResetAccessRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: ResetAccessRule
  nameWithType: RegistrySecurity.ResetAccessRule
- uid: System.Security.AccessControl.RegistrySecurity.SetAccessRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: SetAccessRule
  nameWithType: RegistrySecurity.SetAccessRule
- uid: System.Security.AccessControl.RegistrySecurity.SetAuditRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: SetAuditRule
  nameWithType: RegistrySecurity.SetAuditRule
