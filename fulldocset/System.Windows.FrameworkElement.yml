### YamlMime:ManagedReference
items:
- uid: System.Windows.FrameworkElement
  id: FrameworkElement
  children:
  - System.Windows.FrameworkElement.#ctor
  - System.Windows.FrameworkElement.ActualHeight
  - System.Windows.FrameworkElement.ActualHeightProperty
  - System.Windows.FrameworkElement.ActualWidth
  - System.Windows.FrameworkElement.ActualWidthProperty
  - System.Windows.FrameworkElement.AddLogicalChild(System.Object)
  - System.Windows.FrameworkElement.ApplyTemplate
  - System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)
  - System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)
  - System.Windows.FrameworkElement.BeginInit
  - System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  - System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  - System.Windows.FrameworkElement.BindingGroup
  - System.Windows.FrameworkElement.BindingGroupProperty
  - System.Windows.FrameworkElement.BringIntoView
  - System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)
  - System.Windows.FrameworkElement.ContextMenu
  - System.Windows.FrameworkElement.ContextMenuClosing
  - System.Windows.FrameworkElement.ContextMenuClosingEvent
  - System.Windows.FrameworkElement.ContextMenuOpening
  - System.Windows.FrameworkElement.ContextMenuOpeningEvent
  - System.Windows.FrameworkElement.ContextMenuProperty
  - System.Windows.FrameworkElement.Cursor
  - System.Windows.FrameworkElement.CursorProperty
  - System.Windows.FrameworkElement.DataContext
  - System.Windows.FrameworkElement.DataContextChanged
  - System.Windows.FrameworkElement.DataContextProperty
  - System.Windows.FrameworkElement.DefaultStyleKey
  - System.Windows.FrameworkElement.DefaultStyleKeyProperty
  - System.Windows.FrameworkElement.EndInit
  - System.Windows.FrameworkElement.FindName(System.String)
  - System.Windows.FrameworkElement.FindResource(System.Object)
  - System.Windows.FrameworkElement.FlowDirection
  - System.Windows.FrameworkElement.FlowDirectionProperty
  - System.Windows.FrameworkElement.FocusVisualStyle
  - System.Windows.FrameworkElement.FocusVisualStyleProperty
  - System.Windows.FrameworkElement.ForceCursor
  - System.Windows.FrameworkElement.ForceCursorProperty
  - System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)
  - System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)
  - System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)
  - System.Windows.FrameworkElement.GetTemplateChild(System.String)
  - System.Windows.FrameworkElement.GetUIParentCore
  - System.Windows.FrameworkElement.GetVisualChild(System.Int32)
  - System.Windows.FrameworkElement.Height
  - System.Windows.FrameworkElement.HeightProperty
  - System.Windows.FrameworkElement.HorizontalAlignment
  - System.Windows.FrameworkElement.HorizontalAlignmentProperty
  - System.Windows.FrameworkElement.InheritanceBehavior
  - System.Windows.FrameworkElement.Initialized
  - System.Windows.FrameworkElement.InputScope
  - System.Windows.FrameworkElement.InputScopeProperty
  - System.Windows.FrameworkElement.IsInitialized
  - System.Windows.FrameworkElement.IsLoaded
  - System.Windows.FrameworkElement.Language
  - System.Windows.FrameworkElement.LanguageProperty
  - System.Windows.FrameworkElement.LayoutTransform
  - System.Windows.FrameworkElement.LayoutTransformProperty
  - System.Windows.FrameworkElement.Loaded
  - System.Windows.FrameworkElement.LoadedEvent
  - System.Windows.FrameworkElement.LogicalChildren
  - System.Windows.FrameworkElement.Margin
  - System.Windows.FrameworkElement.MarginProperty
  - System.Windows.FrameworkElement.MaxHeight
  - System.Windows.FrameworkElement.MaxHeightProperty
  - System.Windows.FrameworkElement.MaxWidth
  - System.Windows.FrameworkElement.MaxWidthProperty
  - System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)
  - System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)
  - System.Windows.FrameworkElement.MinHeight
  - System.Windows.FrameworkElement.MinHeightProperty
  - System.Windows.FrameworkElement.MinWidth
  - System.Windows.FrameworkElement.MinWidthProperty
  - System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)
  - System.Windows.FrameworkElement.Name
  - System.Windows.FrameworkElement.NameProperty
  - System.Windows.FrameworkElement.OnApplyTemplate
  - System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  - System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  - System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)
  - System.Windows.FrameworkElement.OnInitialized(System.EventArgs)
  - System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)
  - System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)
  - System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  - System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  - System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)
  - System.Windows.FrameworkElement.OverridesDefaultStyle
  - System.Windows.FrameworkElement.OverridesDefaultStyleProperty
  - System.Windows.FrameworkElement.Parent
  - System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)
  - System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  - System.Windows.FrameworkElement.RegisterName(System.String,System.Object)
  - System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)
  - System.Windows.FrameworkElement.RequestBringIntoView
  - System.Windows.FrameworkElement.RequestBringIntoViewEvent
  - System.Windows.FrameworkElement.Resources
  - System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)
  - System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  - System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)
  - System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)
  - System.Windows.FrameworkElement.ShouldSerializeResources
  - System.Windows.FrameworkElement.ShouldSerializeStyle
  - System.Windows.FrameworkElement.ShouldSerializeTriggers
  - System.Windows.FrameworkElement.SizeChanged
  - System.Windows.FrameworkElement.SizeChangedEvent
  - System.Windows.FrameworkElement.SourceUpdated
  - System.Windows.FrameworkElement.Style
  - System.Windows.FrameworkElement.StyleProperty
  - System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  - System.Windows.FrameworkElement.Tag
  - System.Windows.FrameworkElement.TagProperty
  - System.Windows.FrameworkElement.TargetUpdated
  - System.Windows.FrameworkElement.TemplatedParent
  - System.Windows.FrameworkElement.ToolTip
  - System.Windows.FrameworkElement.ToolTipClosing
  - System.Windows.FrameworkElement.ToolTipClosingEvent
  - System.Windows.FrameworkElement.ToolTipOpening
  - System.Windows.FrameworkElement.ToolTipOpeningEvent
  - System.Windows.FrameworkElement.ToolTipProperty
  - System.Windows.FrameworkElement.Triggers
  - System.Windows.FrameworkElement.TryFindResource(System.Object)
  - System.Windows.FrameworkElement.Unloaded
  - System.Windows.FrameworkElement.UnloadedEvent
  - System.Windows.FrameworkElement.UnregisterName(System.String)
  - System.Windows.FrameworkElement.UpdateDefaultStyle
  - System.Windows.FrameworkElement.UseLayoutRounding
  - System.Windows.FrameworkElement.UseLayoutRoundingProperty
  - System.Windows.FrameworkElement.VerticalAlignment
  - System.Windows.FrameworkElement.VerticalAlignmentProperty
  - System.Windows.FrameworkElement.VisualChildrenCount
  - System.Windows.FrameworkElement.Width
  - System.Windows.FrameworkElement.WidthProperty
  langs:
  - csharp
  name: FrameworkElement
  nameWithType: FrameworkElement
  fullName: System.Windows.FrameworkElement
  type: Class
  summary: "Fornece um conjunto de nível de framework WPF de propriedades, eventos e métodos de [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] elementos. Esta classe representa a implementação do framework nível WPF fornecida está incorporada no nível principal WPF [!INCLUDE[TLA#tla_api#plural](~/add/includes/tlasharptla-apisharpplural-md.md)] que são definidos pelo <xref href=&quot;System.Windows.UIElement&quot;> </xref>."
  remarks: "FrameworkElement é o ponto de ligação entre classes de elemento de nível de framework WPF e o conjunto de nível de principais do WPF de <xref:System.Windows.UIElement>Serviços de apresentação.</xref:System.Windows.UIElement> Para mais informações sobre estes conceitos, consulte [WPF arquitetura](~/add/includes/ajax-current-ext-md.md).       Expande FrameworkElement <xref:System.Windows.UIElement>e adiciona as seguintes funcionalidades:- **definição do sistema de esquema**: fornece de FrameworkElement específicas implementações de nível de framework WPF métodos que foram definidos como virtuais membros no <xref:System.Windows.UIElement>.</xref:System.Windows.UIElement> para determinados</xref:System.Windows.UIElement> Nomeadamente, FrameworkElement seals determinadas substituições de esquema de nível de principais do WPF e, em vez disso, fornece um equivalente ao nível do framework WPF que deriva de classes deve substituir em vez disso. Por exemplo, FrameworkElement seals <xref:System.Windows.UIElement.ArrangeCore%2A>mas fornece <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>.</xref:System.Windows.FrameworkElement.ArrangeOverride%2A> </xref:System.Windows.UIElement.ArrangeCore%2A> Estas alterações refletem o facto de que no WPF ao nível do framework há um sistema de esquema completa no local que é possível compor o qualquer FrameworkElement classe derivada. No WPF principal nível, a determinados membros que serão estruturar uma geral [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] são a solução de esquema com base no local, mas o motor do sistema de esquema real não está definido. Para obter mais informações, consulte [esquema](~/add/includes/ajax-current-ext-md.md).      - **Árvore lógica:** geral [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] modelo de programação, muitas vezes, é expresso em termos de que está a ser uma árvore de elementos. Suporte para expressa a árvore de elementos como uma árvore lógica, e que acompanha o suporte para definir nessa árvore no markup é implementado o nível de FrameworkElement. Tenha em atenção contudo que FrameworkElement deliberadamente não definir um modelo de conteúdo e sai dessa responsabilidade de classes derivadas. Para obter mais informações, consulte [árvores no WPF](~/add/includes/ajax-current-ext-md.md).      - **Eventos de duração de objetos:** , muitas vezes, é útil para saber quando um elemento foi inicializado (denomina-se o construtor) ou quando o elemento pela primeira vez é carregado para uma árvore lógica. FrameworkElement define vários eventos relacionados com a duração de objetos que fornecem hooks útil para operações do code-behind que envolvem elementos, tais como adicionar mais elementos subordinados. Para obter mais informações, consulte [eventos de duração do objeto](~/add/includes/ajax-current-ext-md.md).      - **Suporte para o enlace de dados e referências de recursos dinâmicos:** o suporte de nível de propriedade para o enlace de dados e de recursos é implementado pelo <xref:System.Windows.DependencyProperty>classe e embodied no sistema de propriedade, mas a capacidade para resolver um valor do membro que é armazenado como uma <xref:System.Windows.Expression>(a construção programação subjacente enlace de dados e de recursos dinâmicos) é implementada por FrameworkElement.</xref:System.Windows.Expression> </xref:System.Windows.DependencyProperty> Para obter mais informações, consulte [descrição geral de enlace de dados](~/add/includes/ajax-current-ext-md.md) e [XAML recursos](~/add/includes/ajax-current-ext-md.md).      - **Estilos:** FrameworkElement define o <xref:System.Windows.FrameworkElement.Style%2A>propriedade.</xref:System.Windows.FrameworkElement.Style%2A> No entanto, FrameworkElement ainda não suporte para modelos de definir, ou suportar decoradores. Estas funcionalidades são introduzidas pelo classes de controlo, tais como <xref:System.Windows.Controls.Control>e <xref:System.Windows.Controls.ContentControl>.</xref:System.Windows.Controls.ContentControl> </xref:System.Windows.Controls.Control>      - **Mais suporte de animação:** algumas suporte de animação já foi definido ao nível de principais do WPF, mas FrameworkElement expande este implementando <xref:System.Windows.FrameworkElement.BeginStoryboard%2A>e relacionadas com os membros.</xref:System.Windows.FrameworkElement.BeginStoryboard%2A>       Como podem ser vistos a partir da hierarquia de classes, muitos [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] classes de derivar de FrameworkElement, diretamente ou através de classes base intermédias como <xref:System.Windows.Controls.Panel>ou <xref:System.Windows.Controls.Control>.</xref:System.Windows.Controls.Control> </xref:System.Windows.Controls.Panel>       Se pretender utilizar FrameworkElement como uma classe base, pode querer examinar primeiro as classes derivadas existentes. FrameworkElement fornece suporte para vários cenários básicos, mas também não tem um número de funcionalidades que estão desejável para um &quot;elemento&quot; no sentido de um bloco modular que utilizar para criar [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] no [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]. Por exemplo, um FrameworkElement não define qualquer modelo de conteúdo true; FrameworkElement como classe base não define uma propriedade que pode criar [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] elementos subordinados. Em particular, pode querer observar <xref:System.Windows.Controls.Control>e <xref:System.Windows.Controls.ContentControl>.</xref:System.Windows.Controls.ContentControl> </xref:System.Windows.Controls.Control>"
  syntax:
    content: >-
      [System.Windows.Markup.RuntimeNameProperty("Name")]

      [System.Windows.Markup.UsableDuringInitialization(true)]

      [System.Windows.Markup.XmlLangProperty("Language")]

      [System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))]

      public class FrameworkElement : System.Windows.UIElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient
  inheritance:
  - System.Object
  - System.Windows.Threading.DispatcherObject
  - System.Windows.DependencyObject
  - System.Windows.Media.Visual
  - System.Windows.UIElement
  implements:
  - System.ComponentModel.ISupportInitialize
  - System.Windows.IFrameworkInputElement
  - System.Windows.Markup.IQueryAmbient
  inheritedMembers:
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)
  - System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.DependencyObjectType
  - System.Windows.DependencyObject.Equals(System.Object)
  - System.Windows.DependencyObject.GetHashCode
  - System.Windows.DependencyObject.GetLocalValueEnumerator
  - System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.IsSealed
  - System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)
  - System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)
  - System.Windows.Media.Visual.AddVisualChild(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.FindCommonVisualAncestor(System.Windows.DependencyObject)
  - System.Windows.Media.Visual.IsAncestorOf(System.Windows.DependencyObject)
  - System.Windows.Media.Visual.IsDescendantOf(System.Windows.DependencyObject)
  - System.Windows.Media.Visual.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)
  - System.Windows.Media.Visual.OnVisualChildrenChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)
  - System.Windows.Media.Visual.PointFromScreen(System.Windows.Point)
  - System.Windows.Media.Visual.PointToScreen(System.Windows.Point)
  - System.Windows.Media.Visual.RemoveVisualChild(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.TransformToAncestor(System.Windows.Media.Media3D.Visual3D)
  - System.Windows.Media.Visual.TransformToAncestor(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.TransformToDescendant(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.TransformToVisual(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.VisualBitmapEffect
  - System.Windows.Media.Visual.VisualBitmapEffectInput
  - System.Windows.Media.Visual.VisualBitmapScalingMode
  - System.Windows.Media.Visual.VisualCacheMode
  - System.Windows.Media.Visual.VisualClearTypeHint
  - System.Windows.Media.Visual.VisualClip
  - System.Windows.Media.Visual.VisualEdgeMode
  - System.Windows.Media.Visual.VisualEffect
  - System.Windows.Media.Visual.VisualOffset
  - System.Windows.Media.Visual.VisualOpacity
  - System.Windows.Media.Visual.VisualOpacityMask
  - System.Windows.Media.Visual.VisualParent
  - System.Windows.Media.Visual.VisualScrollableAreaClip
  - System.Windows.Media.Visual.VisualTextHintingMode
  - System.Windows.Media.Visual.VisualTextRenderingMode
  - System.Windows.Media.Visual.VisualTransform
  - System.Windows.Media.Visual.VisualXSnappingGuidelines
  - System.Windows.Media.Visual.VisualYSnappingGuidelines
  - System.Windows.Threading.DispatcherObject.CheckAccess
  - System.Windows.Threading.DispatcherObject.Dispatcher
  - System.Windows.Threading.DispatcherObject.VerifyAccess
  - System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)
  - System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)
  - System.Windows.UIElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)
  - System.Windows.UIElement.AllowDrop
  - System.Windows.UIElement.AllowDropProperty
  - System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)
  - System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.UIElement.AreAnyTouchesCaptured
  - System.Windows.UIElement.AreAnyTouchesCapturedProperty
  - System.Windows.UIElement.AreAnyTouchesCapturedWithin
  - System.Windows.UIElement.AreAnyTouchesCapturedWithinProperty
  - System.Windows.UIElement.AreAnyTouchesDirectlyOver
  - System.Windows.UIElement.AreAnyTouchesDirectlyOverProperty
  - System.Windows.UIElement.AreAnyTouchesOver
  - System.Windows.UIElement.AreAnyTouchesOverProperty
  - System.Windows.UIElement.Arrange(System.Windows.Rect)
  - System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)
  - System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.UIElement.BitmapEffect
  - System.Windows.UIElement.BitmapEffectInput
  - System.Windows.UIElement.BitmapEffectInputProperty
  - System.Windows.UIElement.BitmapEffectProperty
  - System.Windows.UIElement.CacheMode
  - System.Windows.UIElement.CacheModeProperty
  - System.Windows.UIElement.CaptureMouse
  - System.Windows.UIElement.CaptureStylus
  - System.Windows.UIElement.CaptureTouch(System.Windows.Input.TouchDevice)
  - System.Windows.UIElement.Clip
  - System.Windows.UIElement.ClipProperty
  - System.Windows.UIElement.ClipToBounds
  - System.Windows.UIElement.ClipToBoundsProperty
  - System.Windows.UIElement.CommandBindings
  - System.Windows.UIElement.DesiredSize
  - System.Windows.UIElement.DragEnter
  - System.Windows.UIElement.DragEnterEvent
  - System.Windows.UIElement.DragLeave
  - System.Windows.UIElement.DragLeaveEvent
  - System.Windows.UIElement.DragOver
  - System.Windows.UIElement.DragOverEvent
  - System.Windows.UIElement.Drop
  - System.Windows.UIElement.DropEvent
  - System.Windows.UIElement.Effect
  - System.Windows.UIElement.EffectProperty
  - System.Windows.UIElement.Focus
  - System.Windows.UIElement.Focusable
  - System.Windows.UIElement.FocusableChanged
  - System.Windows.UIElement.FocusableProperty
  - System.Windows.UIElement.GetAnimationBaseValue(System.Windows.DependencyProperty)
  - System.Windows.UIElement.GiveFeedback
  - System.Windows.UIElement.GiveFeedbackEvent
  - System.Windows.UIElement.GotFocus
  - System.Windows.UIElement.GotFocusEvent
  - System.Windows.UIElement.GotKeyboardFocus
  - System.Windows.UIElement.GotKeyboardFocusEvent
  - System.Windows.UIElement.GotMouseCapture
  - System.Windows.UIElement.GotMouseCaptureEvent
  - System.Windows.UIElement.GotStylusCapture
  - System.Windows.UIElement.GotStylusCaptureEvent
  - System.Windows.UIElement.GotTouchCapture
  - System.Windows.UIElement.GotTouchCaptureEvent
  - System.Windows.UIElement.HasAnimatedProperties
  - System.Windows.UIElement.HasEffectiveKeyboardFocus
  - System.Windows.UIElement.HitTestCore(System.Windows.Media.GeometryHitTestParameters)
  - System.Windows.UIElement.HitTestCore(System.Windows.Media.PointHitTestParameters)
  - System.Windows.UIElement.InputBindings
  - System.Windows.UIElement.InputHitTest(System.Windows.Point)
  - System.Windows.UIElement.InvalidateArrange
  - System.Windows.UIElement.InvalidateMeasure
  - System.Windows.UIElement.InvalidateVisual
  - System.Windows.UIElement.IsArrangeValid
  - System.Windows.UIElement.IsEnabled
  - System.Windows.UIElement.IsEnabledChanged
  - System.Windows.UIElement.IsEnabledCore
  - System.Windows.UIElement.IsEnabledProperty
  - System.Windows.UIElement.IsFocused
  - System.Windows.UIElement.IsFocusedProperty
  - System.Windows.UIElement.IsHitTestVisible
  - System.Windows.UIElement.IsHitTestVisibleChanged
  - System.Windows.UIElement.IsHitTestVisibleProperty
  - System.Windows.UIElement.IsInputMethodEnabled
  - System.Windows.UIElement.IsKeyboardFocused
  - System.Windows.UIElement.IsKeyboardFocusedChanged
  - System.Windows.UIElement.IsKeyboardFocusedProperty
  - System.Windows.UIElement.IsKeyboardFocusWithin
  - System.Windows.UIElement.IsKeyboardFocusWithinChanged
  - System.Windows.UIElement.IsKeyboardFocusWithinProperty
  - System.Windows.UIElement.IsManipulationEnabled
  - System.Windows.UIElement.IsManipulationEnabledProperty
  - System.Windows.UIElement.IsMeasureValid
  - System.Windows.UIElement.IsMouseCaptured
  - System.Windows.UIElement.IsMouseCapturedChanged
  - System.Windows.UIElement.IsMouseCapturedProperty
  - System.Windows.UIElement.IsMouseCaptureWithin
  - System.Windows.UIElement.IsMouseCaptureWithinChanged
  - System.Windows.UIElement.IsMouseCaptureWithinProperty
  - System.Windows.UIElement.IsMouseDirectlyOver
  - System.Windows.UIElement.IsMouseDirectlyOverChanged
  - System.Windows.UIElement.IsMouseDirectlyOverProperty
  - System.Windows.UIElement.IsMouseOver
  - System.Windows.UIElement.IsMouseOverProperty
  - System.Windows.UIElement.IsStylusCaptured
  - System.Windows.UIElement.IsStylusCapturedChanged
  - System.Windows.UIElement.IsStylusCapturedProperty
  - System.Windows.UIElement.IsStylusCaptureWithin
  - System.Windows.UIElement.IsStylusCaptureWithinChanged
  - System.Windows.UIElement.IsStylusCaptureWithinProperty
  - System.Windows.UIElement.IsStylusDirectlyOver
  - System.Windows.UIElement.IsStylusDirectlyOverChanged
  - System.Windows.UIElement.IsStylusDirectlyOverProperty
  - System.Windows.UIElement.IsStylusOver
  - System.Windows.UIElement.IsStylusOverProperty
  - System.Windows.UIElement.IsVisible
  - System.Windows.UIElement.IsVisibleChanged
  - System.Windows.UIElement.IsVisibleProperty
  - System.Windows.UIElement.KeyDown
  - System.Windows.UIElement.KeyDownEvent
  - System.Windows.UIElement.KeyUp
  - System.Windows.UIElement.KeyUpEvent
  - System.Windows.UIElement.LayoutUpdated
  - System.Windows.UIElement.LostFocus
  - System.Windows.UIElement.LostFocusEvent
  - System.Windows.UIElement.LostKeyboardFocus
  - System.Windows.UIElement.LostKeyboardFocusEvent
  - System.Windows.UIElement.LostMouseCapture
  - System.Windows.UIElement.LostMouseCaptureEvent
  - System.Windows.UIElement.LostStylusCapture
  - System.Windows.UIElement.LostStylusCaptureEvent
  - System.Windows.UIElement.LostTouchCapture
  - System.Windows.UIElement.LostTouchCaptureEvent
  - System.Windows.UIElement.ManipulationBoundaryFeedback
  - System.Windows.UIElement.ManipulationBoundaryFeedbackEvent
  - System.Windows.UIElement.ManipulationCompleted
  - System.Windows.UIElement.ManipulationCompletedEvent
  - System.Windows.UIElement.ManipulationDelta
  - System.Windows.UIElement.ManipulationDeltaEvent
  - System.Windows.UIElement.ManipulationInertiaStarting
  - System.Windows.UIElement.ManipulationInertiaStartingEvent
  - System.Windows.UIElement.ManipulationStarted
  - System.Windows.UIElement.ManipulationStartedEvent
  - System.Windows.UIElement.ManipulationStarting
  - System.Windows.UIElement.ManipulationStartingEvent
  - System.Windows.UIElement.Measure(System.Windows.Size)
  - System.Windows.UIElement.MouseDown
  - System.Windows.UIElement.MouseDownEvent
  - System.Windows.UIElement.MouseEnter
  - System.Windows.UIElement.MouseEnterEvent
  - System.Windows.UIElement.MouseLeave
  - System.Windows.UIElement.MouseLeaveEvent
  - System.Windows.UIElement.MouseLeftButtonDown
  - System.Windows.UIElement.MouseLeftButtonDownEvent
  - System.Windows.UIElement.MouseLeftButtonUp
  - System.Windows.UIElement.MouseLeftButtonUpEvent
  - System.Windows.UIElement.MouseMove
  - System.Windows.UIElement.MouseMoveEvent
  - System.Windows.UIElement.MouseRightButtonDown
  - System.Windows.UIElement.MouseRightButtonDownEvent
  - System.Windows.UIElement.MouseRightButtonUp
  - System.Windows.UIElement.MouseRightButtonUpEvent
  - System.Windows.UIElement.MouseUp
  - System.Windows.UIElement.MouseUpEvent
  - System.Windows.UIElement.MouseWheel
  - System.Windows.UIElement.MouseWheelEvent
  - System.Windows.UIElement.OnAccessKey(System.Windows.Input.AccessKeyEventArgs)
  - System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)
  - System.Windows.UIElement.OnCreateAutomationPeer
  - System.Windows.UIElement.OnDragEnter(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnDragLeave(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnDragOver(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnDrop(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  - System.Windows.UIElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.UIElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnKeyDown(System.Windows.Input.KeyEventArgs)
  - System.Windows.UIElement.OnKeyUp(System.Windows.Input.KeyEventArgs)
  - System.Windows.UIElement.OnLostFocus(System.Windows.RoutedEventArgs)
  - System.Windows.UIElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.UIElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)
  - System.Windows.UIElement.OnManipulationCompleted(System.Windows.Input.ManipulationCompletedEventArgs)
  - System.Windows.UIElement.OnManipulationDelta(System.Windows.Input.ManipulationDeltaEventArgs)
  - System.Windows.UIElement.OnManipulationInertiaStarting(System.Windows.Input.ManipulationInertiaStartingEventArgs)
  - System.Windows.UIElement.OnManipulationStarted(System.Windows.Input.ManipulationStartedEventArgs)
  - System.Windows.UIElement.OnManipulationStarting(System.Windows.Input.ManipulationStartingEventArgs)
  - System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseMove(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  - System.Windows.UIElement.OnPreviewDragEnter(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnPreviewDragLeave(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnPreviewDragOver(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnPreviewDrop(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  - System.Windows.UIElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.UIElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)
  - System.Windows.UIElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)
  - System.Windows.UIElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  - System.Windows.UIElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  - System.Windows.UIElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.UIElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.UIElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)
  - System.Windows.UIElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  - System.Windows.UIElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)
  - System.Windows.UIElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  - System.Windows.UIElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)
  - System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)
  - System.Windows.UIElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.UIElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.UIElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)
  - System.Windows.UIElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  - System.Windows.UIElement.OnStylusUp(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)
  - System.Windows.UIElement.OnTouchDown(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnTouchMove(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnTouchUp(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.Opacity
  - System.Windows.UIElement.OpacityMask
  - System.Windows.UIElement.OpacityMaskProperty
  - System.Windows.UIElement.OpacityProperty
  - System.Windows.UIElement.PersistId
  - System.Windows.UIElement.PreviewDragEnter
  - System.Windows.UIElement.PreviewDragEnterEvent
  - System.Windows.UIElement.PreviewDragLeave
  - System.Windows.UIElement.PreviewDragLeaveEvent
  - System.Windows.UIElement.PreviewDragOver
  - System.Windows.UIElement.PreviewDragOverEvent
  - System.Windows.UIElement.PreviewDrop
  - System.Windows.UIElement.PreviewDropEvent
  - System.Windows.UIElement.PreviewGiveFeedback
  - System.Windows.UIElement.PreviewGiveFeedbackEvent
  - System.Windows.UIElement.PreviewGotKeyboardFocus
  - System.Windows.UIElement.PreviewGotKeyboardFocusEvent
  - System.Windows.UIElement.PreviewKeyDown
  - System.Windows.UIElement.PreviewKeyDownEvent
  - System.Windows.UIElement.PreviewKeyUp
  - System.Windows.UIElement.PreviewKeyUpEvent
  - System.Windows.UIElement.PreviewLostKeyboardFocus
  - System.Windows.UIElement.PreviewLostKeyboardFocusEvent
  - System.Windows.UIElement.PreviewMouseDown
  - System.Windows.UIElement.PreviewMouseDownEvent
  - System.Windows.UIElement.PreviewMouseLeftButtonDown
  - System.Windows.UIElement.PreviewMouseLeftButtonDownEvent
  - System.Windows.UIElement.PreviewMouseLeftButtonUp
  - System.Windows.UIElement.PreviewMouseLeftButtonUpEvent
  - System.Windows.UIElement.PreviewMouseMove
  - System.Windows.UIElement.PreviewMouseMoveEvent
  - System.Windows.UIElement.PreviewMouseRightButtonDown
  - System.Windows.UIElement.PreviewMouseRightButtonDownEvent
  - System.Windows.UIElement.PreviewMouseRightButtonUp
  - System.Windows.UIElement.PreviewMouseRightButtonUpEvent
  - System.Windows.UIElement.PreviewMouseUp
  - System.Windows.UIElement.PreviewMouseUpEvent
  - System.Windows.UIElement.PreviewMouseWheel
  - System.Windows.UIElement.PreviewMouseWheelEvent
  - System.Windows.UIElement.PreviewQueryContinueDrag
  - System.Windows.UIElement.PreviewQueryContinueDragEvent
  - System.Windows.UIElement.PreviewStylusButtonDown
  - System.Windows.UIElement.PreviewStylusButtonDownEvent
  - System.Windows.UIElement.PreviewStylusButtonUp
  - System.Windows.UIElement.PreviewStylusButtonUpEvent
  - System.Windows.UIElement.PreviewStylusDown
  - System.Windows.UIElement.PreviewStylusDownEvent
  - System.Windows.UIElement.PreviewStylusInAirMove
  - System.Windows.UIElement.PreviewStylusInAirMoveEvent
  - System.Windows.UIElement.PreviewStylusInRange
  - System.Windows.UIElement.PreviewStylusInRangeEvent
  - System.Windows.UIElement.PreviewStylusMove
  - System.Windows.UIElement.PreviewStylusMoveEvent
  - System.Windows.UIElement.PreviewStylusOutOfRange
  - System.Windows.UIElement.PreviewStylusOutOfRangeEvent
  - System.Windows.UIElement.PreviewStylusSystemGesture
  - System.Windows.UIElement.PreviewStylusSystemGestureEvent
  - System.Windows.UIElement.PreviewStylusUp
  - System.Windows.UIElement.PreviewStylusUpEvent
  - System.Windows.UIElement.PreviewTextInput
  - System.Windows.UIElement.PreviewTextInputEvent
  - System.Windows.UIElement.PreviewTouchDown
  - System.Windows.UIElement.PreviewTouchDownEvent
  - System.Windows.UIElement.PreviewTouchMove
  - System.Windows.UIElement.PreviewTouchMoveEvent
  - System.Windows.UIElement.PreviewTouchUp
  - System.Windows.UIElement.PreviewTouchUpEvent
  - System.Windows.UIElement.QueryContinueDrag
  - System.Windows.UIElement.QueryContinueDragEvent
  - System.Windows.UIElement.QueryCursor
  - System.Windows.UIElement.QueryCursorEvent
  - System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)
  - System.Windows.UIElement.ReleaseAllTouchCaptures
  - System.Windows.UIElement.ReleaseMouseCapture
  - System.Windows.UIElement.ReleaseStylusCapture
  - System.Windows.UIElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)
  - System.Windows.UIElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)
  - System.Windows.UIElement.RenderSize
  - System.Windows.UIElement.RenderTransform
  - System.Windows.UIElement.RenderTransformOrigin
  - System.Windows.UIElement.RenderTransformOriginProperty
  - System.Windows.UIElement.RenderTransformProperty
  - System.Windows.UIElement.ShouldSerializeCommandBindings
  - System.Windows.UIElement.ShouldSerializeInputBindings
  - System.Windows.UIElement.SnapsToDevicePixels
  - System.Windows.UIElement.SnapsToDevicePixelsProperty
  - System.Windows.UIElement.StylusButtonDown
  - System.Windows.UIElement.StylusButtonDownEvent
  - System.Windows.UIElement.StylusButtonUp
  - System.Windows.UIElement.StylusButtonUpEvent
  - System.Windows.UIElement.StylusDown
  - System.Windows.UIElement.StylusDownEvent
  - System.Windows.UIElement.StylusEnter
  - System.Windows.UIElement.StylusEnterEvent
  - System.Windows.UIElement.StylusInAirMove
  - System.Windows.UIElement.StylusInAirMoveEvent
  - System.Windows.UIElement.StylusInRange
  - System.Windows.UIElement.StylusInRangeEvent
  - System.Windows.UIElement.StylusLeave
  - System.Windows.UIElement.StylusLeaveEvent
  - System.Windows.UIElement.StylusMove
  - System.Windows.UIElement.StylusMoveEvent
  - System.Windows.UIElement.StylusOutOfRange
  - System.Windows.UIElement.StylusOutOfRangeEvent
  - System.Windows.UIElement.StylusPlugIns
  - System.Windows.UIElement.StylusSystemGesture
  - System.Windows.UIElement.StylusSystemGestureEvent
  - System.Windows.UIElement.StylusUp
  - System.Windows.UIElement.StylusUpEvent
  - System.Windows.UIElement.TextInput
  - System.Windows.UIElement.TextInputEvent
  - System.Windows.UIElement.TouchDown
  - System.Windows.UIElement.TouchDownEvent
  - System.Windows.UIElement.TouchEnter
  - System.Windows.UIElement.TouchEnterEvent
  - System.Windows.UIElement.TouchesCaptured
  - System.Windows.UIElement.TouchesCapturedWithin
  - System.Windows.UIElement.TouchesDirectlyOver
  - System.Windows.UIElement.TouchesOver
  - System.Windows.UIElement.TouchLeave
  - System.Windows.UIElement.TouchLeaveEvent
  - System.Windows.UIElement.TouchMove
  - System.Windows.UIElement.TouchMoveEvent
  - System.Windows.UIElement.TouchUp
  - System.Windows.UIElement.TouchUpEvent
  - System.Windows.UIElement.TranslatePoint(System.Windows.Point,System.Windows.UIElement)
  - System.Windows.UIElement.Uid
  - System.Windows.UIElement.UidProperty
  - System.Windows.UIElement.UpdateLayout
  - System.Windows.UIElement.Visibility
  - System.Windows.UIElement.VisibilityProperty
  platform:
  - net462
- uid: System.Windows.FrameworkElement.#ctor
  id: '#ctor'
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FrameworkElement()
  nameWithType: FrameworkElement.FrameworkElement()
  fullName: System.Windows.FrameworkElement.FrameworkElement()
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicializa uma nova instância do <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref> classe."
  syntax:
    content: public FrameworkElement ();
    parameters: []
  overload: System.Windows.FrameworkElement.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ActualHeight
  id: ActualHeight
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ActualHeight
  nameWithType: FrameworkElement.ActualHeight
  fullName: System.Windows.FrameworkElement.ActualHeight
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém a altura composta deste elemento."
  remarks: "Esta propriedade é um valor calculado com base nas outras entradas de altura e o sistema de esquema. O valor é definido pelo sistema de esquema, com base numa passagem de composição real e pode, por conseguinte, ligeiramente ficar mais lentos durante o valor de conjunto de propriedades, tais como <xref:System.Windows.FrameworkElement.Height%2A>que estejam a base da alteração de entrada.</xref:System.Windows.FrameworkElement.Height%2A>       Uma vez ActualHeight é um valor calculado, deve ter conhecimento que podem existir vários ou incrementais comunicado alterações ao mesmo como resultado de várias operações pelo esquema sistema. O sistema de esquema pode ser a calcular o espaço de medidas necessárias para elementos subordinados, restrições pelo elemento principal e assim sucessivamente.       Apesar de não é possível definir esta propriedade da [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], pode baseá um <xref:System.Windows.Trigger>após o respetivo valor num style.</xref:System.Windows.Trigger>      <a name=&quot;dependencyPropertyInfo_ActualHeight&quot;></a># # Informações de propriedade de dependência |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.ActualHeightProperty>|   | Definir propriedades de metadados `true`| Nenhum |</xref:System.Windows.FrameworkElement.ActualHeightProperty>"
  example:
  - "The following example displays various height properties.  \n  \n [!code-cs[HeightMinHeightMaxHeight#3](~/add/codesnippet/csharp/Height_MinHeight_MaxHeight_CSharp/Window1.xaml.cs#3)]\n [!code-vb[HeightMinHeightMaxHeight#3](~/add/codesnippet/visualbasic/Height_MinHeight_MaxHeight/Window1.xaml.vb#3)]"
  syntax:
    content: public double ActualHeight { get; }
    return:
      type: System.Double
      description: "A altura do elemento, como um valor no [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]. O valor predefinido é 0 (zero)."
  overload: System.Windows.FrameworkElement.ActualHeight*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ActualHeightProperty
  id: ActualHeightProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ActualHeightProperty
  nameWithType: FrameworkElement.ActualHeightProperty
  fullName: System.Windows.FrameworkElement.ActualHeightProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.ActualHeight*>propriedade de dependência.</xref:System.Windows.FrameworkElement.ActualHeight*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ActualHeightProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ActualWidth
  id: ActualWidth
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ActualWidth
  nameWithType: FrameworkElement.ActualWidth
  fullName: System.Windows.FrameworkElement.ActualWidth
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém a largura composta deste elemento."
  remarks: "Esta propriedade é um valor calculado com base nas outras entradas de largura e o sistema de esquema. O valor é definido pelo sistema de esquema, com base numa passagem de composição real e pode, por conseguinte, ligeiramente ficar mais lentos durante o valor de conjunto de propriedades, tais como <xref:System.Windows.FrameworkElement.Width%2A>que estejam a base da alteração de entrada.</xref:System.Windows.FrameworkElement.Width%2A>       Uma vez ActualWidth é um valor calculado, deve ter conhecimento que podem existir vários ou incrementais comunicado alterações ao mesmo como resultado de várias operações pelo esquema sistema. O sistema de esquema pode ser a calcular o espaço de medidas necessárias para elementos subordinados, restrições pelo elemento principal e assim sucessivamente.       Apesar de não é possível definir esta propriedade da [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], pode baseá um <xref:System.Windows.Trigger>após o respetivo valor num style.</xref:System.Windows.Trigger>      <a name=&quot;dependencyPropertyInfo_ActualWidth&quot;></a># # Informações de propriedade de dependência |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.ActualWidthProperty>|   | Definir propriedades de metadados `true`| Nenhum |</xref:System.Windows.FrameworkElement.ActualWidthProperty>"
  example:
  - "The following example displays various width properties.  \n  \n [!code-vb[WidthMinWidthMaxWidth#3](~/add/codesnippet/visualbasic/Width_MinWidth_MaxWidth/Window1.xaml.vb#3)]\n [!code-cs[WidthMinWidthMaxWidth#3](~/add/codesnippet/csharp/Width_MinWidth_MaxWidth_CSharp/Window1.xaml.cs#3)]"
  syntax:
    content: public double ActualWidth { get; }
    return:
      type: System.Double
      description: "A largura do elemento, como um valor no [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]. O valor predefinido é 0 (zero)."
  overload: System.Windows.FrameworkElement.ActualWidth*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ActualWidthProperty
  id: ActualWidthProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ActualWidthProperty
  nameWithType: FrameworkElement.ActualWidthProperty
  fullName: System.Windows.FrameworkElement.ActualWidthProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.ActualWidth*>propriedade de dependência.</xref:System.Windows.FrameworkElement.ActualWidth*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ActualWidthProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.AddLogicalChild(System.Object)
  id: AddLogicalChild(System.Object)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: AddLogicalChild(Object)
  nameWithType: FrameworkElement.AddLogicalChild(Object)
  fullName: System.Windows.FrameworkElement.AddLogicalChild(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Adiciona o objecto fornecido a árvore lógica deste elemento."
  remarks: "Utilize este método para a implementação de coleções em objetos que representam os elementos subordinados de lógica de um elemento. Manutenção da coleção de coleções de elemento subordinado pode ser efetuada em getters de propriedade ou setters, processamento de eventos foi alterado, construtores, ou dentro dos próprios tipos de coleção de classe.       Para autores de controlo, manipular a árvore lógica neste nível não está a prática recomendada, a menos que nenhum dos modelos de conteúdo para as classes de controlo base disponíveis são adequados para o seu cenário de controlo. Considere subclassing ao nível dos <xref:System.Windows.Controls.ContentControl>, <xref:System.Windows.Controls.ItemsControl>e <xref:System.Windows.Controls.HeaderedItemsControl>.</xref:System.Windows.Controls.HeaderedItemsControl> </xref:System.Windows.Controls.ItemsControl> </xref:System.Windows.Controls.ContentControl> Estas classes fornecem um modelo de conteúdo com a imposição específico de elementos subordinados de árvore lógica dedicado através de [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)], bem como suporte de outras funcionalidades normalmente desejável num [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] controlo, tais como o estilo através de modelos. Para obter mais informações sobre como utilizar <xref:System.Windows.FrameworkElement.LogicalChildren%2A>e AddLogicalChild, consulte [árvores no WPF](~/add/includes/ajax-current-ext-md.md).</xref:System.Windows.FrameworkElement.LogicalChildren%2A>       AddLogicalChild poderá gerar uma exceção se a chamada num momento quando árvore lógica está a ser iterated por outro processo."
  example:
  - "The following example implements a `Child` property on a custom <xref:System.Windows.FrameworkElement> that does its own visual layer implementation. The property setter is designed so that if the value changes, the old value is removed from the logical tree, as well as a class-specific visual collection. The property value is cached, and then the new value is added to both the logical tree and the custom visual collection.  \n  \n [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/add/codesnippet/visualbasic/compositiontargetrenderinganimations/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]\n [!code-cs[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/add/codesnippet/csharp/CompositionTargetRenderingAnimations/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]"
  syntax:
    content: protected void AddLogicalChild (object child);
    parameters:
    - id: child
      type: System.Object
      description: "Elemento subordinado a adicionar."
  overload: System.Windows.FrameworkElement.AddLogicalChild*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ApplyTemplate
  id: ApplyTemplate
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ApplyTemplate()
  nameWithType: FrameworkElement.ApplyTemplate()
  fullName: System.Windows.FrameworkElement.ApplyTemplate()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Baseia-se a árvore de visual o modelo atual, se necessário e devolve um valor que indica se a árvore visual foi reconstruída por esta chamada."
  remarks: "As aplicações podem chamar este método para garantir que a árvore de um elemento visual está concluída. Este passo de garantia poderá ser necessário se o código irá ser verificar os elementos subordinados na árvore. Para a lógica de elemento típico dentro de aplicações, chamar ApplyTemplate não é necessário, porque os modelos serão aplicados em elementos de um momento apropriada na respetiva durações automaticamente.       ApplyTemplate denomina-se em todas as medidas de passar pelo sistema de esquema ao nível do framework WPF.       <xref:System.Windows.FrameworkElement>podem utilizar as classes derivadas de <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A>processador de classe para ser notificado de cenários em que este método foi chamado explicitamente ou pelo sistema de esquema.</xref:System.Windows.FrameworkElement.OnApplyTemplate%2A></xref:System.Windows.FrameworkElement> <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A>é chamado depois do modelo é totalmente gerado e ligado à árvore lógica.</xref:System.Windows.FrameworkElement.OnApplyTemplate%2A>"
  syntax:
    content: public bool ApplyTemplate ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se os visuais que foram adicionados à árvore; Devolve <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> caso contrário."
  overload: System.Windows.FrameworkElement.ApplyTemplate*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)
  id: ArrangeCore(System.Windows.Rect)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ArrangeCore(Rect)
  nameWithType: FrameworkElement.ArrangeCore(Rect)
  fullName: System.Windows.FrameworkElement.ArrangeCore(Rect)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Implementa <xref:System.Windows.UIElement.ArrangeCore*>(definido como virtual no <xref href=&quot;System.Windows.UIElement&quot;> </xref>) e seals a implementação.</xref:System.Windows.UIElement.ArrangeCore*>"
  remarks: "Este método está selado. Para substituir a lógica no seu elemento personalizado especificamente para a passagem de dispor de esquema do elemento, a <xref:System.Windows.FrameworkElement>classe derivada tem de substituir <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>.</xref:System.Windows.FrameworkElement.ArrangeOverride%2A> </xref:System.Windows.FrameworkElement>"
  syntax:
    content: protected override sealed void ArrangeCore (System.Windows.Rect finalRect);
    parameters:
    - id: finalRect
      type: System.Windows.Rect
      description: "A área final no principal que este elemento deve utilizar para dispor próprio e os respectivos valores secundários."
  overload: System.Windows.FrameworkElement.ArrangeCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)
  id: ArrangeOverride(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ArrangeOverride(Size)
  nameWithType: FrameworkElement.ArrangeOverride(Size)
  fullName: System.Windows.FrameworkElement.ArrangeOverride(Size)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Quando substituí-lo de uma classe derivada, posições elementos subordinados e determina um tamanho para um <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref> classe derivada."
  syntax:
    content: protected virtual System.Windows.Size ArrangeOverride (System.Windows.Size finalSize);
    parameters:
    - id: finalSize
      type: System.Windows.Size
      description: "A área final no principal que este elemento deve utilizar para dispor próprio e os respectivos valores secundários."
    return:
      type: System.Windows.Size
      description: "O tamanho real utilizado."
  overload: System.Windows.FrameworkElement.ArrangeOverride*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BeginInit
  id: BeginInit
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BeginInit()
  nameWithType: FrameworkElement.BeginInit()
  fullName: System.Windows.FrameworkElement.BeginInit()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicia o processo de inicialização para este elemento."
  remarks: "Pode chamar este método em elementos individuais se são ajustá-los de formas que ainda não expõe ou ligar o elemento à árvore qualquer elemento. Por exemplo, pode ter criado um novo <xref:System.Windows.FrameworkElement>, mas ainda não tiver ainda ligado-lo para qualquer árvore lógica.</xref:System.Windows.FrameworkElement> Em alternativa, árvore lógica em que o elemento é um elemento subordinado dentro da mesma poderá não estar ligado uma janela ou a página da aplicação."
  syntax:
    content: public virtual void BeginInit ();
    parameters: []
  overload: System.Windows.FrameworkElement.BeginInit*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  id: BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BeginStoryboard(Storyboard)
  nameWithType: FrameworkElement.BeginStoryboard(Storyboard)
  fullName: System.Windows.FrameworkElement.BeginStoryboard(Storyboard)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Começa a sequência de ações que estão contidas no guião gráfico principal fornecido."
  remarks: "Cenários de animação mais típicos não utilizam este método. Normalmente, crie o <xref:System.Windows.Media.Animation.Storyboard>ou <xref:System.Windows.Media.Animation.BeginStoryboard>elemento no markup e, em seguida, coloque como o <xref:System.Windows.EventTrigger>conteúdo num elemento.</xref:System.Windows.EventTrigger> </xref:System.Windows.Media.Animation.BeginStoryboard> </xref:System.Windows.Media.Animation.Storyboard> Quando é acionada pelo evento, é executada, em seguida, a animação. Maioria dos aspetos de controlo de um <xref:System.Windows.Media.Animation.Storyboard>pode ser resolvido pela propriedades que estão expostas no markup.</xref:System.Windows.Media.Animation.Storyboard>       Para as assinaturas que não utilizam o `isControllable`, parâmetro ou quando este parâmetro for especificado `false`, os relógios de linha cronológica que estão associados a animação são removidos assim que a animação atinge o período &quot;Preenchimento&quot;. Por conseguinte, não é possível reiniciar a animação depois de executar uma vez. Controlar uma animação também requer que o storyboard têm um [x: nome da diretiva](~/add/includes/ajax-current-ext-md.md) ou estar acessível por referência no código."
  example:
  - "The following example retrieves a <xref:System.Windows.Media.Animation.Storyboard> from resources, and then runs that <xref:System.Windows.Media.Animation.Storyboard> when an internal event is class handled.  \n  \n [!code-vb[CubeAnimation#FEBeginStoryboard](~/add/codesnippet/visualbasic/cubeanimation_xbap/page1.xaml.vb#febeginstoryboard)]\n [!code-cs[CubeAnimation#FEBeginStoryboard](~/add/codesnippet/csharp/CubeAnimation_XBAP/Page1.xaml.cs#febeginstoryboard)]"
  syntax:
    content: public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);
    parameters:
    - id: storyboard
      type: System.Windows.Media.Animation.Storyboard
      description: "O storyboard para começar."
  overload: System.Windows.FrameworkElement.BeginStoryboard*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  id: BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BeginStoryboard(Storyboard,HandoffBehavior)
  nameWithType: FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior)
  fullName: System.Windows.FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Começa a sequência de ações contidas no guião gráfico principal fornecido, com opções especificadas para que deve acontecer se a propriedade já está a ser animada."
  remarks: "Cenários de animação mais típicos não utilizam este método. Normalmente, crie o <xref:System.Windows.Media.Animation.Storyboard>ou <xref:System.Windows.Media.Animation.BeginStoryboard>elemento no markup e, em seguida, coloque como o <xref:System.Windows.EventTrigger>conteúdo num elemento.</xref:System.Windows.EventTrigger> </xref:System.Windows.Media.Animation.BeginStoryboard> </xref:System.Windows.Media.Animation.Storyboard> Quando é acionada pelo evento, é executada, em seguida, a animação. Maioria dos aspetos de controlo de um <xref:System.Windows.Media.Animation.Storyboard>pode ser resolvido pela propriedades que estão expostas no markup.</xref:System.Windows.Media.Animation.Storyboard>       Para as assinaturas que não utilizam o `isControllable`, parâmetro ou quando este parâmetro for especificado `false`, os relógios de linha cronológica que estão associados a animação são removidos assim que a animação atinge o período &quot;Preenchimento&quot;. Por conseguinte, não é possível reiniciar a animação depois de executar uma vez. Controlar uma animação também requer que o storyboard têm um [x: nome da diretiva](~/add/includes/ajax-current-ext-md.md) ou estar acessível por referência no código.       Comportamento de handoff pode ser especificado como um atributo de <xref:System.Windows.Media.Animation.BeginStoryboard>.</xref:System.Windows.Media.Animation.BeginStoryboard>      ## Utilizando a compor HandoffBehavior quando aplica um <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, ou <xref:System.Windows.Media.Animation.AnimationClock>para uma propriedade utilizando o <xref:System.Windows.Media.Animation.HandoffBehavior> <xref:System.Windows.Media.Animation.HandoffBehavior>, qualquer <xref:System.Windows.Media.Animation.Clock>objetos anteriormente associados essa propriedade continuam a consumir recursos de sistema; o sistema de temporização não remove automaticamente os relógios.</xref:System.Windows.Media.Animation.Clock> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.AnimationTimeline> </xref:System.Windows.Media.Animation.Storyboard>       Para evitar problemas de desempenho ao aplicar um grande número de relógios utilizando <xref:System.Windows.Media.Animation.HandoffBehavior>, deve remover os relógios composição da propriedade animada depois de estarem concluídas.</xref:System.Windows.Media.Animation.HandoffBehavior> Existem várias formas para remover um relógio: - para remover todos os relógios de uma propriedade, utilize o <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>ou <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>método do objeto animado.</xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> </xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> Especifique a propriedade que está a ser animada como o primeiro parâmetro e `null` como o segundo. Esta ação remove todos os relógios de animação da propriedade.      -Para remover um específico <xref:System.Windows.Media.Animation.AnimationClock>de uma lista de relógios, utilize a <xref:System.Windows.Media.Animation.Clock.Controller%2A>propriedade de <xref:System.Windows.Media.Animation.AnimationClock>obter um <xref:System.Windows.Media.Animation.ClockController>em seguida, chame o <xref:System.Windows.Media.Animation.ClockController.Remove%2A>método de <xref:System.Windows.Media.Animation.ClockController>.</xref:System.Windows.Media.Animation.ClockController> </xref:System.Windows.Media.Animation.ClockController.Remove%2A> </xref:System.Windows.Media.Animation.ClockController> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.AnimationClock> Isto é geralmente feito o <xref:System.Windows.Media.Animation.Clock.Completed>processador de eventos para um clock.</xref:System.Windows.Media.Animation.Clock.Completed> Tenha em atenção que os relógios de raiz apenas podem ser controlados por um <xref:System.Windows.Media.Animation.ClockController>; o <xref:System.Windows.Media.Animation.Clock.Controller%2A>devolve de propriedade de um relógio subordinado `null`.</xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.ClockController> Tenha em atenção que o <xref:System.Windows.Media.Animation.Clock.Completed>o evento não é gerado se a duração efetiva do relógio é indefinidamente.</xref:System.Windows.Media.Animation.Clock.Completed>  Nesse caso, o utilizador tem de determinar quando deve chamar <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</xref:System.Windows.Media.Animation.ClockController.Remove%2A>       Isto é principalmente um problema para animações em objetos que têm uma duração de tempo.  Quando um objeto é memória libertada, os relógios também estiver desligados e libertação da memória.       Para obter mais informações sobre os objetos de relógio, consulte [animação e descrição geral do sistema de temporização](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example retrieves a <xref:System.Windows.Media.Animation.Storyboard> from resources, and then runs that <xref:System.Windows.Media.Animation.Storyboard> when an internal event is class handled.  \n  \n [!code-vb[CubeAnimation#FEBeginStoryboard](~/add/codesnippet/visualbasic/cubeanimation_xbap/page1.xaml.vb#febeginstoryboard)]\n [!code-cs[CubeAnimation#FEBeginStoryboard](~/add/codesnippet/csharp/CubeAnimation_XBAP/Page1.xaml.cs#febeginstoryboard)]"
  syntax:
    content: public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);
    parameters:
    - id: storyboard
      type: System.Windows.Media.Animation.Storyboard
      description: "O storyboard para começar."
    - id: handoffBehavior
      type: System.Windows.Media.Animation.HandoffBehavior
      description: "Um valor de enumeração que descreve o comportamento a utilizar se uma propriedade descrita de guião gráfico principal já está a ser animado."
  overload: System.Windows.FrameworkElement.BeginStoryboard*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  id: BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  nameWithType: FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  fullName: System.Windows.FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Começa a sequência de ações contidas no guião gráfico principal fornecido com o estado especificado para o controlo da animação depois de ser iniciado."
  remarks: "Cenários de animação mais típicos não utilizam este método. Normalmente, crie o <xref:System.Windows.Media.Animation.Storyboard>ou <xref:System.Windows.Media.Animation.BeginStoryboard>elemento no markup e, em seguida, coloque como o <xref:System.Windows.EventTrigger>conteúdo num elemento.</xref:System.Windows.EventTrigger> </xref:System.Windows.Media.Animation.BeginStoryboard> </xref:System.Windows.Media.Animation.Storyboard> Quando é acionada pelo evento, é executada, em seguida, a animação. Maioria dos aspetos de controlo de um <xref:System.Windows.Media.Animation.Storyboard>pode ser resolvido pela propriedades que estão expostas no markup.</xref:System.Windows.Media.Animation.Storyboard>       Para as assinaturas que não utilizam o `isControllable`, parâmetro ou quando este parâmetro for especificado `false`, os relógios de linha cronológica que estão associados a animação são removidos assim que a animação atinge o período &quot;Preenchimento&quot;. Por conseguinte, não é possível reiniciar a animação depois de executar uma vez. Controlar uma animação também requer que o storyboard têm um [x: nome da diretiva](~/add/includes/ajax-current-ext-md.md) ou estar acessível por referência no código.       Comportamento de handoff pode ser especificado como um atributo de <xref:System.Windows.Media.Animation.BeginStoryboard>.</xref:System.Windows.Media.Animation.BeginStoryboard>      ## Utilizando a compor HandoffBehavior quando aplica um <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, ou <xref:System.Windows.Media.Animation.AnimationClock>para uma propriedade utilizando o <xref:System.Windows.Media.Animation.HandoffBehavior> <xref:System.Windows.Media.Animation.HandoffBehavior>, qualquer <xref:System.Windows.Media.Animation.Clock>objetos anteriormente associados essa propriedade continuam a consumir recursos de sistema; o sistema de temporização não remove automaticamente os relógios.</xref:System.Windows.Media.Animation.Clock> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.AnimationTimeline> </xref:System.Windows.Media.Animation.Storyboard>       Para evitar problemas de desempenho ao aplicar um grande número de relógios utilizando <xref:System.Windows.Media.Animation.HandoffBehavior>, deve remover os relógios composição da propriedade animada depois de estarem concluídas.</xref:System.Windows.Media.Animation.HandoffBehavior> Existem várias formas para remover um relógio: - para remover todos os relógios de uma propriedade, utilize o <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>ou <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>método do objeto animado.</xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> </xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> Especifique a propriedade que está a ser animada como o primeiro parâmetro e `null` como o segundo. Esta ação remove todos os relógios de animação da propriedade.      -Para remover um específico <xref:System.Windows.Media.Animation.AnimationClock>de uma lista de relógios, utilize a <xref:System.Windows.Media.Animation.Clock.Controller%2A>propriedade de <xref:System.Windows.Media.Animation.AnimationClock>obter um <xref:System.Windows.Media.Animation.ClockController>em seguida, chame o <xref:System.Windows.Media.Animation.ClockController.Remove%2A>método de <xref:System.Windows.Media.Animation.ClockController>.</xref:System.Windows.Media.Animation.ClockController> </xref:System.Windows.Media.Animation.ClockController.Remove%2A> </xref:System.Windows.Media.Animation.ClockController> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.AnimationClock> Isto é geralmente feito o <xref:System.Windows.Media.Animation.Clock.Completed>processador de eventos para um clock.</xref:System.Windows.Media.Animation.Clock.Completed> Tenha em atenção que os relógios de raiz apenas podem ser controlados por um <xref:System.Windows.Media.Animation.ClockController>; o <xref:System.Windows.Media.Animation.Clock.Controller%2A>devolve de propriedade de um relógio subordinado `null`.</xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.ClockController> Tenha em atenção que o <xref:System.Windows.Media.Animation.Clock.Completed>o evento não é gerado se a duração efetiva do relógio é indefinidamente.</xref:System.Windows.Media.Animation.Clock.Completed>  Nesse caso, o utilizador tem de determinar quando deve chamar <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</xref:System.Windows.Media.Animation.ClockController.Remove%2A>       Isto é principalmente um problema para animações em objetos que têm uma duração de tempo.  Quando um objeto é memória libertada, os relógios também estiver desligados e libertação da memória.       Para obter mais informações sobre os objetos de relógio, consulte [animação e descrição geral do sistema de temporização](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);
    parameters:
    - id: storyboard
      type: System.Windows.Media.Animation.Storyboard
      description: "O storyboard para começar."
    - id: handoffBehavior
      type: System.Windows.Media.Animation.HandoffBehavior
      description: "Um valor de enumeração que descreve o comportamento a utilizar se uma propriedade descrita de guião gráfico principal já está a ser animado."
    - id: isControllable
      type: System.Boolean
      description: "Declara se a animação é controllable (pode ser colocado em pausa) depois de ser iniciado."
  overload: System.Windows.FrameworkElement.BeginStoryboard*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BindingGroup
  id: BindingGroup
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BindingGroup
  nameWithType: FrameworkElement.BindingGroup
  fullName: System.Windows.FrameworkElement.BindingGroup
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define o <xref href=&quot;System.Windows.Data.BindingGroup&quot;> </xref> que é utilizado para o elemento."
  remarks: "A <xref:System.Windows.Data.BindingGroup>podem ser utilizados para validar os valores de várias propriedades de um objeto.</xref:System.Windows.Data.BindingGroup> Por exemplo, suponha que uma aplicação pede ao utilizador para introduzir um endereço e, em seguida, preenche um objeto do tipo `Address`, que tem as propriedades `Street`, `City`, `ZipCode`, e `Country`, com os valores que o utilizador forneceu. A aplicação tem um painel que contém quatro <xref:System.Windows.Controls.TextBox>controlos, cada um dos quais está vinculada a uma das propriedades do objeto.</xref:System.Windows.Controls.TextBox> Pode utilizar um <xref:System.Windows.Controls.ValidationRule>num <xref:System.Windows.Data.BindingGroup>para validar o `Address` objeto.</xref:System.Windows.Data.BindingGroup> </xref:System.Windows.Controls.ValidationRule> Por exemplo, o <xref:System.Windows.Controls.ValidationRule>pode Certifique-se de que o código postal válido para o país/região do endereço.</xref:System.Windows.Controls.ValidationRule>       Elementos subordinados herdam o <xref:System.Windows.Data.BindingGroup>dos respetivos elementos principais, apenas tal como acontece com quaisquer outras propriedade herdável.</xref:System.Windows.Data.BindingGroup>      <a name=&quot;dependencyPropertyInfo_BindingGroup&quot;></a># # Informações de propriedade de dependência |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.BindingGroupProperty>|   | Definir propriedades de metadados **verdadeiro**|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkElement.BindingGroupProperty>"
  example:
  - "The following examples are part of an application that checks whether the user has set the properties of two objects to equal values. The first example creates two <xref:System.Windows.Controls.TextBox> controls, each of which is bound to a different data source. The <xref:System.Windows.Controls.StackPanel> has a <xref:System.Windows.Data.BindingGroup> that contains a <xref:System.Windows.Controls.ValidationRule> that checks that the two strings are equal.  \n  \n [!code-xml[BindingGroupSnippets#BindingGroupComplete](~/add/codesnippet/xaml/BindingGroupSnippets/Window3.xaml#bindinggroupcomplete)]  \n  \n The following example shows the <xref:System.Windows.Controls.ValidationRule> that the previous example uses.  In the <xref:System.Windows.Controls.ValidationRule.Validate%2A> method override, the example gets each source object from the <xref:System.Windows.Data.BindingGroup> and checks whether the properties of the objects are equal.  \n  \n [!code-cs[BindingGroupSnippets#BindingGroupNameValidationRule](~/add/codesnippet/csharp/BindingGroupSnippets/Window3.xaml.cs#bindinggroupnamevalidationrule)]\n [!code-vb[BindingGroupSnippets#BindingGroupNameValidationRule](~/add/codesnippet/visualbasic/bindinggroupsnippets/window3.xaml.vb#bindinggroupnamevalidationrule)]  \n  \n To invoke the <xref:System.Windows.Controls.ValidationRule>, call the <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> method.  The following example calls <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> when the click event of the button occurs.  \n  \n [!code-cs[BindingGroupSnippets#UpdateSourcesClick](~/add/codesnippet/csharp/BindingGroupSnippets/Window3.xaml.cs#updatesourcesclick)]\n [!code-vb[BindingGroupSnippets#UpdateSourcesClick](~/add/codesnippet/visualbasic/bindinggroupsnippets/window3.xaml.vb#updatesourcesclick)]"
  syntax:
    content: public System.Windows.Data.BindingGroup BindingGroup { get; set; }
    return:
      type: System.Windows.Data.BindingGroup
      description: "O <xref href=&quot;System.Windows.Data.BindingGroup&quot;> </xref> que é utilizado para o elemento."
  overload: System.Windows.FrameworkElement.BindingGroup*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BindingGroupProperty
  id: BindingGroupProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BindingGroupProperty
  nameWithType: FrameworkElement.BindingGroupProperty
  fullName: System.Windows.FrameworkElement.BindingGroupProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.BindingGroup*>propriedade de dependência.</xref:System.Windows.FrameworkElement.BindingGroup*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty BindingGroupProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BringIntoView
  id: BringIntoView
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BringIntoView()
  nameWithType: FrameworkElement.BringIntoView()
  fullName: System.Windows.FrameworkElement.BringIntoView()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Tentativas para colocar este elemento numa vista, dentro de qualquer regiões deslocável que está contido dentro de mensagens em fila."
  remarks: "Ao chamar este método, emitir uma <xref:System.Windows.FrameworkElement.RequestBringIntoView>eventos que origina do elemento actual.</xref:System.Windows.FrameworkElement.RequestBringIntoView> Este evento é desencadeado para que pode ser processada por um <xref:System.Windows.Controls.ScrollViewer>, ou uma classe derivada ou semelhante.</xref:System.Windows.Controls.ScrollViewer> O comportamento esperado é que o evento é processado pelo elemento principal, marcado processado nos dados de evento, e a origem do evento seja colocada numa vista através de lógica incorporada a <xref:System.Windows.Controls.ScrollViewer>controlo.</xref:System.Windows.Controls.ScrollViewer> Nem o <xref:System.Windows.FrameworkElement.RequestBringIntoView>eventos nem o método BringIntoView transmitir quaisquer informações sobre êxito ou falha, exceto que o evento é normalmente marcado processado no êxito.</xref:System.Windows.FrameworkElement.RequestBringIntoView> Motivos da falha podem incluir as definições de elemento, tais como <xref:System.Windows.UIElement.Visibility%2A>a ser um valor que não sejam <xref:System.Windows.Visibility>.</xref:System.Windows.Visibility> </xref:System.Windows.UIElement.Visibility%2A>       Se utilizar a assinatura não especifica um `targetRectangle`, em seguida, o tamanho do elemento todo (respetivo <xref:System.Windows.UIElement.RenderSize%2A>) irá ser tornado visível.</xref:System.Windows.UIElement.RenderSize%2A>       Ao chamar este método, potencialmente irá chamar <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A>em qualquer área deslocável principal que contém o elemento.</xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> Se este elemento não está contido numa área deslocável, o <xref:System.Windows.FrameworkElement.RequestBringIntoView>evento ainda é gerado, mas será possível sem qualquer efeito porque não existem nenhuma escuta de eventos.</xref:System.Windows.FrameworkElement.RequestBringIntoView>"
  example:
  - "The following example implements a handler for an application navigation event that responds whenever the [!INCLUDE[TLA#tla_uri](~/add/includes/tlasharptla-uri-md.md)] being navigated to includes a fragment. The fragment is named in the [!INCLUDE[TLA2#tla_uri](~/add/includes/tla2sharptla-uri-md.md)] following the hash sign (#), and the implemented behavior causes the element to scroll into view within the frame. BringIntoView and <xref:System.Windows.FrameworkElement.RequestBringIntoView> request that scrolling behavior in the example.  \n  \n [!code-vb[FragmentNavigationSample#FEBringIntoView](~/add/codesnippet/visualbasic/FragmentNavigationSampleVisualBasic/MainWindow.xaml.vb#febringintoview)]\n [!code-cs[FragmentNavigationSample#FEBringIntoView](~/add/codesnippet/csharp/FragmentNavigationSample/MainWindow.xaml.cs#febringintoview)]"
  syntax:
    content: public void BringIntoView ();
    parameters: []
  overload: System.Windows.FrameworkElement.BringIntoView*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)
  id: BringIntoView(System.Windows.Rect)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BringIntoView(Rect)
  nameWithType: FrameworkElement.BringIntoView(Rect)
  fullName: System.Windows.FrameworkElement.BringIntoView(Rect)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Tentativas para colocar o tamanho de região fornecido deste elemento numa vista, dentro de qualquer regiões deslocável que está contido no."
  remarks: "Ao chamar este método, emitir uma <xref:System.Windows.FrameworkElement.RequestBringIntoView>eventos que origina do elemento actual.</xref:System.Windows.FrameworkElement.RequestBringIntoView> Este evento é desencadeado para que pode ser processada por um <xref:System.Windows.Controls.ScrollViewer>, ou uma classe derivada ou semelhante.</xref:System.Windows.Controls.ScrollViewer> O comportamento esperado é que o evento é processado pelo elemento principal, marcado processado nos dados de evento, e a origem do evento seja colocada numa vista através de lógica incorporada a <xref:System.Windows.Controls.ScrollViewer>controlo.</xref:System.Windows.Controls.ScrollViewer> Nem o <xref:System.Windows.FrameworkElement.RequestBringIntoView>eventos nem o <xref:System.Windows.FrameworkElement.BringIntoView%2A>método transmitir quaisquer informações sobre êxito ou falha, exceto que o evento é normalmente marcado processado no êxito.</xref:System.Windows.FrameworkElement.BringIntoView%2A> </xref:System.Windows.FrameworkElement.RequestBringIntoView> Motivos da falha podem incluir as definições de elemento, tais como <xref:System.Windows.UIElement.Visibility%2A>a ser um valor que não sejam <xref:System.Windows.Visibility>.</xref:System.Windows.Visibility> </xref:System.Windows.UIElement.Visibility%2A>       Se utilizar a assinatura não especifica um `targetRectangle`, em seguida, o tamanho do elemento todo (respetivo <xref:System.Windows.UIElement.RenderSize%2A>) irá ser tornado visível.</xref:System.Windows.UIElement.RenderSize%2A>       Ao chamar este método, potencialmente irá chamar <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A>em qualquer área deslocável principal que contém o elemento.</xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> Se este elemento não está contido numa área deslocável, o <xref:System.Windows.FrameworkElement.RequestBringIntoView>evento ainda é gerado, mas será possível sem qualquer efeito porque não existem nenhuma escuta de eventos.</xref:System.Windows.FrameworkElement.RequestBringIntoView>"
  example:
  - "The following example has a large graphic in a constrained scrolling region. A button on the page has a handler that scrolls the view to a particular region of the large graphic.  \n  \n [!code-xml[BaseElementsSmorgasbord#BringIntoViewRectMarkup](~/add/codesnippet/xaml/BaseElementsSmorgasbord/Page1.xaml#bringintoviewrectmarkup)]  \n  \n [!code-cs[BaseElementsSmorgasbord#BringIntoViewRectCode](~/add/codesnippet/csharp/BaseElementsSmorgasbord/Page1.xaml.cs#bringintoviewrectcode)]\n [!code-vb[BaseElementsSmorgasbord#BringIntoViewRectCode](~/add/codesnippet/visualbasic/baseelementssmorgasbord/page1.xaml.vb#bringintoviewrectcode)]"
  syntax:
    content: public void BringIntoView (System.Windows.Rect targetRectangle);
    parameters:
    - id: targetRectangle
      type: System.Windows.Rect
      description: "Tamanho especificado do elemento que também deve ser colocado numa vista."
  overload: System.Windows.FrameworkElement.BringIntoView*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ContextMenu
  id: ContextMenu
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ContextMenu
  nameWithType: FrameworkElement.ContextMenu
  fullName: System.Windows.FrameworkElement.ContextMenu
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define o elemento de menu de contexto que deve ser apresentadas sempre que o menu de contexto é solicitado através de [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] neste elemento."
  remarks: "<xref:System.Windows.Controls.ContextMenu>propriamente dito é um <xref:System.Windows.FrameworkElement>classe derivada e é tecnicamente possível <xref:System.Windows.Controls.ContextMenu>automaticamente para ter uma propriedade ContextMenu.</xref:System.Windows.Controls.ContextMenu> </xref:System.Windows.FrameworkElement></xref:System.Windows.Controls.ContextMenu> No entanto, esta ação cria uma experiência de menu de contexto confuso para o utilizador e esta prática não é recomendada.      <a name=&quot;dependencyPropertyInfo_ContextMenu&quot;></a># # Informações de propriedade de dependência |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.ContextMenuProperty>|   | Definir propriedades de metadados `true`| Nenhum |</xref:System.Windows.FrameworkElement.ContextMenuProperty>"
  syntax:
    content: public System.Windows.Controls.ContextMenu ContextMenu { get; set; }
    return:
      type: System.Windows.Controls.ContextMenu
      description: "O menu de contexto atribuído a este elemento."
  overload: System.Windows.FrameworkElement.ContextMenu*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ContextMenuClosing
  id: ContextMenuClosing
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ContextMenuClosing
  nameWithType: FrameworkElement.ContextMenuClosing
  fullName: System.Windows.FrameworkElement.ContextMenuClosing
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre antes de qualquer menu de contexto no elemento está fechado."
  remarks: "Para suprimir o fecho menus de contexto, os processadores do evento devem marcá-lo como processado.       Para utilizar este evento como uma <xref:System.Windows.EventTrigger>num style, tem de referenciar a definição do serviço subjacente do evento: [!code-xml [CorePseudocode #FEContextMenuClosing](~/add/codesnippet/xaml/CorePseudocode/pseudocode.xaml#fecontextmenuclosing) ] (esta utilização é necessária porque a implementação de eventos no <xref:System.Windows.FrameworkElement>que expõe subjacentes evento de serviço não está mapeado o identificador de ContextMenuClosing que pode utilizá-lo como um acionador).</xref:System.Windows.FrameworkElement> </xref:System.Windows.EventTrigger>       <xref:System.Windows.Controls.ContextMenu>propriamente dito é um <xref:System.Windows.FrameworkElement>classe derivada, mas o evento ContextMenuClosing não será gerado por um menu de contexto diretamente.</xref:System.Windows.FrameworkElement></xref:System.Windows.Controls.ContextMenu> Em vez disso, o evento é desencadeado do elemento que é &quot;proprietário&quot; o menu de contexto como uma propriedade e apenas é gerado quando um utilizador tenta fechar o menu de contexto na IU. No entanto, é possível que <xref:System.Windows.Controls.ContextMenu>automaticamente para ter um <xref:System.Windows.FrameworkElement.ContextMenu%2A>propriedade (um menu de contexto aninhadas).</xref:System.Windows.FrameworkElement.ContextMenu%2A> </xref:System.Windows.Controls.ContextMenu> Neste caso, o <xref:System.Windows.Controls.ContextMenu>realmente é proprietário de aninhada <xref:System.Windows.Controls.ContextMenu>e pode aumentar o evento, com a origem do evento que está a ser o menu de contexto aninhados.</xref:System.Windows.Controls.ContextMenu> </xref:System.Windows.Controls.ContextMenu>       O <xref:System.Windows.Controls.ContextMenu>própria classe também tem um evento semelhante (<xref:System.Windows.Controls.ContextMenu.Closed>), mas a <xref:System.Windows.Controls.ContextMenu.Closed>evento não fornecer-lhe a oportunidade para cancelar a ação do utilizador.</xref:System.Windows.Controls.ContextMenu.Closed> </xref:System.Windows.Controls.ContextMenu.Closed> </xref:System.Windows.Controls.ContextMenu>      <a name=&quot;routedEventInfo_ContextMenuClosing&quot;></a># # Encaminhados informações sobre eventos |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.ContextMenuClosingEvent>|   | Estratégia de encaminhamento | Bubbling |   | Delegado | <xref:System.Windows.Controls.ContextMenuEventHandler>|      -Ignorar <xref:System.Windows.FrameworkElement.OnContextMenuClosing%2A>para implementar a classe de processamento para este evento em classes derivadas.</xref:System.Windows.FrameworkElement.OnContextMenuClosing%2A> </xref:System.Windows.Controls.ContextMenuEventHandler> </xref:System.Windows.FrameworkElement.ContextMenuClosingEvent>"
  syntax:
    content: public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;
    return:
      type: System.Windows.Controls.ContextMenuEventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ContextMenuClosingEvent
  id: ContextMenuClosingEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ContextMenuClosingEvent
  nameWithType: FrameworkElement.ContextMenuClosingEvent
  fullName: System.Windows.FrameworkElement.ContextMenuClosingEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref href=&quot;System.Windows.FrameworkElement.ContextMenuClosing&quot;> </xref> evento encaminhado."
  remarks: "Os identificadores de evento encaminhado são criados quando eventos encaminhados estão registados. Estes identificadores contenham um nome de identificação, tipo de proprietário, tipo de processador, estratégia de encaminhamento e método do utilitário para adicionar os proprietários para o evento. Pode utilizar estes identificadores para adicionar processadores de classe.       Para obter mais informações sobre como registar eventos encaminhados, consulte <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A> Para obter mais informações sobre como utilizar identificadores de evento encaminhado para adicionar processadores de classe, consulte <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</xref:System.Windows.EventManager.RegisterClassHandler%2A>"
  syntax:
    content: public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ContextMenuOpening
  id: ContextMenuOpening
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ContextMenuOpening
  nameWithType: FrameworkElement.ContextMenuOpening
  fullName: System.Windows.FrameworkElement.ContextMenuOpening
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando qualquer menu de contexto no elemento é aberto."
  remarks: "Para abrir manualmente menus de contexto, processadores de eventos devem marcar os eventos relevantes como processado. Caso contrário, o valor existente a <xref:System.Windows.FrameworkElement.ContextMenu%2A>propriedade será utilizada para abrir automaticamente um menu de contexto.</xref:System.Windows.FrameworkElement.ContextMenu%2A> Marcar o evento processado eficazmente cancelará a ação predefinida e pode ser uma oportunidade para repor o valor da <xref:System.Windows.FrameworkElement.ContextMenu%2A>propriedade e, em seguida, abra o novo <xref:System.Windows.Controls.ContextMenu>.</xref:System.Windows.Controls.ContextMenu> </xref:System.Windows.FrameworkElement.ContextMenu%2A> No entanto, há um problema de temporização que deve ter em consideração. Para substituir completamente o menu de contexto através de um processador ContextMenuOpening, o menu de contexto inicial não pode ser nulo / vazio. Em alternativa, poderá ter de processar o evento e, em seguida, abra manualmente um menu de contexto de novo. Para obter mais informações, consulte [como: processar o evento ContextMenuOpening](~/add/includes/ajax-current-ext-md.md).       Para utilizar este evento como uma <xref:System.Windows.EventTrigger>num style, tem de referenciar o evento anexado subjacente: [!code-xml [CorePseudocode #FEContextMenuOpening](~/add/codesnippet/xaml/CorePseudocode/pseudocode.xaml#fecontextmenuopening) ] (esta utilização é necessária porque a implementação de eventos no <xref:System.Windows.FrameworkElement>que expõe subjacentes evento de serviço não está mapeado o identificador de ContextMenuOpening que pode utilizá-lo no acionadores).</xref:System.Windows.FrameworkElement> </xref:System.Windows.EventTrigger>       <xref:System.Windows.Controls.ContextMenu>propriamente dito é um <xref:System.Windows.FrameworkElement>classe derivada, mas este evento não será gerado no menu de contexto, que está a ser aberto como uma origem.</xref:System.Windows.FrameworkElement></xref:System.Windows.Controls.ContextMenu> O evento é desencadeado do elemento que é &quot;proprietário&quot; o menu de contexto como uma propriedade e apenas é gerado quando um utilizador tenta abrir um menu de contexto na IU. É possível <xref:System.Windows.Controls.ContextMenu>automaticamente para ter um <xref:System.Windows.FrameworkElement.ContextMenu%2A>propriedade, mas deve evitar este cenário (para obter mais informações, consulte <xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=fullName>).</xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=fullName> </xref:System.Windows.FrameworkElement.ContextMenu%2A> </xref:System.Windows.Controls.ContextMenu>       O <xref:System.Windows.Controls.ContextMenu>própria classe também tem um evento semelhante (<xref:System.Windows.Controls.ContextMenu.Opened>) mas <xref:System.Windows.Controls.ContextMenu.Opened>não fornecer-lhe a oportunidade para cancelar a ação do utilizador.</xref:System.Windows.Controls.ContextMenu.Opened> </xref:System.Windows.Controls.ContextMenu.Opened> </xref:System.Windows.Controls.ContextMenu>      <a name=&quot;routedEventInfo_ContextMenuOpening&quot;></a># # Encaminhados informações sobre eventos |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.ContextMenuOpeningEvent>|   | Estratégia de encaminhamento | Bubbling |   | Delegado | <xref:System.Windows.Controls.ContextMenuEventHandler>|      -Ignorar <xref:System.Windows.FrameworkElement.OnContextMenuOpening%2A>para implementar a classe de processamento para este evento em classes derivadas.</xref:System.Windows.FrameworkElement.OnContextMenuOpening%2A> </xref:System.Windows.Controls.ContextMenuEventHandler> </xref:System.Windows.FrameworkElement.ContextMenuOpeningEvent>"
  syntax:
    content: public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;
    return:
      type: System.Windows.Controls.ContextMenuEventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ContextMenuOpeningEvent
  id: ContextMenuOpeningEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ContextMenuOpeningEvent
  nameWithType: FrameworkElement.ContextMenuOpeningEvent
  fullName: System.Windows.FrameworkElement.ContextMenuOpeningEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref href=&quot;System.Windows.FrameworkElement.ContextMenuOpening&quot;> </xref> evento encaminhado."
  remarks: "Os identificadores de evento encaminhado são criados quando eventos encaminhados estão registados. Estes identificadores contenham um nome de identificação, tipo de proprietário, tipo de processador, estratégia de encaminhamento e método do utilitário para adicionar os proprietários para o evento. Pode utilizar estes identificadores para adicionar processadores de classe.       Para obter mais informações sobre como registar eventos encaminhados, consulte <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A> Para obter mais informações sobre como utilizar identificadores de evento encaminhado para adicionar processadores de classe, consulte <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</xref:System.Windows.EventManager.RegisterClassHandler%2A>"
  syntax:
    content: public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ContextMenuProperty
  id: ContextMenuProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ContextMenuProperty
  nameWithType: FrameworkElement.ContextMenuProperty
  fullName: System.Windows.FrameworkElement.ContextMenuProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.ContextMenu*>propriedade de dependência.</xref:System.Windows.FrameworkElement.ContextMenu*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ContextMenuProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Cursor
  id: Cursor
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Cursor
  nameWithType: FrameworkElement.Cursor
  fullName: System.Windows.FrameworkElement.Cursor
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define o cursor que é apresentada quando o ponteiro do rato está sobre este elemento."
  remarks: "Quando definir esta propriedade [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], a [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] processador depende de conversão de tipo para o <xref:System.Windows.Input.Cursor>classe para avaliar a cadeia.</xref:System.Windows.Input.Cursor> A cadeia fornecida deve avaliar para um <xref:System.Windows.Input.CursorType>valor.</xref:System.Windows.Input.CursorType> Consulte <xref:System.Windows.Input.Cursor>para obter mais detalhes.</xref:System.Windows.Input.Cursor>       Se o cursor conforme estabelecido por esta propriedade serão ou não serão apresentados quando o ponteiro do rato está sobre este elemento também estão dependente no valor da <xref:System.Windows.FrameworkElement.ForceCursor%2A>propriedade.</xref:System.Windows.FrameworkElement.ForceCursor%2A> Além disso, considerações relacionadas com eventos, como um arrastar Active Directory, captura do rato, modos dentro e assim sucessivamente, controlos de edição de texto afetará também o cursor com prioridade mais alta do que o valor que especifica nesta propriedade.       Para reverter o comportamento de definir esta propriedade para o eventual predefinido, defina-o como `null` novamente.       O `null` predefinido realmente significa que a determinação do valor práticas cursor é deferida aqui e deve ser obtida a partir noutro local. Se apresentada sem programáticos valores de uma origem, o cursor predefinido que é mais visualmente uma [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] aplicação será uma seta. No entanto, as alterações de cursor transitório não estão definidas para os valores de Cursor dos elementos quando estes são transmitidos através de. O Cursor propriedade comunicará apenas valores não nulos existentes na casos em que foi realmente definido, para a instância através de código ou um estilo. Cada movimento do rato sobre um [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] aplicação gera um <xref:System.Windows.UIElement.QueryCursor>eventos.</xref:System.Windows.UIElement.QueryCursor> As bolhas de eventos e qualquer elemento ao longo da rota tem a oportunidade para processar o evento de e para definir o valor de cursor através de argumentos deste evento. Este é o mecanismo que produz o cursor visualmente aparente na maioria dos casos. Se um <xref:System.Windows.UIElement.QueryCursor>processador devolve um resultado de cursor, em seguida, o facto de que o evento é processado e tem um valor foi alterado nos argumentos tem precedência sobre o valor da propriedade Cursor qualquer nível, a menos que <xref:System.Windows.FrameworkElement.ForceCursor%2A>está definido.</xref:System.Windows.FrameworkElement.ForceCursor%2A> </xref:System.Windows.UIElement.QueryCursor>       Se não não estiver a criar um cursor personalizado, normalmente, defina esta propriedade para um valor de uma propriedade estática da <xref:System.Windows.Input.Cursors>classe.</xref:System.Windows.Input.Cursors> A definição de Cursor no código requer um dos seguintes:-chamar o <xref:System.Windows.Input.Cursor>construtor para obter um <xref:System.Windows.Input.Cursor>instância.</xref:System.Windows.Input.Cursor> </xref:System.Windows.Input.Cursor> Ambas as assinaturas do <xref:System.Windows.Input.Cursor>construtor utilizar fluxos ou de ficheiros, anticipation que está a criar o <xref:System.Windows.Input.Cursor>objeto para um cursor personalizado.</xref:System.Windows.Input.Cursor> </xref:System.Windows.Input.Cursor>      -Utilize o <xref:System.Windows.Input.CursorConverter>classe e a respetiva <xref:System.Windows.Input.CursorConverter.ConvertFrom%2A>método para especificar um cursor pelo <xref:System.Windows.Input.CursorType>, ou uma cadeia que pode avaliar para um <xref:System.Windows.Input.CursorType>e converter regressar ao <xref:System.Windows.Input.Cursor>.</xref:System.Windows.Input.Cursor> </xref:System.Windows.Input.CursorType> </xref:System.Windows.Input.CursorType> </xref:System.Windows.Input.CursorConverter.ConvertFrom%2A> </xref:System.Windows.Input.CursorConverter>       Definir o <xref:System.Windows.Input.Cursor>para um valor personalizado não está ativada em confiança parcial.</xref:System.Windows.Input.Cursor> Para obter mais informações sobre cursores personalizados, consulte [descrição geral de entrada](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;dependencyPropertyInfo_Cursor&quot;></a># # Informações de propriedade de dependência |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.CursorProperty>|   | Definir propriedades de metadados `true`| Nenhum |</xref:System.Windows.FrameworkElement.CursorProperty>"
  example:
  - "The following example shows how to deliberately set the cursor graphic.  \n  \n [!code-cs[cursors#ChangeCursorsSample](~/add/codesnippet/csharp/cursors/Window1.xaml.cs#changecursorssample)]\n [!code-vb[cursors#ChangeCursorsSample](~/add/codesnippet/visualbasic/cursors/Window1.xaml.vb#changecursorssample)]"
  syntax:
    content: public System.Windows.Input.Cursor Cursor { get; set; }
    return:
      type: System.Windows.Input.Cursor
      description: "O cursor a apresentar. O valor predefinido é definido como <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> por esta propriedade de dependência. No entanto, a predefinição prática em tempo de execução serão provenientes vários fatores."
  overload: System.Windows.FrameworkElement.Cursor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.CursorProperty
  id: CursorProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: CursorProperty
  nameWithType: FrameworkElement.CursorProperty
  fullName: System.Windows.FrameworkElement.CursorProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.Cursor*>propriedade de dependência.</xref:System.Windows.FrameworkElement.Cursor*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty CursorProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.DataContext
  id: DataContext
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: DataContext
  nameWithType: FrameworkElement.DataContext
  fullName: System.Windows.FrameworkElement.DataContext
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define o contexto de dados para um elemento quando que participa no enlace de dados."
  remarks: "*Contexto de dados* é um conceito que permite que os elementos herdar as informações da respetiva elementos principais sobre a origem de dados que é utilizada para enlace, bem como outras características do enlace, tais como o caminho.       Contexto de dados pode ser definido diretamente para um [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] objeto, com os vínculos avaliar para as propriedades desse objeto. Em alternativa, pode definir o contexto de dados um <xref:System.Windows.Data.DataSourceProvider>objeto.</xref:System.Windows.Data.DataSourceProvider>       Esta propriedade de dependência herde os valores de propriedade. Se existirem elementos subordinados sem outros valores para DataContext estabelecida através de valores locais ou de estilos, o sistema de propriedade definirá o valor para o valor de DataContext do elemento principal mais próximo com este valor atribuído.       Em alternativa, pode utilizar uma das seguintes propriedades do <xref:System.Windows.Data.Binding>classe para especificar explicitamente a origem de enlace: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, ou <xref:System.Windows.Data.Binding.RelativeSource%2A>.</xref:System.Windows.Data.Binding.RelativeSource%2A> </xref:System.Windows.Data.Binding.Source%2A> </xref:System.Windows.Data.Binding.ElementName%2A> </xref:System.Windows.Data.Binding> Para obter mais informações, consulte [como: Especifique a origem de enlace](~/add/includes/ajax-current-ext-md.md).       No [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], DataContext normalmente está definido como um <xref:System.Windows.Data.Binding>declaração.</xref:System.Windows.Data.Binding> Pode utilizar a sintaxe do elemento de propriedade ou a sintaxe de atributo. Sintaxe de atributo é mostrado no exemplo nesta página. Também pode utilizar o código para definir o DataContext.       DataContext é uma propriedade vinculável, para facilitar os cenários onde um contexto pode ser vinculado a outra. No entanto, se vincular a DataContext, tenha cuidado de não criar referências de enlace circular (não ligar a um DataContext para si próprio, que é possível fazer devido a natureza de herança de valor de propriedade da propriedade DataContext).      <a name=&quot;xamlPropertyElementUsage_DataContext&quot;></a># # Utilização de elemento de propriedade de XAML ```   <object>     <object.DataContext>       <dataContextObject />     </object.DataContext>   </object>   ``` <a name=&quot;xamlAttributeUsage_DataContext&quot;> </a> # # utilização de atributos de XAML ```   <object DataContext=&quot;bindingUsage&quot;/>   - or -   <object DataContext=&quot;{resourceExtension contextResourceKey}&quot;/>   ``` <a name=&quot;xamlValues_DataContext&quot;> </a> # # XAML valores *dataContextObject* um objeto diretamente incorporado que funciona como o contexto de dados para qualquer enlaces dentro do elemento principal.             Normalmente, este objeto é um <xref:System.Windows.Data.Binding>ou outro <xref:System.Windows.Data.BindingBase>derivados de classe.</xref:System.Windows.Data.BindingBase> </xref:System.Windows.Data.Binding> Em alternativa, os dados não processados de qualquer [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] pretendido para enlace pode ser colocado aqui, com os vínculos reais definidos mais tarde de tipo de objeto.       *bindingUsage* a utilização de um enlace que avalia a um contexto de dados adequada. Para obter mais informações, consulte [enlace extensão de Markup](~/add/includes/ajax-current-ext-md.md).       *resourceExtension* um dos seguintes: ou. Esta utilização é utilizada ao fazer referência ao definido como um objeto em recursos de dados não processados. Consulte [XAML recursos](~/add/includes/ajax-current-ext-md.md).       *contextResourceKey* o identificador da chave para o objeto a ser pedido a partir de um <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>      <a name=&quot;dependencyPropertyInfo_DataContext&quot;></a># # Informações de propriedade de dependência |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.DataContextProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkElement.DataContextProperty>"
  example:
  - "The following example illustrates how a data context acts on a binding and provides the information that defines the specific values of bound properties.  \n  \n [!code-xml[MasterDetail#DataContextProperty](~/add/codesnippet/xaml/MasterDetail/Page1.xaml#datacontextproperty)]  \n[!code-xml[MasterDetail#DataContextProperty2](~/add/codesnippet/xaml/MasterDetail/Page1.xaml#datacontextproperty2)]  \n[!code-xml[MasterDetail#DataContextProperty3](~/add/codesnippet/xaml/MasterDetail/Page1.xaml#datacontextproperty3)]"
  syntax:
    content: public object DataContext { get; set; }
    return:
      type: System.Object
      description: "O objeto a utilizar como contexto de dados."
  overload: System.Windows.FrameworkElement.DataContext*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.DataContextChanged
  id: DataContextChanged
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: DataContextChanged
  nameWithType: FrameworkElement.DataContextChanged
  fullName: System.Windows.FrameworkElement.DataContextChanged
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando o contexto de dados para este elemento é alterado."
  remarks: "Para obter uma explicação sobre contextos de dados e o enlace de dados, consulte [descrição geral de enlace de dados](~/add/includes/ajax-current-ext-md.md).      > [!IMPORTANT] > Quando o <xref:System.Windows.FrameworkElement.DataContext%2A>alterações um elemento, todas as propriedades de vinculados a dados neste elemento potencialmente são afetadas.</xref:System.Windows.FrameworkElement.DataContext%2A> Isto aplica-se para quaisquer elementos que estão a elementos subordinados do elemento actual na árvore lógica, que herdam o contexto de dados, bem como o próprio elemento atual. Todos os enlaces essas existentes tem novamente interpretar a nova <xref:System.Windows.FrameworkElement.DataContext%2A>e será reevaluate os resultados de enlace.</xref:System.Windows.FrameworkElement.DataContext%2A> O motor de enlace de dados não é determinística sobre a ordem destes reevaluations, relativamente ao gerar o evento DataContextChanged. Os reevaluations podem ocorrer antes do evento, depois do evento ou em qualquer combinação."
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.DataContextProperty
  id: DataContextProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: DataContextProperty
  nameWithType: FrameworkElement.DataContextProperty
  fullName: System.Windows.FrameworkElement.DataContextProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.DataContext*>propriedade de dependência.</xref:System.Windows.FrameworkElement.DataContext*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty DataContextProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.DefaultStyleKey
  id: DefaultStyleKey
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: DefaultStyleKey
  nameWithType: FrameworkElement.DefaultStyleKey
  fullName: System.Windows.FrameworkElement.DefaultStyleKey
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define a chave a utilizar para referenciar o estilo para este controlo quando estilos de temas são utilizados ou definidos."
  remarks: "Normalmente, esta propriedade não está definida através de qualquer um dos respetivos acessores de propriedade direct. Em vez disso, substitua os metadados específicos do tipo desta propriedade de dependência sempre que cria um novo <xref:System.Windows.FrameworkElement>derivados de classe.</xref:System.Windows.FrameworkElement> Quando derivar um controlo, chame o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>método contra o <xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>identificador, num construtor estático do controlo derivados de classe (ou inicialização de classe equivalentes).</xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty> </xref:System.Windows.DependencyProperty.OverrideMetadata%2A>       Um controlo normalmente substitui o valor predefinido desta propriedade deve ser do seu próprio tipo, mas, em alguns casos também pode utilizar um tipo base para o qual exista um estilo de dicionários o tema. Isto apenas é prático se os modelos de controlo do controlo base definem completamente a representação visual desse controlo derivada e qualquer membros adicionais expõem os tipos derivados não necessitam de elementos adicionais como parte do modelo de controlo.       Se pretender que o elemento ou controlo deliberadamente não utilizar estilos de temas, defina o <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A>propriedade `true`.</xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A>      <a name=&quot;dependencyPropertyInfo_DefaultStyleKey&quot;></a># # Informações de propriedade de dependência |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>"
  example:
  - "The following example illustrates the dependency property metadata override usage discussed in Remarks. This code defines a custom control class `NumericUpDown` intended to be used from a dedicated control library assembly. The illustrated static constructor references some private initialization function, registers a class handler (another common control subclassing scenario; see [Marking Routed Events as Handled, and Class Handling](~/add/includes/ajax-current-ext-md.md)) and finally overrides the DefaultStyleKey dependency property metadata on the `NumericUpDown` class. DefaultStyleKey always returns its own type as the intended key, which is the convention that the theme style system uses to look up the style for some arbitrary otherwise non-styled control. The complete sample also defines the actual control's theme style that is referenced by that key; see [NumericUpDown Custom Control with Theme and UI Automation Support Sample](http://go.microsoft.com/fwlink/?LinkID=160025).  \n  \n [!code-cs[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/add/codesnippet/csharp/CustomControlLibrary/NumericUpDown.cs#staticctorofcustomclasscommontasks)]\n [!code-vb[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/add/codesnippet/visualbasic/customcontrollibrary/numericupdown.vb#staticctorofcustomclasscommontasks)]  \n[!code-cs[CustomControlNumericUpDown#Close](~/add/codesnippet/csharp/CustomControlLibrary/NumericUpDown.cs#close)]\n[!code-vb[CustomControlNumericUpDown#Close](~/add/codesnippet/visualbasic/customcontrollibrary/numericupdown.vb#close)]"
  syntax:
    content: protected object DefaultStyleKey { get; set; }
    return:
      type: System.Object
      description: "A chave de estilo. Para funcionar corretamente como parte da pesquisa de style de tema, este valor deve ser o <xref:System.Type>do controlo que está a ser escovado.</xref:System.Type>"
  overload: System.Windows.FrameworkElement.DefaultStyleKey*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.DefaultStyleKeyProperty
  id: DefaultStyleKeyProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: DefaultStyleKeyProperty
  nameWithType: FrameworkElement.DefaultStyleKeyProperty
  fullName: System.Windows.FrameworkElement.DefaultStyleKeyProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.DefaultStyleKey*>propriedade de dependência.</xref:System.Windows.FrameworkElement.DefaultStyleKey*>"
  syntax:
    content: protected static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.EndInit
  id: EndInit
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: EndInit()
  nameWithType: FrameworkElement.EndInit()
  fullName: System.Windows.FrameworkElement.EndInit()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Indica que o processo de inicialização para o elemento seja concluído."
  remarks: "Se <xref:System.Windows.FrameworkElement.BeginInit%2A>anteriormente foi chamado, a base de implementação irá elevar o <xref:System.Windows.FrameworkElement.Initialized>eventos.</xref:System.Windows.FrameworkElement.Initialized> </xref:System.Windows.FrameworkElement.BeginInit%2A> Caso contrário, se <xref:System.Windows.FrameworkElement.BeginInit%2A>não foi chamado ou não foi possível determinar se <xref:System.Windows.FrameworkElement.BeginInit%2A>foi chamado <xref:System.Windows.FrameworkElement.Initialized>não é gerado e é emitida uma exceção em vez disso.</xref:System.Windows.FrameworkElement.Initialized> </xref:System.Windows.FrameworkElement.BeginInit%2A> </xref:System.Windows.FrameworkElement.BeginInit%2A>"
  syntax:
    content: public virtual void EndInit ();
    parameters: []
  overload: System.Windows.FrameworkElement.EndInit*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "EndInit foi chamado sem <xref:System.Windows.FrameworkElement.BeginInit*>anteriormente ter sido chamado no elemento.</xref:System.Windows.FrameworkElement.BeginInit*>"
  platform:
  - net462
- uid: System.Windows.FrameworkElement.FindName(System.String)
  id: FindName(System.String)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FindName(String)
  nameWithType: FrameworkElement.FindName(String)
  fullName: System.Windows.FrameworkElement.FindName(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Localiza um elemento com o nome de identificador fornecido."
  remarks: "Se o elemento tem elementos subordinados, estes elementos subordinados são recursivamente procurar todos os para o pedido com o nome de elemento.       FindName funciona dentro namescope do elemento actual. Para obter mais informações, consulte [WPF XAML Namescopes](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public object FindName (string name);
    parameters:
    - id: name
      type: System.String
      description: "O nome do elemento pedido."
    return:
      type: System.Object
      description: "O elemento de pedido. Isto pode ser <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se foi encontrado nenhum elemento correspondente."
  overload: System.Windows.FrameworkElement.FindName*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.FindResource(System.Object)
  id: FindResource(System.Object)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FindResource(Object)
  nameWithType: FrameworkElement.FindResource(Object)
  fullName: System.Windows.FrameworkElement.FindResource(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Procura um recurso com a chave especificada e emite uma exceção se o recurso pedido não foi encontrado."
  remarks: "> [!IMPORTANT]> Se chamar este método para uma chave que não é possível encontrar, é emitida uma exceção. Se não pretende processar as exceções que resultam de chamar FindResource, chamada <xref:System.Windows.FrameworkElement.TryFindResource%2A>em vez disso.</xref:System.Windows.FrameworkElement.TryFindResource%2A> <xref:System.Windows.FrameworkElement.TryFindResource%2A>Devolve `null` quando um recurso pedido não é possível encontrar e não acionar uma excepção.</xref:System.Windows.FrameworkElement.TryFindResource%2A>       Se o recurso não foi encontrado no elemento de chamada, o elemento principal na árvore lógica é procurar seguinte, em seguida, a aplicação, em seguida, temas e por fim recursos do sistema. Metodologia esta pesquisa é idêntica à forma como a árvore é procurada se um recurso foi pedido por uma referência de recursos dinâmicos no markup. Para obter mais informações sobre a pesquisa de recursos, consulte [XAML recursos](~/add/includes/ajax-current-ext-md.md).       Normalmente, imediatamente que converta um FindResource retorno valor para o tipo da propriedade essa definição com o valor devolvido do recurso.       Chaves de recurso não são necessariamente cadeias. Por exemplo, estilos para controlos ao nível do tema deliberadamente são codificados para o <xref:System.Type>do controlo e estilos de aplicação ou página para controlos, normalmente, utilizam este mesmo Convenção de chave.</xref:System.Type> Para obter mais informações, consulte [estilos e Templating](~/add/includes/ajax-current-ext-md.md) ou [XAML recursos](../Topic/XAML%20Resources.md)."
  example:
  - "The following example obtains a named resource and casts it to an appropriate type to fill a property.  \n  \n [!code-cs[PropertiesOvwSupport#ResourceProceduralGet](~/add/codesnippet/csharp/PropertiesOvwSupport/page3.xaml.cs#resourceproceduralget)]\n [!code-vb[PropertiesOvwSupport#ResourceProceduralGet](~/add/codesnippet/visualbasic/propertiesovwsupport/page3.xaml.vb#resourceproceduralget)]"
  syntax:
    content: public object FindResource (object resourceKey);
    parameters:
    - id: resourceKey
      type: System.Object
      description: "O identificador da chave para o recurso pedido."
    return:
      type: System.Object
      description: "O recurso pedido. Se não foi encontrado nenhum recurso com a chave fornecida, é emitida uma exceção. Um <xref href=&quot;System.Windows.DependencyProperty.UnsetValue&quot;> </xref> também poderá ser devolvido o valor no caso de exceção."
  overload: System.Windows.FrameworkElement.FindResource*
  exceptions:
  - type: System.Windows.ResourceReferenceKeyNotFoundException
    commentId: T:System.Windows.ResourceReferenceKeyNotFoundException
    description: "<code>resourceKey</code>Não foi encontrada e não existe um processador de eventos para o <xref href=&quot;System.Windows.Threading.Dispatcher.UnhandledException&quot;> </xref> eventos.       - ou - <code>resourceKey</code> não foi possível localizar e a <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled*> propriedade é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> no <xref href=&quot;System.Windows.Threading.Dispatcher.UnhandledException&quot;> </xref> eventos."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>resourceKey</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.FrameworkElement.FlowDirection
  id: FlowDirection
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FlowDirection
  nameWithType: FrameworkElement.FlowDirection
  fullName: System.Windows.FrameworkElement.FlowDirection
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define a direção que texto e outros [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] elementos fluxo dentro de qualquer elemento principal que controla o respetiva esquema."
  remarks: "The dependency property usage sets the FlowDirection on this element. Because of property value inheritance, setting FlowDirection on an element can potentially set FlowDirection on all child elements that did not set FlowDirection locally or though other means such as styles.  \n  \n This property is not automatically set as part of any application culture information, because an element might contain content that is not necessarily intended to obey the general flow direction implied by the culture information. For more information on globalization considerations, see [Globalization for WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n This property has a defined [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] property accessor, so it functions as a dependency property. However, it is also registered as attached, so it can also function as an attached property. The attached registration is mainly so that property value inheritance is supported, but the property can also be used as a true attached property. The attached property usage is only relevant if the object you intend to set the flow direction on has a <xref:System.Windows.FrameworkElement> parent element that performs layout upon it, is itself not a <xref:System.Windows.FrameworkElement>, and does not already have a more directly defined `FlowDirection` property. (Some of the flow document classes such as <xref:System.Windows.Documents.Block> and <xref:System.Windows.Documents.Inline> define their own `FlowDirection`, and this property can also set the flow direction. The property value is then read by the eventual content host without requiring attached property usage.)  \n  \n<a name=\"xamlAttributeUsage_FlowDirection\"></a>   \n## XAML Attribute Usage  \n \\<*object* **FlowDirection**=\"<xref:System.Windows.FlowDirection>\"/>  \n  \n<a name=\"xamlTextUsage_FlowDirection\"></a>   \n## XAML Text Usage  \n This property can also be set on classes that are not <xref:System.Windows.FrameworkElement> derived classes, by the following [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] attached property usage:  \n  \n `<` *object* `FrameworkElement.`**FlowDirection**=\"<xref:System.Windows.FlowDirection>`\"/>`  \n  \n<a name=\"dependencyPropertyInfo_FlowDirection\"></a>   \n## Dependency Property Information  \n  \n|||  \n|-|-|  \n|Identifier field|<xref:System.Windows.FrameworkElement.FlowDirectionProperty>|  \n|Metadata properties set to `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  \n  \n This property is both a dependency property and an attached property; see Remarks."
  syntax:
    content: public System.Windows.FlowDirection FlowDirection { get; set; }
    return:
      type: System.Windows.FlowDirection
      description: "A direção que texto e outros [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] elementos fluxo dentro do respetivo elemento principal, como um valor de enumeração. O valor predefinido é <xref href=&quot;System.Windows.FlowDirection&quot;> </xref>."
  overload: System.Windows.FrameworkElement.FlowDirection*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.FlowDirectionProperty
  id: FlowDirectionProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FlowDirectionProperty
  nameWithType: FrameworkElement.FlowDirectionProperty
  fullName: System.Windows.FrameworkElement.FlowDirectionProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.FlowDirection*>propriedade de dependência.</xref:System.Windows.FrameworkElement.FlowDirection*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty FlowDirectionProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.FocusVisualStyle
  id: FocusVisualStyle
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FocusVisualStyle
  nameWithType: FrameworkElement.FocusVisualStyle
  fullName: System.Windows.FrameworkElement.FocusVisualStyle
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define uma propriedade que permite que a personalização do aspeto, efeitos ou outras características de estilo que se irão aplicar a este elemento quando-captura o foco do teclado."
  remarks: "Esta propriedade afeta a aparência visual, mas não comunica <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>nos metadados.</xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> Isto acontece porque a alteração de aparência visual condicionada por eventos e não podem é aplicadas em todas as horas e, por conseguinte, deve não geralmente comunicam quaisquer informações de visual ou esquema nos metadados.       Concecionais, o comportamento de foco aplicado a um controlo visual deve ser coherent do controlo para controlo. A forma mais sensible para impor a coerência é apenas alterar o estilo visual foco se são composição um tema de todo. Definir esta propriedade no estilos do controlo individuais e não como parte de um tema não é a utilização pretendida desta propriedade, porque poderá provocar uma experiência de utilizador confuso sobre o foco do teclado. São destinar comportamento de específico do controlo que não se encontra deliberadamente coherent entre um tema, uma abordagem de melhor muito estiver a utilizar acionadores em estilos para propriedades do Estado de entrada individuais, tais como <xref:System.Windows.UIElement.IsFocused%2A>ou <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>e para fazê-lo de forma visualmente não interfere com qualquer estilo visual de foco existente.</xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A> </xref:System.Windows.UIElement.IsFocused%2A> Para obter mais informações sobre a intenção de estrutura de FocusVisualStyle e propriedades de foco alternativos, consulte [Styling para foco em controlos e FocusVisualStyle](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;xamlAttributeUsage_FocusVisualStyle&quot;></a># # Utilização do atributo de XAML ```   <object FocusVisualStyle=&quot;{resourceExtension styleResourceKey}&quot;/>   ``` <a name=&quot;xamlPropertyElementUsage_FocusVisualStyle&quot;> </a> # # utilização de elemento de propriedade XAML <a name=&quot;xamlValues_FocusVisualStyle&quot;> </a> # # XAML valores *resourceExtension* um dos seguintes:, ou.       Consulte [XAML recursos](~/add/includes/ajax-current-ext-md.md).       *styleResourceKey* a chave que identifica o estilo de que está a ser solicitado. A chave refere-se a um recurso existente no <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>      > [!NOTE] > Sintaxe do elemento de propriedade é tecnicamente possível, mas não recomendadas. Consulte [Inline estilos e modelos](~/add/includes/ajax-current-ext-md.md). Uma referência de enlace utilizando ou <xref:System.Windows.Data.Binding>é também possível, mas invulgar.</xref:System.Windows.Data.Binding>      <a name=&quot;dependencyPropertyInfo_FocusVisualStyle&quot;></a># # Informações de propriedade de dependência |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.FocusVisualStyleProperty>|   | Definir propriedades de metadados `true`| Nenhum |</xref:System.Windows.FrameworkElement.FocusVisualStyleProperty>"
  syntax:
    content: public System.Windows.Style FocusVisualStyle { get; set; }
    return:
      type: System.Windows.Style
      description: "O estilo pretendido para aplicar no foco. O valor predefinido conforme declarado na propriedade de dependência é uma estática vazia <xref href=&quot;System.Windows.Style&quot;> </xref>. No entanto, o valor Efetivo em tempo de execução é frequentemente (mas não sempre) um style como fornecido pelo suporte de tema para controlos."
  overload: System.Windows.FrameworkElement.FocusVisualStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.FocusVisualStyleProperty
  id: FocusVisualStyleProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FocusVisualStyleProperty
  nameWithType: FrameworkElement.FocusVisualStyleProperty
  fullName: System.Windows.FrameworkElement.FocusVisualStyleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.FocusVisualStyle*>propriedade de dependência.</xref:System.Windows.FrameworkElement.FocusVisualStyle*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ForceCursor
  id: ForceCursor
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ForceCursor
  nameWithType: FrameworkElement.ForceCursor
  fullName: System.Windows.FrameworkElement.ForceCursor
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define um valor que indica se esta <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref> deverá forçar o [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] para compor o cursor conforme declarado pelo <xref:System.Windows.FrameworkElement.Cursor*>propriedade.</xref:System.Windows.FrameworkElement.Cursor*>"
  remarks: "Se definir esta propriedade para `true` irão substituir as preferências de cursor estabelecidas pelo elementos subordinados. Ao fazê-lo de aplicação, por isso, no geral [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] podem ser confusos para o utilizador, particularmente se estão a tentar efetuar elementos subordinados especificar os cursores. A definição de ForceCursor é mais adequada nos cenários de controlo de subclassing ou compositing.      <a name=&quot;dependencyPropertyInfo_ForceCursor&quot;></a># # Informações de propriedade de dependência |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.ForceCursorProperty>|   | Definir propriedades de metadados `true`| Nenhum |</xref:System.Windows.FrameworkElement.ForceCursorProperty>"
  example:
  - "The following example forces the cursor value.  \n  \n [!code-xml[ForceCursor#ForceCursor](~/add/codesnippet/xaml/forcecursor/default.xaml#forcecursor)]"
  syntax:
    content: public bool ForceCursor { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se a apresentação de cursor enquanto estiver sobre este elemento é forçada a utilizar atual <xref:System.Windows.FrameworkElement.Cursor*>definições para o cursor (incluindo em todos os elementos subordinados); caso contrário <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Windows.FrameworkElement.Cursor*> O valor predefinido é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkElement.ForceCursor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ForceCursorProperty
  id: ForceCursorProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ForceCursorProperty
  nameWithType: FrameworkElement.ForceCursorProperty
  fullName: System.Windows.FrameworkElement.ForceCursorProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.ForceCursor*>propriedade de dependência.</xref:System.Windows.FrameworkElement.ForceCursor*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ForceCursorProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)
  id: GetBindingExpression(System.Windows.DependencyProperty)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: GetBindingExpression(DependencyProperty)
  nameWithType: FrameworkElement.GetBindingExpression(DependencyProperty)
  fullName: System.Windows.FrameworkElement.GetBindingExpression(DependencyProperty)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Devolve o <xref href=&quot;System.Windows.Data.BindingExpression&quot;> </xref> que representa o enlace na propriedade especificada."
  remarks: "A verificar o valor de retorno para `null` é uma técnica pode utilizar para determinar se uma propriedade tem um enlace de Active Directory.       Este método é realmente apenas um conveniência papel de embrulho à volta a <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=fullName>método.</xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=fullName> GetBindingExpression passa a instância atual e o `dp` parâmetro <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=fullName>.</xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=fullName>"
  syntax:
    content: public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "O destino <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> para obter o enlace do."
    return:
      type: System.Windows.Data.BindingExpression
      description: "A <xref href=&quot;System.Windows.Data.BindingExpression&quot;> </xref> se a propriedade de destino tem um enlace de Active Directory; caso contrário, devolve <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkElement.GetBindingExpression*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)
  id: GetFlowDirection(System.Windows.DependencyObject)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: GetFlowDirection(DependencyObject)
  nameWithType: FrameworkElement.GetFlowDirection(DependencyObject)
  fullName: System.Windows.FrameworkElement.GetFlowDirection(DependencyObject)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém o valor da <xref:System.Windows.FrameworkElement.FlowDirection*>anexado a propriedade especificada <xref href=&quot;System.Windows.DependencyObject&quot;> </xref>.</xref:System.Windows.FrameworkElement.FlowDirection*>"
  remarks: "O objetivo principal deste método é oferecer suporte a propriedade anexada sintaxe para o <xref:System.Windows.FrameworkElement.FlowDirection%2A>propriedade, por conseguinte, permitindo subordinado elementos de um fornecido <xref:System.Windows.FrameworkElement>para especificar a direção do fluxo de disposição dentro do respetivo elemento principal.</xref:System.Windows.FrameworkElement> </xref:System.Windows.FrameworkElement.FlowDirection%2A> Obter o valor atual <xref:System.Windows.FrameworkElement>, utilize a direta [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] acessor <xref:System.Windows.FrameworkElement.FlowDirection%2A>.</xref:System.Windows.FrameworkElement.FlowDirection%2A> </xref:System.Windows.FrameworkElement>"
  syntax:
    content: public static System.Windows.FlowDirection GetFlowDirection (System.Windows.DependencyObject element);
    parameters:
    - id: element
      type: System.Windows.DependencyObject
      description: "O elemento para devolver um <xref:System.Windows.FrameworkElement.FlowDirection*>for.</xref:System.Windows.FrameworkElement.FlowDirection*>"
    return:
      type: System.Windows.FlowDirection
      description: "A direção do fluxo de pedido, como um valor de enumeração."
  overload: System.Windows.FrameworkElement.GetFlowDirection*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)
  id: GetLayoutClip(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: GetLayoutClip(Size)
  nameWithType: FrameworkElement.GetLayoutClip(Size)
  fullName: System.Windows.FrameworkElement.GetLayoutClip(Size)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Devolve uma geometria uma máscara de recorte. A máscara aplica-se do sistema de esquema tenta dispor de um elemento que é maior do que o espaço de apresentação disponível."
  remarks: "Margens serão subtraídas o `layoutSlotSize` como parte do comportamento do sistema de esquema.       Uma referência null devolvida indica que não existem recorte irá ocorrer. Devolve a implementação predefinida sempre `null` quando <xref:System.Windows.UIElement.ClipToBounds%2A>é `false`.</xref:System.Windows.UIElement.ClipToBounds%2A> Este método substitui <xref:System.Windows.UIElement.GetLayoutClip%2A?displayProperty=fullName>.</xref:System.Windows.UIElement.GetLayoutClip%2A?displayProperty=fullName> O <xref:System.Windows.FrameworkElement>implementação utiliza <xref:System.Windows.FrameworkElement.MaxHeight%2A>e <xref:System.Windows.FrameworkElement.MaxWidth%2A>nos seus cálculos.</xref:System.Windows.FrameworkElement.MaxWidth%2A> </xref:System.Windows.FrameworkElement.MaxHeight%2A> </xref:System.Windows.FrameworkElement> Várias as subclasses de <xref:System.Windows.FrameworkElement>Substituir novamente este método.</xref:System.Windows.FrameworkElement> <xref:System.Windows.Documents.Adorner.GetLayoutClip%2A?displayProperty=fullName>, as substituições sempre devolver `null` porque elementos complementares deliberadamente são frequentemente fora dos limites comum.</xref:System.Windows.Documents.Adorner.GetLayoutClip%2A?displayProperty=fullName> <xref:System.Windows.Controls.Canvas.GetLayoutClip%2A?displayProperty=fullName>and <xref:System.Windows.Controls.InkPresenter.GetLayoutClip%2A?displayProperty=fullName> return `null` if <xref:System.Windows.UIElement.ClipToBounds%2A> is `false`.</xref:System.Windows.UIElement.ClipToBounds%2A></xref:System.Windows.Controls.InkPresenter.GetLayoutClip%2A?displayProperty=fullName></xref:System.Windows.Controls.Canvas.GetLayoutClip%2A?displayProperty=fullName>"
  syntax:
    content: protected override System.Windows.Media.Geometry GetLayoutClip (System.Windows.Size layoutSlotSize);
    parameters:
    - id: layoutSlotSize
      type: System.Windows.Size
      description: "O tamanho da peça do elemento que suporta a apresentação visual."
    return:
      type: System.Windows.Media.Geometry
      description: "A geometria recorte."
  overload: System.Windows.FrameworkElement.GetLayoutClip*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.GetTemplateChild(System.String)
  id: GetTemplateChild(System.String)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: GetTemplateChild(String)
  nameWithType: FrameworkElement.GetTemplateChild(String)
  fullName: System.Windows.FrameworkElement.GetTemplateChild(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Devolve o elemento com nome da árvore visual de um instanciadas <xref href=&quot;System.Windows.Controls.ControlTemplate&quot;> </xref>."
  remarks: "Modelos no [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] tem um namescope autónomo. Isto acontece porque os modelos são reutilizados e qualquer nome definido num modelo não é possível permanecem exclusivo quando instanciar o respetivo modelo de várias instâncias de um controlo. Chame o método GetTemplateChild para devolver as referências a objetos que vêm de modelo depois de ser instanciado. Não é possível utilizar o <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=fullName>método para localizar itens a partir de modelos porque <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=fullName>Age num mais geral âmbito e não existe nenhuma ligação entre o <xref:System.Windows.Controls.ControlTemplate>classe próprio e o modelo com instâncias criadas quando é aplicada.</xref:System.Windows.Controls.ControlTemplate> </xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=fullName> </xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=fullName>       <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=fullName>Fornece a mesma função que este método.</xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=fullName> <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=fullName>é público, em vez de protegidos e utiliza corretas considerações de nome de âmbito que lhe permite aceder ao modelo dentro de um elemento e encontrar itens nele com nome.</xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=fullName> Utilize <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=fullName>quando precisa de obter um elemento fora do seu controlo principal.</xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=fullName>"
  syntax:
    content: protected System.Windows.DependencyObject GetTemplateChild (string childName);
    parameters:
    - id: childName
      type: System.String
      description: "Nome dos subordinados para localizar."
    return:
      type: System.Windows.DependencyObject
      description: "O elemento de pedido. Poderá ser <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> não existir nenhum elemento do nome do pedido."
  overload: System.Windows.FrameworkElement.GetTemplateChild*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.GetUIParentCore
  id: GetUIParentCore
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: GetUIParentCore()
  nameWithType: FrameworkElement.GetUIParentCore()
  fullName: System.Windows.FrameworkElement.GetUIParentCore()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Devolve um primário lógico alternativo para este elemento se não houver nenhuma visual principal."
  remarks: "Este método substitui <xref:System.Windows.UIElement.GetUIParentCore%2A?displayProperty=fullName>.</xref:System.Windows.UIElement.GetUIParentCore%2A?displayProperty=fullName> A predefinição <xref:System.Windows.FrameworkElement>implementação devolve o único visual principal esperado, que é o mesmo resultado como obter o <xref:System.Windows.FrameworkElement.Parent%2A>valor.</xref:System.Windows.FrameworkElement.Parent%2A> </xref:System.Windows.FrameworkElement> Implementações de classe derivada poderão devolver relações principal alternativo."
  syntax:
    content: protected override System.Windows.DependencyObject GetUIParentCore ();
    parameters: []
    return:
      type: System.Windows.DependencyObject
      description: "Devolve algo diferente de <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> sempre que uma implementação de nível de framework WPF deste método tem uma ligação não visual principal."
  overload: System.Windows.FrameworkElement.GetUIParentCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.GetVisualChild(System.Int32)
  id: GetVisualChild(System.Int32)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: GetVisualChild(Int32)
  nameWithType: FrameworkElement.GetVisualChild(Int32)
  fullName: System.Windows.FrameworkElement.GetVisualChild(Int32)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Substituições &lt;xref:System.Windows.Media.Visual.GetVisualChild%2A?displayProperty=fullName&gt;e devolve um subordinado no índice especificado a partir de uma coleção de elementos subordinados."
  remarks: "No <xref:System.Windows.FrameworkElement>implementação, o índice só é válido é zero.</xref:System.Windows.FrameworkElement> O modelo de conteúdo para GetVisualChild suporta zero ou um subordinado elementos não é uma coleção."
  example:
  - "The following example shows how a custom adorner uses the values declared by a <xref:System.Windows.Media.VisualCollection> that it maintains for its multiple visual children. These values are reported through overrides of <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> and GetVisualChild.  \n  \n [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/add/codesnippet/visualbasic/resizingadorner/resizingadorner.vb#fevisualoverridespre)]\n [!code-cs[Adorners_ResizingAdorner#FEVisualOverridesPre](~/add/codesnippet/csharp/ResizingAdorner/ResizingAdorner.cs#fevisualoverridespre)]  \n[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/add/codesnippet/visualbasic/resizingadorner/resizingadorner.vb#fevisualoverrides)]\n[!code-cs[Adorners_ResizingAdorner#FEVisualOverrides](~/add/codesnippet/csharp/ResizingAdorner/ResizingAdorner.cs#fevisualoverrides)]"
  syntax:
    content: protected override System.Windows.Media.Visual GetVisualChild (int index);
    parameters:
    - id: index
      type: System.Int32
      description: "O índice baseado em zero do elemento subordinado pedida na coleção."
    return:
      type: System.Windows.Media.Visual
      description: "O elemento de pedido subordinado. Isto não deve devolver <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>; se o índice fornecido está fora do intervalo, é emitida uma exceção."
  overload: System.Windows.FrameworkElement.GetVisualChild*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Height
  id: Height
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Height
  nameWithType: FrameworkElement.Height
  fullName: System.Windows.FrameworkElement.Height
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define a altura do elemento sugerida."
  remarks: "A altura é uma das três propriedades graváveis no <xref:System.Windows.FrameworkElement>que especifique informações de altura.</xref:System.Windows.FrameworkElement> As outras duas são <xref:System.Windows.FrameworkElement.MinHeight%2A>e <xref:System.Windows.FrameworkElement.MaxHeight%2A>.</xref:System.Windows.FrameworkElement.MaxHeight%2A> </xref:System.Windows.FrameworkElement.MinHeight%2A> Se não houver um conflito entre estes valores, a ordem da aplicação para a determinação de altura real é que o primeiro <xref:System.Windows.FrameworkElement.MinHeight%2A>tem de ser honrado, em seguida, <xref:System.Windows.FrameworkElement.MaxHeight%2A>e por fim, se estiver dentro dos limites, altura.</xref:System.Windows.FrameworkElement.MaxHeight%2A> </xref:System.Windows.FrameworkElement.MinHeight%2A>       Se este elemento é um elemento subordinado dentro de alguns outro elemento, em seguida, definir esta propriedade para um valor é apenas um valor sugerido. O sistema de esquema, bem como a lógica de esquema específica do elemento principal utilizará o valor como uma entrada nonbinding durante o processo de esquema. Em termos práticos, um <xref:System.Windows.FrameworkElement>é quase sempre o elemento subordinado de algo pessoa; mesmo quando define a altura em <xref:System.Windows.Window>.</xref:System.Windows.Window> </xref:System.Windows.FrameworkElement> (Para <xref:System.Windows.Window>, que o valor é utilizado quando o modelo de aplicação subjacente estabelece os pressupostos de composição básico que cria o Hwnd que aloja a aplicação.)</xref:System.Windows.Window>       Para além de aceitável <xref:System.Double>valores, esta propriedade também podem ser <xref:System.Double.NaN?displayProperty=fullName>.</xref:System.Double.NaN?displayProperty=fullName> </xref:System.Double> Este é como especificar o comportamento de dimensionamento automático no código. No [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] definir o valor para a cadeia &quot;Auto&quot; (sensível a maiúsculas e minúsculas) para ativar automaticamente o comportamento de dimensionamento. Comportamento de dimensionamento de automática implica que o elemento irá preencher a altura disponível. Tenha em atenção contudo que controlos específicos frequentemente fornecem valores predefinidos através do respetivos estilos de temas predefinido que desactivará automaticamente o comportamento de dimensionamento, a menos que seja especificamente reativada.       O valor de retorno desta propriedade é sempre o mesmo que qualquer valor que foi definido para o mesmo. Em contraste, o valor da <xref:System.Windows.FrameworkElement.ActualHeight%2A>pode variar.</xref:System.Windows.FrameworkElement.ActualHeight%2A> Isto pode acontecer o estaticamente porque o esquema rejeitou o tamanho sugerido por algum motivo, ou momentaneamente. O sistema de esquema próprio funciona de forma assíncrona em relação ao conjunto do sistema de propriedade de altura e não pode ter processados específico de que a alteração de propriedade de dimensionamento ainda.       As restrições de valor sobre o <xref:System.Double>valor são impostas por um <xref:System.Windows.ValidateValueCallback>mecanismo.</xref:System.Windows.ValidateValueCallback> </xref:System.Double> Se tentar definir um valor inválido, é emitida uma exceção de tempo de execução.       Para além de verificação de validação, é um valor superior não determinístico vinculado a altura que é imposta pelo sistema do esquema (este é um número muito elevado, maior <xref:System.Single.MaxValue?displayProperty=fullName>inferior, mas <xref:System.Double.MaxValue?displayProperty=fullName>).</xref:System.Double.MaxValue?displayProperty=fullName> </xref:System.Single.MaxValue?displayProperty=fullName> Se exceder este limite, o elemento não irá compor e sem exceção é emitida. Não defina altura para um valor que é significativamente maior do que o tamanho máximo de quaisquer possíveis apresentação visual ou pode exceder este limite superior não determinístico.      <a name=&quot;xamlAttributeUsage_Height&quot;></a># # Utilização do atributo de XAML ```   <object Height=&quot;double&quot;/>   - or -   <object Height=&quot;qualifiedDouble&quot;/>   - or -   <object Height=&quot;Auto&quot;/>   ``` <a name=&quot;xamlValues_Height&quot;> </a> # # XAML valores *duplo* <xref:System.Double> cadeia representação de um <xref:System.Double>valor igual ou maior do que 0,0.</xref:System.Double> </xref:System.Double>           Consulte observações para obter informações de limite superior. Este valor é interpretado como um [!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)] medida. As cadeias não tem de incluir explicitamente decimais. Por exemplo, um valor de `1` é aceitável.       *qualifiedDouble* A *duplo* valor, tal como descrito acima, seguido de uma das seguintes cadeias de declaração de unidade: `px`, `in`, `cm`, `pt`.       `px`(predefinição) é [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)] `in` é polegadas; 1 in = = 96px `cm` é centímetros; 1cm==(96/2.54) px `pt` é pontos; 1pt==(96/72) px **automática** permite autosizing comportamento.        Consulte observações.      <a name=&quot;dependencyPropertyInfo_Height&quot;></a># # Informações de propriedade de dependência |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.HeightProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.HeightProperty>"
  syntax:
    content: public double Height { get; set; }
    return:
      type: System.Double
      description: "A altura do elemento, na [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]. O valor predefinido é &lt;xref:System.Double?displayProperty=fullName&gt;. Este valor tem de ser igual ou maior do que 0,0. Consulte observações para obter informações de limite superior."
  overload: System.Windows.FrameworkElement.Height*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.HeightProperty
  id: HeightProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: HeightProperty
  nameWithType: FrameworkElement.HeightProperty
  fullName: System.Windows.FrameworkElement.HeightProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.Height*>propriedade de dependência.</xref:System.Windows.FrameworkElement.Height*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty HeightProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.HorizontalAlignment
  id: HorizontalAlignment
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: HorizontalAlignment
  nameWithType: FrameworkElement.HorizontalAlignment
  fullName: System.Windows.FrameworkElement.HorizontalAlignment
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define as características de alinhamento horizontal aplicadas a este elemento quando compõe dentro de um elemento principal, por exemplo, um painel ou itens de controlo."
  remarks: "Quando <xref:System.Windows.FrameworkElement.Height%2A>e <xref:System.Windows.FrameworkElement.Width%2A>Propriedades explicitamente estão definidas num elemento, destas medidas demorar precedent superior durante o esquema e efeitos típicos da definição HorizontalAlignment para <xref:System.Windows.HorizontalAlignment>.</xref:System.Windows.HorizontalAlignment> , serão canceladas</xref:System.Windows.FrameworkElement.Width%2A> </xref:System.Windows.FrameworkElement.Height%2A>       HorizontalAlignment é o [!INCLUDE[TLA#tla_net](~/add/includes/tlasharptla-net-md.md)] acessor de propriedade para o que é na realidade uma propriedade de dependência. Esta propriedade de dependência específico bastante frequentemente tem o valor de aparente &quot;predefinido&quot; definir de forma diferente nos elementos subclassed, particularmente controlos. Esta situação ocorre geralmente de uma das seguintes formas: a propriedade de dependência novamente está registada uma subclasse específico, mas com metadados diferentes para definir as respetivas predefinições; ou existe um estilo predefinido a ser aplicado que define esse valor de propriedade de dependência de forma diferente. Por exemplo, o aparente &quot;predefinido&quot; de HorizontalAlignment para um <xref:System.Windows.Controls.Label>controlo será <xref:System.Windows.HorizontalAlignment>, mesmo que <xref:System.Windows.Controls.Label>herda HorizontalAlignment direta de <xref:System.Windows.FrameworkElement>.</xref:System.Windows.FrameworkElement> </xref:System.Windows.Controls.Label> </xref:System.Windows.HorizontalAlignment> </xref:System.Windows.Controls.Label> Isto acontece porque esse valor foi reposto no estilo predefinido do <xref:System.Windows.Controls.Label>, dentro do modelo de controlo de estilo.</xref:System.Windows.Controls.Label>       <xref:System.Windows.Controls.Canvas>Utilize HorizontalAlignment durante a composição de esquema, porque <xref:System.Windows.Controls.Canvas>baseia-se no posicionamento absoluto.</xref:System.Windows.Controls.Canvas></xref:System.Windows.Controls.Canvas>       Quando herdado por <xref:System.Windows.Controls.Label>ou classes derivadas, <xref:System.Windows.Controls.Label>redefine o valor predefinido desta propriedade de dependência para ser <xref:System.Windows.HorizontalAlignment>.</xref:System.Windows.HorizontalAlignment> </xref:System.Windows.Controls.Label> </xref:System.Windows.Controls.Label>      <a name=&quot;dependencyPropertyInfo_HorizontalAlignment&quot;></a># # Informações de propriedade de dependência |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.HorizontalAlignmentProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> </xref:System.Windows.FrameworkElement.HorizontalAlignmentProperty>"
  syntax:
    content: public System.Windows.HorizontalAlignment HorizontalAlignment { get; set; }
    return:
      type: System.Windows.HorizontalAlignment
      description: "Uma definição de alinhamento horizontal, como um valor de enumeração. A predefinição é <xref href=&quot;System.Windows.HorizontalAlignment&quot;> </xref>."
  overload: System.Windows.FrameworkElement.HorizontalAlignment*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.HorizontalAlignmentProperty
  id: HorizontalAlignmentProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: HorizontalAlignmentProperty
  nameWithType: FrameworkElement.HorizontalAlignmentProperty
  fullName: System.Windows.FrameworkElement.HorizontalAlignmentProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.HorizontalAlignment*>propriedade de dependência.</xref:System.Windows.FrameworkElement.HorizontalAlignment*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty HorizontalAlignmentProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.InheritanceBehavior
  id: InheritanceBehavior
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: InheritanceBehavior
  nameWithType: FrameworkElement.InheritanceBehavior
  fullName: System.Windows.FrameworkElement.InheritanceBehavior
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define os limites de âmbito de herança de valor de propriedade, pesquisa de chave de recurso e pesquisa RelativeSource FindAncestor."
  remarks: "Determinados limites na árvore de elemento defina InheritanceBehavior deliberadamente limitar o âmbito do comportamento de herança, para uma pesquisa de recursos de imposição para verificar os recursos de aplicação ou para impedir que uma pesquisa de RelativeSource FindAncestor ainda mais a consultar o elemento actual ou any. RelativeSource FindAncestor pesquisa ocorre quando um enlace utiliza um <xref:System.Windows.Data.RelativeSource>que tenha o <xref:System.Windows.Data.RelativeSource.Mode%2A>propriedade definida como o <xref:System.Windows.Data.RelativeSourceMode?displayProperty=fullName>valor.</xref:System.Windows.Data.RelativeSourceMode?displayProperty=fullName> </xref:System.Windows.Data.RelativeSource.Mode%2A> </xref:System.Windows.Data.RelativeSource>       Se pretender que a sua classe derivada para definir esta propriedade, deve fazê-num construtor estático ou outras rotinas de inicialização."
  syntax:
    content: protected System.Windows.InheritanceBehavior InheritanceBehavior { get; set; }
    return:
      type: System.Windows.InheritanceBehavior
      description: "Um valor de enumeração. A predefinição é <xref href=&quot;System.Windows.InheritanceBehavior&quot;> </xref>."
  overload: System.Windows.FrameworkElement.InheritanceBehavior*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Initialized
  id: Initialized
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Initialized
  nameWithType: FrameworkElement.Initialized
  fullName: System.Windows.FrameworkElement.Initialized
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando este <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref> está inicializado. Este evento coincida com casos em que o valor da <xref:System.Windows.FrameworkElement.IsInitialized*>propriedade é alterado de <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (ou indefinido) para <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Windows.FrameworkElement.IsInitialized*>"
  remarks: "Este evento será acionado sempre que o <xref:System.Windows.FrameworkElement.EndInit%2A>ou <xref:System.Windows.FrameworkElement.OnVisualParentChanged%2A>métodos são denominados.</xref:System.Windows.FrameworkElement.OnVisualParentChanged%2A> </xref:System.Windows.FrameworkElement.EndInit%2A> Chamadas para o método tem provir do código de aplicação ou através de [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)] comportamento do processador quando um [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] página está a ser processada.       Se optar por processar <xref:System.Windows.FrameworkElement.Loaded>ou Initialized depende nos seus requisitos.</xref:System.Windows.FrameworkElement.Loaded> Se não precisa de ler as propriedades de elemento, pretende repor propriedades e não necessita de quaisquer informações de esquema, Initialized poderão o evento melhor agir. Se precisar de todas as propriedades do elemento para que fique disponível e tem a definição propriedades que se prevê a repor o esquema, <xref:System.Windows.FrameworkElement.Loaded>poderá ser o evento melhor agir.</xref:System.Windows.FrameworkElement.Loaded> Tenha o cuidado de reentrancy se o processador repõe as propriedades que são interpretadas pelo sistema esquema tem de estar verdadeiramente que é necessária uma passagem de esquema novo. (Poderá ter de verificar o <xref:System.Windows.FrameworkPropertyMetadata>valores na propriedade se não souber das propriedades que podem exigir um novo esquema passaram se estes estão a ser alterados.)</xref:System.Windows.FrameworkPropertyMetadata>       Para obter mais informações sobre a sequência de eventos de objeto para uma <xref:System.Windows.FrameworkElement>e também para vários relacionados com classes de elemento e aplicações, consulte o artigo [eventos de duração do objeto](~/add/includes/ajax-current-ext-md.md).</xref:System.Windows.FrameworkElement>"
  syntax:
    content: public event EventHandler Initialized;
    return:
      type: System.EventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.InputScope
  id: InputScope
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: InputScope
  nameWithType: FrameworkElement.InputScope
  fullName: System.Windows.FrameworkElement.InputScope
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define o contexto de entrada utilizado por este <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref>."
  remarks: "Esta propriedade de dependência herde os valores de propriedade. Se existirem elementos subordinados sem outros valores para InputScope estabelecida através de valores locais ou de estilos, o sistema de propriedade definirá o valor para o valor de InputScope do elemento mais próximo predecessor com este valor atribuído.       Embora um [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] utilização de sintaxe está listada e é sintaticamente permitida, definir esta propriedade no [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] não é comum.      <a name=&quot;dependencyPropertyInfo_InputScope&quot;></a># # Informações de propriedade de dependência |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.InputScopeProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkElement.InputScopeProperty>"
  syntax:
    content: public System.Windows.Input.InputScope InputScope { get; set; }
    return:
      type: System.Windows.Input.InputScope
      description: "O âmbito de entrada, que modifica como entrada de métodos alternativos de entrada é interpretada. O valor predefinido é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> (o que resulta num processamento predefinição de comandos)."
  overload: System.Windows.FrameworkElement.InputScope*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.InputScopeProperty
  id: InputScopeProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: InputScopeProperty
  nameWithType: FrameworkElement.InputScopeProperty
  fullName: System.Windows.FrameworkElement.InputScopeProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.InputScope*>propriedade de dependência.</xref:System.Windows.FrameworkElement.InputScope*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty InputScopeProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.IsInitialized
  id: IsInitialized
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: IsInitialized
  nameWithType: FrameworkElement.IsInitialized
  fullName: System.Windows.FrameworkElement.IsInitialized
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém um valor que indica se este elemento foi inicializado, quer durante o processamento por um [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] processador, ou fazendo com que explicitamente o <xref:System.Windows.FrameworkElement.EndInit*>método chamado.</xref:System.Windows.FrameworkElement.EndInit*>"
  remarks: "Esta propriedade também pode ser `true` se este elemento foi movido dentro da árvore lógica da forma a que tem um elemento principal novo e, por conseguinte, ficar recarregada novamente.       Esta propriedade é útil se também estiver a utilizar <xref:System.Windows.FrameworkElement.BeginInit%2A>e <xref:System.Windows.FrameworkElement.EndInit%2A>.</xref:System.Windows.FrameworkElement.EndInit%2A> </xref:System.Windows.FrameworkElement.BeginInit%2A> Os elementos da árvore lógica que são carregados por um [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] processador garantirá ser inicializada. São inicializados de elementos não se encontra na árvore lógica quando <xref:System.Windows.FrameworkElement.EndInit%2A>é chamado.</xref:System.Windows.FrameworkElement.EndInit%2A> Na ausência de qualquer processamento específico de <xref:System.Windows.FrameworkElement.BeginInit%2A>e <xref:System.Windows.FrameworkElement.EndInit%2A>, isto irá acontecer, assim que o construtor devolve o resultado foi inicializado.</xref:System.Windows.FrameworkElement.EndInit%2A> </xref:System.Windows.FrameworkElement.BeginInit%2A>"
  syntax:
    content: public bool IsInitialized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o elemento é inicializado pelo acima mencionados [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] chamadas de método ou processamento; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkElement.IsInitialized*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.IsLoaded
  id: IsLoaded
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: IsLoaded
  nameWithType: FrameworkElement.IsLoaded
  fullName: System.Windows.FrameworkElement.IsLoaded
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém um valor que indica se este elemento foi carregado para a apresentação."
  remarks: "De recentemente construído <xref:System.Windows.FrameworkElement>, esta propriedade é iniciado `false`e permanece `true` após ser definido `true`, mesmo que o elemento subsequentemente é removido da árvore lógica ligada por código.</xref:System.Windows.FrameworkElement> `true`Estado é definido pela lógica de apresentação gerais quando elementos são carregados para o motor de apresentação.       Normalmente, os elementos carregados são composta, mas não todos <xref:System.Windows.FrameworkElement>classes derivadas têm uma apresentação e outras propriedades, tais como <xref:System.Windows.UIElement.Visibility%2A>pode influenciar a apresentação.</xref:System.Windows.UIElement.Visibility%2A> </xref:System.Windows.FrameworkElement>"
  example:
  - "The following example implements two handlers: one is handling the <xref:System.Windows.FrameworkElement.Loaded> event of the root element, so it is certain that the page root element is loaded because that is the significance of the event. The other handler is hooked to a user control, and calls IsLoaded to assure that the root element is loaded completely. Both handlers call the same function (not shown) that will populate child elements with fresh data.  \n  \n [!code-cs[GroupBoxExample#FEIsLoaded](~/add/codesnippet/csharp/GroupBoxExample/Page1.xaml.cs#feisloaded)]"
  syntax:
    content: public bool IsLoaded { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o elemento atual está ligado a uma árvore de elemento; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> se o elemento tem nunca foi ligado a uma árvore de elemento carregado."
  overload: System.Windows.FrameworkElement.IsLoaded*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Language
  id: Language
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Language
  nameWithType: FrameworkElement.Language
  fullName: System.Windows.FrameworkElement.Language
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define a informação do idioma localização/globalização que se aplica a um elemento."
  remarks: "Os formatos de cadeia seguem o padrão de RFC 3066. Por exemplo, E.U.A. Inglês é &quot;en-US&quot;. Para obter mais informações sobre os valores e o formato, consulte <xref:System.Windows.Markup.XmlLanguage>.</xref:System.Windows.Markup.XmlLanguage>       Esta propriedade de dependência herde os valores de propriedade. Se existirem elementos subordinados sem outros valores para o idioma estabelecida através de valores locais ou de estilos, o sistema de propriedade definirá o valor para o valor de idioma do elemento mais próximo predecessor com este valor atribuído.       [!INCLUDE[TLA2#tla_xml](~/add/includes/tla2sharptla-xml-md.md)]Define o significado geral do `xml:lang` atributo. Idioma essencialmente expõe o significado deste atributo como uma propriedade de dependência. Idioma pode ser ajustado através de programação e pode participar na herança de valor de sistema de propriedade de uma forma que parallels como o `xml:lang` atributo pode herdar ao âmbito do elemento subordinado no [!INCLUDE[TLA2#tla_xml](~/add/includes/tla2sharptla-xml-md.md)]. Se definir o idioma, esse valor torna-se a `xml:lang` e substitui qualquer valor anterior. Para obter mais informações, consulte [XML: lang processamento em XAML](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;dependencyPropertyInfo_CultureInfo&quot;></a># # Informações de propriedade de dependência |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.LanguageProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkElement.LanguageProperty>"
  syntax:
    content: public System.Windows.Markup.XmlLanguage Language { get; set; }
    return:
      type: System.Windows.Markup.XmlLanguage
      description: "As informações de idioma para este elemento. O valor predefinido é um <xref href=&quot;System.Windows.Markup.XmlLanguage&quot;> </xref> com o respetivo <xref:System.Windows.Markup.XmlLanguage.IetfLanguageTag*>valor definido para a cadeia &quot;en-US&quot;.</xref:System.Windows.Markup.XmlLanguage.IetfLanguageTag*>"
  overload: System.Windows.FrameworkElement.Language*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.LanguageProperty
  id: LanguageProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: LanguageProperty
  nameWithType: FrameworkElement.LanguageProperty
  fullName: System.Windows.FrameworkElement.LanguageProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.Language*>propriedade de dependência.</xref:System.Windows.FrameworkElement.Language*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty LanguageProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.LayoutTransform
  id: LayoutTransform
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: LayoutTransform
  nameWithType: FrameworkElement.LayoutTransform
  fullName: System.Windows.FrameworkElement.LayoutTransform
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define uma transformação de gráficos que se deve aplicar a este elemento quando o esquema é executado."
  remarks: "Contrast para <xref:System.Windows.UIElement.RenderTransform%2A>, LayoutTransform irá afetar os resultados de esquema.</xref:System.Windows.UIElement.RenderTransform%2A>       Definir uma transformação fornece capacidades poderosas de dimensionamento e rodar. No entanto, ignora LayoutTransform <xref:System.Windows.Media.TranslateTransform>operações.</xref:System.Windows.Media.TranslateTransform> Isto acontece porque o comportamento do sistema de esquema para elementos subordinados de um <xref:System.Windows.FrameworkElement>corrige automaticamente quaisquer desvios para a posição de um elemento rotated ou dimensionado para o esquema e de sistema de coordenadas do elemento principal.</xref:System.Windows.FrameworkElement>       LayoutTransform pode levar ao nível de desempenho fraco aplicação se é a invocar um cenário que não necessita de uma passagem completa pelo sistema de esquema. Quando aplica um LayoutTransform para o <xref:System.Windows.Controls.Panel.Children%2A>coleção do <xref:System.Windows.Controls.Panel>, aciona uma nova passagem pelo sistema de esquema e força ecrã todos os objetos a ser remeasured e reorganizar.</xref:System.Windows.Controls.Panel> </xref:System.Windows.Controls.Panel.Children%2A> Se estão a atualizar a aplicação concluída [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)], esta funcionalidade pode ser exatamente o que precisa. No entanto, se não precisar de uma passagem de esquema completa, utilize o <xref:System.Windows.UIElement.RenderTransform%2A>propriedade, o que não será invocado o sistema de esquema e, por conseguinte, é normalmente uma melhor opção para este cenário.</xref:System.Windows.UIElement.RenderTransform%2A>       Exemplos de cenários onde LayoutTransform seria útil incluem: rodar elementos, tais como componentes de menu do horizontal para vertical ou vice-versa, dimensionamento elementos (ampliar) no foco, fornecendo o comportamento de edição, etc.      <a name=&quot;dependencyPropertyInfo_LayoutTransform&quot;> </a> # # Informações de propriedade de dependência |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.LayoutTransformProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.LayoutTransformProperty>"
  example:
  - "The following example shows how to apply a LayoutTransform to an element. The example creates an instance of <xref:System.Windows.Controls.Button> and hosts it within a parent <xref:System.Windows.Controls.Grid>. It also uses the LayoutTransform property to apply a <xref:System.Windows.Media.RotateTransform> to the <xref:System.Windows.Controls.Button>.  \n  \n [!code-vb[LayoutTransform#1](~/add/codesnippet/visualbasic/LayoutTransformVB/LayoutTransform.vb#1)]\n [!code-cpp[LayoutTransform#1](~/add/codesnippet/cpp/layouttransform/LayoutTransform.cpp#1)]\n [!code-xml[LayoutTransform#1](~/add/codesnippet/xaml/LayoutTransform/default.xaml#1)]\n [!code-cs[LayoutTransform#1](~/add/codesnippet/csharp/LayoutTransformCsharp/LayoutTransform.cs#1)]"
  syntax:
    content: public System.Windows.Media.Transform LayoutTransform { get; set; }
    return:
      type: System.Windows.Media.Transform
      description: "A transformação deve utilizar este elemento. A predefinição é <xref:System.Windows.Media.Transform.Identity*>.</xref:System.Windows.Media.Transform.Identity*>"
  overload: System.Windows.FrameworkElement.LayoutTransform*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.LayoutTransformProperty
  id: LayoutTransformProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: LayoutTransformProperty
  nameWithType: FrameworkElement.LayoutTransformProperty
  fullName: System.Windows.FrameworkElement.LayoutTransformProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.LayoutTransform*>propriedade de dependência.</xref:System.Windows.FrameworkElement.LayoutTransform*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty LayoutTransformProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Loaded
  id: Loaded
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Loaded
  nameWithType: FrameworkElement.Loaded
  fullName: System.Windows.FrameworkElement.Loaded
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando o elemento é disposto, pronto para interação e composto."
  remarks: "Carregar é normalmente o último evento desencadeado numa sequência de inicialização do elemento. Sempre será desencadeado após <xref:System.Windows.FrameworkElement.Initialized>.</xref:System.Windows.FrameworkElement.Initialized> Se optar por processar carregado ou <xref:System.Windows.FrameworkElement.Initialized>depende nos seus requisitos.</xref:System.Windows.FrameworkElement.Initialized> Se não pretender ler as propriedades de elemento, pretende repor propriedades e não necessitam de quaisquer informações de esquema, <xref:System.Windows.FrameworkElement.Initialized>poderá ser o evento melhor agir.</xref:System.Windows.FrameworkElement.Initialized> Se precisar de todas as propriedades do elemento para que fique disponível e irá ser definir propriedades que se prevê a repor o esquema, carregar pode ser o evento melhor agir. Tenha o cuidado de reentrancy se o processador repõe as propriedades que são interpretadas pelo sistema esquema tem de estar verdadeiramente que é necessária uma passagem de esquema novo. (Poderá ter de verificar o <xref:System.Windows.FrameworkPropertyMetadata>valores na propriedade se não souber das propriedades que podem exigir um novo esquema passaram se estes estão a ser alterados.)</xref:System.Windows.FrameworkPropertyMetadata>       Para obter mais informações sobre a sequência de eventos de objeto para uma <xref:System.Windows.FrameworkElement>e também para vários relacionados com classes de elemento e aplicações, consulte o artigo [eventos de duração do objeto](~/add/includes/ajax-current-ext-md.md).</xref:System.Windows.FrameworkElement>       Os eventos encaminhados diretos não siga uma rota, apenas são processados no elemento da mesmo em que são gerados. Direcionar os eventos encaminhados suporta outro comportamento de evento encaminhado: suporta a uma coleção de processadores acessível e pode ser utilizados como um <xref:System.Windows.EventTrigger>num style.</xref:System.Windows.EventTrigger>       Carregar e <xref:System.Windows.FrameworkElement.Unloaded>podem ambos ser geradas em controlos como resultado das alterações do tema de sistema iniciada pelo utilizador.</xref:System.Windows.FrameworkElement.Unloaded> Uma alteração de tema faz com que um invalidação de modelo de controlo e da árvore visual contida, o que por sua vez faz com que o controlo completo descarregar e volte a carregar. Por conseguinte carregado não pode ser considerado como ocorre apenas quando uma página é primeiro carregada através de navegação para a página.      <a name=&quot;routedEventInfo_Loaded&quot;></a># # Encaminhados informações sobre eventos |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.LoadedEvent>|   | Estratégia de encaminhamento | Direto |   | Delegado | <xref:System.Windows.RoutedEventHandler>|</xref:System.Windows.RoutedEventHandler></xref:System.Windows.FrameworkElement.LoadedEvent>"
  syntax:
    content: public event System.Windows.RoutedEventHandler Loaded;
    return:
      type: System.Windows.RoutedEventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.LoadedEvent
  id: LoadedEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: LoadedEvent
  nameWithType: FrameworkElement.LoadedEvent
  fullName: System.Windows.FrameworkElement.LoadedEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref href=&quot;System.Windows.FrameworkElement.Loaded&quot;> </xref> evento encaminhado."
  remarks: "Os identificadores de evento encaminhado são criados quando eventos encaminhados estão registados. Estes identificadores contenham um nome de identificação, tipo de proprietário, tipo de processador, estratégia de encaminhamento e método do utilitário para adicionar os proprietários para o evento. Pode utilizar estes identificadores para adicionar processadores de classe.       Para obter mais informações sobre como registar eventos encaminhados, consulte <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A> Para obter mais informações sobre como utilizar identificadores de evento encaminhado para adicionar processadores de classe, consulte <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</xref:System.Windows.EventManager.RegisterClassHandler%2A>"
  syntax:
    content: public static readonly System.Windows.RoutedEvent LoadedEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.LogicalChildren
  id: LogicalChildren
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: LogicalChildren
  nameWithType: FrameworkElement.LogicalChildren
  fullName: System.Windows.FrameworkElement.LogicalChildren
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém um enumerador de elementos subordinados lógica deste elemento."
  remarks: "LogicalChildren permite-lhe iterar elementos subordinados. Isto é útil para os elementos que poderão não tem uma coleção definida, dedicada, mas ainda conter mais de um elemento subordinado, particularmente <xref:System.Windows.FrameworkContentElement>elementos subordinados.</xref:System.Windows.FrameworkContentElement>       Para obter mais informações sobre como utilizar LogicalChildren e <xref:System.Windows.FrameworkElement.AddLogicalChild%2A>, consulte [árvores no WPF](~/add/includes/ajax-current-ext-md.md).</xref:System.Windows.FrameworkElement.AddLogicalChild%2A>"
  syntax:
    content: protected virtual System.Collections.IEnumerator LogicalChildren { get; }
    return:
      type: System.Collections.IEnumerator
      description: "Um enumerador de elementos subordinados lógica deste elemento."
  overload: System.Windows.FrameworkElement.LogicalChildren*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Margin
  id: Margin
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Margin
  nameWithType: FrameworkElement.Margin
  fullName: System.Windows.FrameworkElement.Margin
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define a margem externa de um elemento."
  remarks: "A margem é o espaço entre este elemento e outros elementos que irão ser adjacentes quando cria o esquema de [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]. Elementos partilhados podem estar elementos de ponto a ponto (tal como outros elementos da coleção de um controlo principal comum), ou também podem ser o principal deste elemento.       A margem está definida como um <xref:System.Windows.Thickness>estrutura e não como um número para que a margem pode ser definida asymmetrically.</xref:System.Windows.Thickness> O <xref:System.Windows.Thickness>estrutura próprio suporta uma conversão de tipo cadeia para que pode especificar uma margem assimétrica no [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] também a sintaxe de atributos.</xref:System.Windows.Thickness>       A margem de diferente de zero aplica-se espaço fora do esquema de elemento <xref:System.Windows.FrameworkElement.ActualWidth%2A>e <xref:System.Windows.FrameworkElement.ActualHeight%2A>.</xref:System.Windows.FrameworkElement.ActualHeight%2A> </xref:System.Windows.FrameworkElement.ActualWidth%2A>       Margens são cumulativas para elementos colaterais num esquema; Por exemplo, dois elementos adjacentes que com uma margem de 30 definidos na margem adjoining teria 60 unidades de espaço entre eles.       Os elementos que tenham margens definir irão não normalmente restringir o tamanho da margem da especificado se o espaço atribuído retângulo não é suficientemente grande para a margem plus a área de conteúdo do elemento. A área de conteúdo do elemento ser restrita em vez disso, quando o esquema é calculado. O cenário apenas onde as margens seriam restrita é também se o conteúdo já está restringido para zero.      <a name=&quot;xamlAttributeUsage_Margin&quot;></a># # Utilização do atributo de XAML ```   <object Margin=&quot;left,top,right,bottom&quot;/>   - or -   <object Margin=&quot;left,top&quot;/>   - or -   <object Margin=&quot;thicknessReference&quot;/>   ``` <a name=&quot;xamlPropertyElementUsage_Margin&quot;> </a> # # utilização de elemento de propriedade XAML ```   <object>     <object.Margin>       <Thickness Left=&quot;left&quot; Top=&quot;top&quot; Right=&quot;right&quot; Bottom=&quot;bottom&quot;/>     </object.Margin>   </object>   ``` <a name=&quot;xamlValues_Margin&quot;> </a> # # XAML valores *à esquerda, principais, com o botão direito, inferior* Number valores entre 0 e <xref:System.Double.PositiveInfinity>que especifique as propriedades de dimensão possível quatro de um <xref:System.Windows.Thickness>estrutura.</xref:System.Windows.Thickness> </xref:System.Double.PositiveInfinity>                   A utilização do atributo também irá aceitar abreviados valores que se aplicam a ordem fornecida, symmetrically e logicamente. Por exemplo, `Margin=&quot;20&quot;` será interpretado tem de estar verdadeiramente um <xref:System.Windows.Thickness>com todas as propriedades a definir para 20.</xref:System.Windows.Thickness> `Margin=&quot;20,50&quot;`será interpretado tem de estar verdadeiramente um <xref:System.Windows.Thickness>com <xref:System.Windows.Thickness.Left%2A>e <xref:System.Windows.Thickness.Right%2A>definido como 20, e <xref:System.Windows.Thickness.Top%2A>e <xref:System.Windows.Thickness.Bottom%2A>definido como 50.</xref:System.Windows.Thickness.Bottom%2A> </xref:System.Windows.Thickness.Top%2A> </xref:System.Windows.Thickness.Right%2A> </xref:System.Windows.Thickness.Left%2A> </xref:System.Windows.Thickness>       A unidade de predefinido para um <xref:System.Windows.Thickness>medida é [!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)].</xref:System.Windows.Thickness> Pode também especificar outras unidades, acrescentando as cadeias de tipo de unidade `cm`, `in`, ou `pt` para qualquer medida.       Número de valores fornecidos como [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] atributos não tem de especificar decimais (0 é aceitável, não tem de ser fornecido como 0,0). Para mais informações sobre [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)] utilização, consulte <xref:System.Windows.Thickness>.</xref:System.Windows.Thickness>       *thicknessReference* uma referência de objeto para uma <xref:System.Windows.Thickness>.</xref:System.Windows.Thickness> existente Esta situação pode ter um `}`, um, ou `}` referência. Para mais informações sobre [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)] utilização, consulte <xref:System.Windows.Thickness>.</xref:System.Windows.Thickness>      <a name=&quot;dependencyPropertyInfo_Margin&quot;></a># # Informações de propriedade de dependência |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.MarginProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.MarginProperty>"
  syntax:
    content: public System.Windows.Thickness Margin { get; set; }
    return:
      type: System.Windows.Thickness
      description: "Fornece valores de margem para o elemento. O valor predefinido é um <xref href=&quot;System.Windows.Thickness&quot;> </xref> com todas as propriedades de igual a 0 (zero)."
  overload: System.Windows.FrameworkElement.Margin*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MarginProperty
  id: MarginProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MarginProperty
  nameWithType: FrameworkElement.MarginProperty
  fullName: System.Windows.FrameworkElement.MarginProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.Margin*>propriedade de dependência.</xref:System.Windows.FrameworkElement.Margin*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty MarginProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MaxHeight
  id: MaxHeight
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MaxHeight
  nameWithType: FrameworkElement.MaxHeight
  fullName: System.Windows.FrameworkElement.MaxHeight
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define a restrição de altura máxima do elemento."
  remarks: "Esta é uma das três propriedades no <xref:System.Windows.FrameworkElement>que especifique informações de altura.</xref:System.Windows.FrameworkElement> As outras duas são <xref:System.Windows.FrameworkElement.MinHeight%2A>e <xref:System.Windows.FrameworkElement.Height%2A>.</xref:System.Windows.FrameworkElement.Height%2A> </xref:System.Windows.FrameworkElement.MinHeight%2A>  Se houver um conflito entre estes valores, a ordem da aplicação para a determinação de altura real é primeiro <xref:System.Windows.FrameworkElement.MinHeight%2A>tem de ser honrado, em seguida, MaxHeight e, finalmente, se cada um destes está dentro dos limites, <xref:System.Windows.FrameworkElement.Height%2A>.</xref:System.Windows.FrameworkElement.Height%2A> </xref:System.Windows.FrameworkElement.MinHeight%2A>       As restrições de valor sobre o <xref:System.Double>valor são impostas por um <xref:System.Windows.ValidateValueCallback>mecanismo.</xref:System.Windows.ValidateValueCallback> </xref:System.Double> Se tentar definir um valor inválido é emitida uma exceção de tempo de execução.      <a name=&quot;xamlAttributeUsage_MaxHeight&quot;></a># # Utilização do atributo de XAML ```   <object MaxHeight=&quot;double&quot;/>   - or –   <object MaxHeight =&quot;qualifiedDouble&quot;/>   ``` <a name=&quot;xamlValues_MaxHeight&quot;> </a> # # XAML valores *duplo* <xref:System.Double> cadeia representação de um <xref:System.Double>valor igual ou maior do que 0,0.</xref:System.Double> </xref:System.Double>           Isto é interpretado como um [!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)] medida. As cadeias não tem de incluir explicitamente decimais. Por exemplo, um valor de `1` é aceitável.       O mesmo <xref:System.Double>aplicam restrições de intervalo, tal como mencionado na secção de valor de propriedade, exceto que tem de utilizar [x: estática extensão de Markup](~/add/includes/ajax-current-ext-md.md) se tem de definir explicitamente o valor para ser <xref:System.Double.PositiveInfinity>.</xref:System.Double.PositiveInfinity> </xref:System.Double>       *qualifiedDouble* A *duplo* valor, tal como descrito acima, seguido de uma das seguintes cadeias de declaração de unidade: `px`, `in`, `cm`, `pt`.       `px`(predefinição) é [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)] `in` é polegadas; 1 in = = 96px `cm` é centímetros; 1cm==(96/2.54) px `pt` é pontos; 1pt==(96/72) px <a name=&quot;dependencyPropertyInfo_MaxHeight&quot;> </a> # # informações de propriedade de dependência |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.MaxHeightProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.MaxHeightProperty>       "
  syntax:
    content: public double MaxHeight { get; set; }
    return:
      type: System.Double
      description: "A altura máxima do elemento, na [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]. O valor predefinido é <xref:System.Double>.</xref:System.Double> Este valor pode ser qualquer valor igual ou maior do que 0,0. <xref:System.Double>Também é válido.</xref:System.Double>"
  overload: System.Windows.FrameworkElement.MaxHeight*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MaxHeightProperty
  id: MaxHeightProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MaxHeightProperty
  nameWithType: FrameworkElement.MaxHeightProperty
  fullName: System.Windows.FrameworkElement.MaxHeightProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.MaxHeight*>propriedade de dependência.</xref:System.Windows.FrameworkElement.MaxHeight*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty MaxHeightProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MaxWidth
  id: MaxWidth
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MaxWidth
  nameWithType: FrameworkElement.MaxWidth
  fullName: System.Windows.FrameworkElement.MaxWidth
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define a restrição de largura máxima do elemento."
  remarks: "Esta é uma das três propriedades no <xref:System.Windows.FrameworkElement>que especifique informações de largura.</xref:System.Windows.FrameworkElement> As outras duas são <xref:System.Windows.FrameworkElement.MinWidth%2A>e <xref:System.Windows.FrameworkElement.Width%2A>.</xref:System.Windows.FrameworkElement.Width%2A> </xref:System.Windows.FrameworkElement.MinWidth%2A> Se houver um conflito entre estes valores, a ordem da aplicação para a determinação de largura real é primeiro <xref:System.Windows.FrameworkElement.MinWidth%2A>tem de ser honrado, em seguida, MaxWidth e, finalmente, se cada um destes está dentro dos limites, <xref:System.Windows.FrameworkElement.Width%2A>.</xref:System.Windows.FrameworkElement.Width%2A> </xref:System.Windows.FrameworkElement.MinWidth%2A>       As restrições de valor sobre o <xref:System.Double>valor são impostas por um <xref:System.Windows.ValidateValueCallback>mecanismo.</xref:System.Windows.ValidateValueCallback> </xref:System.Double> Se tentar definir um valor inválido, é emitida uma exceção de tempo de execução.      <a name=&quot;xamlAttributeUsage_MaxWidth&quot;></a># # Utilização do atributo de XAML ```   <object MaxWidth=&quot;double&quot;/>   - or -   <object MaxWidth=&quot;qualifiedDouble&quot;/>   ``` <a name=&quot;xamlValues_MaxWidth&quot;> </a> # # XAML valores *duplo* <xref:System.Double> cadeia representação de um <xref:System.Double>valor igual ou maior do que 0,0.</xref:System.Double> </xref:System.Double>           Isto é interpretado como um [!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)] medida. As cadeias não tem de incluir explicitamente decimais. Por exemplo, um valor de `1` é aceitável.       O mesmo <xref:System.Double>aplicam restrições de intervalo, tal como mencionado na secção de valor de propriedade, exceto que tem de utilizar [x: estática extensão de Markup](~/add/includes/ajax-current-ext-md.md) para definir o valor para ser <xref:System.Double.PositiveInfinity>.</xref:System.Double.PositiveInfinity> </xref:System.Double>       *qualifiedDouble* A *duplo* valor, tal como descrito acima, seguido de uma das seguintes cadeias de declaração de unidade: `px`, `in`, `cm`, `pt`.       `px`(predefinição) é [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)] `in` é polegadas; 1 in = = 96px `cm` é centímetros; 1cm==(96/2.54) px `pt` é pontos; 1pt==(96/72) px <a name=&quot;dependencyPropertyInfo_MaxWidth&quot;> </a> # # informações de propriedade de dependência |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.MaxWidthProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.MaxWidthProperty>       "
  syntax:
    content: public double MaxWidth { get; set; }
    return:
      type: System.Double
      description: "A largura máxima do elemento, na [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]. O valor predefinido é <xref:System.Double>.</xref:System.Double> Este valor pode ser qualquer valor igual ou maior do que 0,0. <xref:System.Double>Também é válido.</xref:System.Double>"
  overload: System.Windows.FrameworkElement.MaxWidth*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MaxWidthProperty
  id: MaxWidthProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MaxWidthProperty
  nameWithType: FrameworkElement.MaxWidthProperty
  fullName: System.Windows.FrameworkElement.MaxWidthProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.MaxWidth*>propriedade de dependência.</xref:System.Windows.FrameworkElement.MaxWidth*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty MaxWidthProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)
  id: MeasureCore(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MeasureCore(Size)
  nameWithType: FrameworkElement.MeasureCore(Size)
  fullName: System.Windows.FrameworkElement.MeasureCore(Size)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Implementa basic medidas-passagem de comportamento do sistema de esquema <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref>."
  remarks: "Este método substitui <xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=fullName>liga ao nível do WPF núcleos e implementações de medida do esquema de nível de framework WPF.</xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=fullName> O <xref:System.Windows.FrameworkElement>implementação seals o método.</xref:System.Windows.FrameworkElement> Para ajustar o comportamento de esquema de passagem de medidas de qualquer elemento que é criada no nível framework WPF, substituir <xref:System.Windows.FrameworkElement.MeasureOverride%2A>em vez disso.</xref:System.Windows.FrameworkElement.MeasureOverride%2A> Para ajustar o comportamento de esquema de passagem de medidas de um elemento que deliberadamente não criar no nível framework WPF ou utilizar <xref:System.Windows.FrameworkElement>, substitua <xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=fullName>.</xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=fullName> </xref:System.Windows.FrameworkElement>"
  syntax:
    content: protected override sealed System.Windows.Size MeasureCore (System.Windows.Size availableSize);
    parameters:
    - id: availableSize
      type: System.Windows.Size
      description: "O tamanho disponível que pode dar o elemento principal para os elementos subordinados."
    return:
      type: System.Windows.Size
      description: "O tamanho pretendido deste elemento no esquema."
  overload: System.Windows.FrameworkElement.MeasureCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)
  id: MeasureOverride(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MeasureOverride(Size)
  nameWithType: FrameworkElement.MeasureOverride(Size)
  fullName: System.Windows.FrameworkElement.MeasureOverride(Size)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Quando substituí-lo de uma classe derivada, mede o tamanho do esquema necessário para elementos subordinados e determina um tamanho para o <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref>-classe derivada."
  remarks: "Substituir MeasureOverride para implementar o comportamento de dimensionamento de esquema personalizadas para o seu elemento participa no [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] sistema de esquema. A implementação deve fazer o seguinte: 1.  Iterar coleção específica do seu elemento de subordinados que fazem parte do esquema, chamada <xref:System.Windows.UIElement.Measure%2A>em cada elemento subordinado.</xref:System.Windows.UIElement.Measure%2A>      2.  Obter imediatamente <xref:System.Windows.UIElement.DesiredSize%2A>no subordinado (isto estiver definido como uma propriedade após <xref:System.Windows.UIElement.Measure%2A>denomina).</xref:System.Windows.UIElement.Measure%2A> </xref:System.Windows.UIElement.DesiredSize%2A>      3.  O tamanho pretendido net principal com base na medida dos elementos subordinados de computação.       O valor de retorno de MeasureOverride deve ser o tamanho do elemento própria assim o desejar, em seguida, torna-se a entrada de medida para o elemento principal do elemento actual. Este processo mesmo continua através do sistema de esquema até que o elemento de raiz da página foi atingido.       Durante este processo, os elementos subordinados podem devolver uma maior <xref:System.Windows.UIElement.DesiredSize%2A>tamanho que iniciais `availableSize` para indicar que o elemento subordinado pretende mais espaço.</xref:System.Windows.UIElement.DesiredSize%2A> Isto poderá ser processado na sua própria implementação ao introduzir uma região deslocável, por redimensionar o controlo principal, através do estabelecimento de alguma forma de ordem empilhada ou qualquer número de soluções para medir ou arranging conteúdo.      > [!IMPORTANT] > Elementos devem chamar <xref:System.Windows.UIElement.Measure%2A>em cada subordinado durante este processo, caso contrário, os elementos subordinados serão não corretamente dimensionados ou dispostos.</xref:System.Windows.UIElement.Measure%2A>"
  syntax:
    content: protected virtual System.Windows.Size MeasureOverride (System.Windows.Size availableSize);
    parameters:
    - id: availableSize
      type: System.Windows.Size
      description: "O tamanho disponível que este elemento pode dar aos elementos subordinados. Infinity pode ser especificado como um valor a indicar que o elemento será dimensionada para qualquer conteúdo está disponível."
    return:
      type: System.Windows.Size
      description: "Tem o tamanho que este elemento determina-lo durante o esquema, com base no respetivos cálculos de tamanhos de elemento subordinado."
  overload: System.Windows.FrameworkElement.MeasureOverride*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MinHeight
  id: MinHeight
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MinHeight
  nameWithType: FrameworkElement.MinHeight
  fullName: System.Windows.FrameworkElement.MinHeight
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define a restrição de altura mínima do elemento."
  remarks: "Esta é uma das três propriedades no <xref:System.Windows.FrameworkElement>que especifique informações de altura.</xref:System.Windows.FrameworkElement>  As outras duas são <xref:System.Windows.FrameworkElement.Height%2A>e <xref:System.Windows.FrameworkElement.MaxHeight%2A>.</xref:System.Windows.FrameworkElement.MaxHeight%2A> </xref:System.Windows.FrameworkElement.Height%2A> Se existir um conflito entre estes valores, a ordem da aplicação para a determinação de altura real é MinHeight primeiro deve ser cumprida, em seguida, <xref:System.Windows.FrameworkElement.MaxHeight%2A>e, finalmente, se cada um destes está dentro dos limites, <xref:System.Windows.FrameworkElement.Height%2A>.</xref:System.Windows.FrameworkElement.Height%2A> </xref:System.Windows.FrameworkElement.MaxHeight%2A>       As restrições de valor sobre o <xref:System.Double>valor são impostas por um <xref:System.Windows.ValidateValueCallback>mecanismo.</xref:System.Windows.ValidateValueCallback> </xref:System.Double> Se tentar definir um valor inválido, é emitida uma exceção de tempo de execução.      <a name=&quot;xamlAttributeUsage_MinHeight&quot;></a># # Utilização do atributo de XAML ```   <object MinHeight=&quot;double&quot;/>   - or -   <object MinHeight=&quot;qualifiedDouble&quot;/>   ``` <a name=&quot;xamlValues_MinHeight&quot;> </a> # # XAML valores *duplo* <xref:System.Double> cadeia representação de um <xref:System.Double>valor igual ou maior do que 0,0.</xref:System.Double> </xref:System.Double>           Isto é interpretado como um [!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)] medida. As cadeias não tem de incluir explicitamente decimais. Por exemplo, um valor de `1` é aceitável.       O mesmo <xref:System.Double>aplicam restrições de intervalo, tal como mencionado na secção de valor de propriedade.</xref:System.Double>       *qualifiedDouble* A *duplo* valor, tal como descrito acima, seguido de uma das seguintes cadeias de declaração de unidade: `px`, `in`, `cm`, `pt`.       `px`(predefinição) é [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)] `in` é polegadas; 1 in = = 96px `cm` é centímetros; 1cm==(96/2.54) px `pt` é pontos; 1pt==(96/72) px <a name=&quot;dependencyPropertyInfo_MinHeight&quot;> </a> # # informações de propriedade de dependência |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.MinHeightProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.MinHeightProperty>       "
  syntax:
    content: public double MinHeight { get; set; }
    return:
      type: System.Double
      description: "A altura mínima do elemento, na [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]. O valor predefinido é 0,0. Este valor pode ser qualquer valor igual ou maior do que 0,0. No entanto, <xref:System.Double>não é válido, nem &lt;xref:System.Double?displayProperty=fullName&gt;.</xref:System.Double>"
  overload: System.Windows.FrameworkElement.MinHeight*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MinHeightProperty
  id: MinHeightProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MinHeightProperty
  nameWithType: FrameworkElement.MinHeightProperty
  fullName: System.Windows.FrameworkElement.MinHeightProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.MinHeight*>propriedade de dependência.</xref:System.Windows.FrameworkElement.MinHeight*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty MinHeightProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MinWidth
  id: MinWidth
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MinWidth
  nameWithType: FrameworkElement.MinWidth
  fullName: System.Windows.FrameworkElement.MinWidth
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define a restrição de largura mínima do elemento."
  remarks: "Esta é uma das três propriedades no <xref:System.Windows.FrameworkElement>que especifique informações de largura.</xref:System.Windows.FrameworkElement>  As outras duas são <xref:System.Windows.FrameworkElement.Width%2A>e <xref:System.Windows.FrameworkElement.MaxWidth%2A>.</xref:System.Windows.FrameworkElement.MaxWidth%2A> </xref:System.Windows.FrameworkElement.Width%2A>  Se existir um conflito entre estes valores, a ordem da aplicação para a determinação de largura real é MinWidth primeiro deve ser cumprida, em seguida, <xref:System.Windows.FrameworkElement.MaxWidth%2A>e, finalmente, se cada um destes está dentro dos limites, <xref:System.Windows.FrameworkElement.Width%2A>.</xref:System.Windows.FrameworkElement.Width%2A> </xref:System.Windows.FrameworkElement.MaxWidth%2A>       As restrições de valor sobre o <xref:System.Double>valor são impostas por um <xref:System.Windows.ValidateValueCallback>mecanismo.</xref:System.Windows.ValidateValueCallback> </xref:System.Double> Se tentar definir um valor inválido, é emitida uma exceção de tempo de execução.      <a name=&quot;xamlAttributeUsage_MinWidth&quot;></a># # Utilização do atributo de XAML ```   <object MinWidth=&quot;double&quot;/>   - or -   <object MinWidth=&quot;qualifiedDouble&quot;/>   ``` <a name=&quot;xamlValues_MinWidth&quot;> </a> # # XAML valores *duplo* <xref:System.Double> cadeia representação de um <xref:System.Double>valor igual ou maior do que 0,0.</xref:System.Double> </xref:System.Double>           Isto é interpretado como um [!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)] medida. As cadeias não tem de incluir explicitamente decimais. Por exemplo, um valor de `1` é aceitável.       O mesmo <xref:System.Double>aplicam restrições de intervalo, tal como mencionado na secção de valor de propriedade.</xref:System.Double>       *qualifiedDouble* A *duplo* valor, tal como descrito acima, seguido de uma das seguintes cadeias de declaração de unidade: `px`, `in`, `cm`, `pt`.       `px`(predefinição) é [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)] `in` é polegadas; 1 in = = 96px `cm` é centímetros; 1cm==(96/2.54) px `pt` é pontos; 1pt==(96/72) px <a name=&quot;dependencyPropertyInfo_MinWidth&quot;> </a> # # informações de propriedade de dependência |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.MinWidthProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.MinWidthProperty>       "
  syntax:
    content: public double MinWidth { get; set; }
    return:
      type: System.Double
      description: "A largura mínima do elemento, na [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]. O valor predefinido é 0,0. Este valor pode ser qualquer valor igual ou maior do que 0,0. No entanto, <xref:System.Double>não é válido, nem &lt;xref:System.Double?displayProperty=fullName&gt;.</xref:System.Double>"
  overload: System.Windows.FrameworkElement.MinWidth*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MinWidthProperty
  id: MinWidthProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MinWidthProperty
  nameWithType: FrameworkElement.MinWidthProperty
  fullName: System.Windows.FrameworkElement.MinWidthProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.MinWidth*>propriedade de dependência.</xref:System.Windows.FrameworkElement.MinWidth*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty MinWidthProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)
  id: MoveFocus(System.Windows.Input.TraversalRequest)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MoveFocus(TraversalRequest)
  nameWithType: FrameworkElement.MoveFocus(TraversalRequest)
  fullName: System.Windows.FrameworkElement.MoveFocus(TraversalRequest)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Move o foco do teclado na direção oposta a este elemento e a outro elemento numa direção transversal fornecido."
  remarks: "Esta implementação substitui <xref:System.Windows.UIElement.MoveFocus%2A?displayProperty=fullName>e seals o método.</xref:System.Windows.UIElement.MoveFocus%2A?displayProperty=fullName>"
  example:
  - "The following example implements a handler that handles several possible button inputs. Each button represents a possible <xref:System.Windows.Input.FocusNavigationDirection>. The handler tracks the element with current keyboard focus, and calls MoveFocus on that element, by specifying the appropriate <xref:System.Windows.Input.FocusNavigationDirection> as initialization for the <xref:System.Windows.Input.TraversalRequest> type parameter provided.  \n  \n [!code-cs[FocusSample#FocusSampleMoveFocus](~/add/codesnippet/csharp/FocusSample/Window1.xaml.cs#focussamplemovefocus)]\n [!code-vb[FocusSample#FocusSampleMoveFocus](~/add/codesnippet/visualbasic/focussample/window1.xaml.vb#focussamplemovefocus)]"
  syntax:
    content: public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);
    parameters:
    - id: request
      type: System.Windows.Input.TraversalRequest
      description: "A direção que foco está a ser movidos, como um valor de enumeração."
    return:
      type: System.Boolean
      description: "Devolve <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> se foco é movido com êxito; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> se o elemento de destino na direção como especificado não existe ou pode não ser teclado concentra-se."
  overload: System.Windows.FrameworkElement.MoveFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Name
  id: Name
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Name
  nameWithType: FrameworkElement.Name
  fullName: System.Windows.FrameworkElement.Name
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define o nome do elemento de identificação. O nome fornece uma referência para que o code-behind, tais como o código de processamento de eventos, pode fazer referência a um elemento de marcação depois-é construído durante o processamento por um [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] processador."
  remarks: "A utilização desta propriedade mais comum é especificar uma [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] nome do elemento como um atributo no markup.       Esta propriedade fornece essencialmente uma propriedade de ao nível do framework conveniência WPF para definir o [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] [x: nome da diretiva](~/add/includes/ajax-current-ext-md.md).       Os nomes têm de ser exclusivos dentro de um namescope. Para obter mais informações, consulte [WPF XAML Namescopes](~/add/includes/ajax-current-ext-md.md).       Obter um nome, se estiver a criar elementos no código não é comum. Se ainda tiver a referência adequada no código, apenas pode chamar os métodos e propriedades no elemento de referem e, geralmente, não serão necessário o nome. Uma exceção é se a cadeia de nome tem algumas sobrecarregado, o que significa, por exemplo se é útil apresentar esse nome nos [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]. Definição de um nome do code-behind se o nome original foi definido a partir do markup não também é recomendado e alterar a propriedade depois de carregar o [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] não irá alterar a referência do objeto original. As referências de objeto são criadas apenas quando os namescopes subjacentes explicitamente são criados durante a análise. Tem de chamar especificamente <xref:System.Windows.FrameworkElement.RegisterName%2A>para efetuar uma alteração eficaz para a propriedade de nome de um elemento já carregada.</xref:System.Windows.FrameworkElement.RegisterName%2A>       É um cenário relevantes em que o nome da definição a partir do código é importante quando registar os nomes de elementos storyboards serão executado, pelo que pode ser referenciadas em tempo de execução. Para poder registar um nome, também poderá ter de instanciar e atribuir um <xref:System.Windows.NameScope>instância.</xref:System.Windows.NameScope> Consulte a secção de exemplo, ou [descrição geral de Storyboards](~/add/includes/ajax-current-ext-md.md).       Nome da definição a partir do código limitou as aplicações, mas a obter um elemento com nome é mais comum. Um cenário específico é se a aplicação suporta um modelo de navegação, em que as páginas recarregar na aplicação e o código de tempo de execução não é necessariamente code-behind definido para essa página. O método do utilitário <xref:System.Windows.FrameworkElement.FindName%2A>, que está disponível a partir de qualquer <xref:System.Windows.FrameworkElement>, pode encontrar qualquer elemento por nome na árvore lógica para que o elemento, Pesquisar recursivamente a árvore conforme necessário.</xref:System.Windows.FrameworkElement> </xref:System.Windows.FrameworkElement.FindName%2A> Ou pode utilizar o <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>método estático de <xref:System.Windows.LogicalTreeHelper>, que também demora uma cadeia de nome como um argumento.</xref:System.Windows.LogicalTreeHelper> </xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>       Utilizado normalmente elementos raiz (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page>por exemplo) implementa a interface <xref:System.Windows.Markup.INameScope>.</xref:System.Windows.Markup.INameScope> </xref:System.Windows.Controls.Page> </xref:System.Windows.Window> Espera-se para impor que os nomes a ser inequívoca dentro do âmbito do seu implementações desta interface. Os elementos de raiz que definem esta interface também definem limites de comportamento namescope para todas as relacionados [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)].       A propriedade de nome também serve como um identificador para que outros processos. Por exemplo, o [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] modelo automatização irá utilizar nome como o AutomationId para clientes e fornecedores.       Os valores de cadeia utilizados para o nome tem algumas restrições, como impõe subjacentes [x: nome da diretiva](../Topic/x:Name%20Directive.md) definidos pelo [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] especificação. Nomeadamente, um nome tem de começar com uma letra ou um caráter de sublinhado (_) e tem de conter apenas letras, dígitos ou carateres de sublinhado. Para obter mais informações, consulte [WPF XAML Namescopes](../Topic/WPF%20XAML%20Namescopes.md).       O nome é uma das propriedades de dependência muito poucos que não podem ser animadas (<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> é `true` nos metadados), porque o nome em si é vital para direcionada para uma animação.</xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> Um nome de enlace de dados é tecnicamente possíveis, mas é um cenário muito invulgar porque um nome de vinculados a dados não é possível servir o principal objetivo pretendido da propriedade: para fornecer um ponto de ligação de identificador para code-behind.      <a name=&quot;dependencyPropertyInfo_Name&quot;></a># # Informações de propriedade de dependência |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.NameProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|</xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> </xref:System.Windows.FrameworkElement.NameProperty>"
  example:
  - "The following example sets the Name property in code, and then registers the name into the newly created <xref:System.Windows.NameScope> by calling <xref:System.Windows.FrameworkElement.RegisterName%2A>. The technique illustrated here is a requirement for animating with storyboards, because storyboards require targeting by the Name, and cannot be targeted by object reference.  \n  \n [!code-vb[animateHeight_procedural#FEName](~/add/codesnippet/visualbasic/animateheight/animatedheightexample.vb#fename)]\n [!code-cs[animateHeight_procedural#FEName](~/add/codesnippet/csharp/animateheight_csharp/AnimatedHeightExample.cs#fename)]"
  syntax:
    content: public string Name { get; set; }
    return:
      type: System.String
      description: "O nome do elemento. A predefinição é uma cadeia vazia."
  overload: System.Windows.FrameworkElement.Name*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.NameProperty
  id: NameProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: NameProperty
  nameWithType: FrameworkElement.NameProperty
  fullName: System.Windows.FrameworkElement.NameProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.Name*>propriedade de dependência.</xref:System.Windows.FrameworkElement.Name*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty NameProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnApplyTemplate
  id: OnApplyTemplate
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnApplyTemplate()
  nameWithType: FrameworkElement.OnApplyTemplate()
  fullName: System.Windows.FrameworkElement.OnApplyTemplate()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Quando substituí-lo de uma classe derivada, é invocado sempre que o código da aplicação ou processos internos chamar <xref:System.Windows.FrameworkElement.ApplyTemplate*>.</xref:System.Windows.FrameworkElement.ApplyTemplate*>"
  remarks: "Este método não tem qualquer implementação de predefinição.       Os modelos são a secção de concluída árvore visual um elemento que inclui a propriedade de modelo de um <xref:System.Windows.Style>que é aplicada para o elemento.</xref:System.Windows.Style> Para obter mais informações, consulte [estilos e Templating](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public virtual void OnApplyTemplate ();
    parameters: []
  overload: System.Windows.FrameworkElement.OnApplyTemplate*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  id: OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnContextMenuClosing(ContextMenuEventArgs)
  nameWithType: FrameworkElement.OnContextMenuClosing(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkElement.OnContextMenuClosing(ContextMenuEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Invocar sempre que um não processada <xref href=&quot;System.Windows.FrameworkElement.ContextMenuClosing&quot;> </xref> evento encaminhado atinge esta classe na respetiva rota. Implemente este método para adicionar classe de processamento para este evento."
  remarks: "This method has no default implementation. You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled."
  syntax:
    content: protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ContextMenuEventArgs
      description: "Fornece dados sobre o evento."
  overload: System.Windows.FrameworkElement.OnContextMenuClosing*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  id: OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnContextMenuOpening(ContextMenuEventArgs)
  nameWithType: FrameworkElement.OnContextMenuOpening(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkElement.OnContextMenuOpening(ContextMenuEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Invocar sempre que um não processada <xref href=&quot;System.Windows.FrameworkElement.ContextMenuOpening&quot;> </xref> evento encaminhado atinge esta classe na respetiva rota. Implemente este método para adicionar classe de processamento para este evento."
  remarks: "This method has no default implementation. You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled."
  syntax:
    content: protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ContextMenuEventArgs
      description: "O <xref href=&quot;System.Windows.RoutedEventArgs&quot;> </xref> que contém os dados do evento."
  overload: System.Windows.FrameworkElement.OnContextMenuOpening*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)
  id: OnGotFocus(System.Windows.RoutedEventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnGotFocus(RoutedEventArgs)
  nameWithType: FrameworkElement.OnGotFocus(RoutedEventArgs)
  fullName: System.Windows.FrameworkElement.OnGotFocus(RoutedEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Invocar sempre que um não processada <xref href=&quot;System.Windows.UIElement.GotFocus&quot;> </xref> eventos atingirem este elemento na respetiva rota."
  remarks: "Ao contrário de algumas outras no * métodos expostos pelos elementos de base, OnGotFocus tem uma implementação predefinida. Especificamente, tem uma implementação que substitui a implementação no nível seguinte do elemento base baixo <xref:System.Windows.UIElement.OnGotFocus%2A>.</xref:System.Windows.UIElement.OnGotFocus%2A> nulo Quando foi invocado, OnGotFocus define o comportamento de foco adequada neste elemento nos casos em que o evento com origem do elemento actual devido a foco do teclado. O processador de OnGotFocus não marcar os argumentos de eventos como processada, mesmo quando o foco esteja definido para o elemento actual. Se a origem do evento foi outro elemento na árvore da (não o elemento actual), o processador não produz qualquer efeito.       Pode substituir este método para alterar o comportamento de foco predefinido no seu elemento, mas tenha em atenção que alterar o comportamento de foco desta forma poderá ser melhor efetuado por não permitir que o elemento seja focusable em todos os (consulte <xref:System.Windows.UIElement.Focusable%2A>).</xref:System.Windows.UIElement.Focusable%2A>"
  syntax:
    content: protected override void OnGotFocus (System.Windows.RoutedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.RoutedEventArgs
      description: "O <xref href=&quot;System.Windows.RoutedEventArgs&quot;> </xref> que contém os dados do evento."
  overload: System.Windows.FrameworkElement.OnGotFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnInitialized(System.EventArgs)
  id: OnInitialized(System.EventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnInitialized(EventArgs)
  nameWithType: FrameworkElement.OnInitialized(EventArgs)
  fullName: System.Windows.FrameworkElement.OnInitialized(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Gera o <xref href=&quot;System.Windows.FrameworkElement.Initialized&quot;> </xref> eventos. Este método é invocado sempre que <xref:System.Windows.FrameworkElement.IsInitialized*>está definido como <xref uid=&quot;langword_csharp_true &quot; name=&quot;true &quot; href=&quot;&quot;> </xref>internamente.</xref:System.Windows.FrameworkElement.IsInitialized*>"
  remarks: "This particular On* method is not a class handler hook. Nor does it exactly follow the established [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] On\\* method convention that the matching event could be suppressed by overriding this method and not calling the base implementation.  \n  \n Note that the <xref:System.Windows.FrameworkElement.IsInitialized%2A> property is read-only, so you cannot set <xref:System.Windows.FrameworkElement.IsInitialized%2A> to force initialization behavior. Setting the initialization state is intended to be done only by the [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] framework."
  syntax:
    content: protected virtual void OnInitialized (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "O <xref href=&quot;System.Windows.RoutedEventArgs&quot;> </xref> que contém os dados do evento."
  overload: System.Windows.FrameworkElement.OnInitialized*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  id: OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnPropertyChanged(DependencyPropertyChangedEventArgs)
  nameWithType: FrameworkElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.FrameworkElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Invocar sempre que o valor Efetivo de qualquer propriedade de dependência neste <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref> foi atualizada. A propriedade de dependência específico que foram alterados é reportada no parâmetro de argumentos. Substituições <xref:System.Windows.DependencyObject.OnPropertyChanged*>.</xref:System.Windows.DependencyObject.OnPropertyChanged*>"
  remarks: "Este método destina-se não, geralmente, detetar alterações de propriedade ou invalidations. Em vez disso, destina-se para as modificações do padrão invalidação geral se for conhecidas determinadas informações sobre classificações de wide das propriedades.       Invocar este método é, potencialmente, muitas vezes durante a vigência de um objeto. Por conseguinte, pode obter um melhor desempenho se substituir os metadados de propriedades específicas e, em seguida, anexar <xref:System.Windows.CoerceValueCallback>ou <xref:System.Windows.PropertyChangedCallback>funções para as propriedades individuais.</xref:System.Windows.PropertyChangedCallback> </xref:System.Windows.CoerceValueCallback> No entanto, utilizaria este método se um <xref:System.Windows.FrameworkElement>inclui um número significativo de propriedades de dependência interligados de valor, ou se inclui lógica, tais como o comportamento de composição que deve ser voltar a executar para vários relacionados com casos de invalidations de propriedade.</xref:System.Windows.FrameworkElement>       Tenha em atenção que não há um com nomes idênticos `OnPropertyChanged` método com uma assinatura diferente (é do tipo de parâmetro <xref:System.ComponentModel.PropertyChangedEventArgs>) que pode aparecer num número de classes.</xref:System.ComponentModel.PropertyChangedEventArgs> Que `OnPropertyChanged` é utilizado para notificações de objeto de dados e faz parte do contrato para <xref:System.ComponentModel.INotifyPropertyChanged>.</xref:System.ComponentModel.INotifyPropertyChanged>"
  syntax:
    content: protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DependencyPropertyChangedEventArgs
      description: "Os dados do evento que descreve a propriedade alterada, bem como valores antigos e novos."
  overload: System.Windows.FrameworkElement.OnPropertyChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)
  id: OnRenderSizeChanged(System.Windows.SizeChangedInfo)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnRenderSizeChanged(SizeChangedInfo)
  nameWithType: FrameworkElement.OnRenderSizeChanged(SizeChangedInfo)
  fullName: System.Windows.FrameworkElement.OnRenderSizeChanged(SizeChangedInfo)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Gera o <xref href=&quot;System.Windows.FrameworkElement.SizeChanged&quot;> </xref> eventos, utilizando as informações especificadas como parte de uma eventual de dados de eventos."
  remarks: "Este método substitui <xref:System.Windows.UIElement.OnRenderSizeChanged%2A>.</xref:System.Windows.UIElement.OnRenderSizeChanged%2A> Se chamar este método repõe o <xref:System.Windows.FrameworkElement.ActualWidth%2A>propriedade, o <xref:System.Windows.FrameworkElement.ActualHeight%2A>propriedade ou ambas, consoante o que é especificado como alterados nos argumentos fornecidos e emitirá sempre o evento.</xref:System.Windows.FrameworkElement.ActualHeight%2A> </xref:System.Windows.FrameworkElement.ActualWidth%2A>"
  syntax:
    content: protected override void OnRenderSizeChanged (System.Windows.SizeChangedInfo sizeInfo);
    parameters:
    - id: sizeInfo
      type: System.Windows.SizeChangedInfo
      description: "Detalhes do tamanho antigo e novo envolvido na alteração."
  overload: System.Windows.FrameworkElement.OnRenderSizeChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)
  id: OnStyleChanged(System.Windows.Style,System.Windows.Style)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnStyleChanged(Style,Style)
  nameWithType: FrameworkElement.OnStyleChanged(Style,Style)
  fullName: System.Windows.FrameworkElement.OnStyleChanged(Style,Style)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Invocada quando altera o estilo de ser utilizado neste elemento, que irá invalidar o esquema."
  remarks: "Este método tem uma implementação predefinida que define um sinalizador interno que indica a condição de estilo alterado."
  syntax:
    content: protected virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);
    parameters:
    - id: oldStyle
      type: System.Windows.Style
      description: "O estilo antigo."
    - id: newStyle
      type: System.Windows.Style
      description: "O estilo de novo."
  overload: System.Windows.FrameworkElement.OnStyleChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  id: OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnToolTipClosing(ToolTipEventArgs)
  nameWithType: FrameworkElement.OnToolTipClosing(ToolTipEventArgs)
  fullName: System.Windows.FrameworkElement.OnToolTipClosing(ToolTipEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Invocar sempre que um não processada <xref href=&quot;System.Windows.FrameworkElement.ToolTipClosing&quot;> </xref> evento encaminhado atinge esta classe na respetiva rota. Implemente este método para adicionar classe de processamento para este evento."
  remarks: "This method has no default implementation. You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled."
  syntax:
    content: protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ToolTipEventArgs
      description: "Fornece dados sobre o evento."
  overload: System.Windows.FrameworkElement.OnToolTipClosing*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  id: OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnToolTipOpening(ToolTipEventArgs)
  nameWithType: FrameworkElement.OnToolTipOpening(ToolTipEventArgs)
  fullName: System.Windows.FrameworkElement.OnToolTipOpening(ToolTipEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Invocar sempre que o <xref href=&quot;System.Windows.FrameworkElement.ToolTipOpening&quot;> </xref> evento encaminhado atinge esta classe na respetiva rota. Implemente este método para adicionar classe de processamento para este evento."
  remarks: "This method has no default implementation. You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route."
  syntax:
    content: protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ToolTipEventArgs
      description: "Fornece dados sobre o evento."
  overload: System.Windows.FrameworkElement.OnToolTipOpening*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)
  id: OnVisualParentChanged(System.Windows.DependencyObject)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnVisualParentChanged(DependencyObject)
  nameWithType: FrameworkElement.OnVisualParentChanged(DependencyObject)
  fullName: System.Windows.FrameworkElement.OnVisualParentChanged(DependencyObject)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Invocada quando o elemento principal deste elemento na árvore visual é alterado. Substituições <xref:System.Windows.UIElement.OnVisualParentChanged*>.</xref:System.Windows.UIElement.OnVisualParentChanged*>"
  remarks: "Da árvore visual é potencialmente diferente da árvore lógica porque este omite elementos que não compor visualmente, tais como coleções e expande alguns elementos on the basis of os respetivos compositing tema e estilo. Para obter mais informações, consulte [árvores no WPF](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: protected override void OnVisualParentChanged (System.Windows.DependencyObject oldParent);
    parameters:
    - id: oldParent
      type: System.Windows.DependencyObject
      description: "O elemento principal antigo. Poderá ser <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> para indicar que o elemento não tinha um elemento visual principal anteriormente."
  overload: System.Windows.FrameworkElement.OnVisualParentChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OverridesDefaultStyle
  id: OverridesDefaultStyle
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OverridesDefaultStyle
  nameWithType: FrameworkElement.OverridesDefaultStyle
  fullName: System.Windows.FrameworkElement.OverridesDefaultStyle
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define um valor que indica se este elemento incorpora propriedades de estilo de estilos de temas."
  remarks: "A mais comuns a utilização desta propriedade é uma utilização indireta num setter de um estilo que está a fornecer um estilo de tema.      > [!IMPORTANT] > Se definir OverridesDefaultStyle para `true` num controlo, será suprimir o modelo de controlo de predefinido fornecido pelos estilos de temas. Esse modelo de controlo, incluem normalmente conteúdo apresentador e outros elementos composited que fornecem básico [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] funcionalidade e visualização do controlo. Se pretender que o controlo para continuar para suportar as mesmas funcionalidades como os estilos de tema predefinido, tem de fornecer um estilo com um modelo de controlo que replica a mesma estrutura de alternativo. Para obter mais informações, consulte [descrição geral da criação de controlo](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;dependencyPropertyInfo_OverridesDefaultStyle&quot;></a># # Informações de propriedade de dependência |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.OverridesDefaultStyleProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.OverridesDefaultStyleProperty>"
  syntax:
    content: public bool OverridesDefaultStyle { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se este elemento não utiliza as propriedades de estilo do tema; todas as propriedades de estilo de origem provenientes de estilos de aplicação local e propriedades de estilo de tema não se aplicam. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>se aplicam primeiro a estilos de aplicação e, em seguida, os estilos de temas aplicam para propriedades que não foram definidas especificamente no estilos de aplicação. A predefinição é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkElement.OverridesDefaultStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OverridesDefaultStyleProperty
  id: OverridesDefaultStyleProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OverridesDefaultStyleProperty
  nameWithType: FrameworkElement.OverridesDefaultStyleProperty
  fullName: System.Windows.FrameworkElement.OverridesDefaultStyleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.OverridesDefaultStyle*>propriedade de dependência.</xref:System.Windows.FrameworkElement.OverridesDefaultStyle*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Parent
  id: Parent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Parent
  nameWithType: FrameworkElement.Parent
  fullName: System.Windows.FrameworkElement.Parent
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém o elemento principal lógica deste elemento."
  remarks: "Poderá ser principal `null` nos casos em que um elemento foi instanciado, mas não está ligado a qualquer árvore lógica que liga, eventualmente, para o elemento de raiz de nível de página ou o objeto de aplicação.       Tenha em atenção que a lógica principal de um elemento, potencialmente, pode alterar, dependendo da funcionalidade da aplicação e manter o valor desta propriedade não irá refletir essa alteração. Normalmente, deve obter o valor imediatamente antes do ficheiro necessário.       Consulte [árvores no WPF](~/add/includes/ajax-current-ext-md.md) para obter mais informações sobre a transversal da árvore lógica e os cenários em que é adequado utilizar principal como uma técnica de deteção de elemento principal.       O motor de propriedade irá potencialmente recalcular todos os valores de propriedade de um elemento quando é reparented, porque algumas propriedades herdam valores através da árvore lógica. O <xref:System.Windows.FrameworkElement.DataContext%2A>que aplica-se para enlaces também podem ser alteradas quando elementos são reparented.</xref:System.Windows.FrameworkElement.DataContext%2A>       Alterar o principal de um elemento é geralmente apenas feito através da manipulação de coleções, utilizando dedicado adicionar ou remover métodos, ou através de definir as propriedades do conteúdo de elementos.       O cenário mais comum para utilizar a propriedade principal é para obter uma referência e, em seguida, obter vários <xref:System.Windows.FrameworkElement>valores de propriedade do principal.</xref:System.Windows.FrameworkElement> Os modelos, o principal do modelo, eventualmente, serão `null`. Para obter passado este ponto e expanda a árvore lógica em que o modelo, na verdade, é aplicado, utilize <xref:System.Windows.FrameworkElement.TemplatedParent%2A>.</xref:System.Windows.FrameworkElement.TemplatedParent%2A>       Tenha em atenção que esta propriedade não comunica principais da árvore visual nos casos em que estes variam entre os principais da árvore lógica. Principais de árvore Visual não são normalmente importantes para cenários de aplicações gerais, mas podem ser os elementos principais pretendido para certos casos nível visual. Consulte <xref:System.Windows.Media.VisualTreeHelper>.</xref:System.Windows.Media.VisualTreeHelper>"
  example:
  - "The following example shows code that checks for an element's parent, and then uses property values from the parent to set properties on the child element to match. In this case these are properties that affect the rendering size.  \n  \n [!code-vb[GeometryDesigner#FEParentProperty](~/add/codesnippet/visualbasic/geometrydesigner/window1.xaml.vb#feparentproperty)]\n [!code-cs[GeometryDesigner#FEParentProperty](~/add/codesnippet/csharp/GeometryDesigner/Window1.xaml.cs#feparentproperty)]"
  syntax:
    content: public System.Windows.DependencyObject Parent { get; }
    return:
      type: System.Windows.DependencyObject
      description: "Primário lógico este elemento."
  overload: System.Windows.FrameworkElement.Parent*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)
  id: ParentLayoutInvalidated(System.Windows.UIElement)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ParentLayoutInvalidated(UIElement)
  nameWithType: FrameworkElement.ParentLayoutInvalidated(UIElement)
  fullName: System.Windows.FrameworkElement.ParentLayoutInvalidated(UIElement)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Suporta implementações de esquema incremental nas subclasses especializadas de <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref>. ParentLayoutInvalidated é invocada quando existe um elemento subordinado invalidou uma propriedade que está marcado como nos metadados como que afetam a medida de principal ou a disposição transmite durante o esquema."
  remarks: "Se este elemento tem um elemento subordinado no qual alguns propriedade foi invalidada e a propriedade foi marcada como <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>ou <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>nos metadados da propriedade durante o registo, este método é invocado.</xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> </xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> A invocação do método notifica o elemento principal, o elemento subordinado específico tem de ser novamente medido se este elemento suporta uma atualização (incremental) parcial de esquema.       Por predefinição, <xref:System.Windows.FrameworkElement>não suporta o esquema de incremental e, no <xref:System.Windows.FrameworkElement>classe este método não tem qualquer implementação de predefinição.</xref:System.Windows.FrameworkElement> </xref:System.Windows.FrameworkElement> O cenário em que a substituir este método seria necessária não é comum, porque é necessária para modificar o comportamento predefinido do sistema de esquema.       Um exemplo de cenário de implementação poderá estar se uma classe tinha limitações de tipo para elementos subordinados possíveis significativamente mais restritivos do que o sistema de esquema ao nível do framework WPF. Devido à natureza destes elementos personalizados, alterações de propriedade foi ser deliberadamente diferidas ao implementar alguns comportamento de esquema personalizado. Por exemplo, de dispor de medidas/método as substituições que tente para otimizar o elemento subordinado compor passagem, foi ser adiadas para determinados tipos de alterações que normalmente iriam resultar em outro passagem de esquema."
  syntax:
    content: protected virtual void ParentLayoutInvalidated (System.Windows.UIElement child);
    parameters:
    - id: child
      type: System.Windows.UIElement
      description: "O elemento subordinado do Reporting Services a alteração."
  overload: System.Windows.FrameworkElement.ParentLayoutInvalidated*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  id: PredictFocus(System.Windows.Input.FocusNavigationDirection)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: PredictFocus(FocusNavigationDirection)
  nameWithType: FrameworkElement.PredictFocus(FocusNavigationDirection)
  fullName: System.Windows.FrameworkElement.PredictFocus(FocusNavigationDirection)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Determina o elemento seguinte que pretende receber o foco relativo para este elemento de uma direção de movimento de foco fornecido, mas não, na verdade, de mover o foco."
  remarks: "<xref:System.Windows.FrameworkElement.MoveFocus%2A>é o método relacionado que, na verdade, mover o foco.</xref:System.Windows.FrameworkElement.MoveFocus%2A>"
  example:
  - "The following example implements a handler that handles several possible button inputs, each button representing a possible <xref:System.Windows.Input.FocusNavigationDirection>. The handler tracks the element with current keyboard focus, and calls PredictFocus on that element, and specifies the appropriate <xref:System.Windows.Input.FocusNavigationDirection> as initialization for the <xref:System.Windows.Input.TraversalRequest> type parameter provided. Instead of moving to that element as <xref:System.Windows.FrameworkElement.MoveFocus%2A> would do, the handler changes the physical dimensions of the predicted focus destination for visualization purposes.  \n  \n [!code-cs[FocusSample#FEPredictFocus](~/add/codesnippet/csharp/FocusSample/Window1.xaml.cs#fepredictfocus)]\n [!code-vb[FocusSample#FEPredictFocus](~/add/codesnippet/visualbasic/focussample/window1.xaml.vb#fepredictfocus)]"
  syntax:
    content: public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);
    parameters:
    - id: direction
      type: System.Windows.Input.FocusNavigationDirection
      description: "A direção para o qual uma alteração de foco potenciais deve ser determinada."
    return:
      type: System.Windows.DependencyObject
      description: "O próximo elemento focar-se seria movidos para se realmente foram atravessado o foco. Poderá devolver <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se foco não é possível mover relativo para este elemento para a direção fornecida."
  overload: System.Windows.FrameworkElement.PredictFocus*
  exceptions:
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: 'Specified one of the following directions in the <xref href=&quot;System.Windows.Input.TraversalRequest&quot;></xref>: <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>, <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>, <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>, <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>. Estas instruções não são válidas para PredictFocus (mas estão legais para <xref:System.Windows.FrameworkElement.MoveFocus*>).</xref:System.Windows.FrameworkElement.MoveFocus*>'
  platform:
  - net462
- uid: System.Windows.FrameworkElement.RegisterName(System.String,System.Object)
  id: RegisterName(System.String,System.Object)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: RegisterName(String,Object)
  nameWithType: FrameworkElement.RegisterName(String,Object)
  fullName: System.Windows.FrameworkElement.RegisterName(String,Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Fornece um acessor que simplifica o acesso ao <xref:System.Windows.NameScope>método de registo.</xref:System.Windows.NameScope>"
  remarks: "Este método é um método de conveniência para chamar <xref:System.Windows.NameScope.RegisterName%2A>.</xref:System.Windows.NameScope.RegisterName%2A> A implementação irá verificar elementos principais sucessivas até encontrar a <xref:System.Windows.NameScope>implementação, que se encontra ao localizar um elemento que implementa <xref:System.Windows.Markup.INameScope>.</xref:System.Windows.Markup.INameScope> </xref:System.Windows.NameScope> aplicável Para obter mais informações sobre namescopes, consulte [WPF XAML Namescopes](~/add/includes/ajax-current-ext-md.md).       Chamar RegisterName é necessário para corretamente ligue storyboards de animação para aplicações quando criado no código. Isto acontece porque uma da chave de guião gráfico principal propriedades, <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, utiliza uma pesquisa de nome de tempo de execução em vez de ser capazes de tirar uma referência a um elemento de destino.</xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> Isto é verdadeiro, mesmo que esteja acessível por referência do código de que o elemento. Para obter mais informações sobre o motivo pelo qual tem de registar nomes para os destinos de guião gráfico principal, consulte [descrição geral de Storyboards](~/add/includes/ajax-current-ext-md.md)."
  example:
  - >-
    [!code-vb[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/add/codesnippet/visualbasic/animateproperty_storyboards_vb/scopeexample.vb#namescopeexample)]
     [!code-cs[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/add/codesnippet/csharp/AnimateProperty_Storyboards_csharp/ScopeExample.cs#namescopeexample)]
  syntax:
    content: public void RegisterName (string name, object scopedElement);
    parameters:
    - id: name
      type: System.String
      description: "Nome a utilizar para o mapeamento de objeto de nome especificado."
    - id: scopedElement
      type: System.Object
      description: "Objeto para o mapeamento."
  overload: System.Windows.FrameworkElement.RegisterName*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)
  id: RemoveLogicalChild(System.Object)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: RemoveLogicalChild(Object)
  nameWithType: FrameworkElement.RemoveLogicalChild(Object)
  fullName: System.Windows.FrameworkElement.RemoveLogicalChild(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Remove o objecto fornecido a árvore lógica este elemento. <xref href=&quot;System.Windows.FrameworkElement&quot;></xref>Atualiza os apontadores de principal de árvore lógica afetados para manter sincronizadas com este eliminação."
  remarks: "Utilize este método para a implementação de coleções em objetos que representam o subordinado lógico de um elemento. Isto pode ser feito na getters de propriedade ou setters, os processadores de classes de `Changed` eventos, construtores, ou dentro da coleção de tipos de si próprios.       Para autores de controlo, manipular a árvore lógica neste nível não está a prática recomendada, a menos que nenhum dos modelos de conteúdo da classe de controlo de base fornecidos são adequados. Considere subclassing ao nível dos <xref:System.Windows.Controls.ContentControl>, <xref:System.Windows.Controls.ItemsControl>e <xref:System.Windows.Controls.HeaderedItemsControl>.</xref:System.Windows.Controls.HeaderedItemsControl> </xref:System.Windows.Controls.ItemsControl> </xref:System.Windows.Controls.ContentControl> Estas classes fornecem um modelo de conteúdo com a imposição específico de subordinados lógicas dedicado através de [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)], bem como suporte de outras funcionalidades normalmente desejável num [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] controlo, tais como o estilo através de modelos."
  example:
  - "The following example implements a `Child` property on a custom <xref:System.Windows.FrameworkElement> that does its own visual layer implementation. The property's setter is designed so that if the value changes, the old value is removed from the logical tree, as well as a class-specific visual collection. The values are cached, and then the new value is added to both the standard WPF framework level logical tree and the custom visual collection.  \n  \n [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/add/codesnippet/visualbasic/compositiontargetrenderinganimations/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]\n [!code-cs[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/add/codesnippet/csharp/CompositionTargetRenderingAnimations/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]"
  syntax:
    content: protected void RemoveLogicalChild (object child);
    parameters:
    - id: child
      type: System.Object
      description: "O elemento para remover."
  overload: System.Windows.FrameworkElement.RemoveLogicalChild*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.RequestBringIntoView
  id: RequestBringIntoView
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: RequestBringIntoView
  nameWithType: FrameworkElement.RequestBringIntoView
  fullName: System.Windows.FrameworkElement.RequestBringIntoView
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando <xref:System.Windows.FrameworkElement.BringIntoView*>denomina-se neste elemento.</xref:System.Windows.FrameworkElement.BringIntoView*>"
  remarks: "Este evento indica a um elemento principal <xref:System.Windows.Controls.ScrollViewer>(ou a classe derivada) que o elemento que desencadeia o evento RequestBringIntoView deve ser tornado visível na região deslocável.</xref:System.Windows.Controls.ScrollViewer> O <xref:System.Windows.Controls.ScrollViewer>será, em seguida, marca o evento RequestBringIntoView como processada, utilizando o processamento de classe do evento.</xref:System.Windows.Controls.ScrollViewer> Em geral RequestBringIntoView dados de eventos não deverá ser marcados processados por qualquer classe que controlam uma região de deslocamento ou por qualquer instância de processador, porque fazê-lo seria interferir com o objetivo pretendido do elemento que chamada <xref:System.Windows.FrameworkElement.BringIntoView%2A>.</xref:System.Windows.FrameworkElement.BringIntoView%2A>      <a name=&quot;routedEventInfo_RequestBringIntoView&quot;></a># # Encaminhados informações sobre eventos |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.RequestBringIntoViewEvent>|   | Estratégia de encaminhamento | Bubbling |   | Delegado | <xref:System.Windows.RequestBringIntoViewEventHandler>|</xref:System.Windows.RequestBringIntoViewEventHandler></xref:System.Windows.FrameworkElement.RequestBringIntoViewEvent>"
  syntax:
    content: public event System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView;
    return:
      type: System.Windows.RequestBringIntoViewEventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.RequestBringIntoViewEvent
  id: RequestBringIntoViewEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: RequestBringIntoViewEvent
  nameWithType: FrameworkElement.RequestBringIntoViewEvent
  fullName: System.Windows.FrameworkElement.RequestBringIntoViewEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref href=&quot;System.Windows.FrameworkElement.RequestBringIntoView&quot;> </xref> evento encaminhado."
  syntax:
    content: public static readonly System.Windows.RoutedEvent RequestBringIntoViewEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Resources
  id: Resources
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Resources
  nameWithType: FrameworkElement.Resources
  fullName: System.Windows.FrameworkElement.Resources
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define o dicionário de recursos definida localmente."
  remarks: "Dicionários de recursos que podem ser definidos no completamente ou parcialmente [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)] são normalmente criadas como um elemento de propriedade e são, normalmente, no elemento de raiz para qualquer página individuais ou para a aplicação. Colocar o dicionário de recursos neste nível torna mais fácil localizar a partir dos elementos subordinados individuais na página (ou de qualquer página, no caso de aplicações). Na maioria dos cenários de aplicação, recomendamos que os estilos de ser definida como elementos de objeto dentro de um dicionário de recurso, ou ser definida como recursos externos para que o recurso de estilo completa pode ser autónomo (esta abordagem ajuda a separar as responsabilidades estruturador do responsabilidades de programador, separando os ficheiros físicos que necessitam de ser editado).       Tenha em atenção que esta propriedade devolve apenas o dicionário de recurso declarado diretamente nesse elemento. Isto é diferente do processo de pesquisa de recurso real, onde um elemento subordinado pode aceder a qualquer um dos recursos definidos em cada elemento principal, Pesquisar recursivamente upwards.       Recursos também podem ser referenciados por código a partir de dentro da coleção, mas tenha em atenção de que os recursos criados no [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] sem dúvida não serão acessíveis até após <xref:System.Windows.FrameworkElement.Loaded>é gerado pelo elemento que declara o dicionário.</xref:System.Windows.FrameworkElement.Loaded> Na verdade, os recursos são analisados no modo assíncrono e não mesmo a <xref:System.Windows.FrameworkElement.Loaded>evento é uma garantia que pode referenciar um [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] definido recursos.</xref:System.Windows.FrameworkElement.Loaded> Por este motivo, geralmente, só deve aceder [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] definidas recursos como parte do código de tempo de execução, ou através de outros [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] técnicas, tais como estilos ou as referências de extensão do recurso para valores de atributo. Ao aceder a recursos através de código, é essencialmente equivalente a uma referência feita a partir do [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)].       Subjacentes <xref:System.Windows.ResourceDictionary>suporta os métodos necessários para adicionar, remover ou consultar recursos a partir de dentro da coleção, utilizando o código.</xref:System.Windows.ResourceDictionary> A propriedade de recursos é definível para suportar o cenário de substituir completamente a coleção de recursos de um elemento seja um novo ou diferentes <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>       Tenha em atenção que o [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] sintaxe indicada não inclui um elemento para <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary> Este é um exemplo da sintaxe de coleção implícita; uma etiqueta que representa o elemento de coleção pode ser omitida. Os elementos que são adicionados como itens na coleção são especificados em vez disso. Para obter mais informações sobre coleções implícitas e [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], consulte [XAML sintaxe em detalhe](~/add/includes/ajax-current-ext-md.md). Um caso onde um <xref:System.Windows.ResourceDictionary>ainda está especificado explicitamente como um elemento é se a introdução de um dicionário intercalado, nesse caso existem, normalmente, não existem elementos subordinados para esse <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary> </xref:System.Windows.ResourceDictionary> Para obter mais informações, consulte [intercaladas dicionários de recurso](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;xamlPropertyElementUsage_Resources&quot;></a># # Utilização de elemento de propriedade de XAML ```   <object>     <object.Resources>       oneOrMoreResourceElements     </object.Resources>   </object>   ``` <a name=&quot;xamlValues_Resources&quot;> </a> # # XAML valores *oneOrMoreResourceElements* um ou mais elementos de objeto, cada um dos quais define um recurso.       Cada elemento de propriedade de recurso em cada <xref:System.Windows.ResourceDictionary>tem de ter um valor exclusivo para o [x: chave diretiva](~/add/includes/ajax-current-ext-md.md), que serve como a chave exclusiva quando os valores são obtidos a partir <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary> </xref:System.Windows.ResourceDictionary>"
  syntax:
    content: public System.Windows.ResourceDictionary Resources { get; set; }
    return:
      type: System.Windows.ResourceDictionary
      description: "O atual definida localmente dicionário de recursos, onde cada recurso pode ser acedido por chave."
  overload: System.Windows.FrameworkElement.Resources*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)
  id: SetBinding(System.Windows.DependencyProperty,System.String)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SetBinding(DependencyProperty,String)
  nameWithType: FrameworkElement.SetBinding(DependencyProperty,String)
  fullName: System.Windows.FrameworkElement.SetBinding(DependencyProperty,String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Anexa um enlace a este elemento, com base no nome de propriedade de origem fornecido como uma qualificação de caminho para a origem de dados."
  remarks: "Este método é um método de conveniência para chamar <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName>, que passa a instância atual como o <xref:System.Windows.DependencyObject>e cria um novo <xref:System.Windows.Data.Binding>com base no fornecido `path` parâmetro.</xref:System.Windows.Data.Binding> </xref:System.Windows.DependencyObject> </xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName> Esta assinatura é mais conveniente se for estabelecer um enlace de predefinição simples. Se tiver de especificar quaisquer propriedades do enlace às condições não predefinidas ou pretende utilizar um <xref:System.Windows.Data.MultiBinding>ou <xref:System.Windows.Data.PriorityBinding>, deve utilizar o <xref:System.Windows.FrameworkElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29>assinatura.</xref:System.Windows.FrameworkElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> </xref:System.Windows.Data.PriorityBinding> </xref:System.Windows.Data.MultiBinding>"
  example:
  - "The following example sets a binding using a specific path.  \n  \n [!code-cs[BaseElementsSmorgasbord#SetBindingPath](~/add/codesnippet/csharp/BaseElementsSmorgasbord/Page1.xaml.cs#setbindingpath)]\n [!code-vb[BaseElementsSmorgasbord#SetBindingPath](~/add/codesnippet/visualbasic/baseelementssmorgasbord/page1.xaml.vb#setbindingpath)]"
  syntax:
    content: public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "Identifica a propriedade de destino em que o enlace deve ser estabelecido."
    - id: path
      type: System.String
      description: "O nome de propriedade de origem ou o caminho para a propriedade utilizada para enlace."
    return:
      type: System.Windows.Data.BindingExpression
      description: "Regista as condições do enlace. Este valor de retorno pode ser útil para a verificação de erro."
  overload: System.Windows.FrameworkElement.SetBinding*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  id: SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SetBinding(DependencyProperty,BindingBase)
  nameWithType: FrameworkElement.SetBinding(DependencyProperty,BindingBase)
  fullName: System.Windows.FrameworkElement.SetBinding(DependencyProperty,BindingBase)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Anexa um enlace a este elemento, consoante o objeto de enlace fornecido."
  remarks: "Este método é um método de conveniência para chamar <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName>, que passa a instância atual como <xref:System.Windows.DependencyObject>.</xref:System.Windows.DependencyObject> </xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName>"
  syntax:
    content: public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "Identifica a propriedade de enlace deve ser estabelecido."
    - id: binding
      type: System.Windows.Data.BindingBase
      description: "Representa as especificações do enlace de dados."
    return:
      type: System.Windows.Data.BindingExpressionBase
      description: "Regista as condições do enlace. Este valor de retorno pode ser útil para a verificação de erro."
  overload: System.Windows.FrameworkElement.SetBinding*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)
  id: SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SetFlowDirection(DependencyObject,FlowDirection)
  nameWithType: FrameworkElement.SetFlowDirection(DependencyObject,FlowDirection)
  fullName: System.Windows.FrameworkElement.SetFlowDirection(DependencyObject,FlowDirection)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Define o valor da <xref:System.Windows.FrameworkElement.FlowDirection*>ligado propriedade para o elemento fornecido.</xref:System.Windows.FrameworkElement.FlowDirection*>"
  remarks: "Este método suporta a propriedade anexada sintaxe para o <xref:System.Windows.FrameworkElement.FlowDirection%2A>propriedade, por conseguinte, permitindo subordinado elementos de um fornecido <xref:System.Windows.FrameworkElement>para especificar a direção do fluxo de disposição dentro do respetivo elemento principal.</xref:System.Windows.FrameworkElement> </xref:System.Windows.FrameworkElement.FlowDirection%2A> Para definir o valor sobre os atuais <xref:System.Windows.FrameworkElement>, utilize a direta [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] acessor <xref:System.Windows.FrameworkElement.FlowDirection%2A>.</xref:System.Windows.FrameworkElement.FlowDirection%2A> </xref:System.Windows.FrameworkElement>"
  syntax:
    content: public static void SetFlowDirection (System.Windows.DependencyObject element, System.Windows.FlowDirection value);
    parameters:
    - id: element
      type: System.Windows.DependencyObject
      description: "O elemento que especifica uma direcção do fluxo de mensagens em fila."
    - id: value
      type: System.Windows.FlowDirection
      description: "Um valor de enumeração, especificar a direção."
  overload: System.Windows.FrameworkElement.SetFlowDirection*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)
  id: SetResourceReference(System.Windows.DependencyProperty,System.Object)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SetResourceReference(DependencyProperty,Object)
  nameWithType: FrameworkElement.SetResourceReference(DependencyProperty,Object)
  fullName: System.Windows.FrameworkElement.SetResourceReference(DependencyProperty,Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Procura um recurso com o nome especificado e configura uma referência do recurso para o mesmo para a propriedade especificada."
  remarks: "Uma referência de recurso é semelhante a utilização de um [extensão de Markup DynamicResource](~/add/includes/ajax-current-ext-md.md) no markup. A referência de recursos cria uma expressão interna que fornece o valor da propriedade especificada de forma diferida do tempo de execução. A expressão será novamente avaliada sempre que o dicionário de recurso indica um valor alterado através de eventos internos ou sempre que o elemento actual é reparented (uma alteração principal alteraria o caminho de pesquisa de dicionário)."
  syntax:
    content: public void SetResourceReference (System.Windows.DependencyProperty dp, object name);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "A propriedade à qual o recurso está vinculado."
    - id: name
      type: System.Object
      description: "O nome do recurso."
  overload: System.Windows.FrameworkElement.SetResourceReference*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ShouldSerializeResources
  id: ShouldSerializeResources
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ShouldSerializeResources()
  nameWithType: FrameworkElement.ShouldSerializeResources()
  fullName: System.Windows.FrameworkElement.ShouldSerializeResources()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Devolve se os processos de serialização devem serializar o conteúdo do <xref:System.Windows.FrameworkElement.Resources*>propriedade.</xref:System.Windows.FrameworkElement.Resources*>"
  remarks: "Esta ação irá devolver `true` , desde que não há, pelo menos, um recurso codificado locais <xref:System.Windows.FrameworkElement.Resources%2A>.</xref:System.Windows.FrameworkElement.Resources%2A>"
  syntax:
    content: public bool ShouldSerializeResources ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o <xref:System.Windows.FrameworkElement.Resources*>valor da propriedade deve ser serializada; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Windows.FrameworkElement.Resources*>"
  overload: System.Windows.FrameworkElement.ShouldSerializeResources*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ShouldSerializeStyle
  id: ShouldSerializeStyle
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ShouldSerializeStyle()
  nameWithType: FrameworkElement.ShouldSerializeStyle()
  fullName: System.Windows.FrameworkElement.ShouldSerializeStyle()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Devolve se os processos de serialização devem serializar o conteúdo do <xref:System.Windows.FrameworkElement.Style*>propriedade.</xref:System.Windows.FrameworkElement.Style*>"
  remarks: "Esta ação irá devolver `true` se o <xref:System.Windows.Style>localmente está definido.</xref:System.Windows.Style>"
  syntax:
    content: public bool ShouldSerializeStyle ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o <xref:System.Windows.FrameworkElement.Style*>valor da propriedade deve ser serializada; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Windows.FrameworkElement.Style*>"
  overload: System.Windows.FrameworkElement.ShouldSerializeStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ShouldSerializeTriggers
  id: ShouldSerializeTriggers
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ShouldSerializeTriggers()
  nameWithType: FrameworkElement.ShouldSerializeTriggers()
  fullName: System.Windows.FrameworkElement.ShouldSerializeTriggers()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Devolve se os processos de serialização devem serializar o conteúdo do <xref:System.Windows.FrameworkElement.Triggers*>propriedade.</xref:System.Windows.FrameworkElement.Triggers*>"
  remarks: "Este método devolve `true` se o <xref:System.Windows.FrameworkElement.Triggers%2A>localmente for definida.</xref:System.Windows.FrameworkElement.Triggers%2A>"
  syntax:
    content: public bool ShouldSerializeTriggers ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se o <xref:System.Windows.FrameworkElement.Triggers*>valor da propriedade deve ser serializada; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Windows.FrameworkElement.Triggers*>"
  overload: System.Windows.FrameworkElement.ShouldSerializeTriggers*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SizeChanged
  id: SizeChanged
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SizeChanged
  nameWithType: FrameworkElement.SizeChanged
  fullName: System.Windows.FrameworkElement.SizeChanged
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando o o <> </> *> ou <> </> *> propriedades altere o valor neste elemento."
  remarks: "Os eventos encaminhados diretos não siga uma rota, apenas são processados no elemento da mesmo em que são gerados. Direcionar os eventos encaminhados suporta outro comportamento de evento encaminhado: suporta a uma coleção de processadores acessível e pode ser utilizados como um <xref:System.Windows.EventTrigger>num style.</xref:System.Windows.EventTrigger>       O sistema de esquema lê propriedades dentro de <xref:System.Windows.SizeChangedEventArgs>classe argumento deste evento, para determinar se as alterações de tamanho comunicado devem ser consideradas significativas.</xref:System.Windows.SizeChangedEventArgs> Isto permite que o sistema de esquema ou as implementações de esquema de controlo específicos para evitar a imposição de uma alteração de esquema devido a visualmente imperceptible diferenças entre os valores de largura ou altura antiga e nova. As diferenças imperceptible poderão dever-se os cálculos de arredondamento ou o mesmo resultado dos tipos de dados de vírgula flutuante.      <a name=&quot;routedEventInfo_SizeChanged&quot;></a># # Encaminhados informações sobre eventos |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.SizeChangedEvent>|   | Estratégia de encaminhamento | Direto |   | Delegado | <xref:System.Windows.SizeChangedEventHandler>|</xref:System.Windows.SizeChangedEventHandler></xref:System.Windows.FrameworkElement.SizeChangedEvent>"
  syntax:
    content: public event System.Windows.SizeChangedEventHandler SizeChanged;
    return:
      type: System.Windows.SizeChangedEventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SizeChangedEvent
  id: SizeChangedEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SizeChangedEvent
  nameWithType: FrameworkElement.SizeChangedEvent
  fullName: System.Windows.FrameworkElement.SizeChangedEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref href=&quot;System.Windows.FrameworkElement.SizeChanged&quot;> </xref> evento encaminhado."
  remarks: "Os identificadores de evento encaminhado são criados quando eventos encaminhados estão registados. Estes identificadores contenham um nome de identificação, tipo de proprietário, tipo de processador, estratégia de encaminhamento e método do utilitário para adicionar os proprietários para o evento. Pode utilizar estes identificadores para adicionar processadores de classe.       Para obter mais informações sobre como registar eventos encaminhados, consulte <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A> Para obter mais informações sobre como utilizar identificadores de evento encaminhado para adicionar processadores de classe, consulte <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</xref:System.Windows.EventManager.RegisterClassHandler%2A>"
  syntax:
    content: public static readonly System.Windows.RoutedEvent SizeChangedEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SourceUpdated
  id: SourceUpdated
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SourceUpdated
  nameWithType: FrameworkElement.SourceUpdated
  fullName: System.Windows.FrameworkElement.SourceUpdated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando o valor de origem é alterado para qualquer propriedade existente neste elemento de enlace."
  remarks: "Este evento cria um alias para o <xref:System.Windows.Data.Binding.SourceUpdated>evento é gerado por qualquer <xref:System.Windows.Data.Binding>associados a este elemento.</xref:System.Windows.Data.Binding> </xref:System.Windows.Data.Binding.SourceUpdated>      <a name=&quot;xamlAttributeUsage_SourceUpdated&quot;></a># # Utilização do atributo de XAML```   <object SourceUpdated=&quot;eventHandler&quot;/>   ```"
  syntax:
    content: public event EventHandler<System.Windows.Data.DataTransferEventArgs> SourceUpdated;
    return:
      type: System.EventHandler{System.Windows.Data.DataTransferEventArgs}
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Style
  id: Style
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Style
  nameWithType: FrameworkElement.Style
  fullName: System.Windows.FrameworkElement.Style
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define o estilo utilizado por este elemento quando é composto."
  remarks: "Para os controlos, o estilo de atual é frequentemente fornecido por um estilo predefinido de temas de controlo ou de estilos geralmente aplicado aos controlos desse tipo pelos recursos ao nível da aplicação ou página (um estilo implícito). Esta propriedade predefinido não definido ou retorno estilos (tema), mas devolver um estilo implícito ou um estilo explícito de que está a funcionar no elemento. No caso de estilos implícitos ou explícitos, é irrelevante se o estilo está especificado como um recurso ou definido localmente.       Definir os estilos tem algumas restrições. Pode repor a propriedade de estilo completa para um novo <xref:System.Windows.Style>em qualquer altura, que irá forçar um recomposition de esquema.</xref:System.Windows.Style> No entanto, como logo que estilo é colocado em utilização por um elemento carregado, o <xref:System.Windows.Style>devem ser consideradas selado.</xref:System.Windows.Style> A tentar efetuar uma alteração a qualquer propriedade individual de um estilo de em utilização (por exemplo, tudo dentro da coleção de <xref:System.Windows.Style.Setters%2A>) faz com que uma exceção ao ser emitida.</xref:System.Windows.Style.Setters%2A> Um estilo que está definido no markup é considerado em utilização, assim que é carregado a partir de um dicionário de recursos (para recursos) ou a página que está contido no é carregada (para inline estilos).       Estilo é uma propriedade de dependência com precedência especial. Localmente definir estilo geralmente opera num mais alta precedência no sistema de propriedade. Se o estilo for nulo neste momento, durante o carregamento a propriedade sistema verifica a existência de estilos implícitos no locais ou aplicação recursos que especifique esse tipo. Se o estilo for ainda nulo após este passo, em seguida, o estilo de agir para efeitos de apresentação que vêm, geralmente, o estilo predefinido (tema), mas o estilo predefinido não é devolvido o valor de propriedade de estilo. Consulte [precedência de valor de propriedade de dependência](~/add/includes/ajax-current-ext-md.md) ou [estilos e Templating](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;xamlAttributeUsage_Style&quot;></a># # Utilização do atributo de XAML ```   <object Style=&quot;{resourceExtension styleResourceKey}&quot;/>   ``` <a name=&quot;xamlPropertyElementUsage_Style&quot;> </a> # # utilização de elemento de propriedade XAML <a name=&quot;xamlValues_Style&quot;> </a> # # XAML valores *resourceExtension* um dos seguintes:, ou.       Consulte [XAML recursos](~/add/includes/ajax-current-ext-md.md).       *styleResourceKey* a chave que identifica o estilo de que está a ser solicitado. A chave refere-se a um recurso existente no <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>      > [!NOTE] > Sintaxe do elemento de propriedade é tecnicamente possível, mas não recomendadas para a maioria dos cenários de estilo. Consulte [Inline estilos e modelos](~/add/includes/ajax-current-ext-md.md). Uma referência de enlace utilizando ou <xref:System.Windows.Data.Binding>é também possível, mas invulgar.</xref:System.Windows.Data.Binding>      <a name=&quot;dependencyPropertyInfo_Style&quot;></a># # Informações de propriedade de dependência |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.StyleProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.StyleProperty>"
  example:
  - "The following example defines a style in a resource dictionary.  \n  \n [!code-xml[FEResource#StyleProperty](~/add/codesnippet/xaml/FEResource/default.xaml#styleproperty)]  \n[!code-xml[FEResource#StyleProperty2](~/add/codesnippet/xaml/FEResource/default.xaml#styleproperty2)]  \n[!code-xml[FEResource#StyleProperty3](~/add/codesnippet/xaml/FEResource/default.xaml#styleproperty3)]  \n[!code-xml[FEResource#StyleProperty4](~/add/codesnippet/xaml/FEResource/default.xaml#styleproperty4)]"
  syntax:
    content: public System.Windows.Style Style { get; set; }
    return:
      type: System.Windows.Style
      description: "O estilo não predefinidas aplicada, para o elemento, se estiver presente. Caso contrário, <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>. A predefinição para uma predefinição-construído <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref> é <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkElement.Style*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.StyleProperty
  id: StyleProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: StyleProperty
  nameWithType: FrameworkElement.StyleProperty
  fullName: System.Windows.FrameworkElement.StyleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.Style*>propriedade de dependência.</xref:System.Windows.FrameworkElement.Style*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty StyleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  id: System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  isEii: true
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: FrameworkElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.FrameworkElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Para obter uma descrição deste membro, consulte o <xref:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable*>método.</xref:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable*>"
  remarks: "Este membro é uma implementação de membro de interface explícita. Pode ser utilizado apenas quando o <xref:System.Windows.FrameworkElement>instância é convertida para um <xref:System.Windows.Markup.IQueryAmbient>interface.</xref:System.Windows.Markup.IQueryAmbient> </xref:System.Windows.FrameworkElement>"
  syntax:
    content: bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);
    parameters:
    - id: propertyName
      type: System.String
      description: "O nome da propriedade ambiente pedida."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se <code> propertyName </code> está disponível; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Tag
  id: Tag
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Tag
  nameWithType: FrameworkElement.Tag
  fullName: System.Windows.FrameworkElement.Tag
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define um valor de objeto arbitrários que pode ser utilizado para armazenar informações personalizadas sobre este elemento."
  remarks: "Esta propriedade é semelhante às propriedades de Tag noutras [!INCLUDE[TLA#tla_ms](~/add/includes/tlasharptla-ms-md.md)] programação modelos, tais como [!INCLUDE[TLA#tla_vba](~/add/includes/ajax-current-ext-md.md)] ou [!INCLUDE[TLA#tla_winforms](~/add/includes/ajax-current-ext-md.md)]. Etiqueta destina-se para fornecer uma localização de propriedade pré-existente onde pode armazenar algumas informações personalizadas básicas sobre quaisquer <xref:System.Windows.FrameworkElement>sem que seja necessário subclassificação de um elemento.</xref:System.Windows.FrameworkElement>       Uma vez que esta propriedade tira um objeto, terá de utilizar a utilização de elemento de propriedade para definir a propriedade de etiqueta [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)] para qualquer coisa que não seja um objeto com um conversor de tipo conhecido e incorporada, como uma cadeia. Os objetos utilizados desta forma, normalmente, não são dentro padrão [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] espaços de nomes e, por conseguinte, pode necessitar de mapeamento de espaço de nomes para o espaço de nomes externo para ser apresentado como sendo [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] elementos. Para obter mais informações, consulte [XAML espaços de nomes e o espaço de nomes de mapeamento para WPF XAML](~/add/includes/ajax-current-ext-md.md) e [XAML e Classes personalizadas para WPF](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;dependencyPropertyInfo_Tag&quot;></a># # Informações de propriedade de dependência |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.TagProperty>|   | Definir propriedades de metadados `true`| Nenhum |</xref:System.Windows.FrameworkElement.TagProperty>"
  syntax:
    content: public object Tag { get; set; }
    return:
      type: System.Object
      description: "O valor pretendido. Esta propriedade não tem nenhum valor predefinido."
  overload: System.Windows.FrameworkElement.Tag*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.TagProperty
  id: TagProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: TagProperty
  nameWithType: FrameworkElement.TagProperty
  fullName: System.Windows.FrameworkElement.TagProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.Tag*>propriedade de dependência.</xref:System.Windows.FrameworkElement.Tag*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty TagProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.TargetUpdated
  id: TargetUpdated
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: TargetUpdated
  nameWithType: FrameworkElement.TargetUpdated
  fullName: System.Windows.FrameworkElement.TargetUpdated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando o valor de destino é alterado para nenhum enlace de propriedades neste elemento."
  remarks: "Este evento cria um alias para o <xref:System.Windows.Data.Binding.TargetUpdated>evento é gerado por qualquer <xref:System.Windows.Data.Binding>associados a este elemento.</xref:System.Windows.Data.Binding> </xref:System.Windows.Data.Binding.TargetUpdated> Normalmente, isto significa que o enlace em questão é um vínculo bidirecional, sendo que a propriedade de dependência vinculada affirms que o valor da propriedade anterior agora inválido de acordo com qualquer validação ou o esquema de colocação em cache que suporta a propriedade ou a origem de dados.       Utilize os dados de eventos do evento TargetUpdated para determinar a propriedade específica que está a comunicar a atualização do valor de destino.      <a name=&quot;xamlAttributeUsage_TargetUpdated&quot;></a># # Utilização do atributo de XAML```   <object TargetUpdated=&quot;eventHandler&quot;/>   ```"
  syntax:
    content: public event EventHandler<System.Windows.Data.DataTransferEventArgs> TargetUpdated;
    return:
      type: System.EventHandler{System.Windows.Data.DataTransferEventArgs}
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.TemplatedParent
  id: TemplatedParent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: TemplatedParent
  nameWithType: FrameworkElement.TemplatedParent
  fullName: System.Windows.FrameworkElement.TemplatedParent
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém uma referência para o principal do modelo deste elemento. Esta propriedade não é relevante se o elemento não tiver sido criado através de um modelo."
  remarks: "TemplatedParent é frequentemente `null` para objetos que são criados na marcação de aplicação ou código. Isto acontece porque criar esses objetos diretamente, não através de um modelo. Referências obtidas orientando árvore lógica da raiz ou pelo nome típico referências de objeto, não provenientes de um modelo.       Casos em que poderá não ser TemplatedParent `null` incluam operações como testes de acessos, processamento de eventos para determinados eventos de entrada nível baixo, walking da árvore visual com <xref:System.Windows.Media.VisualTreeHelper>, ou trabalhar com enumeradores, que poderá devolver elementos provém de modelos.</xref:System.Windows.Media.VisualTreeHelper> Outro cenário é se chamar especificamente <xref:System.Windows.FrameworkTemplate.FindName%2A>contra existente <xref:System.Windows.FrameworkTemplate>e estão a trabalhar com o objeto devolvido.</xref:System.Windows.FrameworkTemplate> </xref:System.Windows.FrameworkTemplate.FindName%2A>       Os modelos são objetos realmente partilhados, onde o conteúdo do modelo é criado apenas uma vez. Por conseguinte, se obter uma referência de objeto para um elemento que proveniente de um modelo, pode constatar que a árvore lógica aparente não comunicar com a raiz de página. Para poder estabelecer ligação este tipo uma referência de modelo a árvore lógica da página, deve obter o valor de TemplatedParent e continuar para navegar nessa árvore de elemento conforme pretendido."
  syntax:
    content: public System.Windows.DependencyObject TemplatedParent { get; }
    return:
      type: System.Windows.DependencyObject
      description: "O elemento cujo <xref href=&quot;System.Windows.FrameworkTemplate&quot;> </xref> <xref:System.Windows.FrameworkTemplate.VisualTree*>causado este elemento seja criado.</xref:System.Windows.FrameworkTemplate.VisualTree*> Este valor é frequentemente <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>; Consulte observações."
  overload: System.Windows.FrameworkElement.TemplatedParent*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ToolTip
  id: ToolTip
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ToolTip
  nameWithType: FrameworkElement.ToolTip
  fullName: System.Windows.FrameworkElement.ToolTip
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define o objecto de sugestão de ferramenta que é apresentado para este elemento de [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]."
  remarks: "Se o valor desta propriedade é do tipo <xref:System.Windows.Controls.ToolTip>, em seguida, esse valor é a descrição que será utilizada no [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)].</xref:System.Windows.Controls.ToolTip>  Se o valor for de qualquer outro tipo, em seguida, esse valor será utilizado como o *conteúdo* para um <xref:System.Windows.Controls.ToolTip>fornecido (construído) pelo sistema.</xref:System.Windows.Controls.ToolTip> Para obter mais informações, consulte <xref:System.Windows.Controls.ToolTipService>.</xref:System.Windows.Controls.ToolTipService> A classe de serviço fornece propriedades anexadas que podem ser utilizadas para personalizar mais <xref:System.Windows.Controls.ToolTip>.</xref:System.Windows.Controls.ToolTip>      <a name=&quot;xamlAttributeUsage_ToolTip&quot;></a># # Utilização do atributo de XAML ```   <object ToolTip=&quot;toolTipContent&quot;/>   ``` <a name=&quot;xamlPropertyElementUsage_ToolTip&quot;> </a> # # utilização de elemento de propriedade XAML ```   <object>     <object.ToolTip>       <ToolTip .../>     </object.ToolTip>   </object>   - or -   <object>     <object.ToolTip>       toolTipObjectContent     </object.ToolTip>   </object>   ``` <a name=&quot;xamlValues_ToolTip&quot;> </a> # # XAML valores *toolTipContent* uma cadeia que torna-se o texto apresentado para a descrição.                   *toolTipObjectContent* alguns objetos, fornecido na forma de elemento de objeto, que deve ser utilizada como o conteúdo para <xref:System.Windows.FrameworkElement>.</xref:System.Windows.FrameworkElement> Normalmente, isto seria um <xref:System.Windows.FrameworkElement>ou outro elemento cria compositing de esquema para a descrição, eventualmente, que contém texto conteúdo dentro da compositing.</xref:System.Windows.FrameworkElement> Nesta utilização, o <xref:System.Windows.Controls.ToolTip>elemento é criado implicitamente do analisados [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]e o *toolTipObjectContent* content está definido como respetivo <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=fullName>propriedade.</xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=fullName> </xref:System.Windows.Controls.ToolTip>       `ToolTip`.../>    See <xref:System.Windows.Controls.ToolTip>.</xref:System.Windows.Controls.ToolTip>      <a name=&quot;dependencyPropertyInfo_ToolTip&quot;></a># # Informações de propriedade de dependência |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.ToolTipProperty>|   | Definir propriedades de metadados `true`| Nenhum |</xref:System.Windows.FrameworkElement.ToolTipProperty>"
  example:
  - "The following example creates a <xref:System.Windows.Controls.ToolTip> in code and then sets the ToolTip property on a <xref:System.Windows.Controls.Primitives.StatusBar> control.  \n  \n [!code-vb[StatusBar#MakeProgressBar](~/add/codesnippet/visualbasic/statusbar/window1.xaml.vb#makeprogressbar)]\n [!code-cs[StatusBar#MakeProgressBar](~/add/codesnippet/csharp/StatusBar/Window1.xaml.cs#makeprogressbar)]"
  syntax:
    content: public object ToolTip { get; set; }
    return:
      type: System.Object
      description: "O objecto de descrição. Consulte observações abaixo para obter detalhes sobre o motivo pelo qual este parâmetro não é do tipo seguro."
  overload: System.Windows.FrameworkElement.ToolTip*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ToolTipClosing
  id: ToolTipClosing
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ToolTipClosing
  nameWithType: FrameworkElement.ToolTipClosing
  fullName: System.Windows.FrameworkElement.ToolTipClosing
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre antes de qualquer descrição no elemento está fechada."
  remarks: "Marcar o evento ToolTipClosing como processado cancele a fechar a descrição. Assim que a descrição é apresentada, fechar a descrição é efetuado apenas em resposta a interação do utilizador com a IU.       Este evento não pode ser um <xref:System.Windows.EventTrigger>num style.</xref:System.Windows.EventTrigger> Isto acontece porque o campo de identificador deste evento reutiliza uma implementação de um serviço que não expõe adição/remoção de métodos de evento para o evento de nível de serviço.      <a name=&quot;routedEventInfo_ToolTipClosing&quot;></a># # Encaminhados informações sobre eventos |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.ToolTipClosingEvent>|   | Estratégia de encaminhamento | Direto |   | Delegado | <xref:System.Windows.Controls.ToolTipEventHandler>|      -Ignorar <xref:System.Windows.FrameworkElement.OnToolTipClosing%2A>para implementar a classe de processamento para este evento em classes derivadas.</xref:System.Windows.FrameworkElement.OnToolTipClosing%2A> </xref:System.Windows.Controls.ToolTipEventHandler> </xref:System.Windows.FrameworkElement.ToolTipClosingEvent>"
  syntax:
    content: public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;
    return:
      type: System.Windows.Controls.ToolTipEventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ToolTipClosingEvent
  id: ToolTipClosingEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ToolTipClosingEvent
  nameWithType: FrameworkElement.ToolTipClosingEvent
  fullName: System.Windows.FrameworkElement.ToolTipClosingEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref href=&quot;System.Windows.FrameworkElement.ToolTipClosing&quot;> </xref> evento encaminhado."
  remarks: "Os identificadores de evento encaminhado são criados quando eventos encaminhados estão registados. Estes identificadores contenham um nome de identificação, tipo de proprietário, tipo de processador, estratégia de encaminhamento e método do utilitário para adicionar os proprietários para o evento. Pode utilizar estes identificadores para adicionar processadores de classe.       Para obter mais informações sobre como registar eventos encaminhados, consulte <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A> Para obter mais informações sobre como utilizar identificadores de evento encaminhado para adicionar processadores de classe, consulte <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</xref:System.Windows.EventManager.RegisterClassHandler%2A>"
  syntax:
    content: public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ToolTipOpening
  id: ToolTipOpening
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ToolTipOpening
  nameWithType: FrameworkElement.ToolTipOpening
  fullName: System.Windows.FrameworkElement.ToolTipOpening
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando qualquer descrição no elemento é aberta."
  remarks: "Para impedir que volte a aparecer na IU descrição, o processador para ToolTipOpening pode marcar a <xref:System.Windows.Controls.ToolTipEventArgs>dados de eventos processados.</xref:System.Windows.Controls.ToolTipEventArgs> Caso contrário, a descrição é apresentada, utilizando o valor do <xref:System.Windows.FrameworkElement.ToolTip%2A>propriedade como o conteúdo de descrição.</xref:System.Windows.FrameworkElement.ToolTip%2A> Outro cenário possíveis é que pode escrever um processador que repõe o valor da <xref:System.Windows.FrameworkElement.ToolTip%2A>propriedade para o elemento que é a origem de evento, antes de apresentar a descrição.</xref:System.Windows.FrameworkElement.ToolTip%2A>       ToolTipOpening não será gerado se o valor de <xref:System.Windows.FrameworkElement.ToolTip%2A>é `null` ou, caso contrário,.</xref:System.Windows.FrameworkElement.ToolTip%2A> Não defina deliberadamente <xref:System.Windows.FrameworkElement.ToolTip%2A>para `null` enquanto uma descrição estiver aberta ou abrir; isto não terá efeito de fechar a descrição e, em vez disso, irá criar um artefacto visual indesejável na IU.</xref:System.Windows.FrameworkElement.ToolTip%2A>       O evento ToolTipOpening não pode ser um <xref:System.Windows.EventTrigger>num style.</xref:System.Windows.EventTrigger> Isto acontece porque o campo de identificador deste evento reutiliza uma implementação de um serviço que não expõe adição/remoção de métodos de evento para o evento de nível de serviço.      <a name=&quot;routedEventInfo_ToolTipOpening&quot;></a># # Encaminhados informações sobre eventos |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.ToolTipOpeningEvent>|   | Estratégia de encaminhamento | Direto |   | Delegado | <xref:System.Windows.Controls.ToolTipEventHandler>|      -Ignorar <xref:System.Windows.FrameworkElement.OnToolTipClosing%2A>para implementar a classe de processamento para este evento em classes derivadas.</xref:System.Windows.FrameworkElement.OnToolTipClosing%2A> </xref:System.Windows.Controls.ToolTipEventHandler> </xref:System.Windows.FrameworkElement.ToolTipOpeningEvent>"
  syntax:
    content: public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;
    return:
      type: System.Windows.Controls.ToolTipEventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ToolTipOpeningEvent
  id: ToolTipOpeningEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ToolTipOpeningEvent
  nameWithType: FrameworkElement.ToolTipOpeningEvent
  fullName: System.Windows.FrameworkElement.ToolTipOpeningEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref href=&quot;System.Windows.FrameworkElement.ToolTipOpening&quot;> </xref> evento encaminhado."
  remarks: "Os identificadores de evento encaminhado são criados quando eventos encaminhados estão registados. Estes identificadores contenham um nome de identificação, tipo de proprietário, tipo de processador, estratégia de encaminhamento e método do utilitário para adicionar os proprietários para o evento. Pode utilizar estes identificadores para adicionar processadores de classe.       Para obter mais informações sobre como registar eventos encaminhados, consulte <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A> Para obter mais informações sobre como utilizar identificadores de evento encaminhado para adicionar processadores de classe, consulte <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</xref:System.Windows.EventManager.RegisterClassHandler%2A>"
  syntax:
    content: public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ToolTipProperty
  id: ToolTipProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ToolTipProperty
  nameWithType: FrameworkElement.ToolTipProperty
  fullName: System.Windows.FrameworkElement.ToolTipProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.ToolTip*>propriedade de dependência.</xref:System.Windows.FrameworkElement.ToolTip*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ToolTipProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Triggers
  id: Triggers
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Triggers
  nameWithType: FrameworkElement.Triggers
  fullName: System.Windows.FrameworkElement.Triggers
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém a coleção de acionadores estabelecer diretamente neste elemento, ou em elementos subordinados."
  remarks: "> [!NOTE]> Esta propriedade só pode ser definida [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)] através da sintaxe de coleção mostrado ou aceder ao objeto da coleção e utilizando os diversos métodos, tais como adicionar. A propriedade para aceder ao objeto de coleção em si é só de leitura, a própria coleção é leitura e escrita. A propriedade só existe nos elementos raiz; tentar encontrá-lo ou defini-lo noutro local, irá causar uma exceção ao ser emitida.       Esta propriedade não permitem-lhe examinar acionadores que existem como parte de estilos em utilização neste elemento. Esta comunica apenas a coleção de acionadores que literalmente são adicionados à coleção de, no markup ou um código. Elementos, normalmente, não tem elementos existentes por predefinição (através de um modelo para a instância); é mais comum para acionadores provenientes compositing controlo ser estabelecida no estilos.       Em termos de comportamento (e tentar estabelecer que efeito provém do que elemento declarado coleção de Acionadores), a condição de acionamento e o efeito de Acionador poderão ser neste elemento, ou podem estar nos respetivos elementos subordinados na árvore lógica. Tenha em atenção que se utilizar eventos de duração, tais como <xref:System.Windows.FrameworkElement.Loaded>para obter esta coleção, acionadores do elemento subordinado não ainda poderão totalmente carregados e a coleção será menor do que seria verdadeiramente em tempo de execução.</xref:System.Windows.FrameworkElement.Loaded>       Tenha em atenção que a coleção de acionadores estabelecida num elemento só suporta <xref:System.Windows.EventTrigger>, não os acionadores de propriedade (<xref:System.Windows.Trigger>).</xref:System.Windows.Trigger> </xref:System.Windows.EventTrigger> Se necessitar de acionadores de propriedade, tem de colocar estes dentro de um estilo ou o modelo e, em seguida, atribuir esse estilo ou o modelo para o elemento ou diretamente através do <xref:System.Windows.FrameworkElement.Style%2A>propriedade, ou indiretamente através de uma referência de estilo implícita.</xref:System.Windows.FrameworkElement.Style%2A>      <a name=&quot;xamlPropertyElementUsage_Triggers&quot;></a># # Utilização de elemento de propriedade de XAML ```   <object>     <object.Triggers>       oneOrMoreTriggers     </object.Triggers>   </object>   ``` <a name=&quot;xamlValues_Triggers&quot;> </a> # # XAML valores *oneOrMoreTriggers* um ou mais definido <xref:System.Windows.EventTrigger>elementos.</xref:System.Windows.EventTrigger>       Cada acionador tal é esperado para conter as referências e ações de guião gráfico principal válido. Tenha em atenção que esta coleção só pode ser estabelecida no elemento raiz de uma página. Para obter mais informações, consulte [descrição geral de Storyboards](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public System.Windows.TriggerCollection Triggers { get; }
    return:
      type: System.Windows.TriggerCollection
      description: "Uma coleção com tipo seguro de <xref href=&quot;System.Windows.Trigger&quot;> </xref> objetos."
  overload: System.Windows.FrameworkElement.Triggers*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.TryFindResource(System.Object)
  id: TryFindResource(System.Object)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: TryFindResource(Object)
  nameWithType: FrameworkElement.TryFindResource(Object)
  fullName: System.Windows.FrameworkElement.TryFindResource(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Procura um recurso com a chave especificada e devolve o recurso de se encontrar."
  remarks: "Se o recurso não foi encontrado no elemento de chamada, a árvore de recurso principal é procurada para cima através da árvore lógica, da mesma forma que a árvore seria se procurar um recurso foram solicitado por chave em tempo de execução. O método devolve `null` só se nenhum recurso dessa chave em qualquer lugar existia na árvore de recurso, pelas condições existentes da árvore no momento em que TryFindResource é chamado.       Normalmente, seria imediatamente converter o valor devolvido para o tipo da propriedade que estava a tentar definir com o valor devolvido do recurso.       O <xref:System.Windows.FrameworkElement.FindResource%2A>método tem um comportamento semelhante, exceto que emite uma exceção, não se foi devolvido nenhum recurso com a chave fornecida.</xref:System.Windows.FrameworkElement.FindResource%2A>"
  example:
  - "The following example is implemented as a button handler, where the button being clicked sets its background to a resource-defined brush obtained by calling TryFindResource on itself. This walks the element tree and finds the resource (the resource itself is defined in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] and is not shown).  \n  \n [!code-cs[BaseElementsSmorgasbord#FETryFindResource](~/add/codesnippet/csharp/BaseElementsSmorgasbord/Page1.xaml.cs#fetryfindresource)]\n [!code-vb[BaseElementsSmorgasbord#FETryFindResource](~/add/codesnippet/visualbasic/baseelementssmorgasbord/page1.xaml.vb#fetryfindresource)]"
  syntax:
    content: public object TryFindResource (object resourceKey);
    parameters:
    - id: resourceKey
      type: System.Object
      description: "O identificador da chave do recurso que deverá existir."
    return:
      type: System.Object
      description: "O recurso encontrado, ou <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> se nenhum recurso com o fornecido <code> key </code> encontra-se."
  overload: System.Windows.FrameworkElement.TryFindResource*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Unloaded
  id: Unloaded
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Unloaded
  nameWithType: FrameworkElement.Unloaded
  fullName: System.Windows.FrameworkElement.Unloaded
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ocorre quando o elemento é removido de dentro de uma árvore de elemento de elementos carregados."
  remarks: "Os eventos encaminhados diretos não siga uma rota, apenas são processados no elemento da mesmo em que são gerados. Direcionar os eventos encaminhados suporta outro comportamento de evento encaminhado: suporta a uma coleção de processadores acessível e pode ser utilizados como um <xref:System.Windows.EventTrigger>num style.</xref:System.Windows.EventTrigger>       <xref:System.Windows.FrameworkElement.Loaded>e Unloaded podem ambos ser gerado em controlos como resultado das alterações do tema de sistema iniciada pelo utilizador.</xref:System.Windows.FrameworkElement.Loaded> Uma alteração de tema faz com que um invalidação de modelo de controlo e da árvore visual contida, o que por sua vez faz com que o controlo completo descarregar e volte a carregar. Por conseguinte Unloaded não pode ser pressupõe-se que ocorrem apenas no navegação sair da página.       Tenha em atenção que o evento Unloaded não é desencadeado depois de uma aplicação começa a ser encerrado. Encerramento de aplicação ocorre quando a condição definidos pelo <xref:System.Windows.Application.ShutdownMode%2A>propriedade ocorre.</xref:System.Windows.Application.ShutdownMode%2A> Se colocar o código de limpeza dentro de um processador para o evento Unloaded, tal como para um <xref:System.Windows.Window>ou um <xref:System.Windows.Controls.UserControl>, não pode ser chamado conforme esperado.</xref:System.Windows.Controls.UserControl> </xref:System.Windows.Window>      <a name=&quot;routedEventInfo_Unloaded&quot;></a># # Encaminhados informações sobre eventos |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.UnloadedEvent>|   | Estratégia de encaminhamento | Direto |   | Delegado | <xref:System.Windows.RoutedEventHandler>|</xref:System.Windows.RoutedEventHandler></xref:System.Windows.FrameworkElement.UnloadedEvent>"
  syntax:
    content: public event System.Windows.RoutedEventHandler Unloaded;
    return:
      type: System.Windows.RoutedEventHandler
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.UnloadedEvent
  id: UnloadedEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: UnloadedEvent
  nameWithType: FrameworkElement.UnloadedEvent
  fullName: System.Windows.FrameworkElement.UnloadedEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref href=&quot;System.Windows.FrameworkElement.Unloaded&quot;> </xref> evento encaminhado."
  remarks: "Os identificadores de evento encaminhado são criados quando eventos encaminhados estão registados. Estes identificadores contenham um nome de identificação, tipo de proprietário, tipo de processador, estratégia de encaminhamento e método do utilitário para adicionar os proprietários para o evento. Pode utilizar estes identificadores para adicionar processadores de classe.       Para obter mais informações sobre como registar eventos encaminhados, consulte <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A> Para obter mais informações sobre como utilizar identificadores de evento encaminhado para adicionar processadores de classe, consulte <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</xref:System.Windows.EventManager.RegisterClassHandler%2A>"
  syntax:
    content: public static readonly System.Windows.RoutedEvent UnloadedEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.UnregisterName(System.String)
  id: UnregisterName(System.String)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: UnregisterName(String)
  nameWithType: FrameworkElement.UnregisterName(String)
  fullName: System.Windows.FrameworkElement.UnregisterName(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Simplifica o acesso ao <xref:System.Windows.NameScope>registo desativação método.</xref:System.Windows.NameScope>"
  remarks: "Só tem de anular o registo nomes se tenciona voltar a registar outro elemento com o mesmo nome."
  syntax:
    content: public void UnregisterName (string name);
    parameters:
    - id: name
      type: System.String
      description: "Nome do par nome de objeto para remover o âmbito atual."
  overload: System.Windows.FrameworkElement.UnregisterName*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.UpdateDefaultStyle
  id: UpdateDefaultStyle
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: UpdateDefaultStyle()
  nameWithType: FrameworkElement.UpdateDefaultStyle()
  fullName: System.Windows.FrameworkElement.UpdateDefaultStyle()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Volta o estilo predefinido para o atual <xref href=&quot;System.Windows.FrameworkElement&quot;> </xref>."
  syntax:
    content: public void UpdateDefaultStyle ();
    parameters: []
  overload: System.Windows.FrameworkElement.UpdateDefaultStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.UseLayoutRounding
  id: UseLayoutRounding
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: UseLayoutRounding
  nameWithType: FrameworkElement.UseLayoutRounding
  fullName: System.Windows.FrameworkElement.UseLayoutRounding
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define um valor que indica se arredondamento do esquema deve ser aplicada a este elemento tamanho e posição durante o esquema."
  remarks: "Quando a propriedade UseLayoutRounding um elemento é `true`, todos os valores de pixel não integral que são calculados durante o <xref:System.Windows.UIElement.Measure%2A>e <xref:System.Windows.UIElement.Arrange%2A>transmite é arredondados a valores de pixel todo.</xref:System.Windows.UIElement.Arrange%2A> </xref:System.Windows.UIElement.Measure%2A>       Esta propriedade é herdada pelos elementos subordinados.      > [!NOTE] > Deve definir UseLayoutRounding para `true` no elemento raiz. O sistema de esquema adiciona coordenadas de subordinados para as coordenadas de principal; Por conseguinte, se as coordenadas de principal não estiverem num limite de pixel, as coordenadas de subordinados também não são num limite de pixel. Se não é possível definir UseLayoutRounding na raiz, defina <xref:System.Windows.UIElement.SnapsToDevicePixels%2A>no subordinado para obter o efeito que quiser.</xref:System.Windows.UIElement.SnapsToDevicePixels%2A>       Objetos de desenho nos limites de pixel elimina as extremidades por transparentes, que são produzidas pelo anti-aliasing, quando um limite de atingir um meio de um pixel de dispositivo. A ilustração seguinte mostra a saída de uma linha de largura de pixel único que se situe no meio de um pixel de dispositivo. A linha no lado esquerdo não utiliza o esquema arredondamento e é um alias de antimalware. A linha à direita utiliza o esquema de arredondamento.       ![Um alias de anti linha em comparação comparada a linha de pixel único. ] (~/add/media/pixelsnaplinecompare.PNG &quot;Linha um alias de anti em comparação comparada a linha de pixel único.&quot;)       Quando utiliza esquema arredondamento e <xref:System.Windows.GridUnitType>dimensionamento, o sistema de esquema cria pequenas variações nos valores de linha ou coluna para evitar a composição de subpixel.</xref:System.Windows.GridUnitType> Por exemplo, se uma grelha tem uma largura total dos 100 com 3 colunas do tamanho <xref:System.Windows.GridUnitType>, em vez de criar três colunas que ter uma largura igual de 33,3, o sistema de esquema cria 2 colunas que tem uma largura de 33 e um que tenha uma largura de 34.</xref:System.Windows.GridUnitType>      > [!NOTE] > No .NET 4.6 alterações efetuadas ao esquema arredondamento para reduzir as instâncias de recorte de controlos com limites. Por predefinição, esta funcionalidade é ativada se o Framework de destino está .NET Framework 4.6 ou superior. As aplicações que as versões anteriores do framework de destino podem optar ativamente por participar para o novo comportamento adicionando a seguinte definição para um ficheiro App. config: `<runtime>``<AppContextSwitchOverrides      value=&quot;Switch.MS.Internal.DoNotApplyLayoutRoundingToMarginsAndBorderThickness=false&quot;/>``</runtime>` a definição apenas entra em vigor quando a aplicação está em execução no .NET Framework 4.6."
  example:
  - "The following example demonstrates the effect that the UseLayoutRounding property has on a single pixel-width line. The line on the left does not use layout rounding and the line on the right uses layout rounding. If you slowly resize the window, you can see the difference that layout rounding makes.  \n  \n```xaml  \n  \n<Page x:Class=\"LayoutRounding.Lines\"  \n    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"  \n    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"  \n    Title=\"Lines\" Name=\"linesPage\"  \n    >  \n  <StackPanel Width=\"150\"  Margin=\"7\" Orientation=\"Horizontal\">  \n    <!-- Single pixel line with layout rounding turned OFF.-->  \n    <Rectangle UseLayoutRounding=\"False\"  \n       Width=\"45.5\" Margin=\"10\" Height=\"1\" Fill=\"Red\"/>  \n    <!-- Single pixel line with layout rounding turned ON.-->  \n    <Rectangle UseLayoutRounding=\"True\"  \n      Width=\"45.5\" Margin=\"10\" Height=\"1\" Fill=\"Red\"/>  \n  </StackPanel>  \n  <!-- Background Grid -->  \n  <Page.Background>  \n    <DrawingBrush  Viewport=\"0,0,10,10\" ViewportUnits=\"Absolute\" TileMode=\"Tile\">  \n      <DrawingBrush.Drawing>  \n        <DrawingGroup>  \n          <GeometryDrawing Brush=\"White\">  \n            <GeometryDrawing.Geometry>  \n              <RectangleGeometry Rect=\"0,0,1,1\" />  \n            </GeometryDrawing.Geometry>  \n          </GeometryDrawing>  \n          <GeometryDrawing Geometry=\"M0,0 L1,0 1,0.1, 0,0.1Z \" Brush=\"#CCCCFF\" />  \n          <GeometryDrawing Geometry=\"M0,0 L0,1 0.1,1, 0.1,0Z\" Brush=\"#CCCCFF\" />  \n        </DrawingGroup>  \n      </DrawingBrush.Drawing>  \n    </DrawingBrush>  \n  </Page.Background>  \n</Page>  \n```"
  syntax:
    content: public bool UseLayoutRounding { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Se for aplicado o esquema arredondamento; caso contrário, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. A predefinição é <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkElement.UseLayoutRounding*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.UseLayoutRoundingProperty
  id: UseLayoutRoundingProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: UseLayoutRoundingProperty
  nameWithType: FrameworkElement.UseLayoutRoundingProperty
  fullName: System.Windows.FrameworkElement.UseLayoutRoundingProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.UseLayoutRounding*>propriedade de dependência.</xref:System.Windows.FrameworkElement.UseLayoutRounding*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty UseLayoutRoundingProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.VerticalAlignment
  id: VerticalAlignment
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: VerticalAlignment
  nameWithType: FrameworkElement.VerticalAlignment
  fullName: System.Windows.FrameworkElement.VerticalAlignment
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define as características de alinhamento vertical aplicadas a este elemento quando compõe dentro de um elemento principal como um painel ou itens de controlo."
  remarks: "Quando <xref:System.Windows.FrameworkElement.Height%2A>e <xref:System.Windows.FrameworkElement.Width%2A>Propriedades explicitamente estão definidas num elemento, destas medidas demorar precedent de esquema e cancelar os efeitos de definir esta propriedade como <xref:System.Windows.VerticalAlignment>.</xref:System.Windows.VerticalAlignment> regulares</xref:System.Windows.FrameworkElement.Width%2A> </xref:System.Windows.FrameworkElement.Height%2A>       VerticalAlignment é o [!INCLUDE[TLA#tla_net](~/add/includes/tlasharptla-net-md.md)] acessor de propriedade para o que é na realidade uma propriedade de dependência. Esta propriedade de dependência específico bastante frequentemente tem o valor de aparente &quot;predefinido&quot; definir de forma diferente em classes derivadas de elemento, particularmente controlos. Esta situação ocorre geralmente de uma das seguintes formas: a propriedade de dependência novamente está registada para uma determinada classe derivada, mas com metadados diferentes para definir as respetivas predefinições; ou existe um estilo predefinido a ser aplicado que define esse valor de propriedade de dependência de forma diferente. Por exemplo, o aparente &quot;predefinido&quot; de VerticalAlignment para um <xref:System.Windows.Controls.ComboBoxItem>controlo será <xref:System.Windows.VerticalAlignment>, mesmo que <xref:System.Windows.Controls.ComboBoxItem>herda VerticalAlignment direta de <xref:System.Windows.FrameworkElement>.</xref:System.Windows.FrameworkElement> </xref:System.Windows.Controls.ComboBoxItem> </xref:System.Windows.VerticalAlignment> </xref:System.Windows.Controls.ComboBoxItem> Isto acontece porque esse valor foi reposto no estilo predefinido do <xref:System.Windows.Controls.ComboBoxItem>, dentro do modelo de controlo de estilo.</xref:System.Windows.Controls.ComboBoxItem>       <xref:System.Windows.Controls.Canvas>Utilize VerticalAlignment durante a composição de esquema, porque <xref:System.Windows.Controls.Canvas>baseia-se no posicionamento absoluto.</xref:System.Windows.Controls.Canvas></xref:System.Windows.Controls.Canvas>       Quando herdado por <xref:System.Windows.Controls.ComboBoxItem>ou quaisquer classes derivadas, <xref:System.Windows.Controls.ComboBoxItem>redefine o valor predefinido desta propriedade ser <xref:System.Windows.VerticalAlignment>.</xref:System.Windows.VerticalAlignment> </xref:System.Windows.Controls.ComboBoxItem> </xref:System.Windows.Controls.ComboBoxItem>      <a name=&quot;dependencyPropertyInfo_VerticalAlignment&quot;></a># # Informações de propriedade de dependência |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.VerticalAlignmentProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> </xref:System.Windows.FrameworkElement.VerticalAlignmentProperty>"
  syntax:
    content: public System.Windows.VerticalAlignment VerticalAlignment { get; set; }
    return:
      type: System.Windows.VerticalAlignment
      description: "Uma definição de alinhamento vertical. A predefinição é <xref href=&quot;System.Windows.VerticalAlignment&quot;> </xref>."
  overload: System.Windows.FrameworkElement.VerticalAlignment*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.VerticalAlignmentProperty
  id: VerticalAlignmentProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: VerticalAlignmentProperty
  nameWithType: FrameworkElement.VerticalAlignmentProperty
  fullName: System.Windows.FrameworkElement.VerticalAlignmentProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.VerticalAlignment*>propriedade de dependência.</xref:System.Windows.FrameworkElement.VerticalAlignment*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty VerticalAlignmentProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.VisualChildrenCount
  id: VisualChildrenCount
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: VisualChildrenCount
  nameWithType: FrameworkElement.VisualChildrenCount
  fullName: System.Windows.FrameworkElement.VisualChildrenCount
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém o número de elementos subordinados visual neste elemento."
  remarks: "O <xref:System.Windows.FrameworkElement>implementação VisualChildrenCount sempre devolve zero ou um.</xref:System.Windows.FrameworkElement> As classes que mantêm uma coleção de subordinado visual que poderá exceder um tem de substituir esta propriedade e o <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.</xref:System.Windows.FrameworkElement.GetVisualChild%2A>       Esta propriedade é geralmente utilizada para determinar os limites superior da coleção subordinada atual para fins de implementar as substituições de esquema (<xref:System.Windows.FrameworkElement.MeasureOverride%2A>, <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>).</xref:System.Windows.FrameworkElement.ArrangeOverride%2A> </xref:System.Windows.FrameworkElement.MeasureOverride%2A>"
  example:
  - "The following example shows how a custom adorner uses the values declared by a <xref:System.Windows.Media.VisualCollection> that it maintains for its multiple visual children and reports these values through overrides of VisualChildrenCount and <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.  \n  \n [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/add/codesnippet/visualbasic/resizingadorner/resizingadorner.vb#fevisualoverridespre)]\n [!code-cs[Adorners_ResizingAdorner#FEVisualOverridesPre](~/add/codesnippet/csharp/ResizingAdorner/ResizingAdorner.cs#fevisualoverridespre)]  \n[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/add/codesnippet/visualbasic/resizingadorner/resizingadorner.vb#fevisualoverrides)]\n[!code-cs[Adorners_ResizingAdorner#FEVisualOverrides](~/add/codesnippet/csharp/ResizingAdorner/ResizingAdorner.cs#fevisualoverrides)]"
  syntax:
    content: protected override int VisualChildrenCount { get; }
    return:
      type: System.Int32
      description: "O número de elementos subordinados visual para este elemento."
  overload: System.Windows.FrameworkElement.VisualChildrenCount*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Width
  id: Width
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Width
  nameWithType: FrameworkElement.Width
  fullName: System.Windows.FrameworkElement.Width
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Obtém ou define a largura do elemento."
  remarks: "Esta é uma das três propriedades no <xref:System.Windows.FrameworkElement>que especifique informações de largura.</xref:System.Windows.FrameworkElement>  As outras duas são <xref:System.Windows.FrameworkElement.MinWidth%2A>e <xref:System.Windows.FrameworkElement.MaxWidth%2A>.</xref:System.Windows.FrameworkElement.MaxWidth%2A> </xref:System.Windows.FrameworkElement.MinWidth%2A>  Se houver um conflito entre estes valores, a ordem da aplicação para a determinação de largura real é primeiro <xref:System.Windows.FrameworkElement.MinWidth%2A>tem de ser honrado, em seguida, <xref:System.Windows.FrameworkElement.MaxWidth%2A>e, finalmente, se cada um destes está dentro dos limites, largura.</xref:System.Windows.FrameworkElement.MaxWidth%2A> </xref:System.Windows.FrameworkElement.MinWidth%2A>       O valor de retorno desta propriedade é sempre o mesmo que qualquer valor que foi definido para o mesmo. Em contraste, o valor da <xref:System.Windows.FrameworkElement.ActualWidth%2A>pode variar.</xref:System.Windows.FrameworkElement.ActualWidth%2A> O esquema poderá ter rejeitou o tamanho sugerido por algum motivo. Além disso, o sistema de esquema próprio funciona de forma assíncrona relativo para o conjunto de sistema de propriedade da largura e não pode ter processados específico de que a alteração de propriedade de dimensionamento ainda.       Para além de aceitável <xref:System.Double>valores, esta propriedade também podem ser <xref:System.Double.NaN?displayProperty=fullName>.</xref:System.Double.NaN?displayProperty=fullName> </xref:System.Double> Esta é a forma como especificar o comportamento de dimensionamento automático. No [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] definir o valor para a cadeia &quot;Auto&quot; (sensível a maiúsculas e minúsculas) para ativar automaticamente o comportamento de dimensionamento. Comportamento de dimensionamento de automática implica que o elemento irá preencher a largura disponível. Tenha em atenção contudo que controlos específicos frequentemente fornecem valores predefinidos no respetivos estilos predefinidos que desactivará automaticamente o comportamento de dimensionamento, a menos que seja especificamente reativada.       Para além de verificação de validação, é um valor superior não determinístico vinculado a largura que é imposta pelo sistema do esquema (este é um número muito elevado, maior <xref:System.Single.MaxValue?displayProperty=fullName>inferior, mas <xref:System.Double.MaxValue?displayProperty=fullName>).</xref:System.Double.MaxValue?displayProperty=fullName> </xref:System.Single.MaxValue?displayProperty=fullName> Se exceder este limite, o elemento não irá compor e sem exceção é emitida. Não defina a largura para um valor que é significativamente maior do que o tamanho máximo de quaisquer possíveis apresentação visual ou pode exceder este limite superior não determinístico.      <a name=&quot;xamlAttributeUsage_Width&quot;></a># # Utilização do atributo de XAML ```   <object Width=&quot;double&quot;/>   - or –   <object Width =&quot;qualifiedDouble&quot;/>   - or -   <object Width =&quot;Auto&quot;/>   ``` <a name=&quot;xamlValues_Width&quot;> </a> # # XAML valores *duplo* <xref:System.Double> cadeia representação de um <xref:System.Double>valor igual ou maior do que 0,0.</xref:System.Double> </xref:System.Double>           Consulte observações para obter informações de limite superior. Este valor é interpretado como um [!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)] medida. As cadeias não tem de incluir explicitamente decimais. Por exemplo, um valor de `1` é aceitável.       *qualifiedDouble* A *duplo* valor, tal como descrito acima, seguido de uma das seguintes cadeias de declaração de unidade: `px`, `in`, `cm`, `pt`.       `px`(predefinição) é [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)] `in` é polegadas; 1 in = = 96px `cm` é centímetros; 1cm==(96/2.54) px `pt` é pontos; 1pt==(96/72) px `Auto` permite autosizing comportamento.        Consulte observações.      <a name=&quot;dependencyPropertyInfo_Width&quot;></a># # Informações de propriedade de dependência |||   |-|-|   | Campo Identificador | <xref:System.Windows.FrameworkElement.WidthProperty>|   | Definir propriedades de metadados `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.WidthProperty>"
  syntax:
    content: public double Width { get; set; }
    return:
      type: System.Double
      description: "A largura do elemento, na [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]. O valor predefinido é &lt;xref:System.Double?displayProperty=fullName&gt;. Este valor tem de ser igual ou maior do que 0,0. Consulte observações para obter informações de limite superior."
  overload: System.Windows.FrameworkElement.Width*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.WidthProperty
  id: WidthProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: WidthProperty
  nameWithType: FrameworkElement.WidthProperty
  fullName: System.Windows.FrameworkElement.WidthProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifica o <xref:System.Windows.FrameworkElement.Width*>propriedade de dependência.</xref:System.Windows.FrameworkElement.Width*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty WidthProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "A adicionar."
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.UIElement
  isExternal: false
  name: System.Windows.UIElement
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Windows.ResourceReferenceKeyNotFoundException
  parent: System.Windows
  isExternal: false
  name: ResourceReferenceKeyNotFoundException
  nameWithType: ResourceReferenceKeyNotFoundException
  fullName: System.Windows.ResourceReferenceKeyNotFoundException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.Windows.FrameworkElement.#ctor
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FrameworkElement()
  nameWithType: FrameworkElement.FrameworkElement()
  fullName: System.Windows.FrameworkElement.FrameworkElement()
- uid: System.Windows.FrameworkElement.ActualHeight
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ActualHeight
  nameWithType: FrameworkElement.ActualHeight
  fullName: System.Windows.FrameworkElement.ActualHeight
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.Windows.FrameworkElement.ActualHeightProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ActualHeightProperty
  nameWithType: FrameworkElement.ActualHeightProperty
  fullName: System.Windows.FrameworkElement.ActualHeightProperty
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Windows.FrameworkElement.ActualWidth
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ActualWidth
  nameWithType: FrameworkElement.ActualWidth
  fullName: System.Windows.FrameworkElement.ActualWidth
- uid: System.Windows.FrameworkElement.ActualWidthProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ActualWidthProperty
  nameWithType: FrameworkElement.ActualWidthProperty
  fullName: System.Windows.FrameworkElement.ActualWidthProperty
- uid: System.Windows.FrameworkElement.AddLogicalChild(System.Object)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: AddLogicalChild(Object)
  nameWithType: FrameworkElement.AddLogicalChild(Object)
  fullName: System.Windows.FrameworkElement.AddLogicalChild(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.FrameworkElement.ApplyTemplate
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ApplyTemplate()
  nameWithType: FrameworkElement.ApplyTemplate()
  fullName: System.Windows.FrameworkElement.ApplyTemplate()
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ArrangeCore(Rect)
  nameWithType: FrameworkElement.ArrangeCore(Rect)
  fullName: System.Windows.FrameworkElement.ArrangeCore(Rect)
- uid: System.Windows.Rect
  parent: System.Windows
  isExternal: false
  name: Rect
  nameWithType: Rect
  fullName: System.Windows.Rect
- uid: System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ArrangeOverride(Size)
  nameWithType: FrameworkElement.ArrangeOverride(Size)
  fullName: System.Windows.FrameworkElement.ArrangeOverride(Size)
- uid: System.Windows.Size
  parent: System.Windows
  isExternal: false
  name: Size
  nameWithType: Size
  fullName: System.Windows.Size
- uid: System.Windows.FrameworkElement.BeginInit
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BeginInit()
  nameWithType: FrameworkElement.BeginInit()
  fullName: System.Windows.FrameworkElement.BeginInit()
- uid: System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BeginStoryboard(Storyboard)
  nameWithType: FrameworkElement.BeginStoryboard(Storyboard)
  fullName: System.Windows.FrameworkElement.BeginStoryboard(Storyboard)
- uid: System.Windows.Media.Animation.Storyboard
  parent: System.Windows.Media.Animation
  isExternal: false
  name: Storyboard
  nameWithType: Storyboard
  fullName: System.Windows.Media.Animation.Storyboard
- uid: System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BeginStoryboard(Storyboard,HandoffBehavior)
  nameWithType: FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior)
  fullName: System.Windows.FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior)
- uid: System.Windows.Media.Animation.HandoffBehavior
  parent: System.Windows.Media.Animation
  isExternal: false
  name: HandoffBehavior
  nameWithType: HandoffBehavior
  fullName: System.Windows.Media.Animation.HandoffBehavior
- uid: System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  nameWithType: FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  fullName: System.Windows.FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
- uid: System.Windows.FrameworkElement.BindingGroup
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BindingGroup
  nameWithType: FrameworkElement.BindingGroup
  fullName: System.Windows.FrameworkElement.BindingGroup
- uid: System.Windows.Data.BindingGroup
  parent: System.Windows.Data
  isExternal: false
  name: BindingGroup
  nameWithType: BindingGroup
  fullName: System.Windows.Data.BindingGroup
- uid: System.Windows.FrameworkElement.BindingGroupProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BindingGroupProperty
  nameWithType: FrameworkElement.BindingGroupProperty
  fullName: System.Windows.FrameworkElement.BindingGroupProperty
- uid: System.Windows.FrameworkElement.BringIntoView
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BringIntoView()
  nameWithType: FrameworkElement.BringIntoView()
  fullName: System.Windows.FrameworkElement.BringIntoView()
- uid: System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BringIntoView(Rect)
  nameWithType: FrameworkElement.BringIntoView(Rect)
  fullName: System.Windows.FrameworkElement.BringIntoView(Rect)
- uid: System.Windows.FrameworkElement.ContextMenu
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenu
  nameWithType: FrameworkElement.ContextMenu
  fullName: System.Windows.FrameworkElement.ContextMenu
- uid: System.Windows.Controls.ContextMenu
  parent: System.Windows.Controls
  isExternal: false
  name: ContextMenu
  nameWithType: ContextMenu
  fullName: System.Windows.Controls.ContextMenu
- uid: System.Windows.FrameworkElement.ContextMenuClosing
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenuClosing
  nameWithType: FrameworkElement.ContextMenuClosing
  fullName: System.Windows.FrameworkElement.ContextMenuClosing
- uid: System.Windows.Controls.ContextMenuEventHandler
  parent: System.Windows.Controls
  isExternal: false
  name: ContextMenuEventHandler
  nameWithType: ContextMenuEventHandler
  fullName: System.Windows.Controls.ContextMenuEventHandler
- uid: System.Windows.FrameworkElement.ContextMenuClosingEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenuClosingEvent
  nameWithType: FrameworkElement.ContextMenuClosingEvent
  fullName: System.Windows.FrameworkElement.ContextMenuClosingEvent
- uid: System.Windows.RoutedEvent
  parent: System.Windows
  isExternal: false
  name: RoutedEvent
  nameWithType: RoutedEvent
  fullName: System.Windows.RoutedEvent
- uid: System.Windows.FrameworkElement.ContextMenuOpening
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenuOpening
  nameWithType: FrameworkElement.ContextMenuOpening
  fullName: System.Windows.FrameworkElement.ContextMenuOpening
- uid: System.Windows.FrameworkElement.ContextMenuOpeningEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenuOpeningEvent
  nameWithType: FrameworkElement.ContextMenuOpeningEvent
  fullName: System.Windows.FrameworkElement.ContextMenuOpeningEvent
- uid: System.Windows.FrameworkElement.ContextMenuProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenuProperty
  nameWithType: FrameworkElement.ContextMenuProperty
  fullName: System.Windows.FrameworkElement.ContextMenuProperty
- uid: System.Windows.FrameworkElement.Cursor
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Cursor
  nameWithType: FrameworkElement.Cursor
  fullName: System.Windows.FrameworkElement.Cursor
- uid: System.Windows.Input.Cursor
  parent: System.Windows.Input
  isExternal: false
  name: Cursor
  nameWithType: Cursor
  fullName: System.Windows.Input.Cursor
- uid: System.Windows.FrameworkElement.CursorProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: CursorProperty
  nameWithType: FrameworkElement.CursorProperty
  fullName: System.Windows.FrameworkElement.CursorProperty
- uid: System.Windows.FrameworkElement.DataContext
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DataContext
  nameWithType: FrameworkElement.DataContext
  fullName: System.Windows.FrameworkElement.DataContext
- uid: System.Windows.FrameworkElement.DataContextChanged
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DataContextChanged
  nameWithType: FrameworkElement.DataContextChanged
  fullName: System.Windows.FrameworkElement.DataContextChanged
- uid: System.Windows.DependencyPropertyChangedEventHandler
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyChangedEventHandler
  nameWithType: DependencyPropertyChangedEventHandler
  fullName: System.Windows.DependencyPropertyChangedEventHandler
- uid: System.Windows.FrameworkElement.DataContextProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DataContextProperty
  nameWithType: FrameworkElement.DataContextProperty
  fullName: System.Windows.FrameworkElement.DataContextProperty
- uid: System.Windows.FrameworkElement.DefaultStyleKey
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DefaultStyleKey
  nameWithType: FrameworkElement.DefaultStyleKey
  fullName: System.Windows.FrameworkElement.DefaultStyleKey
- uid: System.Windows.FrameworkElement.DefaultStyleKeyProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DefaultStyleKeyProperty
  nameWithType: FrameworkElement.DefaultStyleKeyProperty
  fullName: System.Windows.FrameworkElement.DefaultStyleKeyProperty
- uid: System.Windows.FrameworkElement.EndInit
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: EndInit()
  nameWithType: FrameworkElement.EndInit()
  fullName: System.Windows.FrameworkElement.EndInit()
- uid: System.Windows.FrameworkElement.FindName(System.String)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FindName(String)
  nameWithType: FrameworkElement.FindName(String)
  fullName: System.Windows.FrameworkElement.FindName(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.FrameworkElement.FindResource(System.Object)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FindResource(Object)
  nameWithType: FrameworkElement.FindResource(Object)
  fullName: System.Windows.FrameworkElement.FindResource(Object)
- uid: System.Windows.FrameworkElement.FlowDirection
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FlowDirection
  nameWithType: FrameworkElement.FlowDirection
  fullName: System.Windows.FrameworkElement.FlowDirection
- uid: System.Windows.FlowDirection
  parent: System.Windows
  isExternal: false
  name: FlowDirection
  nameWithType: FlowDirection
  fullName: System.Windows.FlowDirection
- uid: System.Windows.FrameworkElement.FlowDirectionProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FlowDirectionProperty
  nameWithType: FrameworkElement.FlowDirectionProperty
  fullName: System.Windows.FrameworkElement.FlowDirectionProperty
- uid: System.Windows.FrameworkElement.FocusVisualStyle
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FocusVisualStyle
  nameWithType: FrameworkElement.FocusVisualStyle
  fullName: System.Windows.FrameworkElement.FocusVisualStyle
- uid: System.Windows.Style
  parent: System.Windows
  isExternal: false
  name: Style
  nameWithType: Style
  fullName: System.Windows.Style
- uid: System.Windows.FrameworkElement.FocusVisualStyleProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FocusVisualStyleProperty
  nameWithType: FrameworkElement.FocusVisualStyleProperty
  fullName: System.Windows.FrameworkElement.FocusVisualStyleProperty
- uid: System.Windows.FrameworkElement.ForceCursor
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ForceCursor
  nameWithType: FrameworkElement.ForceCursor
  fullName: System.Windows.FrameworkElement.ForceCursor
- uid: System.Windows.FrameworkElement.ForceCursorProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ForceCursorProperty
  nameWithType: FrameworkElement.ForceCursorProperty
  fullName: System.Windows.FrameworkElement.ForceCursorProperty
- uid: System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetBindingExpression(DependencyProperty)
  nameWithType: FrameworkElement.GetBindingExpression(DependencyProperty)
  fullName: System.Windows.FrameworkElement.GetBindingExpression(DependencyProperty)
- uid: System.Windows.Data.BindingExpression
  parent: System.Windows.Data
  isExternal: false
  name: BindingExpression
  nameWithType: BindingExpression
  fullName: System.Windows.Data.BindingExpression
- uid: System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetFlowDirection(DependencyObject)
  nameWithType: FrameworkElement.GetFlowDirection(DependencyObject)
  fullName: System.Windows.FrameworkElement.GetFlowDirection(DependencyObject)
- uid: System.Windows.DependencyObject
  parent: System.Windows
  isExternal: false
  name: DependencyObject
  nameWithType: DependencyObject
  fullName: System.Windows.DependencyObject
- uid: System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetLayoutClip(Size)
  nameWithType: FrameworkElement.GetLayoutClip(Size)
  fullName: System.Windows.FrameworkElement.GetLayoutClip(Size)
- uid: System.Windows.Media.Geometry
  parent: System.Windows.Media
  isExternal: false
  name: Geometry
  nameWithType: Geometry
  fullName: System.Windows.Media.Geometry
- uid: System.Windows.FrameworkElement.GetTemplateChild(System.String)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetTemplateChild(String)
  nameWithType: FrameworkElement.GetTemplateChild(String)
  fullName: System.Windows.FrameworkElement.GetTemplateChild(String)
- uid: System.Windows.FrameworkElement.GetUIParentCore
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetUIParentCore()
  nameWithType: FrameworkElement.GetUIParentCore()
  fullName: System.Windows.FrameworkElement.GetUIParentCore()
- uid: System.Windows.FrameworkElement.GetVisualChild(System.Int32)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetVisualChild(Int32)
  nameWithType: FrameworkElement.GetVisualChild(Int32)
  fullName: System.Windows.FrameworkElement.GetVisualChild(Int32)
- uid: System.Windows.Media.Visual
  parent: System.Windows.Media
  isExternal: false
  name: Visual
  nameWithType: Visual
  fullName: System.Windows.Media.Visual
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.FrameworkElement.Height
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Height
  nameWithType: FrameworkElement.Height
  fullName: System.Windows.FrameworkElement.Height
- uid: System.Windows.FrameworkElement.HeightProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: HeightProperty
  nameWithType: FrameworkElement.HeightProperty
  fullName: System.Windows.FrameworkElement.HeightProperty
- uid: System.Windows.FrameworkElement.HorizontalAlignment
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: HorizontalAlignment
  nameWithType: FrameworkElement.HorizontalAlignment
  fullName: System.Windows.FrameworkElement.HorizontalAlignment
- uid: System.Windows.HorizontalAlignment
  parent: System.Windows
  isExternal: false
  name: HorizontalAlignment
  nameWithType: HorizontalAlignment
  fullName: System.Windows.HorizontalAlignment
- uid: System.Windows.FrameworkElement.HorizontalAlignmentProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: HorizontalAlignmentProperty
  nameWithType: FrameworkElement.HorizontalAlignmentProperty
  fullName: System.Windows.FrameworkElement.HorizontalAlignmentProperty
- uid: System.Windows.FrameworkElement.InheritanceBehavior
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: InheritanceBehavior
  nameWithType: FrameworkElement.InheritanceBehavior
  fullName: System.Windows.FrameworkElement.InheritanceBehavior
- uid: System.Windows.InheritanceBehavior
  parent: System.Windows
  isExternal: false
  name: InheritanceBehavior
  nameWithType: InheritanceBehavior
  fullName: System.Windows.InheritanceBehavior
- uid: System.Windows.FrameworkElement.Initialized
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Initialized
  nameWithType: FrameworkElement.Initialized
  fullName: System.Windows.FrameworkElement.Initialized
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Windows.FrameworkElement.InputScope
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: InputScope
  nameWithType: FrameworkElement.InputScope
  fullName: System.Windows.FrameworkElement.InputScope
- uid: System.Windows.Input.InputScope
  parent: System.Windows.Input
  isExternal: false
  name: InputScope
  nameWithType: InputScope
  fullName: System.Windows.Input.InputScope
- uid: System.Windows.FrameworkElement.InputScopeProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: InputScopeProperty
  nameWithType: FrameworkElement.InputScopeProperty
  fullName: System.Windows.FrameworkElement.InputScopeProperty
- uid: System.Windows.FrameworkElement.IsInitialized
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: IsInitialized
  nameWithType: FrameworkElement.IsInitialized
  fullName: System.Windows.FrameworkElement.IsInitialized
- uid: System.Windows.FrameworkElement.IsLoaded
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: IsLoaded
  nameWithType: FrameworkElement.IsLoaded
  fullName: System.Windows.FrameworkElement.IsLoaded
- uid: System.Windows.FrameworkElement.Language
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Language
  nameWithType: FrameworkElement.Language
  fullName: System.Windows.FrameworkElement.Language
- uid: System.Windows.Markup.XmlLanguage
  parent: System.Windows.Markup
  isExternal: false
  name: XmlLanguage
  nameWithType: XmlLanguage
  fullName: System.Windows.Markup.XmlLanguage
- uid: System.Windows.FrameworkElement.LanguageProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LanguageProperty
  nameWithType: FrameworkElement.LanguageProperty
  fullName: System.Windows.FrameworkElement.LanguageProperty
- uid: System.Windows.FrameworkElement.LayoutTransform
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LayoutTransform
  nameWithType: FrameworkElement.LayoutTransform
  fullName: System.Windows.FrameworkElement.LayoutTransform
- uid: System.Windows.Media.Transform
  parent: System.Windows.Media
  isExternal: false
  name: Transform
  nameWithType: Transform
  fullName: System.Windows.Media.Transform
- uid: System.Windows.FrameworkElement.LayoutTransformProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LayoutTransformProperty
  nameWithType: FrameworkElement.LayoutTransformProperty
  fullName: System.Windows.FrameworkElement.LayoutTransformProperty
- uid: System.Windows.FrameworkElement.Loaded
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Loaded
  nameWithType: FrameworkElement.Loaded
  fullName: System.Windows.FrameworkElement.Loaded
- uid: System.Windows.RoutedEventHandler
  parent: System.Windows
  isExternal: false
  name: RoutedEventHandler
  nameWithType: RoutedEventHandler
  fullName: System.Windows.RoutedEventHandler
- uid: System.Windows.FrameworkElement.LoadedEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LoadedEvent
  nameWithType: FrameworkElement.LoadedEvent
  fullName: System.Windows.FrameworkElement.LoadedEvent
- uid: System.Windows.FrameworkElement.LogicalChildren
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LogicalChildren
  nameWithType: FrameworkElement.LogicalChildren
  fullName: System.Windows.FrameworkElement.LogicalChildren
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Windows.FrameworkElement.Margin
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Margin
  nameWithType: FrameworkElement.Margin
  fullName: System.Windows.FrameworkElement.Margin
- uid: System.Windows.Thickness
  parent: System.Windows
  isExternal: false
  name: Thickness
  nameWithType: Thickness
  fullName: System.Windows.Thickness
- uid: System.Windows.FrameworkElement.MarginProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MarginProperty
  nameWithType: FrameworkElement.MarginProperty
  fullName: System.Windows.FrameworkElement.MarginProperty
- uid: System.Windows.FrameworkElement.MaxHeight
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MaxHeight
  nameWithType: FrameworkElement.MaxHeight
  fullName: System.Windows.FrameworkElement.MaxHeight
- uid: System.Windows.FrameworkElement.MaxHeightProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MaxHeightProperty
  nameWithType: FrameworkElement.MaxHeightProperty
  fullName: System.Windows.FrameworkElement.MaxHeightProperty
- uid: System.Windows.FrameworkElement.MaxWidth
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MaxWidth
  nameWithType: FrameworkElement.MaxWidth
  fullName: System.Windows.FrameworkElement.MaxWidth
- uid: System.Windows.FrameworkElement.MaxWidthProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MaxWidthProperty
  nameWithType: FrameworkElement.MaxWidthProperty
  fullName: System.Windows.FrameworkElement.MaxWidthProperty
- uid: System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MeasureCore(Size)
  nameWithType: FrameworkElement.MeasureCore(Size)
  fullName: System.Windows.FrameworkElement.MeasureCore(Size)
- uid: System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MeasureOverride(Size)
  nameWithType: FrameworkElement.MeasureOverride(Size)
  fullName: System.Windows.FrameworkElement.MeasureOverride(Size)
- uid: System.Windows.FrameworkElement.MinHeight
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MinHeight
  nameWithType: FrameworkElement.MinHeight
  fullName: System.Windows.FrameworkElement.MinHeight
- uid: System.Windows.FrameworkElement.MinHeightProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MinHeightProperty
  nameWithType: FrameworkElement.MinHeightProperty
  fullName: System.Windows.FrameworkElement.MinHeightProperty
- uid: System.Windows.FrameworkElement.MinWidth
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MinWidth
  nameWithType: FrameworkElement.MinWidth
  fullName: System.Windows.FrameworkElement.MinWidth
- uid: System.Windows.FrameworkElement.MinWidthProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MinWidthProperty
  nameWithType: FrameworkElement.MinWidthProperty
  fullName: System.Windows.FrameworkElement.MinWidthProperty
- uid: System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MoveFocus(TraversalRequest)
  nameWithType: FrameworkElement.MoveFocus(TraversalRequest)
  fullName: System.Windows.FrameworkElement.MoveFocus(TraversalRequest)
- uid: System.Windows.Input.TraversalRequest
  parent: System.Windows.Input
  isExternal: false
  name: TraversalRequest
  nameWithType: TraversalRequest
  fullName: System.Windows.Input.TraversalRequest
- uid: System.Windows.FrameworkElement.Name
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Name
  nameWithType: FrameworkElement.Name
  fullName: System.Windows.FrameworkElement.Name
- uid: System.Windows.FrameworkElement.NameProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: NameProperty
  nameWithType: FrameworkElement.NameProperty
  fullName: System.Windows.FrameworkElement.NameProperty
- uid: System.Windows.FrameworkElement.OnApplyTemplate
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnApplyTemplate()
  nameWithType: FrameworkElement.OnApplyTemplate()
  fullName: System.Windows.FrameworkElement.OnApplyTemplate()
- uid: System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnContextMenuClosing(ContextMenuEventArgs)
  nameWithType: FrameworkElement.OnContextMenuClosing(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkElement.OnContextMenuClosing(ContextMenuEventArgs)
- uid: System.Windows.Controls.ContextMenuEventArgs
  parent: System.Windows.Controls
  isExternal: false
  name: ContextMenuEventArgs
  nameWithType: ContextMenuEventArgs
  fullName: System.Windows.Controls.ContextMenuEventArgs
- uid: System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnContextMenuOpening(ContextMenuEventArgs)
  nameWithType: FrameworkElement.OnContextMenuOpening(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkElement.OnContextMenuOpening(ContextMenuEventArgs)
- uid: System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnGotFocus(RoutedEventArgs)
  nameWithType: FrameworkElement.OnGotFocus(RoutedEventArgs)
  fullName: System.Windows.FrameworkElement.OnGotFocus(RoutedEventArgs)
- uid: System.Windows.RoutedEventArgs
  parent: System.Windows
  isExternal: false
  name: RoutedEventArgs
  nameWithType: RoutedEventArgs
  fullName: System.Windows.RoutedEventArgs
- uid: System.Windows.FrameworkElement.OnInitialized(System.EventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnInitialized(EventArgs)
  nameWithType: FrameworkElement.OnInitialized(EventArgs)
  fullName: System.Windows.FrameworkElement.OnInitialized(EventArgs)
- uid: System.EventArgs
  parent: System
  isExternal: true
  name: EventArgs
  nameWithType: EventArgs
  fullName: System.EventArgs
- uid: System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnPropertyChanged(DependencyPropertyChangedEventArgs)
  nameWithType: FrameworkElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.FrameworkElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
- uid: System.Windows.DependencyPropertyChangedEventArgs
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyChangedEventArgs
  nameWithType: DependencyPropertyChangedEventArgs
  fullName: System.Windows.DependencyPropertyChangedEventArgs
- uid: System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnRenderSizeChanged(SizeChangedInfo)
  nameWithType: FrameworkElement.OnRenderSizeChanged(SizeChangedInfo)
  fullName: System.Windows.FrameworkElement.OnRenderSizeChanged(SizeChangedInfo)
- uid: System.Windows.SizeChangedInfo
  parent: System.Windows
  isExternal: false
  name: SizeChangedInfo
  nameWithType: SizeChangedInfo
  fullName: System.Windows.SizeChangedInfo
- uid: System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnStyleChanged(Style,Style)
  nameWithType: FrameworkElement.OnStyleChanged(Style,Style)
  fullName: System.Windows.FrameworkElement.OnStyleChanged(Style,Style)
- uid: System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnToolTipClosing(ToolTipEventArgs)
  nameWithType: FrameworkElement.OnToolTipClosing(ToolTipEventArgs)
  fullName: System.Windows.FrameworkElement.OnToolTipClosing(ToolTipEventArgs)
- uid: System.Windows.Controls.ToolTipEventArgs
  parent: System.Windows.Controls
  isExternal: false
  name: ToolTipEventArgs
  nameWithType: ToolTipEventArgs
  fullName: System.Windows.Controls.ToolTipEventArgs
- uid: System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnToolTipOpening(ToolTipEventArgs)
  nameWithType: FrameworkElement.OnToolTipOpening(ToolTipEventArgs)
  fullName: System.Windows.FrameworkElement.OnToolTipOpening(ToolTipEventArgs)
- uid: System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnVisualParentChanged(DependencyObject)
  nameWithType: FrameworkElement.OnVisualParentChanged(DependencyObject)
  fullName: System.Windows.FrameworkElement.OnVisualParentChanged(DependencyObject)
- uid: System.Windows.FrameworkElement.OverridesDefaultStyle
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OverridesDefaultStyle
  nameWithType: FrameworkElement.OverridesDefaultStyle
  fullName: System.Windows.FrameworkElement.OverridesDefaultStyle
- uid: System.Windows.FrameworkElement.OverridesDefaultStyleProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OverridesDefaultStyleProperty
  nameWithType: FrameworkElement.OverridesDefaultStyleProperty
  fullName: System.Windows.FrameworkElement.OverridesDefaultStyleProperty
- uid: System.Windows.FrameworkElement.Parent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Parent
  nameWithType: FrameworkElement.Parent
  fullName: System.Windows.FrameworkElement.Parent
- uid: System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ParentLayoutInvalidated(UIElement)
  nameWithType: FrameworkElement.ParentLayoutInvalidated(UIElement)
  fullName: System.Windows.FrameworkElement.ParentLayoutInvalidated(UIElement)
- uid: System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: PredictFocus(FocusNavigationDirection)
  nameWithType: FrameworkElement.PredictFocus(FocusNavigationDirection)
  fullName: System.Windows.FrameworkElement.PredictFocus(FocusNavigationDirection)
- uid: System.Windows.Input.FocusNavigationDirection
  parent: System.Windows.Input
  isExternal: false
  name: FocusNavigationDirection
  nameWithType: FocusNavigationDirection
  fullName: System.Windows.Input.FocusNavigationDirection
- uid: System.Windows.FrameworkElement.RegisterName(System.String,System.Object)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: RegisterName(String,Object)
  nameWithType: FrameworkElement.RegisterName(String,Object)
  fullName: System.Windows.FrameworkElement.RegisterName(String,Object)
- uid: System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: RemoveLogicalChild(Object)
  nameWithType: FrameworkElement.RemoveLogicalChild(Object)
  fullName: System.Windows.FrameworkElement.RemoveLogicalChild(Object)
- uid: System.Windows.FrameworkElement.RequestBringIntoView
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: RequestBringIntoView
  nameWithType: FrameworkElement.RequestBringIntoView
  fullName: System.Windows.FrameworkElement.RequestBringIntoView
- uid: System.Windows.RequestBringIntoViewEventHandler
  parent: System.Windows
  isExternal: false
  name: RequestBringIntoViewEventHandler
  nameWithType: RequestBringIntoViewEventHandler
  fullName: System.Windows.RequestBringIntoViewEventHandler
- uid: System.Windows.FrameworkElement.RequestBringIntoViewEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: RequestBringIntoViewEvent
  nameWithType: FrameworkElement.RequestBringIntoViewEvent
  fullName: System.Windows.FrameworkElement.RequestBringIntoViewEvent
- uid: System.Windows.FrameworkElement.Resources
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Resources
  nameWithType: FrameworkElement.Resources
  fullName: System.Windows.FrameworkElement.Resources
- uid: System.Windows.ResourceDictionary
  parent: System.Windows
  isExternal: false
  name: ResourceDictionary
  nameWithType: ResourceDictionary
  fullName: System.Windows.ResourceDictionary
- uid: System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetBinding(DependencyProperty,String)
  nameWithType: FrameworkElement.SetBinding(DependencyProperty,String)
  fullName: System.Windows.FrameworkElement.SetBinding(DependencyProperty,String)
- uid: System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetBinding(DependencyProperty,BindingBase)
  nameWithType: FrameworkElement.SetBinding(DependencyProperty,BindingBase)
  fullName: System.Windows.FrameworkElement.SetBinding(DependencyProperty,BindingBase)
- uid: System.Windows.Data.BindingExpressionBase
  parent: System.Windows.Data
  isExternal: false
  name: BindingExpressionBase
  nameWithType: BindingExpressionBase
  fullName: System.Windows.Data.BindingExpressionBase
- uid: System.Windows.Data.BindingBase
  parent: System.Windows.Data
  isExternal: false
  name: BindingBase
  nameWithType: BindingBase
  fullName: System.Windows.Data.BindingBase
- uid: System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetFlowDirection(DependencyObject,FlowDirection)
  nameWithType: FrameworkElement.SetFlowDirection(DependencyObject,FlowDirection)
  fullName: System.Windows.FrameworkElement.SetFlowDirection(DependencyObject,FlowDirection)
- uid: System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetResourceReference(DependencyProperty,Object)
  nameWithType: FrameworkElement.SetResourceReference(DependencyProperty,Object)
  fullName: System.Windows.FrameworkElement.SetResourceReference(DependencyProperty,Object)
- uid: System.Windows.FrameworkElement.ShouldSerializeResources
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ShouldSerializeResources()
  nameWithType: FrameworkElement.ShouldSerializeResources()
  fullName: System.Windows.FrameworkElement.ShouldSerializeResources()
- uid: System.Windows.FrameworkElement.ShouldSerializeStyle
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ShouldSerializeStyle()
  nameWithType: FrameworkElement.ShouldSerializeStyle()
  fullName: System.Windows.FrameworkElement.ShouldSerializeStyle()
- uid: System.Windows.FrameworkElement.ShouldSerializeTriggers
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ShouldSerializeTriggers()
  nameWithType: FrameworkElement.ShouldSerializeTriggers()
  fullName: System.Windows.FrameworkElement.ShouldSerializeTriggers()
- uid: System.Windows.FrameworkElement.SizeChanged
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SizeChanged
  nameWithType: FrameworkElement.SizeChanged
  fullName: System.Windows.FrameworkElement.SizeChanged
- uid: System.Windows.SizeChangedEventHandler
  parent: System.Windows
  isExternal: false
  name: SizeChangedEventHandler
  nameWithType: SizeChangedEventHandler
  fullName: System.Windows.SizeChangedEventHandler
- uid: System.Windows.FrameworkElement.SizeChangedEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SizeChangedEvent
  nameWithType: FrameworkElement.SizeChangedEvent
  fullName: System.Windows.FrameworkElement.SizeChangedEvent
- uid: System.Windows.FrameworkElement.SourceUpdated
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SourceUpdated
  nameWithType: FrameworkElement.SourceUpdated
  fullName: System.Windows.FrameworkElement.SourceUpdated
- uid: System.EventHandler{System.Windows.Data.DataTransferEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<DataTransferEventArgs>
  nameWithType: EventHandler<DataTransferEventArgs>
  fullName: System.EventHandler<System.Windows.Data.DataTransferEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.Windows.Data.DataTransferEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Windows.Data.DataTransferEventArgs
    name: DataTransferEventArgs
    nameWithType: DataTransferEventArgs
    fullName: DataTransferEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Windows.FrameworkElement.Style
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Style
  nameWithType: FrameworkElement.Style
  fullName: System.Windows.FrameworkElement.Style
- uid: System.Windows.FrameworkElement.StyleProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: StyleProperty
  nameWithType: FrameworkElement.StyleProperty
  fullName: System.Windows.FrameworkElement.StyleProperty
- uid: System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: FrameworkElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.FrameworkElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
- uid: System.Windows.FrameworkElement.Tag
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Tag
  nameWithType: FrameworkElement.Tag
  fullName: System.Windows.FrameworkElement.Tag
- uid: System.Windows.FrameworkElement.TagProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: TagProperty
  nameWithType: FrameworkElement.TagProperty
  fullName: System.Windows.FrameworkElement.TagProperty
- uid: System.Windows.FrameworkElement.TargetUpdated
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: TargetUpdated
  nameWithType: FrameworkElement.TargetUpdated
  fullName: System.Windows.FrameworkElement.TargetUpdated
- uid: System.Windows.FrameworkElement.TemplatedParent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: TemplatedParent
  nameWithType: FrameworkElement.TemplatedParent
  fullName: System.Windows.FrameworkElement.TemplatedParent
- uid: System.Windows.FrameworkElement.ToolTip
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTip
  nameWithType: FrameworkElement.ToolTip
  fullName: System.Windows.FrameworkElement.ToolTip
- uid: System.Windows.FrameworkElement.ToolTipClosing
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTipClosing
  nameWithType: FrameworkElement.ToolTipClosing
  fullName: System.Windows.FrameworkElement.ToolTipClosing
- uid: System.Windows.Controls.ToolTipEventHandler
  parent: System.Windows.Controls
  isExternal: false
  name: ToolTipEventHandler
  nameWithType: ToolTipEventHandler
  fullName: System.Windows.Controls.ToolTipEventHandler
- uid: System.Windows.FrameworkElement.ToolTipClosingEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTipClosingEvent
  nameWithType: FrameworkElement.ToolTipClosingEvent
  fullName: System.Windows.FrameworkElement.ToolTipClosingEvent
- uid: System.Windows.FrameworkElement.ToolTipOpening
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTipOpening
  nameWithType: FrameworkElement.ToolTipOpening
  fullName: System.Windows.FrameworkElement.ToolTipOpening
- uid: System.Windows.FrameworkElement.ToolTipOpeningEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTipOpeningEvent
  nameWithType: FrameworkElement.ToolTipOpeningEvent
  fullName: System.Windows.FrameworkElement.ToolTipOpeningEvent
- uid: System.Windows.FrameworkElement.ToolTipProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTipProperty
  nameWithType: FrameworkElement.ToolTipProperty
  fullName: System.Windows.FrameworkElement.ToolTipProperty
- uid: System.Windows.FrameworkElement.Triggers
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Triggers
  nameWithType: FrameworkElement.Triggers
  fullName: System.Windows.FrameworkElement.Triggers
- uid: System.Windows.TriggerCollection
  parent: System.Windows
  isExternal: false
  name: TriggerCollection
  nameWithType: TriggerCollection
  fullName: System.Windows.TriggerCollection
- uid: System.Windows.FrameworkElement.TryFindResource(System.Object)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: TryFindResource(Object)
  nameWithType: FrameworkElement.TryFindResource(Object)
  fullName: System.Windows.FrameworkElement.TryFindResource(Object)
- uid: System.Windows.FrameworkElement.Unloaded
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Unloaded
  nameWithType: FrameworkElement.Unloaded
  fullName: System.Windows.FrameworkElement.Unloaded
- uid: System.Windows.FrameworkElement.UnloadedEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UnloadedEvent
  nameWithType: FrameworkElement.UnloadedEvent
  fullName: System.Windows.FrameworkElement.UnloadedEvent
- uid: System.Windows.FrameworkElement.UnregisterName(System.String)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UnregisterName(String)
  nameWithType: FrameworkElement.UnregisterName(String)
  fullName: System.Windows.FrameworkElement.UnregisterName(String)
- uid: System.Windows.FrameworkElement.UpdateDefaultStyle
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UpdateDefaultStyle()
  nameWithType: FrameworkElement.UpdateDefaultStyle()
  fullName: System.Windows.FrameworkElement.UpdateDefaultStyle()
- uid: System.Windows.FrameworkElement.UseLayoutRounding
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UseLayoutRounding
  nameWithType: FrameworkElement.UseLayoutRounding
  fullName: System.Windows.FrameworkElement.UseLayoutRounding
- uid: System.Windows.FrameworkElement.UseLayoutRoundingProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UseLayoutRoundingProperty
  nameWithType: FrameworkElement.UseLayoutRoundingProperty
  fullName: System.Windows.FrameworkElement.UseLayoutRoundingProperty
- uid: System.Windows.FrameworkElement.VerticalAlignment
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: VerticalAlignment
  nameWithType: FrameworkElement.VerticalAlignment
  fullName: System.Windows.FrameworkElement.VerticalAlignment
- uid: System.Windows.VerticalAlignment
  parent: System.Windows
  isExternal: false
  name: VerticalAlignment
  nameWithType: VerticalAlignment
  fullName: System.Windows.VerticalAlignment
- uid: System.Windows.FrameworkElement.VerticalAlignmentProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: VerticalAlignmentProperty
  nameWithType: FrameworkElement.VerticalAlignmentProperty
  fullName: System.Windows.FrameworkElement.VerticalAlignmentProperty
- uid: System.Windows.FrameworkElement.VisualChildrenCount
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: VisualChildrenCount
  nameWithType: FrameworkElement.VisualChildrenCount
  fullName: System.Windows.FrameworkElement.VisualChildrenCount
- uid: System.Windows.FrameworkElement.Width
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Width
  nameWithType: FrameworkElement.Width
  fullName: System.Windows.FrameworkElement.Width
- uid: System.Windows.FrameworkElement.WidthProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: WidthProperty
  nameWithType: FrameworkElement.WidthProperty
  fullName: System.Windows.FrameworkElement.WidthProperty
- uid: System.Windows.FrameworkElement.#ctor*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FrameworkElement
  nameWithType: FrameworkElement.FrameworkElement
- uid: System.Windows.FrameworkElement.ActualHeight*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ActualHeight
  nameWithType: FrameworkElement.ActualHeight
- uid: System.Windows.FrameworkElement.ActualWidth*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ActualWidth
  nameWithType: FrameworkElement.ActualWidth
- uid: System.Windows.FrameworkElement.AddLogicalChild*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: AddLogicalChild
  nameWithType: FrameworkElement.AddLogicalChild
- uid: System.Windows.FrameworkElement.ApplyTemplate*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ApplyTemplate
  nameWithType: FrameworkElement.ApplyTemplate
- uid: System.Windows.FrameworkElement.ArrangeCore*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ArrangeCore
  nameWithType: FrameworkElement.ArrangeCore
- uid: System.Windows.FrameworkElement.ArrangeOverride*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ArrangeOverride
  nameWithType: FrameworkElement.ArrangeOverride
- uid: System.Windows.FrameworkElement.BeginInit*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BeginInit
  nameWithType: FrameworkElement.BeginInit
- uid: System.Windows.FrameworkElement.BeginStoryboard*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BeginStoryboard
  nameWithType: FrameworkElement.BeginStoryboard
- uid: System.Windows.FrameworkElement.BindingGroup*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BindingGroup
  nameWithType: FrameworkElement.BindingGroup
- uid: System.Windows.FrameworkElement.BringIntoView*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BringIntoView
  nameWithType: FrameworkElement.BringIntoView
- uid: System.Windows.FrameworkElement.ContextMenu*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenu
  nameWithType: FrameworkElement.ContextMenu
- uid: System.Windows.FrameworkElement.Cursor*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Cursor
  nameWithType: FrameworkElement.Cursor
- uid: System.Windows.FrameworkElement.DataContext*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DataContext
  nameWithType: FrameworkElement.DataContext
- uid: System.Windows.FrameworkElement.DefaultStyleKey*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DefaultStyleKey
  nameWithType: FrameworkElement.DefaultStyleKey
- uid: System.Windows.FrameworkElement.EndInit*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: EndInit
  nameWithType: FrameworkElement.EndInit
- uid: System.Windows.FrameworkElement.FindName*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FindName
  nameWithType: FrameworkElement.FindName
- uid: System.Windows.FrameworkElement.FindResource*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FindResource
  nameWithType: FrameworkElement.FindResource
- uid: System.Windows.FrameworkElement.FlowDirection*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FlowDirection
  nameWithType: FrameworkElement.FlowDirection
- uid: System.Windows.FrameworkElement.FocusVisualStyle*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FocusVisualStyle
  nameWithType: FrameworkElement.FocusVisualStyle
- uid: System.Windows.FrameworkElement.ForceCursor*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ForceCursor
  nameWithType: FrameworkElement.ForceCursor
- uid: System.Windows.FrameworkElement.GetBindingExpression*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetBindingExpression
  nameWithType: FrameworkElement.GetBindingExpression
- uid: System.Windows.FrameworkElement.GetFlowDirection*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetFlowDirection
  nameWithType: FrameworkElement.GetFlowDirection
- uid: System.Windows.FrameworkElement.GetLayoutClip*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetLayoutClip
  nameWithType: FrameworkElement.GetLayoutClip
- uid: System.Windows.FrameworkElement.GetTemplateChild*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetTemplateChild
  nameWithType: FrameworkElement.GetTemplateChild
- uid: System.Windows.FrameworkElement.GetUIParentCore*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetUIParentCore
  nameWithType: FrameworkElement.GetUIParentCore
- uid: System.Windows.FrameworkElement.GetVisualChild*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetVisualChild
  nameWithType: FrameworkElement.GetVisualChild
- uid: System.Windows.FrameworkElement.Height*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Height
  nameWithType: FrameworkElement.Height
- uid: System.Windows.FrameworkElement.HorizontalAlignment*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: HorizontalAlignment
  nameWithType: FrameworkElement.HorizontalAlignment
- uid: System.Windows.FrameworkElement.InheritanceBehavior*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: InheritanceBehavior
  nameWithType: FrameworkElement.InheritanceBehavior
- uid: System.Windows.FrameworkElement.InputScope*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: InputScope
  nameWithType: FrameworkElement.InputScope
- uid: System.Windows.FrameworkElement.IsInitialized*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: IsInitialized
  nameWithType: FrameworkElement.IsInitialized
- uid: System.Windows.FrameworkElement.IsLoaded*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: IsLoaded
  nameWithType: FrameworkElement.IsLoaded
- uid: System.Windows.FrameworkElement.Language*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Language
  nameWithType: FrameworkElement.Language
- uid: System.Windows.FrameworkElement.LayoutTransform*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LayoutTransform
  nameWithType: FrameworkElement.LayoutTransform
- uid: System.Windows.FrameworkElement.LogicalChildren*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LogicalChildren
  nameWithType: FrameworkElement.LogicalChildren
- uid: System.Windows.FrameworkElement.Margin*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Margin
  nameWithType: FrameworkElement.Margin
- uid: System.Windows.FrameworkElement.MaxHeight*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MaxHeight
  nameWithType: FrameworkElement.MaxHeight
- uid: System.Windows.FrameworkElement.MaxWidth*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MaxWidth
  nameWithType: FrameworkElement.MaxWidth
- uid: System.Windows.FrameworkElement.MeasureCore*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MeasureCore
  nameWithType: FrameworkElement.MeasureCore
- uid: System.Windows.FrameworkElement.MeasureOverride*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MeasureOverride
  nameWithType: FrameworkElement.MeasureOverride
- uid: System.Windows.FrameworkElement.MinHeight*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MinHeight
  nameWithType: FrameworkElement.MinHeight
- uid: System.Windows.FrameworkElement.MinWidth*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MinWidth
  nameWithType: FrameworkElement.MinWidth
- uid: System.Windows.FrameworkElement.MoveFocus*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MoveFocus
  nameWithType: FrameworkElement.MoveFocus
- uid: System.Windows.FrameworkElement.Name*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Name
  nameWithType: FrameworkElement.Name
- uid: System.Windows.FrameworkElement.OnApplyTemplate*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnApplyTemplate
  nameWithType: FrameworkElement.OnApplyTemplate
- uid: System.Windows.FrameworkElement.OnContextMenuClosing*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnContextMenuClosing
  nameWithType: FrameworkElement.OnContextMenuClosing
- uid: System.Windows.FrameworkElement.OnContextMenuOpening*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnContextMenuOpening
  nameWithType: FrameworkElement.OnContextMenuOpening
- uid: System.Windows.FrameworkElement.OnGotFocus*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnGotFocus
  nameWithType: FrameworkElement.OnGotFocus
- uid: System.Windows.FrameworkElement.OnInitialized*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnInitialized
  nameWithType: FrameworkElement.OnInitialized
- uid: System.Windows.FrameworkElement.OnPropertyChanged*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnPropertyChanged
  nameWithType: FrameworkElement.OnPropertyChanged
- uid: System.Windows.FrameworkElement.OnRenderSizeChanged*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnRenderSizeChanged
  nameWithType: FrameworkElement.OnRenderSizeChanged
- uid: System.Windows.FrameworkElement.OnStyleChanged*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnStyleChanged
  nameWithType: FrameworkElement.OnStyleChanged
- uid: System.Windows.FrameworkElement.OnToolTipClosing*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnToolTipClosing
  nameWithType: FrameworkElement.OnToolTipClosing
- uid: System.Windows.FrameworkElement.OnToolTipOpening*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnToolTipOpening
  nameWithType: FrameworkElement.OnToolTipOpening
- uid: System.Windows.FrameworkElement.OnVisualParentChanged*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnVisualParentChanged
  nameWithType: FrameworkElement.OnVisualParentChanged
- uid: System.Windows.FrameworkElement.OverridesDefaultStyle*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OverridesDefaultStyle
  nameWithType: FrameworkElement.OverridesDefaultStyle
- uid: System.Windows.FrameworkElement.Parent*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Parent
  nameWithType: FrameworkElement.Parent
- uid: System.Windows.FrameworkElement.ParentLayoutInvalidated*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ParentLayoutInvalidated
  nameWithType: FrameworkElement.ParentLayoutInvalidated
- uid: System.Windows.FrameworkElement.PredictFocus*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: PredictFocus
  nameWithType: FrameworkElement.PredictFocus
- uid: System.Windows.FrameworkElement.RegisterName*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: RegisterName
  nameWithType: FrameworkElement.RegisterName
- uid: System.Windows.FrameworkElement.RemoveLogicalChild*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: RemoveLogicalChild
  nameWithType: FrameworkElement.RemoveLogicalChild
- uid: System.Windows.FrameworkElement.Resources*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Resources
  nameWithType: FrameworkElement.Resources
- uid: System.Windows.FrameworkElement.SetBinding*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetBinding
  nameWithType: FrameworkElement.SetBinding
- uid: System.Windows.FrameworkElement.SetFlowDirection*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetFlowDirection
  nameWithType: FrameworkElement.SetFlowDirection
- uid: System.Windows.FrameworkElement.SetResourceReference*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetResourceReference
  nameWithType: FrameworkElement.SetResourceReference
- uid: System.Windows.FrameworkElement.ShouldSerializeResources*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ShouldSerializeResources
  nameWithType: FrameworkElement.ShouldSerializeResources
- uid: System.Windows.FrameworkElement.ShouldSerializeStyle*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ShouldSerializeStyle
  nameWithType: FrameworkElement.ShouldSerializeStyle
- uid: System.Windows.FrameworkElement.ShouldSerializeTriggers*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ShouldSerializeTriggers
  nameWithType: FrameworkElement.ShouldSerializeTriggers
- uid: System.Windows.FrameworkElement.Style*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Style
  nameWithType: FrameworkElement.Style
- uid: System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
  nameWithType: FrameworkElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
- uid: System.Windows.FrameworkElement.Tag*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Tag
  nameWithType: FrameworkElement.Tag
- uid: System.Windows.FrameworkElement.TemplatedParent*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: TemplatedParent
  nameWithType: FrameworkElement.TemplatedParent
- uid: System.Windows.FrameworkElement.ToolTip*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTip
  nameWithType: FrameworkElement.ToolTip
- uid: System.Windows.FrameworkElement.Triggers*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Triggers
  nameWithType: FrameworkElement.Triggers
- uid: System.Windows.FrameworkElement.TryFindResource*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: TryFindResource
  nameWithType: FrameworkElement.TryFindResource
- uid: System.Windows.FrameworkElement.UnregisterName*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UnregisterName
  nameWithType: FrameworkElement.UnregisterName
- uid: System.Windows.FrameworkElement.UpdateDefaultStyle*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UpdateDefaultStyle
  nameWithType: FrameworkElement.UpdateDefaultStyle
- uid: System.Windows.FrameworkElement.UseLayoutRounding*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UseLayoutRounding
  nameWithType: FrameworkElement.UseLayoutRounding
- uid: System.Windows.FrameworkElement.VerticalAlignment*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: VerticalAlignment
  nameWithType: FrameworkElement.VerticalAlignment
- uid: System.Windows.FrameworkElement.VisualChildrenCount*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: VisualChildrenCount
  nameWithType: FrameworkElement.VisualChildrenCount
- uid: System.Windows.FrameworkElement.Width*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Width
  nameWithType: FrameworkElement.Width
